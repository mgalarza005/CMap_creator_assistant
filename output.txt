Kode lerroa: {
Kode lerroa:   "appName": {
Kode lerroa:     "message": "PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appName'))",
Kode lerroa:     "description": "The name of the application"
Kode lerroa:   },
Kode lerroa:   "appShortName": {
Kode lerroa:     "message": "PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))",
Kode lerroa:     "description": "The short_name (maximum of 12 characters recommended) is a short version of the app's name."
Kode lerroa:   },
Kode lerroa:   "appDescription": {
Kode lerroa:     "message": "PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appDescription'))",
Kode lerroa:     "description": "The description of the application"
Kode lerroa:   },
Kode lerroa:   "browserActionTitle": {
Kode lerroa:     "message": "PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appName'))",
Kode lerroa:     "description": "The title of the browser action button"
Kode lerroa:   },
Kode lerroa:   "Dimensions": {
Kode lerroa:     "message": "Criteria",
Kode lerroa:     "description": "Sidebar dimensions header"
Kode lerroa:   },
Kode lerroa:   "backToWorkspace": {
Kode lerroa:     "message": "Back to workspace",
Kode lerroa:     "description": "Text for link to return to workspace in sidebar"
Kode lerroa:   },
Kode lerroa:   "HypothesisLoginRequired": {
Kode lerroa:     "message": "You are not logged in, please login in Hypothes.is or check internet connection.",
Kode lerroa:     "description": "Message to show when login is required"
Kode lerroa:   },
Kode lerroa:   "VisitTheCreatedGroup": {
Kode lerroa:     "message": "You can start annotating. Visit the created group and share it with your colleagues",
Kode lerroa:     "description": "Message to show when group is created"
Kode lerroa:   },
Kode lerroa:   "errorDeletingHypothesisAnnotation": {
Kode lerroa:     "message": "Error deleting annotation, please try it again",
Kode lerroa:     "description": "Message when fails deleting annotation comment"
Kode lerroa:   },
Kode lerroa:   "ErrorConfiguringHighlighter": {
Kode lerroa:     "message": "There was a problem while creating the hypothes.is group. Please reload the page and try it again."
Kode lerroa:   },
Kode lerroa:   "GoogleSheetLoginRequired": {
Kode lerroa:     "message": "You need to give permissions to access your Google Spreadsheet.",
Kode lerroa:     "description": "Message to show when Google Sheets permission is required"
Kode lerroa:   },
Kode lerroa:   "errorUpdatingAnnotationComment": {
Kode lerroa:     "message": "Error updating annotation comment, please try it again.",
Kode lerroa:     "description": "Message when fails updating annotation comment"
Kode lerroa:   },
Kode lerroa:   "noEvidencesFoundForMarkingTitle": {
Kode lerroa:     "message": "No evidences found for this mark"
Kode lerroa:   },
Kode lerroa:   "noEvidencesFoundForMarkingText": {
Kode lerroa:     "message": "You haven't annotated any evidence for this mark, would you like to grade this student with $1?"
Kode lerroa:   },
Kode lerroa:   "Mode": {
Kode lerroa:     "message": "Mode",
Kode lerroa:     "description": "Sidebar mode header"
Kode lerroa:   },
Kode lerroa:   "Marking": {
Kode lerroa:     "message": "Marking",
Kode lerroa:     "description": "Sidebar highlight label"
Kode lerroa:   },
Kode lerroa:   "Evidencing": {
Kode lerroa:     "message": "Evidencing",
Kode lerroa:     "description": "Sidebar evidence annotation"
Kode lerroa:   },
Kode lerroa:   "Highlight": {
Kode lerroa:     "message": "Mapping",
Kode lerroa:     "description": "Sidebar highlight label"
Kode lerroa:   },
Kode lerroa:   "Index": {
Kode lerroa:     "message": "Checker",
Kode lerroa:     "description": "Sidebar index label"
Kode lerroa:   },
Kode lerroa:   "unexpectedError": {
Kode lerroa:     "message": "Unexpected error"
Kode lerroa:   },
Kode lerroa:   "MoodleWrongAssignmentPage": {
Kode lerroa:     "message": "There was a problem when retrieving task information from moodle. Make sure that you are in the main page of the assignment."
Kode lerroa:   },
Kode lerroa:   "ErrorRelatingMoodleAndTool": {
Kode lerroa:     "message": "There was a problem while relating the tool with moodle. Please reload the page and try it again."
Kode lerroa:   },
Kode lerroa:   "GeneratingReviewReport": {
Kode lerroa:     "message": "Generating review report, please be patient."
Kode lerroa:   },
Kode lerroa:   "DeleteAllAnnotationsConfirmationTitle": {
Kode lerroa:     "message": "Do you want to delete all the annotations?"
Kode lerroa:   },
Kode lerroa:   "DeleteAllAnnotationsConfirmationMessage": {
Kode lerroa:     "message": "You are going to delete all the annotations from this review, are you sure that do you want to delete them? You cannot undo this action."
Kode lerroa:   },
Kode lerroa:   "DeleteCriteriaConfirmationTitle": {
Kode lerroa:     "message": "Do you want to delete this criteria?"
Kode lerroa:   },
Kode lerroa:   "DeleteCriteriaConfirmationMessage": {
Kode lerroa:     "message": "You are going to delete this criteria. This will also delete all the annotations done in all the documents with this criteria. Are you sure that do you want to delete them? You cannot undo this action."
Kode lerroa:   },
Kode lerroa:   "expectedInfoMessageNotFound": {
Kode lerroa:     "message": "An information message must go here, but the developer has forgotten to add it..."
Kode lerroa:   },
Kode lerroa:   "CurrentSelectionEmpty": {
Kode lerroa:     "message": "Nothing to highlight, current selection is empty"
Kode lerroa:   },
Kode lerroa:   "CurrentSelectionNotAnnotable": {
Kode lerroa:     "message": "The selected content cannot be highlighted, is not part of the document"
Kode lerroa:   },
Kode lerroa:   "ErrorContactDeveloper": {
Kode lerroa:     "message": "If the error continues, please <a href='https://github.com/onekin/WebAnnotatorSPL/issues/new?title=Bug+$errorMessage$&body=%23+How+to+reproduce%0AWrite+here+any+information+related+to+the+error+found%0A%23+Trace%0A%60$errorStacktrace$%60&labels=bug' target='_blank'>open an issue</a>.",
Kode lerroa:     "placeholders": {
Kode lerroa:       "errorMessage": {
Kode lerroa:         "content": "$1"
Kode lerroa:       },
Kode lerroa:       "errorStacktrace": {
Kode lerroa:         "content": "$2"
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: <html>
Kode lerroa: <head>
Kode lerroa:   <link rel="stylesheet" href="../../styles/browserStorageSearch.css">
Kode lerroa: </head>
Kode lerroa: <body>
Kode lerroa: <div id="searchAnnotationsContainer">
Kode lerroa:   <input type="text" id="searchAnnotationsInput"/>
Kode lerroa: </div>
Kode lerroa: <div id="searchResult">
Kode lerroa: <template id="annotationCardTemplate">
Kode lerroa:   <div class="annotationCard">
Kode lerroa:     <div class="annotationCardUsername"></div>
Kode lerroa:     <div class="annotationCardGroup"></div>
Kode lerroa:     <div class="annotationCardDate"></div>
Kode lerroa:     <div class="annotationCardExact"></div>
Kode lerroa:     <div class="annotationCardComment"></div>
Kode lerroa:     <div class="annotationCardTags"></div>
Kode lerroa:     <div class="annotationCardLink">
Kode lerroa:       <a href="#" target="_blank">
Kode lerroa:         <img class= "annotationCardLinkImg" src="../../images/arrowRight.svg"/>
Kode lerroa:       </a>
Kode lerroa:     </div>
Kode lerroa:   </div>
Kode lerroa: </template>
Kode lerroa: </div>
Kode lerroa: <script src="../../scripts/BrowserStorageSearch.js"></script>
Kode lerroa: </body>
Kode lerroa: </html>
Kode lerroa: /* Copyright 2017 Mozilla Foundation
Kode lerroa:  *
Kode lerroa:  * Licensed under the Apache License, Version 2.0 (the "License");
Kode lerroa:  * you may not use this file except in compliance with the License.
Kode lerroa:  * You may obtain a copy of the License at
Kode lerroa:  *
Kode lerroa:  *     http://www.apache.org/licenses/LICENSE-2.0
Kode lerroa:  *
Kode lerroa:  * Unless required by applicable law or agreed to in writing, software
Kode lerroa:  * distributed under the License is distributed on an "AS IS" BASIS,
Kode lerroa:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
Kode lerroa:  * See the License for the specific language governing permissions and
Kode lerroa:  * limitations under the License.
Kode lerroa:  */
Kode lerroa: 
Kode lerroa: (function webpackUniversalModuleDefinition(root, factory) {
Kode lerroa: 	if(typeof exports === 'object' && typeof module === 'object')
Kode lerroa: 		module.exports = factory();
Kode lerroa: 	else if(typeof define === 'function' && define.amd)
Kode lerroa: 		define("pdfjs-dist/build/pdf", [], factory);
Kode lerroa: 	else if(typeof exports === 'object')
Kode lerroa: 		exports["pdfjs-dist/build/pdf"] = factory();
Kode lerroa: 	else
Kode lerroa: 		root["pdfjs-dist/build/pdf"] = root.pdfjsDistBuildPdf = factory();
Kode lerroa: })(typeof self !== 'undefined' ? self : this, function() {
Kode lerroa: return /******/ (function(modules) { // webpackBootstrap
Kode lerroa: /******/ 	// The module cache
Kode lerroa: /******/ 	var installedModules = {};
Kode lerroa: /******/
Kode lerroa: /******/ 	// The require function
Kode lerroa: /******/ 	function __w_pdfjs_require__(moduleId) {
Kode lerroa: /******/
Kode lerroa: /******/ 		// Check if module is in cache
Kode lerroa: /******/ 		if(installedModules[moduleId]) {
Kode lerroa: /******/ 			return installedModules[moduleId].exports;
Kode lerroa: /******/ 		}
Kode lerroa: /******/ 		// Create a new module (and put it into the cache)
Kode lerroa: /******/ 		var module = installedModules[moduleId] = {
Kode lerroa: /******/ 			i: moduleId,
Kode lerroa: /******/ 			l: false,
Kode lerroa: /******/ 			exports: {}
Kode lerroa: /******/ 		};
Kode lerroa: /******/
Kode lerroa: /******/ 		// Execute the module function
Kode lerroa: /******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
Kode lerroa: /******/
Kode lerroa: /******/ 		// Flag the module as loaded
Kode lerroa: /******/ 		module.l = true;
Kode lerroa: /******/
Kode lerroa: /******/ 		// Return the exports of the module
Kode lerroa: /******/ 		return module.exports;
Kode lerroa: /******/ 	}
Kode lerroa: /******/
Kode lerroa: /******/
Kode lerroa: /******/ 	// expose the modules object (__webpack_modules__)
Kode lerroa: /******/ 	__w_pdfjs_require__.m = modules;
Kode lerroa: /******/
Kode lerroa: /******/ 	// expose the module cache
Kode lerroa: /******/ 	__w_pdfjs_require__.c = installedModules;
Kode lerroa: /******/
Kode lerroa: /******/ 	// define getter function for harmony exports
Kode lerroa: /******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
Kode lerroa: /******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
Kode lerroa: /******/ 			Object.defineProperty(exports, name, {
Kode lerroa: /******/ 				configurable: false,
Kode lerroa: /******/ 				enumerable: true,
Kode lerroa: /******/ 				get: getter
Kode lerroa: /******/ 			});
Kode lerroa: /******/ 		}
Kode lerroa: /******/ 	};
Kode lerroa: /******/
Kode lerroa: /******/ 	// getDefaultExport function for compatibility with non-harmony modules
Kode lerroa: /******/ 	__w_pdfjs_require__.n = function(module) {
Kode lerroa: /******/ 		var getter = module && module.__esModule ?
Kode lerroa: /******/ 			function getDefault() { return module['default']; } :
Kode lerroa: /******/ 			function getModuleExports() { return module; };
Kode lerroa: /******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
Kode lerroa: /******/ 		return getter;
Kode lerroa: /******/ 	};
Kode lerroa: /******/
Kode lerroa: /******/ 	// Object.prototype.hasOwnProperty.call
Kode lerroa: /******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
Kode lerroa: /******/
Kode lerroa: /******/ 	// __webpack_public_path__
Kode lerroa: /******/ 	__w_pdfjs_require__.p = "";
Kode lerroa: /******/
Kode lerroa: /******/ 	// Load entry module and return exports
Kode lerroa: /******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 75);
Kode lerroa: /******/ })
Kode lerroa: /************************************************************************/
Kode lerroa: /******/ ([
Kode lerroa: /* 0 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.unreachable = exports.warn = exports.utf8StringToString = exports.stringToUTF8String = exports.stringToPDFString = exports.stringToBytes = exports.string32 = exports.shadow = exports.setVerbosityLevel = exports.ReadableStream = exports.removeNullCharacters = exports.readUint32 = exports.readUint16 = exports.readInt8 = exports.log2 = exports.loadJpegStream = exports.isEvalSupported = exports.isLittleEndian = exports.createValidAbsoluteUrl = exports.isSameOrigin = exports.isNodeJS = exports.isSpace = exports.isString = exports.isNum = exports.isEmptyObj = exports.isBool = exports.isArrayBuffer = exports.info = exports.getVerbosityLevel = exports.getLookupTableFactory = exports.deprecated = exports.createObjectURL = exports.createPromiseCapability = exports.createBlob = exports.bytesToString = exports.assert = exports.arraysToBytes = exports.arrayByteLength = exports.FormatError = exports.XRefParseException = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.StatTimer = exports.PasswordResponses = exports.PasswordException = exports.PageViewport = exports.NotImplementedException = exports.NativeImageDecoding = exports.MissingPDFException = exports.MissingDataException = exports.MessageHandler = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VERBOSITY_LEVELS = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(76);
Kode lerroa: 
Kode lerroa: var _streams_polyfill = __w_pdfjs_require__(116);
Kode lerroa: 
Kode lerroa: var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
Kode lerroa: var NativeImageDecoding = {
Kode lerroa:   NONE: 'none',
Kode lerroa:   DECODE: 'decode',
Kode lerroa:   DISPLAY: 'display'
Kode lerroa: };
Kode lerroa: var TextRenderingMode = {
Kode lerroa:   FILL: 0,
Kode lerroa:   STROKE: 1,
Kode lerroa:   FILL_STROKE: 2,
Kode lerroa:   INVISIBLE: 3,
Kode lerroa:   FILL_ADD_TO_PATH: 4,
Kode lerroa:   STROKE_ADD_TO_PATH: 5,
Kode lerroa:   FILL_STROKE_ADD_TO_PATH: 6,
Kode lerroa:   ADD_TO_PATH: 7,
Kode lerroa:   FILL_STROKE_MASK: 3,
Kode lerroa:   ADD_TO_PATH_FLAG: 4
Kode lerroa: };
Kode lerroa: var ImageKind = {
Kode lerroa:   GRAYSCALE_1BPP: 1,
Kode lerroa:   RGB_24BPP: 2,
Kode lerroa:   RGBA_32BPP: 3
Kode lerroa: };
Kode lerroa: var AnnotationType = {
Kode lerroa:   TEXT: 1,
Kode lerroa:   LINK: 2,
Kode lerroa:   FREETEXT: 3,
Kode lerroa:   LINE: 4,
Kode lerroa:   SQUARE: 5,
Kode lerroa:   CIRCLE: 6,
Kode lerroa:   POLYGON: 7,
Kode lerroa:   POLYLINE: 8,
Kode lerroa:   HIGHLIGHT: 9,
Kode lerroa:   UNDERLINE: 10,
Kode lerroa:   SQUIGGLY: 11,
Kode lerroa:   STRIKEOUT: 12,
Kode lerroa:   STAMP: 13,
Kode lerroa:   CARET: 14,
Kode lerroa:   INK: 15,
Kode lerroa:   POPUP: 16,
Kode lerroa:   FILEATTACHMENT: 17,
Kode lerroa:   SOUND: 18,
Kode lerroa:   MOVIE: 19,
Kode lerroa:   WIDGET: 20,
Kode lerroa:   SCREEN: 21,
Kode lerroa:   PRINTERMARK: 22,
Kode lerroa:   TRAPNET: 23,
Kode lerroa:   WATERMARK: 24,
Kode lerroa:   THREED: 25,
Kode lerroa:   REDACT: 26
Kode lerroa: };
Kode lerroa: var AnnotationFlag = {
Kode lerroa:   INVISIBLE: 0x01,
Kode lerroa:   HIDDEN: 0x02,
Kode lerroa:   PRINT: 0x04,
Kode lerroa:   NOZOOM: 0x08,
Kode lerroa:   NOROTATE: 0x10,
Kode lerroa:   NOVIEW: 0x20,
Kode lerroa:   READONLY: 0x40,
Kode lerroa:   LOCKED: 0x80,
Kode lerroa:   TOGGLENOVIEW: 0x100,
Kode lerroa:   LOCKEDCONTENTS: 0x200
Kode lerroa: };
Kode lerroa: var AnnotationFieldFlag = {
Kode lerroa:   READONLY: 0x0000001,
Kode lerroa:   REQUIRED: 0x0000002,
Kode lerroa:   NOEXPORT: 0x0000004,
Kode lerroa:   MULTILINE: 0x0001000,
Kode lerroa:   PASSWORD: 0x0002000,
Kode lerroa:   NOTOGGLETOOFF: 0x0004000,
Kode lerroa:   RADIO: 0x0008000,
Kode lerroa:   PUSHBUTTON: 0x0010000,
Kode lerroa:   COMBO: 0x0020000,
Kode lerroa:   EDIT: 0x0040000,
Kode lerroa:   SORT: 0x0080000,
Kode lerroa:   FILESELECT: 0x0100000,
Kode lerroa:   MULTISELECT: 0x0200000,
Kode lerroa:   DONOTSPELLCHECK: 0x0400000,
Kode lerroa:   DONOTSCROLL: 0x0800000,
Kode lerroa:   COMB: 0x1000000,
Kode lerroa:   RICHTEXT: 0x2000000,
Kode lerroa:   RADIOSINUNISON: 0x2000000,
Kode lerroa:   COMMITONSELCHANGE: 0x4000000
Kode lerroa: };
Kode lerroa: var AnnotationBorderStyleType = {
Kode lerroa:   SOLID: 1,
Kode lerroa:   DASHED: 2,
Kode lerroa:   BEVELED: 3,
Kode lerroa:   INSET: 4,
Kode lerroa:   UNDERLINE: 5
Kode lerroa: };
Kode lerroa: var StreamType = {
Kode lerroa:   UNKNOWN: 0,
Kode lerroa:   FLATE: 1,
Kode lerroa:   LZW: 2,
Kode lerroa:   DCT: 3,
Kode lerroa:   JPX: 4,
Kode lerroa:   JBIG: 5,
Kode lerroa:   A85: 6,
Kode lerroa:   AHX: 7,
Kode lerroa:   CCF: 8,
Kode lerroa:   RL: 9
Kode lerroa: };
Kode lerroa: var FontType = {
Kode lerroa:   UNKNOWN: 0,
Kode lerroa:   TYPE1: 1,
Kode lerroa:   TYPE1C: 2,
Kode lerroa:   CIDFONTTYPE0: 3,
Kode lerroa:   CIDFONTTYPE0C: 4,
Kode lerroa:   TRUETYPE: 5,
Kode lerroa:   CIDFONTTYPE2: 6,
Kode lerroa:   TYPE3: 7,
Kode lerroa:   OPENTYPE: 8,
Kode lerroa:   TYPE0: 9,
Kode lerroa:   MMTYPE1: 10
Kode lerroa: };
Kode lerroa: var VERBOSITY_LEVELS = {
Kode lerroa:   errors: 0,
Kode lerroa:   warnings: 1,
Kode lerroa:   infos: 5
Kode lerroa: };
Kode lerroa: var CMapCompressionType = {
Kode lerroa:   NONE: 0,
Kode lerroa:   BINARY: 1,
Kode lerroa:   STREAM: 2
Kode lerroa: };
Kode lerroa: var OPS = {
Kode lerroa:   dependency: 1,
Kode lerroa:   setLineWidth: 2,
Kode lerroa:   setLineCap: 3,
Kode lerroa:   setLineJoin: 4,
Kode lerroa:   setMiterLimit: 5,
Kode lerroa:   setDash: 6,
Kode lerroa:   setRenderingIntent: 7,
Kode lerroa:   setFlatness: 8,
Kode lerroa:   setGState: 9,
Kode lerroa:   save: 10,
Kode lerroa:   restore: 11,
Kode lerroa:   transform: 12,
Kode lerroa:   moveTo: 13,
Kode lerroa:   lineTo: 14,
Kode lerroa:   curveTo: 15,
Kode lerroa:   curveTo2: 16,
Kode lerroa:   curveTo3: 17,
Kode lerroa:   closePath: 18,
Kode lerroa:   rectangle: 19,
Kode lerroa:   stroke: 20,
Kode lerroa:   closeStroke: 21,
Kode lerroa:   fill: 22,
Kode lerroa:   eoFill: 23,
Kode lerroa:   fillStroke: 24,
Kode lerroa:   eoFillStroke: 25,
Kode lerroa:   closeFillStroke: 26,
Kode lerroa:   closeEOFillStroke: 27,
Kode lerroa:   endPath: 28,
Kode lerroa:   clip: 29,
Kode lerroa:   eoClip: 30,
Kode lerroa:   beginText: 31,
Kode lerroa:   endText: 32,
Kode lerroa:   setCharSpacing: 33,
Kode lerroa:   setWordSpacing: 34,
Kode lerroa:   setHScale: 35,
Kode lerroa:   setLeading: 36,
Kode lerroa:   setFont: 37,
Kode lerroa:   setTextRenderingMode: 38,
Kode lerroa:   setTextRise: 39,
Kode lerroa:   moveText: 40,
Kode lerroa:   setLeadingMoveText: 41,
Kode lerroa:   setTextMatrix: 42,
Kode lerroa:   nextLine: 43,
Kode lerroa:   showText: 44,
Kode lerroa:   showSpacedText: 45,
Kode lerroa:   nextLineShowText: 46,
Kode lerroa:   nextLineSetSpacingShowText: 47,
Kode lerroa:   setCharWidth: 48,
Kode lerroa:   setCharWidthAndBounds: 49,
Kode lerroa:   setStrokeColorSpace: 50,
Kode lerroa:   setFillColorSpace: 51,
Kode lerroa:   setStrokeColor: 52,
Kode lerroa:   setStrokeColorN: 53,
Kode lerroa:   setFillColor: 54,
Kode lerroa:   setFillColorN: 55,
Kode lerroa:   setStrokeGray: 56,
Kode lerroa:   setFillGray: 57,
Kode lerroa:   setStrokeRGBColor: 58,
Kode lerroa:   setFillRGBColor: 59,
Kode lerroa:   setStrokeCMYKColor: 60,
Kode lerroa:   setFillCMYKColor: 61,
Kode lerroa:   shadingFill: 62,
Kode lerroa:   beginInlineImage: 63,
Kode lerroa:   beginImageData: 64,
Kode lerroa:   endInlineImage: 65,
Kode lerroa:   paintXObject: 66,
Kode lerroa:   markPoint: 67,
Kode lerroa:   markPointProps: 68,
Kode lerroa:   beginMarkedContent: 69,
Kode lerroa:   beginMarkedContentProps: 70,
Kode lerroa:   endMarkedContent: 71,
Kode lerroa:   beginCompat: 72,
Kode lerroa:   endCompat: 73,
Kode lerroa:   paintFormXObjectBegin: 74,
Kode lerroa:   paintFormXObjectEnd: 75,
Kode lerroa:   beginGroup: 76,
Kode lerroa:   endGroup: 77,
Kode lerroa:   beginAnnotations: 78,
Kode lerroa:   endAnnotations: 79,
Kode lerroa:   beginAnnotation: 80,
Kode lerroa:   endAnnotation: 81,
Kode lerroa:   paintJpegXObject: 82,
Kode lerroa:   paintImageMaskXObject: 83,
Kode lerroa:   paintImageMaskXObjectGroup: 84,
Kode lerroa:   paintImageXObject: 85,
Kode lerroa:   paintInlineImageXObject: 86,
Kode lerroa:   paintInlineImageXObjectGroup: 87,
Kode lerroa:   paintImageXObjectRepeat: 88,
Kode lerroa:   paintImageMaskXObjectRepeat: 89,
Kode lerroa:   paintSolidColorImageMask: 90,
Kode lerroa:   constructPath: 91
Kode lerroa: };
Kode lerroa: var verbosity = VERBOSITY_LEVELS.warnings;
Kode lerroa: function setVerbosityLevel(level) {
Kode lerroa:   verbosity = level;
Kode lerroa: }
Kode lerroa: function getVerbosityLevel() {
Kode lerroa:   return verbosity;
Kode lerroa: }
Kode lerroa: function info(msg) {
Kode lerroa:   if (verbosity >= VERBOSITY_LEVELS.infos) {
Kode lerroa:     console.log('Info: ' + msg);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function warn(msg) {
Kode lerroa:   if (verbosity >= VERBOSITY_LEVELS.warnings) {
Kode lerroa:     console.log('Warning: ' + msg);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function deprecated(details) {
Kode lerroa:   console.log('Deprecated API usage: ' + details);
Kode lerroa: }
Kode lerroa: function unreachable(msg) {
Kode lerroa:   throw new Error(msg);
Kode lerroa: }
Kode lerroa: function assert(cond, msg) {
Kode lerroa:   if (!cond) {
Kode lerroa:     unreachable(msg);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var UNSUPPORTED_FEATURES = {
Kode lerroa:   unknown: 'unknown',
Kode lerroa:   forms: 'forms',
Kode lerroa:   javaScript: 'javaScript',
Kode lerroa:   smask: 'smask',
Kode lerroa:   shadingPattern: 'shadingPattern',
Kode lerroa:   font: 'font'
Kode lerroa: };
Kode lerroa: function isSameOrigin(baseUrl, otherUrl) {
Kode lerroa:   try {
Kode lerroa:     var base = new URL(baseUrl);
Kode lerroa:     if (!base.origin || base.origin === 'null') {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   } catch (e) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   var other = new URL(otherUrl, base);
Kode lerroa:   return base.origin === other.origin;
Kode lerroa: }
Kode lerroa: function isValidProtocol(url) {
Kode lerroa:   if (!url) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   switch (url.protocol) {
Kode lerroa:     case 'http:':
Kode lerroa:     case 'https:':
Kode lerroa:     case 'ftp:':
Kode lerroa:     case 'mailto:':
Kode lerroa:     case 'tel:':
Kode lerroa:       return true;
Kode lerroa:     default:
Kode lerroa:       return false;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function createValidAbsoluteUrl(url, baseUrl) {
Kode lerroa:   if (!url) {
Kode lerroa:     return null;
Kode lerroa:   }
Kode lerroa:   try {
Kode lerroa:     var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
Kode lerroa:     if (isValidProtocol(absoluteUrl)) {
Kode lerroa:       return absoluteUrl;
Kode lerroa:     }
Kode lerroa:   } catch (ex) {}
Kode lerroa:   return null;
Kode lerroa: }
Kode lerroa: function shadow(obj, prop, value) {
Kode lerroa:   Object.defineProperty(obj, prop, {
Kode lerroa:     value: value,
Kode lerroa:     enumerable: true,
Kode lerroa:     configurable: true,
Kode lerroa:     writable: false
Kode lerroa:   });
Kode lerroa:   return value;
Kode lerroa: }
Kode lerroa: function getLookupTableFactory(initializer) {
Kode lerroa:   var lookup;
Kode lerroa:   return function () {
Kode lerroa:     if (initializer) {
Kode lerroa:       lookup = Object.create(null);
Kode lerroa:       initializer(lookup);
Kode lerroa:       initializer = null;
Kode lerroa:     }
Kode lerroa:     return lookup;
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: var PasswordResponses = {
Kode lerroa:   NEED_PASSWORD: 1,
Kode lerroa:   INCORRECT_PASSWORD: 2
Kode lerroa: };
Kode lerroa: var PasswordException = function PasswordExceptionClosure() {
Kode lerroa:   function PasswordException(msg, code) {
Kode lerroa:     this.name = 'PasswordException';
Kode lerroa:     this.message = msg;
Kode lerroa:     this.code = code;
Kode lerroa:   }
Kode lerroa:   PasswordException.prototype = new Error();
Kode lerroa:   PasswordException.constructor = PasswordException;
Kode lerroa:   return PasswordException;
Kode lerroa: }();
Kode lerroa: var UnknownErrorException = function UnknownErrorExceptionClosure() {
Kode lerroa:   function UnknownErrorException(msg, details) {
Kode lerroa:     this.name = 'UnknownErrorException';
Kode lerroa:     this.message = msg;
Kode lerroa:     this.details = details;
Kode lerroa:   }
Kode lerroa:   UnknownErrorException.prototype = new Error();
Kode lerroa:   UnknownErrorException.constructor = UnknownErrorException;
Kode lerroa:   return UnknownErrorException;
Kode lerroa: }();
Kode lerroa: var InvalidPDFException = function InvalidPDFExceptionClosure() {
Kode lerroa:   function InvalidPDFException(msg) {
Kode lerroa:     this.name = 'InvalidPDFException';
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   InvalidPDFException.prototype = new Error();
Kode lerroa:   InvalidPDFException.constructor = InvalidPDFException;
Kode lerroa:   return InvalidPDFException;
Kode lerroa: }();
Kode lerroa: var MissingPDFException = function MissingPDFExceptionClosure() {
Kode lerroa:   function MissingPDFException(msg) {
Kode lerroa:     this.name = 'MissingPDFException';
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   MissingPDFException.prototype = new Error();
Kode lerroa:   MissingPDFException.constructor = MissingPDFException;
Kode lerroa:   return MissingPDFException;
Kode lerroa: }();
Kode lerroa: var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
Kode lerroa:   function UnexpectedResponseException(msg, status) {
Kode lerroa:     this.name = 'UnexpectedResponseException';
Kode lerroa:     this.message = msg;
Kode lerroa:     this.status = status;
Kode lerroa:   }
Kode lerroa:   UnexpectedResponseException.prototype = new Error();
Kode lerroa:   UnexpectedResponseException.constructor = UnexpectedResponseException;
Kode lerroa:   return UnexpectedResponseException;
Kode lerroa: }();
Kode lerroa: var NotImplementedException = function NotImplementedExceptionClosure() {
Kode lerroa:   function NotImplementedException(msg) {
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   NotImplementedException.prototype = new Error();
Kode lerroa:   NotImplementedException.prototype.name = 'NotImplementedException';
Kode lerroa:   NotImplementedException.constructor = NotImplementedException;
Kode lerroa:   return NotImplementedException;
Kode lerroa: }();
Kode lerroa: var MissingDataException = function MissingDataExceptionClosure() {
Kode lerroa:   function MissingDataException(begin, end) {
Kode lerroa:     this.begin = begin;
Kode lerroa:     this.end = end;
Kode lerroa:     this.message = 'Missing data [' + begin + ', ' + end + ')';
Kode lerroa:   }
Kode lerroa:   MissingDataException.prototype = new Error();
Kode lerroa:   MissingDataException.prototype.name = 'MissingDataException';
Kode lerroa:   MissingDataException.constructor = MissingDataException;
Kode lerroa:   return MissingDataException;
Kode lerroa: }();
Kode lerroa: var XRefParseException = function XRefParseExceptionClosure() {
Kode lerroa:   function XRefParseException(msg) {
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   XRefParseException.prototype = new Error();
Kode lerroa:   XRefParseException.prototype.name = 'XRefParseException';
Kode lerroa:   XRefParseException.constructor = XRefParseException;
Kode lerroa:   return XRefParseException;
Kode lerroa: }();
Kode lerroa: var FormatError = function FormatErrorClosure() {
Kode lerroa:   function FormatError(msg) {
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   FormatError.prototype = new Error();
Kode lerroa:   FormatError.prototype.name = 'FormatError';
Kode lerroa:   FormatError.constructor = FormatError;
Kode lerroa:   return FormatError;
Kode lerroa: }();
Kode lerroa: var AbortException = function AbortExceptionClosure() {
Kode lerroa:   function AbortException(msg) {
Kode lerroa:     this.name = 'AbortException';
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   AbortException.prototype = new Error();
Kode lerroa:   AbortException.constructor = AbortException;
Kode lerroa:   return AbortException;
Kode lerroa: }();
Kode lerroa: var NullCharactersRegExp = /\x00/g;
Kode lerroa: function removeNullCharacters(str) {
Kode lerroa:   if (typeof str !== 'string') {
Kode lerroa:     warn('The argument for removeNullCharacters must be a string.');
Kode lerroa:     return str;
Kode lerroa:   }
Kode lerroa:   return str.replace(NullCharactersRegExp, '');
Kode lerroa: }
Kode lerroa: function bytesToString(bytes) {
Kode lerroa:   assert(bytes !== null && (typeof bytes === 'undefined' ? 'undefined' : _typeof(bytes)) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
Kode lerroa:   var length = bytes.length;
Kode lerroa:   var MAX_ARGUMENT_COUNT = 8192;
Kode lerroa:   if (length < MAX_ARGUMENT_COUNT) {
Kode lerroa:     return String.fromCharCode.apply(null, bytes);
Kode lerroa:   }
Kode lerroa:   var strBuf = [];
Kode lerroa:   for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
Kode lerroa:     var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
Kode lerroa:     var chunk = bytes.subarray(i, chunkEnd);
Kode lerroa:     strBuf.push(String.fromCharCode.apply(null, chunk));
Kode lerroa:   }
Kode lerroa:   return strBuf.join('');
Kode lerroa: }
Kode lerroa: function stringToBytes(str) {
Kode lerroa:   assert(typeof str === 'string', 'Invalid argument for stringToBytes');
Kode lerroa:   var length = str.length;
Kode lerroa:   var bytes = new Uint8Array(length);
Kode lerroa:   for (var i = 0; i < length; ++i) {
Kode lerroa:     bytes[i] = str.charCodeAt(i) & 0xFF;
Kode lerroa:   }
Kode lerroa:   return bytes;
Kode lerroa: }
Kode lerroa: function arrayByteLength(arr) {
Kode lerroa:   if (arr.length !== undefined) {
Kode lerroa:     return arr.length;
Kode lerroa:   }
Kode lerroa:   assert(arr.byteLength !== undefined);
Kode lerroa:   return arr.byteLength;
Kode lerroa: }
Kode lerroa: function arraysToBytes(arr) {
Kode lerroa:   if (arr.length === 1 && arr[0] instanceof Uint8Array) {
Kode lerroa:     return arr[0];
Kode lerroa:   }
Kode lerroa:   var resultLength = 0;
Kode lerroa:   var i,
Kode lerroa:       ii = arr.length;
Kode lerroa:   var item, itemLength;
Kode lerroa:   for (i = 0; i < ii; i++) {
Kode lerroa:     item = arr[i];
Kode lerroa:     itemLength = arrayByteLength(item);
Kode lerroa:     resultLength += itemLength;
Kode lerroa:   }
Kode lerroa:   var pos = 0;
Kode lerroa:   var data = new Uint8Array(resultLength);
Kode lerroa:   for (i = 0; i < ii; i++) {
Kode lerroa:     item = arr[i];
Kode lerroa:     if (!(item instanceof Uint8Array)) {
Kode lerroa:       if (typeof item === 'string') {
Kode lerroa:         item = stringToBytes(item);
Kode lerroa:       } else {
Kode lerroa:         item = new Uint8Array(item);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     itemLength = item.byteLength;
Kode lerroa:     data.set(item, pos);
Kode lerroa:     pos += itemLength;
Kode lerroa:   }
Kode lerroa:   return data;
Kode lerroa: }
Kode lerroa: function string32(value) {
Kode lerroa:   return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
Kode lerroa: }
Kode lerroa: function log2(x) {
Kode lerroa:   var n = 1,
Kode lerroa:       i = 0;
Kode lerroa:   while (x > n) {
Kode lerroa:     n <<= 1;
Kode lerroa:     i++;
Kode lerroa:   }
Kode lerroa:   return i;
Kode lerroa: }
Kode lerroa: function readInt8(data, start) {
Kode lerroa:   return data[start] << 24 >> 24;
Kode lerroa: }
Kode lerroa: function readUint16(data, offset) {
Kode lerroa:   return data[offset] << 8 | data[offset + 1];
Kode lerroa: }
Kode lerroa: function readUint32(data, offset) {
Kode lerroa:   return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
Kode lerroa: }
Kode lerroa: function isLittleEndian() {
Kode lerroa:   var buffer8 = new Uint8Array(4);
Kode lerroa:   buffer8[0] = 1;
Kode lerroa:   var view32 = new Uint32Array(buffer8.buffer, 0, 1);
Kode lerroa:   return view32[0] === 1;
Kode lerroa: }
Kode lerroa: function isEvalSupported() {
Kode lerroa:   try {
Kode lerroa:     new Function('');
Kode lerroa:     return true;
Kode lerroa:   } catch (e) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
Kode lerroa: var Util = function UtilClosure() {
Kode lerroa:   function Util() {}
Kode lerroa:   var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
Kode lerroa:   Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
Kode lerroa:     rgbBuf[1] = r;
Kode lerroa:     rgbBuf[3] = g;
Kode lerroa:     rgbBuf[5] = b;
Kode lerroa:     return rgbBuf.join('');
Kode lerroa:   };
Kode lerroa:   Util.transform = function Util_transform(m1, m2) {
Kode lerroa:     return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
Kode lerroa:   };
Kode lerroa:   Util.applyTransform = function Util_applyTransform(p, m) {
Kode lerroa:     var xt = p[0] * m[0] + p[1] * m[2] + m[4];
Kode lerroa:     var yt = p[0] * m[1] + p[1] * m[3] + m[5];
Kode lerroa:     return [xt, yt];
Kode lerroa:   };
Kode lerroa:   Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
Kode lerroa:     var d = m[0] * m[3] - m[1] * m[2];
Kode lerroa:     var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
Kode lerroa:     var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
Kode lerroa:     return [xt, yt];
Kode lerroa:   };
Kode lerroa:   Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
Kode lerroa:     var p1 = Util.applyTransform(r, m);
Kode lerroa:     var p2 = Util.applyTransform(r.slice(2, 4), m);
Kode lerroa:     var p3 = Util.applyTransform([r[0], r[3]], m);
Kode lerroa:     var p4 = Util.applyTransform([r[2], r[1]], m);
Kode lerroa:     return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
Kode lerroa:   };
Kode lerroa:   Util.inverseTransform = function Util_inverseTransform(m) {
Kode lerroa:     var d = m[0] * m[3] - m[1] * m[2];
Kode lerroa:     return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
Kode lerroa:   };
Kode lerroa:   Util.apply3dTransform = function Util_apply3dTransform(m, v) {
Kode lerroa:     return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
Kode lerroa:   };
Kode lerroa:   Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
Kode lerroa:     var transpose = [m[0], m[2], m[1], m[3]];
Kode lerroa:     var a = m[0] * transpose[0] + m[1] * transpose[2];
Kode lerroa:     var b = m[0] * transpose[1] + m[1] * transpose[3];
Kode lerroa:     var c = m[2] * transpose[0] + m[3] * transpose[2];
Kode lerroa:     var d = m[2] * transpose[1] + m[3] * transpose[3];
Kode lerroa:     var first = (a + d) / 2;
Kode lerroa:     var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
Kode lerroa:     var sx = first + second || 1;
Kode lerroa:     var sy = first - second || 1;
Kode lerroa:     return [Math.sqrt(sx), Math.sqrt(sy)];
Kode lerroa:   };
Kode lerroa:   Util.normalizeRect = function Util_normalizeRect(rect) {
Kode lerroa:     var r = rect.slice(0);
Kode lerroa:     if (rect[0] > rect[2]) {
Kode lerroa:       r[0] = rect[2];
Kode lerroa:       r[2] = rect[0];
Kode lerroa:     }
Kode lerroa:     if (rect[1] > rect[3]) {
Kode lerroa:       r[1] = rect[3];
Kode lerroa:       r[3] = rect[1];
Kode lerroa:     }
Kode lerroa:     return r;
Kode lerroa:   };
Kode lerroa:   Util.intersect = function Util_intersect(rect1, rect2) {
Kode lerroa:     function compare(a, b) {
Kode lerroa:       return a - b;
Kode lerroa:     }
Kode lerroa:     var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
Kode lerroa:         orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
Kode lerroa:         result = [];
Kode lerroa:     rect1 = Util.normalizeRect(rect1);
Kode lerroa:     rect2 = Util.normalizeRect(rect2);
Kode lerroa:     if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
Kode lerroa:       result[0] = orderedX[1];
Kode lerroa:       result[2] = orderedX[2];
Kode lerroa:     } else {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
Kode lerroa:       result[1] = orderedY[1];
Kode lerroa:       result[3] = orderedY[2];
Kode lerroa:     } else {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   };
Kode lerroa:   var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
Kode lerroa:   Util.toRoman = function Util_toRoman(number, lowerCase) {
Kode lerroa:     assert(Number.isInteger(number) && number > 0, 'The number should be a positive integer.');
Kode lerroa:     var pos,
Kode lerroa:         romanBuf = [];
Kode lerroa:     while (number >= 1000) {
Kode lerroa:       number -= 1000;
Kode lerroa:       romanBuf.push('M');
Kode lerroa:     }
Kode lerroa:     pos = number / 100 | 0;
Kode lerroa:     number %= 100;
Kode lerroa:     romanBuf.push(ROMAN_NUMBER_MAP[pos]);
Kode lerroa:     pos = number / 10 | 0;
Kode lerroa:     number %= 10;
Kode lerroa:     romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
Kode lerroa:     romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
Kode lerroa:     var romanStr = romanBuf.join('');
Kode lerroa:     return lowerCase ? romanStr.toLowerCase() : romanStr;
Kode lerroa:   };
Kode lerroa:   Util.appendToArray = function Util_appendToArray(arr1, arr2) {
Kode lerroa:     Array.prototype.push.apply(arr1, arr2);
Kode lerroa:   };
Kode lerroa:   Util.prependToArray = function Util_prependToArray(arr1, arr2) {
Kode lerroa:     Array.prototype.unshift.apply(arr1, arr2);
Kode lerroa:   };
Kode lerroa:   Util.extendObj = function extendObj(obj1, obj2) {
Kode lerroa:     for (var key in obj2) {
Kode lerroa:       obj1[key] = obj2[key];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Util.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
Kode lerroa:     while (dict && !dict.has(name)) {
Kode lerroa:       dict = dict.get('Parent');
Kode lerroa:     }
Kode lerroa:     if (!dict) {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:     return getArray ? dict.getArray(name) : dict.get(name);
Kode lerroa:   };
Kode lerroa:   Util.inherit = function Util_inherit(sub, base, prototype) {
Kode lerroa:     sub.prototype = Object.create(base.prototype);
Kode lerroa:     sub.prototype.constructor = sub;
Kode lerroa:     for (var prop in prototype) {
Kode lerroa:       sub.prototype[prop] = prototype[prop];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Util.loadScript = function Util_loadScript(src, callback) {
Kode lerroa:     var script = document.createElement('script');
Kode lerroa:     var loaded = false;
Kode lerroa:     script.setAttribute('src', src);
Kode lerroa:     if (callback) {
Kode lerroa:       script.onload = function () {
Kode lerroa:         if (!loaded) {
Kode lerroa:           callback();
Kode lerroa:         }
Kode lerroa:         loaded = true;
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     document.getElementsByTagName('head')[0].appendChild(script);
Kode lerroa:   };
Kode lerroa:   return Util;
Kode lerroa: }();
Kode lerroa: var PageViewport = function PageViewportClosure() {
Kode lerroa:   function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
Kode lerroa:     this.viewBox = viewBox;
Kode lerroa:     this.scale = scale;
Kode lerroa:     this.rotation = rotation;
Kode lerroa:     this.offsetX = offsetX;
Kode lerroa:     this.offsetY = offsetY;
Kode lerroa:     var centerX = (viewBox[2] + viewBox[0]) / 2;
Kode lerroa:     var centerY = (viewBox[3] + viewBox[1]) / 2;
Kode lerroa:     var rotateA, rotateB, rotateC, rotateD;
Kode lerroa:     rotation = rotation % 360;
Kode lerroa:     rotation = rotation < 0 ? rotation + 360 : rotation;
Kode lerroa:     switch (rotation) {
Kode lerroa:       case 180:
Kode lerroa:         rotateA = -1;
Kode lerroa:         rotateB = 0;
Kode lerroa:         rotateC = 0;
Kode lerroa:         rotateD = 1;
Kode lerroa:         break;
Kode lerroa:       case 90:
Kode lerroa:         rotateA = 0;
Kode lerroa:         rotateB = 1;
Kode lerroa:         rotateC = 1;
Kode lerroa:         rotateD = 0;
Kode lerroa:         break;
Kode lerroa:       case 270:
Kode lerroa:         rotateA = 0;
Kode lerroa:         rotateB = -1;
Kode lerroa:         rotateC = -1;
Kode lerroa:         rotateD = 0;
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         rotateA = 1;
Kode lerroa:         rotateB = 0;
Kode lerroa:         rotateC = 0;
Kode lerroa:         rotateD = -1;
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:     if (dontFlip) {
Kode lerroa:       rotateC = -rotateC;
Kode lerroa:       rotateD = -rotateD;
Kode lerroa:     }
Kode lerroa:     var offsetCanvasX, offsetCanvasY;
Kode lerroa:     var width, height;
Kode lerroa:     if (rotateA === 0) {
Kode lerroa:       offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
Kode lerroa:       offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
Kode lerroa:       width = Math.abs(viewBox[3] - viewBox[1]) * scale;
Kode lerroa:       height = Math.abs(viewBox[2] - viewBox[0]) * scale;
Kode lerroa:     } else {
Kode lerroa:       offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
Kode lerroa:       offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
Kode lerroa:       width = Math.abs(viewBox[2] - viewBox[0]) * scale;
Kode lerroa:       height = Math.abs(viewBox[3] - viewBox[1]) * scale;
Kode lerroa:     }
Kode lerroa:     this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
Kode lerroa:     this.width = width;
Kode lerroa:     this.height = height;
Kode lerroa:     this.fontScale = scale;
Kode lerroa:   }
Kode lerroa:   PageViewport.prototype = {
Kode lerroa:     clone: function PageViewPort_clone(args) {
Kode lerroa:       args = args || {};
Kode lerroa:       var scale = 'scale' in args ? args.scale : this.scale;
Kode lerroa:       var rotation = 'rotation' in args ? args.rotation : this.rotation;
Kode lerroa:       return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
Kode lerroa:     },
Kode lerroa:     convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
Kode lerroa:       return Util.applyTransform([x, y], this.transform);
Kode lerroa:     },
Kode lerroa:     convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
Kode lerroa:       var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
Kode lerroa:       var br = Util.applyTransform([rect[2], rect[3]], this.transform);
Kode lerroa:       return [tl[0], tl[1], br[0], br[1]];
Kode lerroa:     },
Kode lerroa:     convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
Kode lerroa:       return Util.applyInverseTransform([x, y], this.transform);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PageViewport;
Kode lerroa: }();
Kode lerroa: var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
Kode lerroa: function stringToPDFString(str) {
Kode lerroa:   var i,
Kode lerroa:       n = str.length,
Kode lerroa:       strBuf = [];
Kode lerroa:   if (str[0] === '\xFE' && str[1] === '\xFF') {
Kode lerroa:     for (i = 2; i < n; i += 2) {
Kode lerroa:       strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
Kode lerroa:     }
Kode lerroa:   } else {
Kode lerroa:     for (i = 0; i < n; ++i) {
Kode lerroa:       var code = PDFStringTranslateTable[str.charCodeAt(i)];
Kode lerroa:       strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return strBuf.join('');
Kode lerroa: }
Kode lerroa: function stringToUTF8String(str) {
Kode lerroa:   return decodeURIComponent(escape(str));
Kode lerroa: }
Kode lerroa: function utf8StringToString(str) {
Kode lerroa:   return unescape(encodeURIComponent(str));
Kode lerroa: }
Kode lerroa: function isEmptyObj(obj) {
Kode lerroa:   for (var key in obj) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   return true;
Kode lerroa: }
Kode lerroa: function isBool(v) {
Kode lerroa:   return typeof v === 'boolean';
Kode lerroa: }
Kode lerroa: function isNum(v) {
Kode lerroa:   return typeof v === 'number';
Kode lerroa: }
Kode lerroa: function isString(v) {
Kode lerroa:   return typeof v === 'string';
Kode lerroa: }
Kode lerroa: function isArrayBuffer(v) {
Kode lerroa:   return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.byteLength !== undefined;
Kode lerroa: }
Kode lerroa: function isSpace(ch) {
Kode lerroa:   return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
Kode lerroa: }
Kode lerroa: function isNodeJS() {
Kode lerroa:   return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process + '' === '[object process]';
Kode lerroa: }
Kode lerroa: function createPromiseCapability() {
Kode lerroa:   var capability = {};
Kode lerroa:   capability.promise = new Promise(function (resolve, reject) {
Kode lerroa:     capability.resolve = resolve;
Kode lerroa:     capability.reject = reject;
Kode lerroa:   });
Kode lerroa:   return capability;
Kode lerroa: }
Kode lerroa: var StatTimer = function StatTimerClosure() {
Kode lerroa:   function rpad(str, pad, length) {
Kode lerroa:     while (str.length < length) {
Kode lerroa:       str += pad;
Kode lerroa:     }
Kode lerroa:     return str;
Kode lerroa:   }
Kode lerroa:   function StatTimer() {
Kode lerroa:     this.started = Object.create(null);
Kode lerroa:     this.times = [];
Kode lerroa:     this.enabled = true;
Kode lerroa:   }
Kode lerroa:   StatTimer.prototype = {
Kode lerroa:     time: function StatTimer_time(name) {
Kode lerroa:       if (!this.enabled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (name in this.started) {
Kode lerroa:         warn('Timer is already running for ' + name);
Kode lerroa:       }
Kode lerroa:       this.started[name] = Date.now();
Kode lerroa:     },
Kode lerroa:     timeEnd: function StatTimer_timeEnd(name) {
Kode lerroa:       if (!this.enabled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!(name in this.started)) {
Kode lerroa:         warn('Timer has not been started for ' + name);
Kode lerroa:       }
Kode lerroa:       this.times.push({
Kode lerroa:         'name': name,
Kode lerroa:         'start': this.started[name],
Kode lerroa:         'end': Date.now()
Kode lerroa:       });
Kode lerroa:       delete this.started[name];
Kode lerroa:     },
Kode lerroa:     toString: function StatTimer_toString() {
Kode lerroa:       var i, ii;
Kode lerroa:       var times = this.times;
Kode lerroa:       var out = '';
Kode lerroa:       var longest = 0;
Kode lerroa:       for (i = 0, ii = times.length; i < ii; ++i) {
Kode lerroa:         var name = times[i]['name'];
Kode lerroa:         if (name.length > longest) {
Kode lerroa:           longest = name.length;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (i = 0, ii = times.length; i < ii; ++i) {
Kode lerroa:         var span = times[i];
Kode lerroa:         var duration = span.end - span.start;
Kode lerroa:         out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
Kode lerroa:       }
Kode lerroa:       return out;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return StatTimer;
Kode lerroa: }();
Kode lerroa: var createBlob = function createBlob(data, contentType) {
Kode lerroa:   if (typeof Blob !== 'undefined') {
Kode lerroa:     return new Blob([data], { type: contentType });
Kode lerroa:   }
Kode lerroa:   throw new Error('The "Blob" constructor is not supported.');
Kode lerroa: };
Kode lerroa: var createObjectURL = function createObjectURLClosure() {
Kode lerroa:   var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
Kode lerroa:   return function createObjectURL(data, contentType) {
Kode lerroa:     var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:     if (!forceDataSchema && URL.createObjectURL) {
Kode lerroa:       var blob = createBlob(data, contentType);
Kode lerroa:       return URL.createObjectURL(blob);
Kode lerroa:     }
Kode lerroa:     var buffer = 'data:' + contentType + ';base64,';
Kode lerroa:     for (var i = 0, ii = data.length; i < ii; i += 3) {
Kode lerroa:       var b1 = data[i] & 0xFF;
Kode lerroa:       var b2 = data[i + 1] & 0xFF;
Kode lerroa:       var b3 = data[i + 2] & 0xFF;
Kode lerroa:       var d1 = b1 >> 2,
Kode lerroa:           d2 = (b1 & 3) << 4 | b2 >> 4;
Kode lerroa:       var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
Kode lerroa:       var d4 = i + 2 < ii ? b3 & 0x3F : 64;
Kode lerroa:       buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
Kode lerroa:     }
Kode lerroa:     return buffer;
Kode lerroa:   };
Kode lerroa: }();
Kode lerroa: function resolveCall(fn, args) {
Kode lerroa:   var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
Kode lerroa: 
Kode lerroa:   if (!fn) {
Kode lerroa:     return Promise.resolve(undefined);
Kode lerroa:   }
Kode lerroa:   return new Promise(function (resolve, reject) {
Kode lerroa:     resolve(fn.apply(thisArg, args));
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function wrapReason(reason) {
Kode lerroa:   if ((typeof reason === 'undefined' ? 'undefined' : _typeof(reason)) !== 'object') {
Kode lerroa:     return reason;
Kode lerroa:   }
Kode lerroa:   switch (reason.name) {
Kode lerroa:     case 'AbortException':
Kode lerroa:       return new AbortException(reason.message);
Kode lerroa:     case 'MissingPDFException':
Kode lerroa:       return new MissingPDFException(reason.message);
Kode lerroa:     case 'UnexpectedResponseException':
Kode lerroa:       return new UnexpectedResponseException(reason.message, reason.status);
Kode lerroa:     default:
Kode lerroa:       return new UnknownErrorException(reason.message, reason.details);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function makeReasonSerializable(reason) {
Kode lerroa:   if (!(reason instanceof Error) || reason instanceof AbortException || reason instanceof MissingPDFException || reason instanceof UnexpectedResponseException || reason instanceof UnknownErrorException) {
Kode lerroa:     return reason;
Kode lerroa:   }
Kode lerroa:   return new UnknownErrorException(reason.message, reason.toString());
Kode lerroa: }
Kode lerroa: function resolveOrReject(capability, success, reason) {
Kode lerroa:   if (success) {
Kode lerroa:     capability.resolve();
Kode lerroa:   } else {
Kode lerroa:     capability.reject(reason);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function finalize(promise) {
Kode lerroa:   return Promise.resolve(promise).catch(function () {});
Kode lerroa: }
Kode lerroa: function MessageHandler(sourceName, targetName, comObj) {
Kode lerroa:   var _this = this;
Kode lerroa: 
Kode lerroa:   this.sourceName = sourceName;
Kode lerroa:   this.targetName = targetName;
Kode lerroa:   this.comObj = comObj;
Kode lerroa:   this.callbackId = 1;
Kode lerroa:   this.streamId = 1;
Kode lerroa:   this.postMessageTransfers = true;
Kode lerroa:   this.streamSinks = Object.create(null);
Kode lerroa:   this.streamControllers = Object.create(null);
Kode lerroa:   var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);
Kode lerroa:   var ah = this.actionHandler = Object.create(null);
Kode lerroa:   this._onComObjOnMessage = function (event) {
Kode lerroa:     var data = event.data;
Kode lerroa:     if (data.targetName !== _this.sourceName) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (data.stream) {
Kode lerroa:       _this._processStreamMessage(data);
Kode lerroa:     } else if (data.isReply) {
Kode lerroa:       var callbackId = data.callbackId;
Kode lerroa:       if (data.callbackId in callbacksCapabilities) {
Kode lerroa:         var callback = callbacksCapabilities[callbackId];
Kode lerroa:         delete callbacksCapabilities[callbackId];
Kode lerroa:         if ('error' in data) {
Kode lerroa:           callback.reject(wrapReason(data.error));
Kode lerroa:         } else {
Kode lerroa:           callback.resolve(data.data);
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         throw new Error('Cannot resolve callback ' + callbackId);
Kode lerroa:       }
Kode lerroa:     } else if (data.action in ah) {
Kode lerroa:       var action = ah[data.action];
Kode lerroa:       if (data.callbackId) {
Kode lerroa:         var _sourceName = _this.sourceName;
Kode lerroa:         var _targetName = data.sourceName;
Kode lerroa:         Promise.resolve().then(function () {
Kode lerroa:           return action[0].call(action[1], data.data);
Kode lerroa:         }).then(function (result) {
Kode lerroa:           comObj.postMessage({
Kode lerroa:             sourceName: _sourceName,
Kode lerroa:             targetName: _targetName,
Kode lerroa:             isReply: true,
Kode lerroa:             callbackId: data.callbackId,
Kode lerroa:             data: result
Kode lerroa:           });
Kode lerroa:         }, function (reason) {
Kode lerroa:           comObj.postMessage({
Kode lerroa:             sourceName: _sourceName,
Kode lerroa:             targetName: _targetName,
Kode lerroa:             isReply: true,
Kode lerroa:             callbackId: data.callbackId,
Kode lerroa:             error: makeReasonSerializable(reason)
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       } else if (data.streamId) {
Kode lerroa:         _this._createStreamSink(data);
Kode lerroa:       } else {
Kode lerroa:         action[0].call(action[1], data.data);
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Unknown action from worker: ' + data.action);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   comObj.addEventListener('message', this._onComObjOnMessage);
Kode lerroa: }
Kode lerroa: MessageHandler.prototype = {
Kode lerroa:   on: function on(actionName, handler, scope) {
Kode lerroa:     var ah = this.actionHandler;
Kode lerroa:     if (ah[actionName]) {
Kode lerroa:       throw new Error('There is already an actionName called "' + actionName + '"');
Kode lerroa:     }
Kode lerroa:     ah[actionName] = [handler, scope];
Kode lerroa:   },
Kode lerroa:   send: function send(actionName, data, transfers) {
Kode lerroa:     var message = {
Kode lerroa:       sourceName: this.sourceName,
Kode lerroa:       targetName: this.targetName,
Kode lerroa:       action: actionName,
Kode lerroa:       data: data
Kode lerroa:     };
Kode lerroa:     this.postMessage(message, transfers);
Kode lerroa:   },
Kode lerroa:   sendWithPromise: function sendWithPromise(actionName, data, transfers) {
Kode lerroa:     var callbackId = this.callbackId++;
Kode lerroa:     var message = {
Kode lerroa:       sourceName: this.sourceName,
Kode lerroa:       targetName: this.targetName,
Kode lerroa:       action: actionName,
Kode lerroa:       data: data,
Kode lerroa:       callbackId: callbackId
Kode lerroa:     };
Kode lerroa:     var capability = createPromiseCapability();
Kode lerroa:     this.callbacksCapabilities[callbackId] = capability;
Kode lerroa:     try {
Kode lerroa:       this.postMessage(message, transfers);
Kode lerroa:     } catch (e) {
Kode lerroa:       capability.reject(e);
Kode lerroa:     }
Kode lerroa:     return capability.promise;
Kode lerroa:   },
Kode lerroa:   sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
Kode lerroa:     var _this2 = this;
Kode lerroa: 
Kode lerroa:     var streamId = this.streamId++;
Kode lerroa:     var sourceName = this.sourceName;
Kode lerroa:     var targetName = this.targetName;
Kode lerroa:     return new _streams_polyfill.ReadableStream({
Kode lerroa:       start: function start(controller) {
Kode lerroa:         var startCapability = createPromiseCapability();
Kode lerroa:         _this2.streamControllers[streamId] = {
Kode lerroa:           controller: controller,
Kode lerroa:           startCall: startCapability,
Kode lerroa:           isClosed: false
Kode lerroa:         };
Kode lerroa:         _this2.postMessage({
Kode lerroa:           sourceName: sourceName,
Kode lerroa:           targetName: targetName,
Kode lerroa:           action: actionName,
Kode lerroa:           streamId: streamId,
Kode lerroa:           data: data,
Kode lerroa:           desiredSize: controller.desiredSize
Kode lerroa:         });
Kode lerroa:         return startCapability.promise;
Kode lerroa:       },
Kode lerroa:       pull: function pull(controller) {
Kode lerroa:         var pullCapability = createPromiseCapability();
Kode lerroa:         _this2.streamControllers[streamId].pullCall = pullCapability;
Kode lerroa:         _this2.postMessage({
Kode lerroa:           sourceName: sourceName,
Kode lerroa:           targetName: targetName,
Kode lerroa:           stream: 'pull',
Kode lerroa:           streamId: streamId,
Kode lerroa:           desiredSize: controller.desiredSize
Kode lerroa:         });
Kode lerroa:         return pullCapability.promise;
Kode lerroa:       },
Kode lerroa:       cancel: function cancel(reason) {
Kode lerroa:         var cancelCapability = createPromiseCapability();
Kode lerroa:         _this2.streamControllers[streamId].cancelCall = cancelCapability;
Kode lerroa:         _this2.streamControllers[streamId].isClosed = true;
Kode lerroa:         _this2.postMessage({
Kode lerroa:           sourceName: sourceName,
Kode lerroa:           targetName: targetName,
Kode lerroa:           stream: 'cancel',
Kode lerroa:           reason: reason,
Kode lerroa:           streamId: streamId
Kode lerroa:         });
Kode lerroa:         return cancelCapability.promise;
Kode lerroa:       }
Kode lerroa:     }, queueingStrategy);
Kode lerroa:   },
Kode lerroa:   _createStreamSink: function _createStreamSink(data) {
Kode lerroa:     var _this3 = this;
Kode lerroa: 
Kode lerroa:     var self = this;
Kode lerroa:     var action = this.actionHandler[data.action];
Kode lerroa:     var streamId = data.streamId;
Kode lerroa:     var desiredSize = data.desiredSize;
Kode lerroa:     var sourceName = this.sourceName;
Kode lerroa:     var targetName = data.sourceName;
Kode lerroa:     var capability = createPromiseCapability();
Kode lerroa:     var sendStreamRequest = function sendStreamRequest(_ref) {
Kode lerroa:       var stream = _ref.stream,
Kode lerroa:           chunk = _ref.chunk,
Kode lerroa:           transfers = _ref.transfers,
Kode lerroa:           success = _ref.success,
Kode lerroa:           reason = _ref.reason;
Kode lerroa: 
Kode lerroa:       _this3.postMessage({
Kode lerroa:         sourceName: sourceName,
Kode lerroa:         targetName: targetName,
Kode lerroa:         stream: stream,
Kode lerroa:         streamId: streamId,
Kode lerroa:         chunk: chunk,
Kode lerroa:         success: success,
Kode lerroa:         reason: reason
Kode lerroa:       }, transfers);
Kode lerroa:     };
Kode lerroa:     var streamSink = {
Kode lerroa:       enqueue: function enqueue(chunk) {
Kode lerroa:         var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
Kode lerroa:         var transfers = arguments[2];
Kode lerroa: 
Kode lerroa:         if (this.isCancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var lastDesiredSize = this.desiredSize;
Kode lerroa:         this.desiredSize -= size;
Kode lerroa:         if (lastDesiredSize > 0 && this.desiredSize <= 0) {
Kode lerroa:           this.sinkCapability = createPromiseCapability();
Kode lerroa:           this.ready = this.sinkCapability.promise;
Kode lerroa:         }
Kode lerroa:         sendStreamRequest({
Kode lerroa:           stream: 'enqueue',
Kode lerroa:           chunk: chunk,
Kode lerroa:           transfers: transfers
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa:       close: function close() {
Kode lerroa:         if (this.isCancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this.isCancelled = true;
Kode lerroa:         sendStreamRequest({ stream: 'close' });
Kode lerroa:         delete self.streamSinks[streamId];
Kode lerroa:       },
Kode lerroa:       error: function error(reason) {
Kode lerroa:         if (this.isCancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this.isCancelled = true;
Kode lerroa:         sendStreamRequest({
Kode lerroa:           stream: 'error',
Kode lerroa:           reason: reason
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       sinkCapability: capability,
Kode lerroa:       onPull: null,
Kode lerroa:       onCancel: null,
Kode lerroa:       isCancelled: false,
Kode lerroa:       desiredSize: desiredSize,
Kode lerroa:       ready: null
Kode lerroa:     };
Kode lerroa:     streamSink.sinkCapability.resolve();
Kode lerroa:     streamSink.ready = streamSink.sinkCapability.promise;
Kode lerroa:     this.streamSinks[streamId] = streamSink;
Kode lerroa:     resolveCall(action[0], [data.data, streamSink], action[1]).then(function () {
Kode lerroa:       sendStreamRequest({
Kode lerroa:         stream: 'start_complete',
Kode lerroa:         success: true
Kode lerroa:       });
Kode lerroa:     }, function (reason) {
Kode lerroa:       sendStreamRequest({
Kode lerroa:         stream: 'start_complete',
Kode lerroa:         success: false,
Kode lerroa:         reason: reason
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   _processStreamMessage: function _processStreamMessage(data) {
Kode lerroa:     var _this4 = this;
Kode lerroa: 
Kode lerroa:     var sourceName = this.sourceName;
Kode lerroa:     var targetName = data.sourceName;
Kode lerroa:     var streamId = data.streamId;
Kode lerroa:     var sendStreamResponse = function sendStreamResponse(_ref2) {
Kode lerroa:       var stream = _ref2.stream,
Kode lerroa:           success = _ref2.success,
Kode lerroa:           reason = _ref2.reason;
Kode lerroa: 
Kode lerroa:       _this4.comObj.postMessage({
Kode lerroa:         sourceName: sourceName,
Kode lerroa:         targetName: targetName,
Kode lerroa:         stream: stream,
Kode lerroa:         success: success,
Kode lerroa:         streamId: streamId,
Kode lerroa:         reason: reason
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     var deleteStreamController = function deleteStreamController() {
Kode lerroa:       Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function (capability) {
Kode lerroa:         return capability && finalize(capability.promise);
Kode lerroa:       })).then(function () {
Kode lerroa:         delete _this4.streamControllers[data.streamId];
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     switch (data.stream) {
Kode lerroa:       case 'start_complete':
Kode lerroa:         resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
Kode lerroa:         break;
Kode lerroa:       case 'pull_complete':
Kode lerroa:         resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
Kode lerroa:         break;
Kode lerroa:       case 'pull':
Kode lerroa:         if (!this.streamSinks[data.streamId]) {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'pull_complete',
Kode lerroa:             success: true
Kode lerroa:           });
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
Kode lerroa:           this.streamSinks[data.streamId].sinkCapability.resolve();
Kode lerroa:         }
Kode lerroa:         this.streamSinks[data.streamId].desiredSize = data.desiredSize;
Kode lerroa:         resolveCall(this.streamSinks[data.streamId].onPull).then(function () {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'pull_complete',
Kode lerroa:             success: true
Kode lerroa:           });
Kode lerroa:         }, function (reason) {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'pull_complete',
Kode lerroa:             success: false,
Kode lerroa:             reason: reason
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:         break;
Kode lerroa:       case 'enqueue':
Kode lerroa:         assert(this.streamControllers[data.streamId], 'enqueue should have stream controller');
Kode lerroa:         if (!this.streamControllers[data.streamId].isClosed) {
Kode lerroa:           this.streamControllers[data.streamId].controller.enqueue(data.chunk);
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 'close':
Kode lerroa:         assert(this.streamControllers[data.streamId], 'close should have stream controller');
Kode lerroa:         if (this.streamControllers[data.streamId].isClosed) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         this.streamControllers[data.streamId].isClosed = true;
Kode lerroa:         this.streamControllers[data.streamId].controller.close();
Kode lerroa:         deleteStreamController();
Kode lerroa:         break;
Kode lerroa:       case 'error':
Kode lerroa:         assert(this.streamControllers[data.streamId], 'error should have stream controller');
Kode lerroa:         this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
Kode lerroa:         deleteStreamController();
Kode lerroa:         break;
Kode lerroa:       case 'cancel_complete':
Kode lerroa:         resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
Kode lerroa:         deleteStreamController();
Kode lerroa:         break;
Kode lerroa:       case 'cancel':
Kode lerroa:         if (!this.streamSinks[data.streamId]) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function () {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'cancel_complete',
Kode lerroa:             success: true
Kode lerroa:           });
Kode lerroa:         }, function (reason) {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'cancel_complete',
Kode lerroa:             success: false,
Kode lerroa:             reason: reason
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:         this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
Kode lerroa:         this.streamSinks[data.streamId].isCancelled = true;
Kode lerroa:         delete this.streamSinks[data.streamId];
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         throw new Error('Unexpected stream case');
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   postMessage: function postMessage(message, transfers) {
Kode lerroa:     if (transfers && this.postMessageTransfers) {
Kode lerroa:       this.comObj.postMessage(message, transfers);
Kode lerroa:     } else {
Kode lerroa:       this.comObj.postMessage(message);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   destroy: function destroy() {
Kode lerroa:     this.comObj.removeEventListener('message', this._onComObjOnMessage);
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function loadJpegStream(id, imageUrl, objs) {
Kode lerroa:   var img = new Image();
Kode lerroa:   img.onload = function loadJpegStream_onloadClosure() {
Kode lerroa:     objs.resolve(id, img);
Kode lerroa:   };
Kode lerroa:   img.onerror = function loadJpegStream_onerrorClosure() {
Kode lerroa:     objs.resolve(id, null);
Kode lerroa:     warn('Error during JPEG image loading');
Kode lerroa:   };
Kode lerroa:   img.src = imageUrl;
Kode lerroa: }
Kode lerroa: exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
Kode lerroa: exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
Kode lerroa: exports.OPS = OPS;
Kode lerroa: exports.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
Kode lerroa: exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
Kode lerroa: exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
Kode lerroa: exports.AnnotationFieldFlag = AnnotationFieldFlag;
Kode lerroa: exports.AnnotationFlag = AnnotationFlag;
Kode lerroa: exports.AnnotationType = AnnotationType;
Kode lerroa: exports.FontType = FontType;
Kode lerroa: exports.ImageKind = ImageKind;
Kode lerroa: exports.CMapCompressionType = CMapCompressionType;
Kode lerroa: exports.AbortException = AbortException;
Kode lerroa: exports.InvalidPDFException = InvalidPDFException;
Kode lerroa: exports.MessageHandler = MessageHandler;
Kode lerroa: exports.MissingDataException = MissingDataException;
Kode lerroa: exports.MissingPDFException = MissingPDFException;
Kode lerroa: exports.NativeImageDecoding = NativeImageDecoding;
Kode lerroa: exports.NotImplementedException = NotImplementedException;
Kode lerroa: exports.PageViewport = PageViewport;
Kode lerroa: exports.PasswordException = PasswordException;
Kode lerroa: exports.PasswordResponses = PasswordResponses;
Kode lerroa: exports.StatTimer = StatTimer;
Kode lerroa: exports.StreamType = StreamType;
Kode lerroa: exports.TextRenderingMode = TextRenderingMode;
Kode lerroa: exports.UnexpectedResponseException = UnexpectedResponseException;
Kode lerroa: exports.UnknownErrorException = UnknownErrorException;
Kode lerroa: exports.Util = Util;
Kode lerroa: exports.XRefParseException = XRefParseException;
Kode lerroa: exports.FormatError = FormatError;
Kode lerroa: exports.arrayByteLength = arrayByteLength;
Kode lerroa: exports.arraysToBytes = arraysToBytes;
Kode lerroa: exports.assert = assert;
Kode lerroa: exports.bytesToString = bytesToString;
Kode lerroa: exports.createBlob = createBlob;
Kode lerroa: exports.createPromiseCapability = createPromiseCapability;
Kode lerroa: exports.createObjectURL = createObjectURL;
Kode lerroa: exports.deprecated = deprecated;
Kode lerroa: exports.getLookupTableFactory = getLookupTableFactory;
Kode lerroa: exports.getVerbosityLevel = getVerbosityLevel;
Kode lerroa: exports.info = info;
Kode lerroa: exports.isArrayBuffer = isArrayBuffer;
Kode lerroa: exports.isBool = isBool;
Kode lerroa: exports.isEmptyObj = isEmptyObj;
Kode lerroa: exports.isNum = isNum;
Kode lerroa: exports.isString = isString;
Kode lerroa: exports.isSpace = isSpace;
Kode lerroa: exports.isNodeJS = isNodeJS;
Kode lerroa: exports.isSameOrigin = isSameOrigin;
Kode lerroa: exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
Kode lerroa: exports.isLittleEndian = isLittleEndian;
Kode lerroa: exports.isEvalSupported = isEvalSupported;
Kode lerroa: exports.loadJpegStream = loadJpegStream;
Kode lerroa: exports.log2 = log2;
Kode lerroa: exports.readInt8 = readInt8;
Kode lerroa: exports.readUint16 = readUint16;
Kode lerroa: exports.readUint32 = readUint32;
Kode lerroa: exports.removeNullCharacters = removeNullCharacters;
Kode lerroa: exports.ReadableStream = _streams_polyfill.ReadableStream;
Kode lerroa: exports.setVerbosityLevel = setVerbosityLevel;
Kode lerroa: exports.shadow = shadow;
Kode lerroa: exports.string32 = string32;
Kode lerroa: exports.stringToBytes = stringToBytes;
Kode lerroa: exports.stringToPDFString = stringToPDFString;
Kode lerroa: exports.stringToUTF8String = stringToUTF8String;
Kode lerroa: exports.utf8StringToString = utf8StringToString;
Kode lerroa: exports.warn = warn;
Kode lerroa: exports.unreachable = unreachable;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 1 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
Kode lerroa: if (typeof __g == 'number') __g = global;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 2 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 3 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var store = __w_pdfjs_require__(51)('wks');
Kode lerroa: var uid = __w_pdfjs_require__(16);
Kode lerroa: var _Symbol = __w_pdfjs_require__(1).Symbol;
Kode lerroa: var USE_SYMBOL = typeof _Symbol == 'function';
Kode lerroa: var $exports = module.exports = function (name) {
Kode lerroa:   return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
Kode lerroa: };
Kode lerroa: $exports.store = store;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 4 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var core = module.exports = { version: '2.5.7' };
Kode lerroa: if (typeof __e == 'number') __e = core;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 5 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var core = __w_pdfjs_require__(4);
Kode lerroa: var hide = __w_pdfjs_require__(6);
Kode lerroa: var redefine = __w_pdfjs_require__(14);
Kode lerroa: var ctx = __w_pdfjs_require__(11);
Kode lerroa: var PROTOTYPE = 'prototype';
Kode lerroa: var $export = function $export(type, name, source) {
Kode lerroa:   var IS_FORCED = type & $export.F;
Kode lerroa:   var IS_GLOBAL = type & $export.G;
Kode lerroa:   var IS_STATIC = type & $export.S;
Kode lerroa:   var IS_PROTO = type & $export.P;
Kode lerroa:   var IS_BIND = type & $export.B;
Kode lerroa:   var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
Kode lerroa:   var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
Kode lerroa:   var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
Kode lerroa:   var key, own, out, exp;
Kode lerroa:   if (IS_GLOBAL) source = name;
Kode lerroa:   for (key in source) {
Kode lerroa:     own = !IS_FORCED && target && target[key] !== undefined;
Kode lerroa:     out = (own ? target : source)[key];
Kode lerroa:     exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
Kode lerroa:     if (target) redefine(target, key, out, type & $export.U);
Kode lerroa:     if (exports[key] != out) hide(exports, key, exp);
Kode lerroa:     if (IS_PROTO && expProto[key] != out) expProto[key] = out;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: global.core = core;
Kode lerroa: $export.F = 1;
Kode lerroa: $export.G = 2;
Kode lerroa: $export.S = 4;
Kode lerroa: $export.P = 8;
Kode lerroa: $export.B = 16;
Kode lerroa: $export.W = 32;
Kode lerroa: $export.U = 64;
Kode lerroa: $export.R = 128;
Kode lerroa: module.exports = $export;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 6 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var dP = __w_pdfjs_require__(13);
Kode lerroa: var createDesc = __w_pdfjs_require__(27);
Kode lerroa: module.exports = __w_pdfjs_require__(8) ? function (object, key, value) {
Kode lerroa:   return dP.f(object, key, createDesc(1, value));
Kode lerroa: } : function (object, key, value) {
Kode lerroa:   object[key] = value;
Kode lerroa:   return object;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 7 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (!isObject(it)) throw TypeError(it + ' is not an object!');
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 8 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = !__w_pdfjs_require__(9)(function () {
Kode lerroa:   return Object.defineProperty({}, 'a', {
Kode lerroa:     get: function get() {
Kode lerroa:       return 7;
Kode lerroa:     }
Kode lerroa:   }).a != 7;
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 9 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (exec) {
Kode lerroa:   try {
Kode lerroa:     return !!exec();
Kode lerroa:   } catch (e) {
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 10 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var hasOwnProperty = {}.hasOwnProperty;
Kode lerroa: module.exports = function (it, key) {
Kode lerroa:   return hasOwnProperty.call(it, key);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 11 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: module.exports = function (fn, that, length) {
Kode lerroa:   aFunction(fn);
Kode lerroa:   if (that === undefined) return fn;
Kode lerroa:   switch (length) {
Kode lerroa:     case 1:
Kode lerroa:       return function (a) {
Kode lerroa:         return fn.call(that, a);
Kode lerroa:       };
Kode lerroa:     case 2:
Kode lerroa:       return function (a, b) {
Kode lerroa:         return fn.call(that, a, b);
Kode lerroa:       };
Kode lerroa:     case 3:
Kode lerroa:       return function (a, b, c) {
Kode lerroa:         return fn.call(that, a, b, c);
Kode lerroa:       };
Kode lerroa:   }
Kode lerroa:   return function () {
Kode lerroa:     return fn.apply(that, arguments);
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 12 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(17);
Kode lerroa: var min = Math.min;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 13 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var IE8_DOM_DEFINE = __w_pdfjs_require__(45);
Kode lerroa: var toPrimitive = __w_pdfjs_require__(33);
Kode lerroa: var dP = Object.defineProperty;
Kode lerroa: exports.f = __w_pdfjs_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
Kode lerroa:   anObject(O);
Kode lerroa:   P = toPrimitive(P, true);
Kode lerroa:   anObject(Attributes);
Kode lerroa:   if (IE8_DOM_DEFINE) try {
Kode lerroa:     return dP(O, P, Attributes);
Kode lerroa:   } catch (e) {}
Kode lerroa:   if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
Kode lerroa:   if ('value' in Attributes) O[P] = Attributes.value;
Kode lerroa:   return O;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 14 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var hide = __w_pdfjs_require__(6);
Kode lerroa: var has = __w_pdfjs_require__(10);
Kode lerroa: var SRC = __w_pdfjs_require__(16)('src');
Kode lerroa: var TO_STRING = 'toString';
Kode lerroa: var $toString = Function[TO_STRING];
Kode lerroa: var TPL = ('' + $toString).split(TO_STRING);
Kode lerroa: __w_pdfjs_require__(4).inspectSource = function (it) {
Kode lerroa:   return $toString.call(it);
Kode lerroa: };
Kode lerroa: (module.exports = function (O, key, val, safe) {
Kode lerroa:   var isFunction = typeof val == 'function';
Kode lerroa:   if (isFunction) has(val, 'name') || hide(val, 'name', key);
Kode lerroa:   if (O[key] === val) return;
Kode lerroa:   if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
Kode lerroa:   if (O === global) {
Kode lerroa:     O[key] = val;
Kode lerroa:   } else if (!safe) {
Kode lerroa:     delete O[key];
Kode lerroa:     hide(O, key, val);
Kode lerroa:   } else if (O[key]) {
Kode lerroa:     O[key] = val;
Kode lerroa:   } else {
Kode lerroa:     hide(O, key, val);
Kode lerroa:   }
Kode lerroa: })(Function.prototype, TO_STRING, function toString() {
Kode lerroa:   return typeof this == 'function' && this[SRC] || $toString.call(this);
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 15 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.getDefaultSetting = exports.LinkTarget = exports.getFilenameFromUrl = exports.isValidUrl = exports.isExternalLinkTargetSet = exports.addLinkAttributes = exports.RenderingCancelledException = exports.CustomStyle = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _global_scope = __w_pdfjs_require__(20);
Kode lerroa: 
Kode lerroa: var _global_scope2 = _interopRequireDefault(_global_scope);
Kode lerroa: 
Kode lerroa: function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DEFAULT_LINK_REL = 'noopener noreferrer nofollow';
Kode lerroa: var SVG_NS = 'http://www.w3.org/2000/svg';
Kode lerroa: 
Kode lerroa: var DOMCanvasFactory = function () {
Kode lerroa:   function DOMCanvasFactory() {
Kode lerroa:     _classCallCheck(this, DOMCanvasFactory);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(DOMCanvasFactory, [{
Kode lerroa:     key: 'create',
Kode lerroa:     value: function create(width, height) {
Kode lerroa:       if (width <= 0 || height <= 0) {
Kode lerroa:         throw new Error('invalid canvas size');
Kode lerroa:       }
Kode lerroa:       var canvas = document.createElement('canvas');
Kode lerroa:       var context = canvas.getContext('2d');
Kode lerroa:       canvas.width = width;
Kode lerroa:       canvas.height = height;
Kode lerroa:       return {
Kode lerroa:         canvas: canvas,
Kode lerroa:         context: context
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset(canvasAndContext, width, height) {
Kode lerroa:       if (!canvasAndContext.canvas) {
Kode lerroa:         throw new Error('canvas is not specified');
Kode lerroa:       }
Kode lerroa:       if (width <= 0 || height <= 0) {
Kode lerroa:         throw new Error('invalid canvas size');
Kode lerroa:       }
Kode lerroa:       canvasAndContext.canvas.width = width;
Kode lerroa:       canvasAndContext.canvas.height = height;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'destroy',
Kode lerroa:     value: function destroy(canvasAndContext) {
Kode lerroa:       if (!canvasAndContext.canvas) {
Kode lerroa:         throw new Error('canvas is not specified');
Kode lerroa:       }
Kode lerroa:       canvasAndContext.canvas.width = 0;
Kode lerroa:       canvasAndContext.canvas.height = 0;
Kode lerroa:       canvasAndContext.canvas = null;
Kode lerroa:       canvasAndContext.context = null;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return DOMCanvasFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var DOMCMapReaderFactory = function () {
Kode lerroa:   function DOMCMapReaderFactory(_ref) {
Kode lerroa:     var _ref$baseUrl = _ref.baseUrl,
Kode lerroa:         baseUrl = _ref$baseUrl === undefined ? null : _ref$baseUrl,
Kode lerroa:         _ref$isCompressed = _ref.isCompressed,
Kode lerroa:         isCompressed = _ref$isCompressed === undefined ? false : _ref$isCompressed;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, DOMCMapReaderFactory);
Kode lerroa: 
Kode lerroa:     this.baseUrl = baseUrl;
Kode lerroa:     this.isCompressed = isCompressed;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(DOMCMapReaderFactory, [{
Kode lerroa:     key: 'fetch',
Kode lerroa:     value: function fetch(_ref2) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var name = _ref2.name;
Kode lerroa: 
Kode lerroa:       if (!this.baseUrl) {
Kode lerroa:         return Promise.reject(new Error('CMap baseUrl must be specified, ' + 'see "PDFJS.cMapUrl" (and also "PDFJS.cMapPacked").'));
Kode lerroa:       }
Kode lerroa:       if (!name) {
Kode lerroa:         return Promise.reject(new Error('CMap name must be specified.'));
Kode lerroa:       }
Kode lerroa:       return new Promise(function (resolve, reject) {
Kode lerroa:         var url = _this.baseUrl + name + (_this.isCompressed ? '.bcmap' : '');
Kode lerroa:         var request = new XMLHttpRequest();
Kode lerroa:         request.open('GET', url, true);
Kode lerroa:         if (_this.isCompressed) {
Kode lerroa:           request.responseType = 'arraybuffer';
Kode lerroa:         }
Kode lerroa:         request.onreadystatechange = function () {
Kode lerroa:           if (request.readyState !== XMLHttpRequest.DONE) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           if (request.status === 200 || request.status === 0) {
Kode lerroa:             var data = void 0;
Kode lerroa:             if (_this.isCompressed && request.response) {
Kode lerroa:               data = new Uint8Array(request.response);
Kode lerroa:             } else if (!_this.isCompressed && request.responseText) {
Kode lerroa:               data = (0, _util.stringToBytes)(request.responseText);
Kode lerroa:             }
Kode lerroa:             if (data) {
Kode lerroa:               resolve({
Kode lerroa:                 cMapData: data,
Kode lerroa:                 compressionType: _this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE
Kode lerroa:               });
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           reject(new Error('Unable to load ' + (_this.isCompressed ? 'binary ' : '') + 'CMap at: ' + url));
Kode lerroa:         };
Kode lerroa:         request.send(null);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return DOMCMapReaderFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var DOMSVGFactory = function () {
Kode lerroa:   function DOMSVGFactory() {
Kode lerroa:     _classCallCheck(this, DOMSVGFactory);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(DOMSVGFactory, [{
Kode lerroa:     key: 'create',
Kode lerroa:     value: function create(width, height) {
Kode lerroa:       (0, _util.assert)(width > 0 && height > 0, 'Invalid SVG dimensions');
Kode lerroa:       var svg = document.createElementNS(SVG_NS, 'svg:svg');
Kode lerroa:       svg.setAttribute('version', '1.1');
Kode lerroa:       svg.setAttribute('width', width + 'px');
Kode lerroa:       svg.setAttribute('height', height + 'px');
Kode lerroa:       svg.setAttribute('preserveAspectRatio', 'none');
Kode lerroa:       svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
Kode lerroa:       return svg;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'createElement',
Kode lerroa:     value: function createElement(type) {
Kode lerroa:       (0, _util.assert)(typeof type === 'string', 'Invalid SVG element type');
Kode lerroa:       return document.createElementNS(SVG_NS, type);
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return DOMSVGFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var CustomStyle = function CustomStyleClosure() {
Kode lerroa:   var prefixes = ['ms', 'Moz', 'Webkit', 'O'];
Kode lerroa:   var _cache = Object.create(null);
Kode lerroa:   function CustomStyle() {}
Kode lerroa:   CustomStyle.getProp = function get(propName, element) {
Kode lerroa:     if (arguments.length === 1 && typeof _cache[propName] === 'string') {
Kode lerroa:       return _cache[propName];
Kode lerroa:     }
Kode lerroa:     element = element || document.documentElement;
Kode lerroa:     var style = element.style,
Kode lerroa:         prefixed,
Kode lerroa:         uPropName;
Kode lerroa:     if (typeof style[propName] === 'string') {
Kode lerroa:       return _cache[propName] = propName;
Kode lerroa:     }
Kode lerroa:     uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);
Kode lerroa:     for (var i = 0, l = prefixes.length; i < l; i++) {
Kode lerroa:       prefixed = prefixes[i] + uPropName;
Kode lerroa:       if (typeof style[prefixed] === 'string') {
Kode lerroa:         return _cache[propName] = prefixed;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return _cache[propName] = 'undefined';
Kode lerroa:   };
Kode lerroa:   CustomStyle.setProp = function set(propName, element, str) {
Kode lerroa:     var prop = this.getProp(propName);
Kode lerroa:     if (prop !== 'undefined') {
Kode lerroa:       element.style[prop] = str;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CustomStyle;
Kode lerroa: }();
Kode lerroa: var RenderingCancelledException = function RenderingCancelledException() {
Kode lerroa:   function RenderingCancelledException(msg, type) {
Kode lerroa:     this.message = msg;
Kode lerroa:     this.type = type;
Kode lerroa:   }
Kode lerroa:   RenderingCancelledException.prototype = new Error();
Kode lerroa:   RenderingCancelledException.prototype.name = 'RenderingCancelledException';
Kode lerroa:   RenderingCancelledException.constructor = RenderingCancelledException;
Kode lerroa:   return RenderingCancelledException;
Kode lerroa: }();
Kode lerroa: var LinkTarget = {
Kode lerroa:   NONE: 0,
Kode lerroa:   SELF: 1,
Kode lerroa:   BLANK: 2,
Kode lerroa:   PARENT: 3,
Kode lerroa:   TOP: 4
Kode lerroa: };
Kode lerroa: var LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];
Kode lerroa: function addLinkAttributes(link, params) {
Kode lerroa:   var url = params && params.url;
Kode lerroa:   link.href = link.title = url ? (0, _util.removeNullCharacters)(url) : '';
Kode lerroa:   if (url) {
Kode lerroa:     var target = params.target;
Kode lerroa:     if (typeof target === 'undefined') {
Kode lerroa:       target = getDefaultSetting('externalLinkTarget');
Kode lerroa:     }
Kode lerroa:     link.target = LinkTargetStringMap[target];
Kode lerroa:     var rel = params.rel;
Kode lerroa:     if (typeof rel === 'undefined') {
Kode lerroa:       rel = getDefaultSetting('externalLinkRel');
Kode lerroa:     }
Kode lerroa:     link.rel = rel;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function getFilenameFromUrl(url) {
Kode lerroa:   var anchor = url.indexOf('#');
Kode lerroa:   var query = url.indexOf('?');
Kode lerroa:   var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
Kode lerroa:   return url.substring(url.lastIndexOf('/', end) + 1, end);
Kode lerroa: }
Kode lerroa: function getDefaultSetting(id) {
Kode lerroa:   var globalSettings = _global_scope2.default.PDFJS;
Kode lerroa:   switch (id) {
Kode lerroa:     case 'pdfBug':
Kode lerroa:       return globalSettings ? globalSettings.pdfBug : false;
Kode lerroa:     case 'disableAutoFetch':
Kode lerroa:       return globalSettings ? globalSettings.disableAutoFetch : false;
Kode lerroa:     case 'disableStream':
Kode lerroa:       return globalSettings ? globalSettings.disableStream : false;
Kode lerroa:     case 'disableRange':
Kode lerroa:       return globalSettings ? globalSettings.disableRange : false;
Kode lerroa:     case 'disableFontFace':
Kode lerroa:       return globalSettings ? globalSettings.disableFontFace : false;
Kode lerroa:     case 'disableCreateObjectURL':
Kode lerroa:       return globalSettings ? globalSettings.disableCreateObjectURL : false;
Kode lerroa:     case 'disableWebGL':
Kode lerroa:       return globalSettings ? globalSettings.disableWebGL : true;
Kode lerroa:     case 'cMapUrl':
Kode lerroa:       return globalSettings ? globalSettings.cMapUrl : null;
Kode lerroa:     case 'cMapPacked':
Kode lerroa:       return globalSettings ? globalSettings.cMapPacked : false;
Kode lerroa:     case 'postMessageTransfers':
Kode lerroa:       return globalSettings ? globalSettings.postMessageTransfers : true;
Kode lerroa:     case 'workerPort':
Kode lerroa:       return globalSettings ? globalSettings.workerPort : null;
Kode lerroa:     case 'workerSrc':
Kode lerroa:       return globalSettings ? globalSettings.workerSrc : null;
Kode lerroa:     case 'disableWorker':
Kode lerroa:       return globalSettings ? globalSettings.disableWorker : false;
Kode lerroa:     case 'maxImageSize':
Kode lerroa:       return globalSettings ? globalSettings.maxImageSize : -1;
Kode lerroa:     case 'imageResourcesPath':
Kode lerroa:       return globalSettings ? globalSettings.imageResourcesPath : '';
Kode lerroa:     case 'isEvalSupported':
Kode lerroa:       return globalSettings ? globalSettings.isEvalSupported : true;
Kode lerroa:     case 'externalLinkTarget':
Kode lerroa:       if (!globalSettings) {
Kode lerroa:         return LinkTarget.NONE;
Kode lerroa:       }
Kode lerroa:       switch (globalSettings.externalLinkTarget) {
Kode lerroa:         case LinkTarget.NONE:
Kode lerroa:         case LinkTarget.SELF:
Kode lerroa:         case LinkTarget.BLANK:
Kode lerroa:         case LinkTarget.PARENT:
Kode lerroa:         case LinkTarget.TOP:
Kode lerroa:           return globalSettings.externalLinkTarget;
Kode lerroa:       }
Kode lerroa:       (0, _util.warn)('PDFJS.externalLinkTarget is invalid: ' + globalSettings.externalLinkTarget);
Kode lerroa:       globalSettings.externalLinkTarget = LinkTarget.NONE;
Kode lerroa:       return LinkTarget.NONE;
Kode lerroa:     case 'externalLinkRel':
Kode lerroa:       return globalSettings ? globalSettings.externalLinkRel : DEFAULT_LINK_REL;
Kode lerroa:     case 'enableStats':
Kode lerroa:       return !!(globalSettings && globalSettings.enableStats);
Kode lerroa:     case 'pdfjsNext':
Kode lerroa:       return !!(globalSettings && globalSettings.pdfjsNext);
Kode lerroa:     default:
Kode lerroa:       throw new Error('Unknown default setting: ' + id);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function isExternalLinkTargetSet() {
Kode lerroa:   var externalLinkTarget = getDefaultSetting('externalLinkTarget');
Kode lerroa:   switch (externalLinkTarget) {
Kode lerroa:     case LinkTarget.NONE:
Kode lerroa:       return false;
Kode lerroa:     case LinkTarget.SELF:
Kode lerroa:     case LinkTarget.BLANK:
Kode lerroa:     case LinkTarget.PARENT:
Kode lerroa:     case LinkTarget.TOP:
Kode lerroa:       return true;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function isValidUrl(url, allowRelative) {
Kode lerroa:   (0, _util.deprecated)('isValidUrl(), please use createValidAbsoluteUrl() instead.');
Kode lerroa:   var baseUrl = allowRelative ? 'http://example.com' : null;
Kode lerroa:   return (0, _util.createValidAbsoluteUrl)(url, baseUrl) !== null;
Kode lerroa: }
Kode lerroa: exports.CustomStyle = CustomStyle;
Kode lerroa: exports.RenderingCancelledException = RenderingCancelledException;
Kode lerroa: exports.addLinkAttributes = addLinkAttributes;
Kode lerroa: exports.isExternalLinkTargetSet = isExternalLinkTargetSet;
Kode lerroa: exports.isValidUrl = isValidUrl;
Kode lerroa: exports.getFilenameFromUrl = getFilenameFromUrl;
Kode lerroa: exports.LinkTarget = LinkTarget;
Kode lerroa: exports.getDefaultSetting = getDefaultSetting;
Kode lerroa: exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
Kode lerroa: exports.DOMCanvasFactory = DOMCanvasFactory;
Kode lerroa: exports.DOMCMapReaderFactory = DOMCMapReaderFactory;
Kode lerroa: exports.DOMSVGFactory = DOMSVGFactory;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 16 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var id = 0;
Kode lerroa: var px = Math.random();
Kode lerroa: module.exports = function (key) {
Kode lerroa:   return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 17 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ceil = Math.ceil;
Kode lerroa: var floor = Math.floor;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 18 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var defined = __w_pdfjs_require__(35);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return Object(defined(it));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 19 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = {};
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 20 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = typeof window !== 'undefined' && window.Math === Math ? window : typeof global !== 'undefined' && global.Math === Math ? global : typeof self !== 'undefined' && self.Math === Math ? self : {};
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 21 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = false;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 22 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (typeof it != 'function') throw TypeError(it + ' is not a function!');
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 23 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var redefine = __w_pdfjs_require__(14);
Kode lerroa: module.exports = function (target, src, safe) {
Kode lerroa:   for (var key in src) {
Kode lerroa:     redefine(target, key, src[key], safe);
Kode lerroa:   }return target;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 24 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (it, Constructor, name, forbiddenField) {
Kode lerroa:   if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
Kode lerroa:     throw TypeError(name + ': incorrect invocation!');
Kode lerroa:   }
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 25 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toString = {}.toString;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return toString.call(it).slice(8, -1);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 26 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var def = __w_pdfjs_require__(13).f;
Kode lerroa: var has = __w_pdfjs_require__(10);
Kode lerroa: var TAG = __w_pdfjs_require__(3)('toStringTag');
Kode lerroa: module.exports = function (it, tag, stat) {
Kode lerroa:   if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
Kode lerroa:     configurable: true,
Kode lerroa:     value: tag
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 27 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (bitmap, value) {
Kode lerroa:   return {
Kode lerroa:     enumerable: !(bitmap & 1),
Kode lerroa:     configurable: !(bitmap & 2),
Kode lerroa:     writable: !(bitmap & 4),
Kode lerroa:     value: value
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 28 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var IObject = __w_pdfjs_require__(34);
Kode lerroa: var defined = __w_pdfjs_require__(35);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return IObject(defined(it));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 29 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(17);
Kode lerroa: var max = Math.max;
Kode lerroa: var min = Math.min;
Kode lerroa: module.exports = function (index, length) {
Kode lerroa:   index = toInteger(index);
Kode lerroa:   return index < 0 ? max(index + length, 0) : min(index, length);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 30 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var cof = __w_pdfjs_require__(25);
Kode lerroa: var TAG = __w_pdfjs_require__(3)('toStringTag');
Kode lerroa: var ARG = cof(function () {
Kode lerroa:   return arguments;
Kode lerroa: }()) == 'Arguments';
Kode lerroa: var tryGet = function tryGet(it, key) {
Kode lerroa:   try {
Kode lerroa:     return it[key];
Kode lerroa:   } catch (e) {}
Kode lerroa: };
Kode lerroa: module.exports = function (it) {
Kode lerroa:   var O, T, B;
Kode lerroa:   return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 31 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ctx = __w_pdfjs_require__(11);
Kode lerroa: var call = __w_pdfjs_require__(98);
Kode lerroa: var isArrayIter = __w_pdfjs_require__(53);
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: var getIterFn = __w_pdfjs_require__(57);
Kode lerroa: var BREAK = {};
Kode lerroa: var RETURN = {};
Kode lerroa: var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
Kode lerroa:   var iterFn = ITERATOR ? function () {
Kode lerroa:     return iterable;
Kode lerroa:   } : getIterFn(iterable);
Kode lerroa:   var f = ctx(fn, that, entries ? 2 : 1);
Kode lerroa:   var index = 0;
Kode lerroa:   var length, step, iterator, result;
Kode lerroa:   if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
Kode lerroa:   if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
Kode lerroa:     result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
Kode lerroa:     if (result === BREAK || result === RETURN) return result;
Kode lerroa:   } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
Kode lerroa:     result = call(iterator, f, step.value, entries);
Kode lerroa:     if (result === BREAK || result === RETURN) return result;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: _exports.BREAK = BREAK;
Kode lerroa: _exports.RETURN = RETURN;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 32 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var document = __w_pdfjs_require__(1).document;
Kode lerroa: var is = isObject(document) && isObject(document.createElement);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return is ? document.createElement(it) : {};
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 33 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: module.exports = function (it, S) {
Kode lerroa:   if (!isObject(it)) return it;
Kode lerroa:   var fn, val;
Kode lerroa:   if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
Kode lerroa:   if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
Kode lerroa:   if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
Kode lerroa:   throw TypeError("Can't convert object to primitive value");
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 34 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var cof = __w_pdfjs_require__(25);
Kode lerroa: module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
Kode lerroa:   return cof(it) == 'String' ? it.split('') : Object(it);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 35 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (it == undefined) throw TypeError("Can't call method on  " + it);
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 36 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var shared = __w_pdfjs_require__(51)('keys');
Kode lerroa: var uid = __w_pdfjs_require__(16);
Kode lerroa: module.exports = function (key) {
Kode lerroa:   return shared[key] || (shared[key] = uid(key));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 37 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 38 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $keys = __w_pdfjs_require__(49);
Kode lerroa: var enumBugKeys = __w_pdfjs_require__(37);
Kode lerroa: module.exports = Object.keys || function keys(O) {
Kode lerroa:   return $keys(O, enumBugKeys);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 39 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ctx = __w_pdfjs_require__(11);
Kode lerroa: var IObject = __w_pdfjs_require__(34);
Kode lerroa: var toObject = __w_pdfjs_require__(18);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: var asc = __w_pdfjs_require__(82);
Kode lerroa: module.exports = function (TYPE, $create) {
Kode lerroa:   var IS_MAP = TYPE == 1;
Kode lerroa:   var IS_FILTER = TYPE == 2;
Kode lerroa:   var IS_SOME = TYPE == 3;
Kode lerroa:   var IS_EVERY = TYPE == 4;
Kode lerroa:   var IS_FIND_INDEX = TYPE == 6;
Kode lerroa:   var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
Kode lerroa:   var create = $create || asc;
Kode lerroa:   return function ($this, callbackfn, that) {
Kode lerroa:     var O = toObject($this);
Kode lerroa:     var self = IObject(O);
Kode lerroa:     var f = ctx(callbackfn, that, 3);
Kode lerroa:     var length = toLength(self.length);
Kode lerroa:     var index = 0;
Kode lerroa:     var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
Kode lerroa:     var val, res;
Kode lerroa:     for (; length > index; index++) {
Kode lerroa:       if (NO_HOLES || index in self) {
Kode lerroa:         val = self[index];
Kode lerroa:         res = f(val, index, O);
Kode lerroa:         if (TYPE) {
Kode lerroa:           if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {
Kode lerroa:             case 3:
Kode lerroa:               return true;
Kode lerroa:             case 5:
Kode lerroa:               return val;
Kode lerroa:             case 6:
Kode lerroa:               return index;
Kode lerroa:             case 2:
Kode lerroa:               result.push(val);
Kode lerroa:           } else if (IS_EVERY) return false;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 40 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: var SPECIES = __w_pdfjs_require__(3)('species');
Kode lerroa: module.exports = function (O, D) {
Kode lerroa:   var C = anObject(O).constructor;
Kode lerroa:   var S;
Kode lerroa:   return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 41 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ITERATOR = __w_pdfjs_require__(3)('iterator');
Kode lerroa: var SAFE_CLOSING = false;
Kode lerroa: try {
Kode lerroa:   var riter = [7][ITERATOR]();
Kode lerroa:   riter['return'] = function () {
Kode lerroa:     SAFE_CLOSING = true;
Kode lerroa:   };
Kode lerroa:   Array.from(riter, function () {
Kode lerroa:     throw 2;
Kode lerroa:   });
Kode lerroa: } catch (e) {}
Kode lerroa: module.exports = function (exec, skipClosing) {
Kode lerroa:   if (!skipClosing && !SAFE_CLOSING) return false;
Kode lerroa:   var safe = false;
Kode lerroa:   try {
Kode lerroa:     var arr = [7];
Kode lerroa:     var iter = arr[ITERATOR]();
Kode lerroa:     iter.next = function () {
Kode lerroa:       return { done: safe = true };
Kode lerroa:     };
Kode lerroa:     arr[ITERATOR] = function () {
Kode lerroa:       return iter;
Kode lerroa:     };
Kode lerroa:     exec(arr);
Kode lerroa:   } catch (e) {}
Kode lerroa:   return safe;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 42 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: function PromiseCapability(C) {
Kode lerroa:   var resolve, reject;
Kode lerroa:   this.promise = new C(function ($$resolve, $$reject) {
Kode lerroa:     if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
Kode lerroa:     resolve = $$resolve;
Kode lerroa:     reject = $$reject;
Kode lerroa:   });
Kode lerroa:   this.resolve = aFunction(resolve);
Kode lerroa:   this.reject = aFunction(reject);
Kode lerroa: }
Kode lerroa: module.exports.f = function (C) {
Kode lerroa:   return new PromiseCapability(C);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 43 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var META = __w_pdfjs_require__(16)('meta');
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var has = __w_pdfjs_require__(10);
Kode lerroa: var setDesc = __w_pdfjs_require__(13).f;
Kode lerroa: var id = 0;
Kode lerroa: var isExtensible = Object.isExtensible || function () {
Kode lerroa:   return true;
Kode lerroa: };
Kode lerroa: var FREEZE = !__w_pdfjs_require__(9)(function () {
Kode lerroa:   return isExtensible(Object.preventExtensions({}));
Kode lerroa: });
Kode lerroa: var setMeta = function setMeta(it) {
Kode lerroa:   setDesc(it, META, {
Kode lerroa:     value: {
Kode lerroa:       i: 'O' + ++id,
Kode lerroa:       w: {}
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: var fastKey = function fastKey(it, create) {
Kode lerroa:   if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
Kode lerroa:   if (!has(it, META)) {
Kode lerroa:     if (!isExtensible(it)) return 'F';
Kode lerroa:     if (!create) return 'E';
Kode lerroa:     setMeta(it);
Kode lerroa:   }
Kode lerroa:   return it[META].i;
Kode lerroa: };
Kode lerroa: var getWeak = function getWeak(it, create) {
Kode lerroa:   if (!has(it, META)) {
Kode lerroa:     if (!isExtensible(it)) return true;
Kode lerroa:     if (!create) return false;
Kode lerroa:     setMeta(it);
Kode lerroa:   }
Kode lerroa:   return it[META].w;
Kode lerroa: };
Kode lerroa: var onFreeze = function onFreeze(it) {
Kode lerroa:   if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: var meta = module.exports = {
Kode lerroa:   KEY: META,
Kode lerroa:   NEED: false,
Kode lerroa:   fastKey: fastKey,
Kode lerroa:   getWeak: getWeak,
Kode lerroa:   onFreeze: onFreeze
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 44 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.validateResponseStatus = exports.validateRangeRequestCapabilities = exports.createResponseStatusError = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: function validateRangeRequestCapabilities(_ref) {
Kode lerroa:   var getResponseHeader = _ref.getResponseHeader,
Kode lerroa:       isHttp = _ref.isHttp,
Kode lerroa:       rangeChunkSize = _ref.rangeChunkSize,
Kode lerroa:       disableRange = _ref.disableRange;
Kode lerroa: 
Kode lerroa:   (0, _util.assert)(rangeChunkSize > 0);
Kode lerroa:   var returnValues = {
Kode lerroa:     allowRangeRequests: false,
Kode lerroa:     suggestedLength: undefined
Kode lerroa:   };
Kode lerroa:   if (disableRange || !isHttp) {
Kode lerroa:     return returnValues;
Kode lerroa:   }
Kode lerroa:   if (getResponseHeader('Accept-Ranges') !== 'bytes') {
Kode lerroa:     return returnValues;
Kode lerroa:   }
Kode lerroa:   var contentEncoding = getResponseHeader('Content-Encoding') || 'identity';
Kode lerroa:   if (contentEncoding !== 'identity') {
Kode lerroa:     return returnValues;
Kode lerroa:   }
Kode lerroa:   var length = parseInt(getResponseHeader('Content-Length'), 10);
Kode lerroa:   if (!Number.isInteger(length)) {
Kode lerroa:     return returnValues;
Kode lerroa:   }
Kode lerroa:   returnValues.suggestedLength = length;
Kode lerroa:   if (length <= 2 * rangeChunkSize) {
Kode lerroa:     return returnValues;
Kode lerroa:   }
Kode lerroa:   returnValues.allowRangeRequests = true;
Kode lerroa:   return returnValues;
Kode lerroa: }
Kode lerroa: function createResponseStatusError(status, url) {
Kode lerroa:   if (status === 404 || status === 0 && /^file:/.test(url)) {
Kode lerroa:     return new _util.MissingPDFException('Missing PDF "' + url + '".');
Kode lerroa:   }
Kode lerroa:   return new _util.UnexpectedResponseException('Unexpected server response (' + status + ') while retrieving PDF "' + url + '".', status);
Kode lerroa: }
Kode lerroa: function validateResponseStatus(status) {
Kode lerroa:   return status === 200 || status === 206;
Kode lerroa: }
Kode lerroa: exports.createResponseStatusError = createResponseStatusError;
Kode lerroa: exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
Kode lerroa: exports.validateResponseStatus = validateResponseStatus;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 45 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = !__w_pdfjs_require__(8) && !__w_pdfjs_require__(9)(function () {
Kode lerroa:   return Object.defineProperty(__w_pdfjs_require__(32)('div'), 'a', {
Kode lerroa:     get: function get() {
Kode lerroa:       return 7;
Kode lerroa:     }
Kode lerroa:   }).a != 7;
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 46 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var hide = __w_pdfjs_require__(6);
Kode lerroa: var uid = __w_pdfjs_require__(16);
Kode lerroa: var TYPED = uid('typed_array');
Kode lerroa: var VIEW = uid('view');
Kode lerroa: var ABV = !!(global.ArrayBuffer && global.DataView);
Kode lerroa: var CONSTR = ABV;
Kode lerroa: var i = 0;
Kode lerroa: var l = 9;
Kode lerroa: var Typed;
Kode lerroa: var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');
Kode lerroa: while (i < l) {
Kode lerroa:   if (Typed = global[TypedArrayConstructors[i++]]) {
Kode lerroa:     hide(Typed.prototype, TYPED, true);
Kode lerroa:     hide(Typed.prototype, VIEW, true);
Kode lerroa:   } else CONSTR = false;
Kode lerroa: }
Kode lerroa: module.exports = {
Kode lerroa:   ABV: ABV,
Kode lerroa:   CONSTR: CONSTR,
Kode lerroa:   TYPED: TYPED,
Kode lerroa:   VIEW: VIEW
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 47 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(17);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (it === undefined) return 0;
Kode lerroa:   var number = toInteger(it);
Kode lerroa:   var length = toLength(number);
Kode lerroa:   if (number !== length) throw RangeError('Wrong length!');
Kode lerroa:   return length;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 48 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $keys = __w_pdfjs_require__(49);
Kode lerroa: var hiddenKeys = __w_pdfjs_require__(37).concat('length', 'prototype');
Kode lerroa: exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
Kode lerroa:   return $keys(O, hiddenKeys);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 49 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var has = __w_pdfjs_require__(10);
Kode lerroa: var toIObject = __w_pdfjs_require__(28);
Kode lerroa: var arrayIndexOf = __w_pdfjs_require__(50)(false);
Kode lerroa: var IE_PROTO = __w_pdfjs_require__(36)('IE_PROTO');
Kode lerroa: module.exports = function (object, names) {
Kode lerroa:   var O = toIObject(object);
Kode lerroa:   var i = 0;
Kode lerroa:   var result = [];
Kode lerroa:   var key;
Kode lerroa:   for (key in O) {
Kode lerroa:     if (key != IE_PROTO) has(O, key) && result.push(key);
Kode lerroa:   }while (names.length > i) {
Kode lerroa:     if (has(O, key = names[i++])) {
Kode lerroa:       ~arrayIndexOf(result, key) || result.push(key);
Kode lerroa:     }
Kode lerroa:   }return result;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 50 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toIObject = __w_pdfjs_require__(28);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: var toAbsoluteIndex = __w_pdfjs_require__(29);
Kode lerroa: module.exports = function (IS_INCLUDES) {
Kode lerroa:   return function ($this, el, fromIndex) {
Kode lerroa:     var O = toIObject($this);
Kode lerroa:     var length = toLength(O.length);
Kode lerroa:     var index = toAbsoluteIndex(fromIndex, length);
Kode lerroa:     var value;
Kode lerroa:     if (IS_INCLUDES && el != el) while (length > index) {
Kode lerroa:       value = O[index++];
Kode lerroa:       if (value != value) return true;
Kode lerroa:     } else for (; length > index; index++) {
Kode lerroa:       if (IS_INCLUDES || index in O) {
Kode lerroa:         if (O[index] === el) return IS_INCLUDES || index || 0;
Kode lerroa:       }
Kode lerroa:     }return !IS_INCLUDES && -1;
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 51 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var core = __w_pdfjs_require__(4);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var SHARED = '__core-js_shared__';
Kode lerroa: var store = global[SHARED] || (global[SHARED] = {});
Kode lerroa: (module.exports = function (key, value) {
Kode lerroa:   return store[key] || (store[key] = value !== undefined ? value : {});
Kode lerroa: })('versions', []).push({
Kode lerroa:   version: core.version,
Kode lerroa:   mode: __w_pdfjs_require__(21) ? 'pure' : 'global',
Kode lerroa:   copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 52 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toObject = __w_pdfjs_require__(18);
Kode lerroa: var toAbsoluteIndex = __w_pdfjs_require__(29);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: module.exports = function fill(value) {
Kode lerroa:   var O = toObject(this);
Kode lerroa:   var length = toLength(O.length);
Kode lerroa:   var aLen = arguments.length;
Kode lerroa:   var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
Kode lerroa:   var end = aLen > 2 ? arguments[2] : undefined;
Kode lerroa:   var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
Kode lerroa:   while (endPos > index) {
Kode lerroa:     O[index++] = value;
Kode lerroa:   }return O;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 53 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var Iterators = __w_pdfjs_require__(19);
Kode lerroa: var ITERATOR = __w_pdfjs_require__(3)('iterator');
Kode lerroa: var ArrayProto = Array.prototype;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 54 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var dPs = __w_pdfjs_require__(81);
Kode lerroa: var enumBugKeys = __w_pdfjs_require__(37);
Kode lerroa: var IE_PROTO = __w_pdfjs_require__(36)('IE_PROTO');
Kode lerroa: var Empty = function Empty() {};
Kode lerroa: var PROTOTYPE = 'prototype';
Kode lerroa: var _createDict = function createDict() {
Kode lerroa:   var iframe = __w_pdfjs_require__(32)('iframe');
Kode lerroa:   var i = enumBugKeys.length;
Kode lerroa:   var lt = '<';
Kode lerroa:   var gt = '>';
Kode lerroa:   var iframeDocument;
Kode lerroa:   iframe.style.display = 'none';
Kode lerroa:   __w_pdfjs_require__(55).appendChild(iframe);
Kode lerroa:   iframe.src = 'javascript:';
Kode lerroa:   iframeDocument = iframe.contentWindow.document;
Kode lerroa:   iframeDocument.open();
Kode lerroa:   iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
Kode lerroa:   iframeDocument.close();
Kode lerroa:   _createDict = iframeDocument.F;
Kode lerroa:   while (i--) {
Kode lerroa:     delete _createDict[PROTOTYPE][enumBugKeys[i]];
Kode lerroa:   }return _createDict();
Kode lerroa: };
Kode lerroa: module.exports = Object.create || function create(O, Properties) {
Kode lerroa:   var result;
Kode lerroa:   if (O !== null) {
Kode lerroa:     Empty[PROTOTYPE] = anObject(O);
Kode lerroa:     result = new Empty();
Kode lerroa:     Empty[PROTOTYPE] = null;
Kode lerroa:     result[IE_PROTO] = O;
Kode lerroa:   } else result = _createDict();
Kode lerroa:   return Properties === undefined ? result : dPs(result, Properties);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 55 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var document = __w_pdfjs_require__(1).document;
Kode lerroa: module.exports = document && document.documentElement;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 56 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var has = __w_pdfjs_require__(10);
Kode lerroa: var toObject = __w_pdfjs_require__(18);
Kode lerroa: var IE_PROTO = __w_pdfjs_require__(36)('IE_PROTO');
Kode lerroa: var ObjectProto = Object.prototype;
Kode lerroa: module.exports = Object.getPrototypeOf || function (O) {
Kode lerroa:   O = toObject(O);
Kode lerroa:   if (has(O, IE_PROTO)) return O[IE_PROTO];
Kode lerroa:   if (typeof O.constructor == 'function' && O instanceof O.constructor) {
Kode lerroa:     return O.constructor.prototype;
Kode lerroa:   }
Kode lerroa:   return O instanceof Object ? ObjectProto : null;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 57 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var classof = __w_pdfjs_require__(30);
Kode lerroa: var ITERATOR = __w_pdfjs_require__(3)('iterator');
Kode lerroa: var Iterators = __w_pdfjs_require__(19);
Kode lerroa: module.exports = __w_pdfjs_require__(4).getIteratorMethod = function (it) {
Kode lerroa:   if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 58 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var addToUnscopables = __w_pdfjs_require__(85);
Kode lerroa: var step = __w_pdfjs_require__(86);
Kode lerroa: var Iterators = __w_pdfjs_require__(19);
Kode lerroa: var toIObject = __w_pdfjs_require__(28);
Kode lerroa: module.exports = __w_pdfjs_require__(59)(Array, 'Array', function (iterated, kind) {
Kode lerroa:   this._t = toIObject(iterated);
Kode lerroa:   this._i = 0;
Kode lerroa:   this._k = kind;
Kode lerroa: }, function () {
Kode lerroa:   var O = this._t;
Kode lerroa:   var kind = this._k;
Kode lerroa:   var index = this._i++;
Kode lerroa:   if (!O || index >= O.length) {
Kode lerroa:     this._t = undefined;
Kode lerroa:     return step(1);
Kode lerroa:   }
Kode lerroa:   if (kind == 'keys') return step(0, index);
Kode lerroa:   if (kind == 'values') return step(0, O[index]);
Kode lerroa:   return step(0, [index, O[index]]);
Kode lerroa: }, 'values');
Kode lerroa: Iterators.Arguments = Iterators.Array;
Kode lerroa: addToUnscopables('keys');
Kode lerroa: addToUnscopables('values');
Kode lerroa: addToUnscopables('entries');
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 59 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var LIBRARY = __w_pdfjs_require__(21);
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: var redefine = __w_pdfjs_require__(14);
Kode lerroa: var hide = __w_pdfjs_require__(6);
Kode lerroa: var Iterators = __w_pdfjs_require__(19);
Kode lerroa: var $iterCreate = __w_pdfjs_require__(87);
Kode lerroa: var setToStringTag = __w_pdfjs_require__(26);
Kode lerroa: var getPrototypeOf = __w_pdfjs_require__(56);
Kode lerroa: var ITERATOR = __w_pdfjs_require__(3)('iterator');
Kode lerroa: var BUGGY = !([].keys && 'next' in [].keys());
Kode lerroa: var FF_ITERATOR = '@@iterator';
Kode lerroa: var KEYS = 'keys';
Kode lerroa: var VALUES = 'values';
Kode lerroa: var returnThis = function returnThis() {
Kode lerroa:   return this;
Kode lerroa: };
Kode lerroa: module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
Kode lerroa:   $iterCreate(Constructor, NAME, next);
Kode lerroa:   var getMethod = function getMethod(kind) {
Kode lerroa:     if (!BUGGY && kind in proto) return proto[kind];
Kode lerroa:     switch (kind) {
Kode lerroa:       case KEYS:
Kode lerroa:         return function keys() {
Kode lerroa:           return new Constructor(this, kind);
Kode lerroa:         };
Kode lerroa:       case VALUES:
Kode lerroa:         return function values() {
Kode lerroa:           return new Constructor(this, kind);
Kode lerroa:         };
Kode lerroa:     }
Kode lerroa:     return function entries() {
Kode lerroa:       return new Constructor(this, kind);
Kode lerroa:     };
Kode lerroa:   };
Kode lerroa:   var TAG = NAME + ' Iterator';
Kode lerroa:   var DEF_VALUES = DEFAULT == VALUES;
Kode lerroa:   var VALUES_BUG = false;
Kode lerroa:   var proto = Base.prototype;
Kode lerroa:   var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
Kode lerroa:   var $default = $native || getMethod(DEFAULT);
Kode lerroa:   var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
Kode lerroa:   var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
Kode lerroa:   var methods, key, IteratorPrototype;
Kode lerroa:   if ($anyNative) {
Kode lerroa:     IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
Kode lerroa:     if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
Kode lerroa:       setToStringTag(IteratorPrototype, TAG, true);
Kode lerroa:       if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (DEF_VALUES && $native && $native.name !== VALUES) {
Kode lerroa:     VALUES_BUG = true;
Kode lerroa:     $default = function values() {
Kode lerroa:       return $native.call(this);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
Kode lerroa:     hide(proto, ITERATOR, $default);
Kode lerroa:   }
Kode lerroa:   Iterators[NAME] = $default;
Kode lerroa:   Iterators[TAG] = returnThis;
Kode lerroa:   if (DEFAULT) {
Kode lerroa:     methods = {
Kode lerroa:       values: DEF_VALUES ? $default : getMethod(VALUES),
Kode lerroa:       keys: IS_SET ? $default : getMethod(KEYS),
Kode lerroa:       entries: $entries
Kode lerroa:     };
Kode lerroa:     if (FORCED) for (key in methods) {
Kode lerroa:       if (!(key in proto)) redefine(proto, key, methods[key]);
Kode lerroa:     } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
Kode lerroa:   }
Kode lerroa:   return methods;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 60 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var dP = __w_pdfjs_require__(13);
Kode lerroa: var DESCRIPTORS = __w_pdfjs_require__(8);
Kode lerroa: var SPECIES = __w_pdfjs_require__(3)('species');
Kode lerroa: module.exports = function (KEY) {
Kode lerroa:   var C = global[KEY];
Kode lerroa:   if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
Kode lerroa:     configurable: true,
Kode lerroa:     get: function get() {
Kode lerroa:       return this;
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 61 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var pIE = __w_pdfjs_require__(62);
Kode lerroa: var createDesc = __w_pdfjs_require__(27);
Kode lerroa: var toIObject = __w_pdfjs_require__(28);
Kode lerroa: var toPrimitive = __w_pdfjs_require__(33);
Kode lerroa: var has = __w_pdfjs_require__(10);
Kode lerroa: var IE8_DOM_DEFINE = __w_pdfjs_require__(45);
Kode lerroa: var gOPD = Object.getOwnPropertyDescriptor;
Kode lerroa: exports.f = __w_pdfjs_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P) {
Kode lerroa:   O = toIObject(O);
Kode lerroa:   P = toPrimitive(P, true);
Kode lerroa:   if (IE8_DOM_DEFINE) try {
Kode lerroa:     return gOPD(O, P);
Kode lerroa:   } catch (e) {}
Kode lerroa:   if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 62 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: exports.f = {}.propertyIsEnumerable;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 63 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var classof = __w_pdfjs_require__(30);
Kode lerroa: var test = {};
Kode lerroa: test[__w_pdfjs_require__(3)('toStringTag')] = 'z';
Kode lerroa: if (test + '' != '[object z]') {
Kode lerroa:   __w_pdfjs_require__(14)(Object.prototype, 'toString', function toString() {
Kode lerroa:     return '[object ' + classof(this) + ']';
Kode lerroa:   }, true);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 64 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $iterators = __w_pdfjs_require__(58);
Kode lerroa: var getKeys = __w_pdfjs_require__(38);
Kode lerroa: var redefine = __w_pdfjs_require__(14);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var hide = __w_pdfjs_require__(6);
Kode lerroa: var Iterators = __w_pdfjs_require__(19);
Kode lerroa: var wks = __w_pdfjs_require__(3);
Kode lerroa: var ITERATOR = wks('iterator');
Kode lerroa: var TO_STRING_TAG = wks('toStringTag');
Kode lerroa: var ArrayValues = Iterators.Array;
Kode lerroa: var DOMIterables = {
Kode lerroa:   CSSRuleList: true,
Kode lerroa:   CSSStyleDeclaration: false,
Kode lerroa:   CSSValueList: false,
Kode lerroa:   ClientRectList: false,
Kode lerroa:   DOMRectList: false,
Kode lerroa:   DOMStringList: false,
Kode lerroa:   DOMTokenList: true,
Kode lerroa:   DataTransferItemList: false,
Kode lerroa:   FileList: false,
Kode lerroa:   HTMLAllCollection: false,
Kode lerroa:   HTMLCollection: false,
Kode lerroa:   HTMLFormElement: false,
Kode lerroa:   HTMLSelectElement: false,
Kode lerroa:   MediaList: true,
Kode lerroa:   MimeTypeArray: false,
Kode lerroa:   NamedNodeMap: false,
Kode lerroa:   NodeList: true,
Kode lerroa:   PaintRequestList: false,
Kode lerroa:   Plugin: false,
Kode lerroa:   PluginArray: false,
Kode lerroa:   SVGLengthList: false,
Kode lerroa:   SVGNumberList: false,
Kode lerroa:   SVGPathSegList: false,
Kode lerroa:   SVGPointList: false,
Kode lerroa:   SVGStringList: false,
Kode lerroa:   SVGTransformList: false,
Kode lerroa:   SourceBufferList: false,
Kode lerroa:   StyleSheetList: true,
Kode lerroa:   TextTrackCueList: false,
Kode lerroa:   TextTrackList: false,
Kode lerroa:   TouchList: false
Kode lerroa: };
Kode lerroa: for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
Kode lerroa:   var NAME = collections[i];
Kode lerroa:   var explicit = DOMIterables[NAME];
Kode lerroa:   var Collection = global[NAME];
Kode lerroa:   var proto = Collection && Collection.prototype;
Kode lerroa:   var key;
Kode lerroa:   if (proto) {
Kode lerroa:     if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
Kode lerroa:     if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
Kode lerroa:     Iterators[NAME] = ArrayValues;
Kode lerroa:     if (explicit) for (key in $iterators) {
Kode lerroa:       if (!proto[key]) redefine(proto, key, $iterators[key], true);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 65 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ctx = __w_pdfjs_require__(11);
Kode lerroa: var invoke = __w_pdfjs_require__(99);
Kode lerroa: var html = __w_pdfjs_require__(55);
Kode lerroa: var cel = __w_pdfjs_require__(32);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var process = global.process;
Kode lerroa: var setTask = global.setImmediate;
Kode lerroa: var clearTask = global.clearImmediate;
Kode lerroa: var MessageChannel = global.MessageChannel;
Kode lerroa: var Dispatch = global.Dispatch;
Kode lerroa: var counter = 0;
Kode lerroa: var queue = {};
Kode lerroa: var ONREADYSTATECHANGE = 'onreadystatechange';
Kode lerroa: var defer, channel, port;
Kode lerroa: var run = function run() {
Kode lerroa:   var id = +this;
Kode lerroa:   if (queue.hasOwnProperty(id)) {
Kode lerroa:     var fn = queue[id];
Kode lerroa:     delete queue[id];
Kode lerroa:     fn();
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var listener = function listener(event) {
Kode lerroa:   run.call(event.data);
Kode lerroa: };
Kode lerroa: if (!setTask || !clearTask) {
Kode lerroa:   setTask = function setImmediate(fn) {
Kode lerroa:     var args = [];
Kode lerroa:     var i = 1;
Kode lerroa:     while (arguments.length > i) {
Kode lerroa:       args.push(arguments[i++]);
Kode lerroa:     }queue[++counter] = function () {
Kode lerroa:       invoke(typeof fn == 'function' ? fn : Function(fn), args);
Kode lerroa:     };
Kode lerroa:     defer(counter);
Kode lerroa:     return counter;
Kode lerroa:   };
Kode lerroa:   clearTask = function clearImmediate(id) {
Kode lerroa:     delete queue[id];
Kode lerroa:   };
Kode lerroa:   if (__w_pdfjs_require__(25)(process) == 'process') {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       process.nextTick(ctx(run, id, 1));
Kode lerroa:     };
Kode lerroa:   } else if (Dispatch && Dispatch.now) {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       Dispatch.now(ctx(run, id, 1));
Kode lerroa:     };
Kode lerroa:   } else if (MessageChannel) {
Kode lerroa:     channel = new MessageChannel();
Kode lerroa:     port = channel.port2;
Kode lerroa:     channel.port1.onmessage = listener;
Kode lerroa:     defer = ctx(port.postMessage, port, 1);
Kode lerroa:   } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       global.postMessage(id + '', '*');
Kode lerroa:     };
Kode lerroa:     global.addEventListener('message', listener, false);
Kode lerroa:   } else if (ONREADYSTATECHANGE in cel('script')) {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
Kode lerroa:         html.removeChild(this);
Kode lerroa:         run.call(id);
Kode lerroa:       };
Kode lerroa:     };
Kode lerroa:   } else {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       setTimeout(ctx(run, id, 1), 0);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: module.exports = {
Kode lerroa:   set: setTask,
Kode lerroa:   clear: clearTask
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 66 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (exec) {
Kode lerroa:   try {
Kode lerroa:     return {
Kode lerroa:       e: false,
Kode lerroa:       v: exec()
Kode lerroa:     };
Kode lerroa:   } catch (e) {
Kode lerroa:     return {
Kode lerroa:       e: true,
Kode lerroa:       v: e
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 67 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var newPromiseCapability = __w_pdfjs_require__(42);
Kode lerroa: module.exports = function (C, x) {
Kode lerroa:   anObject(C);
Kode lerroa:   if (isObject(x) && x.constructor === C) return x;
Kode lerroa:   var promiseCapability = newPromiseCapability.f(C);
Kode lerroa:   var resolve = promiseCapability.resolve;
Kode lerroa:   resolve(x);
Kode lerroa:   return promiseCapability.promise;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 68 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: module.exports = function (it, TYPE) {
Kode lerroa:   if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 69 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.build = exports.version = exports._UnsupportedManager = exports.setPDFNetworkStreamClass = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.getDocument = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _dom_utils = __w_pdfjs_require__(15);
Kode lerroa: 
Kode lerroa: var _font_loader = __w_pdfjs_require__(119);
Kode lerroa: 
Kode lerroa: var _canvas = __w_pdfjs_require__(120);
Kode lerroa: 
Kode lerroa: var _global_scope = __w_pdfjs_require__(20);
Kode lerroa: 
Kode lerroa: var _global_scope2 = _interopRequireDefault(_global_scope);
Kode lerroa: 
Kode lerroa: var _metadata = __w_pdfjs_require__(71);
Kode lerroa: 
Kode lerroa: var _transport_stream = __w_pdfjs_require__(123);
Kode lerroa: 
Kode lerroa: function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DEFAULT_RANGE_CHUNK_SIZE = 65536;
Kode lerroa: var isWorkerDisabled = false;
Kode lerroa: var workerSrc;
Kode lerroa: var isPostMessageTransfersDisabled = false;
Kode lerroa: var pdfjsFilePath = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : null;
Kode lerroa: var fakeWorkerFilesLoader = null;
Kode lerroa: var useRequireEnsure = false;
Kode lerroa: {
Kode lerroa:   if (typeof window === 'undefined') {
Kode lerroa:     isWorkerDisabled = true;
Kode lerroa:     if (typeof require.ensure === 'undefined') {
Kode lerroa:       require.ensure = require('node-ensure');
Kode lerroa:     }
Kode lerroa:     useRequireEnsure = true;
Kode lerroa:   } else if (typeof require !== 'undefined' && typeof require.ensure === 'function') {
Kode lerroa:     useRequireEnsure = true;
Kode lerroa:   }
Kode lerroa:   if (typeof requirejs !== 'undefined' && requirejs.toUrl) {
Kode lerroa:     workerSrc = requirejs.toUrl('pdfjs-dist/build/pdf.worker.js');
Kode lerroa:   }
Kode lerroa:   var dynamicLoaderSupported = typeof requirejs !== 'undefined' && requirejs.load;
Kode lerroa:   fakeWorkerFilesLoader = useRequireEnsure ? function (callback) {
Kode lerroa:     require.ensure([], function () {
Kode lerroa:       var worker;
Kode lerroa:       worker = require('./pdf.worker.js');
Kode lerroa:       callback(worker.WorkerMessageHandler);
Kode lerroa:     });
Kode lerroa:   } : dynamicLoaderSupported ? function (callback) {
Kode lerroa:     requirejs(['pdfjs-dist/build/pdf.worker'], function (worker) {
Kode lerroa:       callback(worker.WorkerMessageHandler);
Kode lerroa:     });
Kode lerroa:   } : null;
Kode lerroa: }
Kode lerroa: var PDFNetworkStream;
Kode lerroa: function setPDFNetworkStreamClass(cls) {
Kode lerroa:   PDFNetworkStream = cls;
Kode lerroa: }
Kode lerroa: function getDocument(src, pdfDataRangeTransport, passwordCallback, progressCallback) {
Kode lerroa:   var task = new PDFDocumentLoadingTask();
Kode lerroa:   if (arguments.length > 1) {
Kode lerroa:     (0, _util.deprecated)('getDocument is called with pdfDataRangeTransport, ' + 'passwordCallback or progressCallback argument');
Kode lerroa:   }
Kode lerroa:   if (pdfDataRangeTransport) {
Kode lerroa:     if (!(pdfDataRangeTransport instanceof PDFDataRangeTransport)) {
Kode lerroa:       pdfDataRangeTransport = Object.create(pdfDataRangeTransport);
Kode lerroa:       pdfDataRangeTransport.length = src.length;
Kode lerroa:       pdfDataRangeTransport.initialData = src.initialData;
Kode lerroa:       if (!pdfDataRangeTransport.abort) {
Kode lerroa:         pdfDataRangeTransport.abort = function () {};
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     src = Object.create(src);
Kode lerroa:     src.range = pdfDataRangeTransport;
Kode lerroa:   }
Kode lerroa:   task.onPassword = passwordCallback || null;
Kode lerroa:   task.onProgress = progressCallback || null;
Kode lerroa:   var source;
Kode lerroa:   if (typeof src === 'string') {
Kode lerroa:     source = { url: src };
Kode lerroa:   } else if ((0, _util.isArrayBuffer)(src)) {
Kode lerroa:     source = { data: src };
Kode lerroa:   } else if (src instanceof PDFDataRangeTransport) {
Kode lerroa:     source = { range: src };
Kode lerroa:   } else {
Kode lerroa:     if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) !== 'object') {
Kode lerroa:       throw new Error('Invalid parameter in getDocument, ' + 'need either Uint8Array, string or a parameter object');
Kode lerroa:     }
Kode lerroa:     if (!src.url && !src.data && !src.range) {
Kode lerroa:       throw new Error('Invalid parameter object: need either .data, .range or .url');
Kode lerroa:     }
Kode lerroa:     source = src;
Kode lerroa:   }
Kode lerroa:   var params = {};
Kode lerroa:   var rangeTransport = null;
Kode lerroa:   var worker = null;
Kode lerroa:   var CMapReaderFactory = _dom_utils.DOMCMapReaderFactory;
Kode lerroa:   for (var key in source) {
Kode lerroa:     if (key === 'url' && typeof window !== 'undefined') {
Kode lerroa:       params[key] = new URL(source[key], window.location).href;
Kode lerroa:       continue;
Kode lerroa:     } else if (key === 'range') {
Kode lerroa:       rangeTransport = source[key];
Kode lerroa:       continue;
Kode lerroa:     } else if (key === 'worker') {
Kode lerroa:       worker = source[key];
Kode lerroa:       continue;
Kode lerroa:     } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {
Kode lerroa:       var pdfBytes = source[key];
Kode lerroa:       if (typeof pdfBytes === 'string') {
Kode lerroa:         params[key] = (0, _util.stringToBytes)(pdfBytes);
Kode lerroa:       } else if ((typeof pdfBytes === 'undefined' ? 'undefined' : _typeof(pdfBytes)) === 'object' && pdfBytes !== null && !isNaN(pdfBytes.length)) {
Kode lerroa:         params[key] = new Uint8Array(pdfBytes);
Kode lerroa:       } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
Kode lerroa:         params[key] = new Uint8Array(pdfBytes);
Kode lerroa:       } else {
Kode lerroa:         throw new Error('Invalid PDF binary data: either typed array, ' + 'string or array-like object is expected in the ' + 'data property.');
Kode lerroa:       }
Kode lerroa:       continue;
Kode lerroa:     } else if (key === 'CMapReaderFactory') {
Kode lerroa:       CMapReaderFactory = source[key];
Kode lerroa:       continue;
Kode lerroa:     }
Kode lerroa:     params[key] = source[key];
Kode lerroa:   }
Kode lerroa:   params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
Kode lerroa:   params.ignoreErrors = params.stopAtErrors !== true;
Kode lerroa:   if (params.disableNativeImageDecoder !== undefined) {
Kode lerroa:     (0, _util.deprecated)('parameter disableNativeImageDecoder, ' + 'use nativeImageDecoderSupport instead');
Kode lerroa:   }
Kode lerroa:   params.nativeImageDecoderSupport = params.nativeImageDecoderSupport || (params.disableNativeImageDecoder === true ? _util.NativeImageDecoding.NONE : _util.NativeImageDecoding.DECODE);
Kode lerroa:   if (params.nativeImageDecoderSupport !== _util.NativeImageDecoding.DECODE && params.nativeImageDecoderSupport !== _util.NativeImageDecoding.NONE && params.nativeImageDecoderSupport !== _util.NativeImageDecoding.DISPLAY) {
Kode lerroa:     (0, _util.warn)('Invalid parameter nativeImageDecoderSupport: ' + 'need a state of enum {NativeImageDecoding}');
Kode lerroa:     params.nativeImageDecoderSupport = _util.NativeImageDecoding.DECODE;
Kode lerroa:   }
Kode lerroa:   if (!worker) {
Kode lerroa:     var workerPort = (0, _dom_utils.getDefaultSetting)('workerPort');
Kode lerroa:     worker = workerPort ? PDFWorker.fromPort(workerPort) : new PDFWorker();
Kode lerroa:     task._worker = worker;
Kode lerroa:   }
Kode lerroa:   var docId = task.docId;
Kode lerroa:   worker.promise.then(function () {
Kode lerroa:     if (task.destroyed) {
Kode lerroa:       throw new Error('Loading aborted');
Kode lerroa:     }
Kode lerroa:     return _fetchDocument(worker, params, rangeTransport, docId).then(function (workerId) {
Kode lerroa:       if (task.destroyed) {
Kode lerroa:         throw new Error('Loading aborted');
Kode lerroa:       }
Kode lerroa:       var networkStream = void 0;
Kode lerroa:       if (rangeTransport) {
Kode lerroa:         networkStream = new _transport_stream.PDFDataTransportStream(params, rangeTransport);
Kode lerroa:       } else if (!params.data) {
Kode lerroa:         networkStream = new PDFNetworkStream({
Kode lerroa:           source: params,
Kode lerroa:           disableRange: (0, _dom_utils.getDefaultSetting)('disableRange')
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var messageHandler = new _util.MessageHandler(docId, workerId, worker.port);
Kode lerroa:       messageHandler.postMessageTransfers = worker.postMessageTransfers;
Kode lerroa:       var transport = new WorkerTransport(messageHandler, task, networkStream, CMapReaderFactory);
Kode lerroa:       task._transport = transport;
Kode lerroa:       messageHandler.send('Ready', null);
Kode lerroa:     });
Kode lerroa:   }).catch(task._capability.reject);
Kode lerroa:   return task;
Kode lerroa: }
Kode lerroa: function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
Kode lerroa:   if (worker.destroyed) {
Kode lerroa:     return Promise.reject(new Error('Worker was destroyed'));
Kode lerroa:   }
Kode lerroa:   var apiVersion = '1.10.100';
Kode lerroa:   source.disableAutoFetch = (0, _dom_utils.getDefaultSetting)('disableAutoFetch');
Kode lerroa:   source.disableStream = (0, _dom_utils.getDefaultSetting)('disableStream');
Kode lerroa:   source.chunkedViewerLoading = !!pdfDataRangeTransport;
Kode lerroa:   if (pdfDataRangeTransport) {
Kode lerroa:     source.length = pdfDataRangeTransport.length;
Kode lerroa:     source.initialData = pdfDataRangeTransport.initialData;
Kode lerroa:   }
Kode lerroa:   return worker.messageHandler.sendWithPromise('GetDocRequest', {
Kode lerroa:     docId: docId,
Kode lerroa:     apiVersion: apiVersion,
Kode lerroa:     source: {
Kode lerroa:       data: source.data,
Kode lerroa:       url: source.url,
Kode lerroa:       password: source.password,
Kode lerroa:       disableAutoFetch: source.disableAutoFetch,
Kode lerroa:       rangeChunkSize: source.rangeChunkSize,
Kode lerroa:       length: source.length
Kode lerroa:     },
Kode lerroa:     maxImageSize: (0, _dom_utils.getDefaultSetting)('maxImageSize'),
Kode lerroa:     disableFontFace: (0, _dom_utils.getDefaultSetting)('disableFontFace'),
Kode lerroa:     disableCreateObjectURL: (0, _dom_utils.getDefaultSetting)('disableCreateObjectURL'),
Kode lerroa:     postMessageTransfers: (0, _dom_utils.getDefaultSetting)('postMessageTransfers') && !isPostMessageTransfersDisabled,
Kode lerroa:     docBaseUrl: source.docBaseUrl,
Kode lerroa:     nativeImageDecoderSupport: source.nativeImageDecoderSupport,
Kode lerroa:     ignoreErrors: source.ignoreErrors,
Kode lerroa:     isEvalSupported: (0, _dom_utils.getDefaultSetting)('isEvalSupported')
Kode lerroa:   }).then(function (workerId) {
Kode lerroa:     if (worker.destroyed) {
Kode lerroa:       throw new Error('Worker was destroyed');
Kode lerroa:     }
Kode lerroa:     return workerId;
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
Kode lerroa:   var nextDocumentId = 0;
Kode lerroa:   function PDFDocumentLoadingTask() {
Kode lerroa:     this._capability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._transport = null;
Kode lerroa:     this._worker = null;
Kode lerroa:     this.docId = 'd' + nextDocumentId++;
Kode lerroa:     this.destroyed = false;
Kode lerroa:     this.onPassword = null;
Kode lerroa:     this.onProgress = null;
Kode lerroa:     this.onUnsupportedFeature = null;
Kode lerroa:   }
Kode lerroa:   PDFDocumentLoadingTask.prototype = {
Kode lerroa:     get promise() {
Kode lerroa:       return this._capability.promise;
Kode lerroa:     },
Kode lerroa:     destroy: function destroy() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       this.destroyed = true;
Kode lerroa:       var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
Kode lerroa:       return transportDestroyed.then(function () {
Kode lerroa:         _this._transport = null;
Kode lerroa:         if (_this._worker) {
Kode lerroa:           _this._worker.destroy();
Kode lerroa:           _this._worker = null;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {
Kode lerroa:       return this.promise.then.apply(this.promise, arguments);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDFDocumentLoadingTask;
Kode lerroa: }();
Kode lerroa: var PDFDataRangeTransport = function pdfDataRangeTransportClosure() {
Kode lerroa:   function PDFDataRangeTransport(length, initialData) {
Kode lerroa:     this.length = length;
Kode lerroa:     this.initialData = initialData;
Kode lerroa:     this._rangeListeners = [];
Kode lerroa:     this._progressListeners = [];
Kode lerroa:     this._progressiveReadListeners = [];
Kode lerroa:     this._readyCapability = (0, _util.createPromiseCapability)();
Kode lerroa:   }
Kode lerroa:   PDFDataRangeTransport.prototype = {
Kode lerroa:     addRangeListener: function PDFDataRangeTransport_addRangeListener(listener) {
Kode lerroa:       this._rangeListeners.push(listener);
Kode lerroa:     },
Kode lerroa:     addProgressListener: function PDFDataRangeTransport_addProgressListener(listener) {
Kode lerroa:       this._progressListeners.push(listener);
Kode lerroa:     },
Kode lerroa:     addProgressiveReadListener: function PDFDataRangeTransport_addProgressiveReadListener(listener) {
Kode lerroa:       this._progressiveReadListeners.push(listener);
Kode lerroa:     },
Kode lerroa:     onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {
Kode lerroa:       var listeners = this._rangeListeners;
Kode lerroa:       for (var i = 0, n = listeners.length; i < n; ++i) {
Kode lerroa:         listeners[i](begin, chunk);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       this._readyCapability.promise.then(function () {
Kode lerroa:         var listeners = _this2._progressListeners;
Kode lerroa:         for (var i = 0, n = listeners.length; i < n; ++i) {
Kode lerroa:           listeners[i](loaded);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     onDataProgressiveRead: function PDFDataRangeTransport_onDataProgress(chunk) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       this._readyCapability.promise.then(function () {
Kode lerroa:         var listeners = _this3._progressiveReadListeners;
Kode lerroa:         for (var i = 0, n = listeners.length; i < n; ++i) {
Kode lerroa:           listeners[i](chunk);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     transportReady: function PDFDataRangeTransport_transportReady() {
Kode lerroa:       this._readyCapability.resolve();
Kode lerroa:     },
Kode lerroa:     requestDataRange: function PDFDataRangeTransport_requestDataRange(begin, end) {
Kode lerroa:       throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');
Kode lerroa:     },
Kode lerroa:     abort: function PDFDataRangeTransport_abort() {}
Kode lerroa:   };
Kode lerroa:   return PDFDataRangeTransport;
Kode lerroa: }();
Kode lerroa: var PDFDocumentProxy = function PDFDocumentProxyClosure() {
Kode lerroa:   function PDFDocumentProxy(pdfInfo, transport, loadingTask) {
Kode lerroa:     this.pdfInfo = pdfInfo;
Kode lerroa:     this.transport = transport;
Kode lerroa:     this.loadingTask = loadingTask;
Kode lerroa:   }
Kode lerroa:   PDFDocumentProxy.prototype = {
Kode lerroa:     get numPages() {
Kode lerroa:       return this.pdfInfo.numPages;
Kode lerroa:     },
Kode lerroa:     get fingerprint() {
Kode lerroa:       return this.pdfInfo.fingerprint;
Kode lerroa:     },
Kode lerroa:     getPage: function PDFDocumentProxy_getPage(pageNumber) {
Kode lerroa:       return this.transport.getPage(pageNumber);
Kode lerroa:     },
Kode lerroa:     getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {
Kode lerroa:       return this.transport.getPageIndex(ref);
Kode lerroa:     },
Kode lerroa:     getDestinations: function PDFDocumentProxy_getDestinations() {
Kode lerroa:       return this.transport.getDestinations();
Kode lerroa:     },
Kode lerroa:     getDestination: function PDFDocumentProxy_getDestination(id) {
Kode lerroa:       return this.transport.getDestination(id);
Kode lerroa:     },
Kode lerroa:     getPageLabels: function PDFDocumentProxy_getPageLabels() {
Kode lerroa:       return this.transport.getPageLabels();
Kode lerroa:     },
Kode lerroa:     getPageMode: function getPageMode() {
Kode lerroa:       return this.transport.getPageMode();
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     getAttachments: function PDFDocumentProxy_getAttachments() {
Kode lerroa:       return this.transport.getAttachments();
Kode lerroa:     },
Kode lerroa:     getJavaScript: function PDFDocumentProxy_getJavaScript() {
Kode lerroa:       return this.transport.getJavaScript();
Kode lerroa:     },
Kode lerroa:     getOutline: function PDFDocumentProxy_getOutline() {
Kode lerroa:       return this.transport.getOutline();
Kode lerroa:     },
Kode lerroa:     getMetadata: function PDFDocumentProxy_getMetadata() {
Kode lerroa:       return this.transport.getMetadata();
Kode lerroa:     },
Kode lerroa:     getData: function PDFDocumentProxy_getData() {
Kode lerroa:       return this.transport.getData();
Kode lerroa:     },
Kode lerroa:     getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {
Kode lerroa:       return this.transport.downloadInfoCapability.promise;
Kode lerroa:     },
Kode lerroa:     getStats: function PDFDocumentProxy_getStats() {
Kode lerroa:       return this.transport.getStats();
Kode lerroa:     },
Kode lerroa:     cleanup: function PDFDocumentProxy_cleanup() {
Kode lerroa:       this.transport.startCleanup();
Kode lerroa:     },
Kode lerroa:     destroy: function PDFDocumentProxy_destroy() {
Kode lerroa:       return this.loadingTask.destroy();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDFDocumentProxy;
Kode lerroa: }();
Kode lerroa: var PDFPageProxy = function PDFPageProxyClosure() {
Kode lerroa:   function PDFPageProxy(pageIndex, pageInfo, transport) {
Kode lerroa:     this.pageIndex = pageIndex;
Kode lerroa:     this.pageInfo = pageInfo;
Kode lerroa:     this.transport = transport;
Kode lerroa:     this.stats = new _util.StatTimer();
Kode lerroa:     this.stats.enabled = (0, _dom_utils.getDefaultSetting)('enableStats');
Kode lerroa:     this.commonObjs = transport.commonObjs;
Kode lerroa:     this.objs = new PDFObjects();
Kode lerroa:     this.cleanupAfterRender = false;
Kode lerroa:     this.pendingCleanup = false;
Kode lerroa:     this.intentStates = Object.create(null);
Kode lerroa:     this.destroyed = false;
Kode lerroa:   }
Kode lerroa:   PDFPageProxy.prototype = {
Kode lerroa:     get pageNumber() {
Kode lerroa:       return this.pageIndex + 1;
Kode lerroa:     },
Kode lerroa:     get rotate() {
Kode lerroa:       return this.pageInfo.rotate;
Kode lerroa:     },
Kode lerroa:     get ref() {
Kode lerroa:       return this.pageInfo.ref;
Kode lerroa:     },
Kode lerroa:     get userUnit() {
Kode lerroa:       return this.pageInfo.userUnit;
Kode lerroa:     },
Kode lerroa:     get view() {
Kode lerroa:       return this.pageInfo.view;
Kode lerroa:     },
Kode lerroa:     getViewport: function PDFPageProxy_getViewport(scale, rotate) {
Kode lerroa:       if (arguments.length < 2) {
Kode lerroa:         rotate = this.rotate;
Kode lerroa:       }
Kode lerroa:       return new _util.PageViewport(this.view, scale, rotate, 0, 0);
Kode lerroa:     },
Kode lerroa:     getAnnotations: function PDFPageProxy_getAnnotations(params) {
Kode lerroa:       var intent = params && params.intent || null;
Kode lerroa:       if (!this.annotationsPromise || this.annotationsIntent !== intent) {
Kode lerroa:         this.annotationsPromise = this.transport.getAnnotations(this.pageIndex, intent);
Kode lerroa:         this.annotationsIntent = intent;
Kode lerroa:       }
Kode lerroa:       return this.annotationsPromise;
Kode lerroa:     },
Kode lerroa:     render: function PDFPageProxy_render(params) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       var stats = this.stats;
Kode lerroa:       stats.time('Overall');
Kode lerroa:       this.pendingCleanup = false;
Kode lerroa:       var renderingIntent = params.intent === 'print' ? 'print' : 'display';
Kode lerroa:       var canvasFactory = params.canvasFactory || new _dom_utils.DOMCanvasFactory();
Kode lerroa:       if (!this.intentStates[renderingIntent]) {
Kode lerroa:         this.intentStates[renderingIntent] = Object.create(null);
Kode lerroa:       }
Kode lerroa:       var intentState = this.intentStates[renderingIntent];
Kode lerroa:       if (!intentState.displayReadyCapability) {
Kode lerroa:         intentState.receivingOperatorList = true;
Kode lerroa:         intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
Kode lerroa:         intentState.operatorList = {
Kode lerroa:           fnArray: [],
Kode lerroa:           argsArray: [],
Kode lerroa:           lastChunk: false
Kode lerroa:         };
Kode lerroa:         this.stats.time('Page Request');
Kode lerroa:         this.transport.messageHandler.send('RenderPageRequest', {
Kode lerroa:           pageIndex: this.pageNumber - 1,
Kode lerroa:           intent: renderingIntent,
Kode lerroa:           renderInteractiveForms: params.renderInteractiveForms === true
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var complete = function complete(error) {
Kode lerroa:         var i = intentState.renderTasks.indexOf(internalRenderTask);
Kode lerroa:         if (i >= 0) {
Kode lerroa:           intentState.renderTasks.splice(i, 1);
Kode lerroa:         }
Kode lerroa:         if (_this4.cleanupAfterRender) {
Kode lerroa:           _this4.pendingCleanup = true;
Kode lerroa:         }
Kode lerroa:         _this4._tryCleanup();
Kode lerroa:         if (error) {
Kode lerroa:           internalRenderTask.capability.reject(error);
Kode lerroa:         } else {
Kode lerroa:           internalRenderTask.capability.resolve();
Kode lerroa:         }
Kode lerroa:         stats.timeEnd('Rendering');
Kode lerroa:         stats.timeEnd('Overall');
Kode lerroa:       };
Kode lerroa:       var internalRenderTask = new InternalRenderTask(complete, params, this.objs, this.commonObjs, intentState.operatorList, this.pageNumber, canvasFactory);
Kode lerroa:       internalRenderTask.useRequestAnimationFrame = renderingIntent !== 'print';
Kode lerroa:       if (!intentState.renderTasks) {
Kode lerroa:         intentState.renderTasks = [];
Kode lerroa:       }
Kode lerroa:       intentState.renderTasks.push(internalRenderTask);
Kode lerroa:       var renderTask = internalRenderTask.task;
Kode lerroa:       if (params.continueCallback) {
Kode lerroa:         (0, _util.deprecated)('render is used with continueCallback parameter');
Kode lerroa:         renderTask.onContinue = params.continueCallback;
Kode lerroa:       }
Kode lerroa:       intentState.displayReadyCapability.promise.then(function (transparency) {
Kode lerroa:         if (_this4.pendingCleanup) {
Kode lerroa:           complete();
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         stats.time('Rendering');
Kode lerroa:         internalRenderTask.initializeGraphics(transparency);
Kode lerroa:         internalRenderTask.operatorListChanged();
Kode lerroa:       }).catch(complete);
Kode lerroa:       return renderTask;
Kode lerroa:     },
Kode lerroa:     getOperatorList: function PDFPageProxy_getOperatorList() {
Kode lerroa:       function operatorListChanged() {
Kode lerroa:         if (intentState.operatorList.lastChunk) {
Kode lerroa:           intentState.opListReadCapability.resolve(intentState.operatorList);
Kode lerroa:           var i = intentState.renderTasks.indexOf(opListTask);
Kode lerroa:           if (i >= 0) {
Kode lerroa:             intentState.renderTasks.splice(i, 1);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var renderingIntent = 'oplist';
Kode lerroa:       if (!this.intentStates[renderingIntent]) {
Kode lerroa:         this.intentStates[renderingIntent] = Object.create(null);
Kode lerroa:       }
Kode lerroa:       var intentState = this.intentStates[renderingIntent];
Kode lerroa:       var opListTask;
Kode lerroa:       if (!intentState.opListReadCapability) {
Kode lerroa:         opListTask = {};
Kode lerroa:         opListTask.operatorListChanged = operatorListChanged;
Kode lerroa:         intentState.receivingOperatorList = true;
Kode lerroa:         intentState.opListReadCapability = (0, _util.createPromiseCapability)();
Kode lerroa:         intentState.renderTasks = [];
Kode lerroa:         intentState.renderTasks.push(opListTask);
Kode lerroa:         intentState.operatorList = {
Kode lerroa:           fnArray: [],
Kode lerroa:           argsArray: [],
Kode lerroa:           lastChunk: false
Kode lerroa:         };
Kode lerroa:         this.transport.messageHandler.send('RenderPageRequest', {
Kode lerroa:           pageIndex: this.pageIndex,
Kode lerroa:           intent: renderingIntent
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       return intentState.opListReadCapability.promise;
Kode lerroa:     },
Kode lerroa:     streamTextContent: function streamTextContent() {
Kode lerroa:       var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
Kode lerroa: 
Kode lerroa:       var TEXT_CONTENT_CHUNK_SIZE = 100;
Kode lerroa:       return this.transport.messageHandler.sendWithStream('GetTextContent', {
Kode lerroa:         pageIndex: this.pageNumber - 1,
Kode lerroa:         normalizeWhitespace: params.normalizeWhitespace === true,
Kode lerroa:         combineTextItems: params.disableCombineTextItems !== true
Kode lerroa:       }, {
Kode lerroa:         highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
Kode lerroa:         size: function size(textContent) {
Kode lerroa:           return textContent.items.length;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     getTextContent: function PDFPageProxy_getTextContent(params) {
Kode lerroa:       params = params || {};
Kode lerroa:       var readableStream = this.streamTextContent(params);
Kode lerroa:       return new Promise(function (resolve, reject) {
Kode lerroa:         function pump() {
Kode lerroa:           reader.read().then(function (_ref) {
Kode lerroa:             var value = _ref.value,
Kode lerroa:                 done = _ref.done;
Kode lerroa: 
Kode lerroa:             if (done) {
Kode lerroa:               resolve(textContent);
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             _util.Util.extendObj(textContent.styles, value.styles);
Kode lerroa:             _util.Util.appendToArray(textContent.items, value.items);
Kode lerroa:             pump();
Kode lerroa:           }, reject);
Kode lerroa:         }
Kode lerroa:         var reader = readableStream.getReader();
Kode lerroa:         var textContent = {
Kode lerroa:           items: [],
Kode lerroa:           styles: Object.create(null)
Kode lerroa:         };
Kode lerroa:         pump();
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     _destroy: function PDFPageProxy_destroy() {
Kode lerroa:       this.destroyed = true;
Kode lerroa:       this.transport.pageCache[this.pageIndex] = null;
Kode lerroa:       var waitOn = [];
Kode lerroa:       Object.keys(this.intentStates).forEach(function (intent) {
Kode lerroa:         if (intent === 'oplist') {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var intentState = this.intentStates[intent];
Kode lerroa:         intentState.renderTasks.forEach(function (renderTask) {
Kode lerroa:           var renderCompleted = renderTask.capability.promise.catch(function () {});
Kode lerroa:           waitOn.push(renderCompleted);
Kode lerroa:           renderTask.cancel();
Kode lerroa:         });
Kode lerroa:       }, this);
Kode lerroa:       this.objs.clear();
Kode lerroa:       this.annotationsPromise = null;
Kode lerroa:       this.pendingCleanup = false;
Kode lerroa:       return Promise.all(waitOn);
Kode lerroa:     },
Kode lerroa:     destroy: function destroy() {
Kode lerroa:       (0, _util.deprecated)('page destroy method, use cleanup() instead');
Kode lerroa:       this.cleanup();
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     cleanup: function PDFPageProxy_cleanup() {
Kode lerroa:       this.pendingCleanup = true;
Kode lerroa:       this._tryCleanup();
Kode lerroa:     },
Kode lerroa:     _tryCleanup: function PDFPageProxy_tryCleanup() {
Kode lerroa:       if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) {
Kode lerroa:         var intentState = this.intentStates[intent];
Kode lerroa:         return intentState.renderTasks.length !== 0 || intentState.receivingOperatorList;
Kode lerroa:       }, this)) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       Object.keys(this.intentStates).forEach(function (intent) {
Kode lerroa:         delete this.intentStates[intent];
Kode lerroa:       }, this);
Kode lerroa:       this.objs.clear();
Kode lerroa:       this.annotationsPromise = null;
Kode lerroa:       this.pendingCleanup = false;
Kode lerroa:     },
Kode lerroa:     _startRenderPage: function PDFPageProxy_startRenderPage(transparency, intent) {
Kode lerroa:       var intentState = this.intentStates[intent];
Kode lerroa:       if (intentState.displayReadyCapability) {
Kode lerroa:         intentState.displayReadyCapability.resolve(transparency);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk, intent) {
Kode lerroa:       var intentState = this.intentStates[intent];
Kode lerroa:       var i, ii;
Kode lerroa:       for (i = 0, ii = operatorListChunk.length; i < ii; i++) {
Kode lerroa:         intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
Kode lerroa:         intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
Kode lerroa:       }
Kode lerroa:       intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
Kode lerroa:       for (i = 0; i < intentState.renderTasks.length; i++) {
Kode lerroa:         intentState.renderTasks[i].operatorListChanged();
Kode lerroa:       }
Kode lerroa:       if (operatorListChunk.lastChunk) {
Kode lerroa:         intentState.receivingOperatorList = false;
Kode lerroa:         this._tryCleanup();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDFPageProxy;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var LoopbackPort = function () {
Kode lerroa:   function LoopbackPort(defer) {
Kode lerroa:     _classCallCheck(this, LoopbackPort);
Kode lerroa: 
Kode lerroa:     this._listeners = [];
Kode lerroa:     this._defer = defer;
Kode lerroa:     this._deferred = Promise.resolve(undefined);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(LoopbackPort, [{
Kode lerroa:     key: 'postMessage',
Kode lerroa:     value: function postMessage(obj, transfers) {
Kode lerroa:       var _this5 = this;
Kode lerroa: 
Kode lerroa:       function cloneValue(value) {
Kode lerroa:         if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {
Kode lerroa:           return value;
Kode lerroa:         }
Kode lerroa:         if (cloned.has(value)) {
Kode lerroa:           return cloned.get(value);
Kode lerroa:         }
Kode lerroa:         var result;
Kode lerroa:         var buffer;
Kode lerroa:         if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
Kode lerroa:           var transferable = transfers && transfers.indexOf(buffer) >= 0;
Kode lerroa:           if (value === buffer) {
Kode lerroa:             result = value;
Kode lerroa:           } else if (transferable) {
Kode lerroa:             result = new value.constructor(buffer, value.byteOffset, value.byteLength);
Kode lerroa:           } else {
Kode lerroa:             result = new value.constructor(value);
Kode lerroa:           }
Kode lerroa:           cloned.set(value, result);
Kode lerroa:           return result;
Kode lerroa:         }
Kode lerroa:         result = Array.isArray(value) ? [] : {};
Kode lerroa:         cloned.set(value, result);
Kode lerroa:         for (var i in value) {
Kode lerroa:           var desc,
Kode lerroa:               p = value;
Kode lerroa:           while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
Kode lerroa:             p = Object.getPrototypeOf(p);
Kode lerroa:           }
Kode lerroa:           if (typeof desc.value === 'undefined' || typeof desc.value === 'function') {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           result[i] = cloneValue(desc.value);
Kode lerroa:         }
Kode lerroa:         return result;
Kode lerroa:       }
Kode lerroa:       if (!this._defer) {
Kode lerroa:         this._listeners.forEach(function (listener) {
Kode lerroa:           listener.call(this, { data: obj });
Kode lerroa:         }, this);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var cloned = new WeakMap();
Kode lerroa:       var e = { data: cloneValue(obj) };
Kode lerroa:       this._deferred.then(function () {
Kode lerroa:         _this5._listeners.forEach(function (listener) {
Kode lerroa:           listener.call(this, e);
Kode lerroa:         }, _this5);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'addEventListener',
Kode lerroa:     value: function addEventListener(name, listener) {
Kode lerroa:       this._listeners.push(listener);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'removeEventListener',
Kode lerroa:     value: function removeEventListener(name, listener) {
Kode lerroa:       var i = this._listeners.indexOf(listener);
Kode lerroa:       this._listeners.splice(i, 1);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'terminate',
Kode lerroa:     value: function terminate() {
Kode lerroa:       this._listeners = [];
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return LoopbackPort;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var PDFWorker = function PDFWorkerClosure() {
Kode lerroa:   var nextFakeWorkerId = 0;
Kode lerroa:   function getWorkerSrc() {
Kode lerroa:     if (typeof workerSrc !== 'undefined') {
Kode lerroa:       return workerSrc;
Kode lerroa:     }
Kode lerroa:     if ((0, _dom_utils.getDefaultSetting)('workerSrc')) {
Kode lerroa:       return (0, _dom_utils.getDefaultSetting)('workerSrc');
Kode lerroa:     }
Kode lerroa:     if (pdfjsFilePath) {
Kode lerroa:       return pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, '.worker$1$2');
Kode lerroa:     }
Kode lerroa:     throw new Error('No PDFJS.workerSrc specified');
Kode lerroa:   }
Kode lerroa:   var fakeWorkerFilesLoadedCapability = void 0;
Kode lerroa:   function setupFakeWorkerGlobal() {
Kode lerroa:     var WorkerMessageHandler;
Kode lerroa:     if (fakeWorkerFilesLoadedCapability) {
Kode lerroa:       return fakeWorkerFilesLoadedCapability.promise;
Kode lerroa:     }
Kode lerroa:     fakeWorkerFilesLoadedCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     var loader = fakeWorkerFilesLoader || function (callback) {
Kode lerroa:       _util.Util.loadScript(getWorkerSrc(), function () {
Kode lerroa:         callback(window.pdfjsDistBuildPdfWorker.WorkerMessageHandler);
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     loader(fakeWorkerFilesLoadedCapability.resolve);
Kode lerroa:     return fakeWorkerFilesLoadedCapability.promise;
Kode lerroa:   }
Kode lerroa:   function createCDNWrapper(url) {
Kode lerroa:     var wrapper = 'importScripts(\'' + url + '\');';
Kode lerroa:     return URL.createObjectURL(new Blob([wrapper]));
Kode lerroa:   }
Kode lerroa:   var pdfWorkerPorts = new WeakMap();
Kode lerroa:   function PDFWorker(name, port) {
Kode lerroa:     if (port && pdfWorkerPorts.has(port)) {
Kode lerroa:       throw new Error('Cannot use more than one PDFWorker per port');
Kode lerroa:     }
Kode lerroa:     this.name = name;
Kode lerroa:     this.destroyed = false;
Kode lerroa:     this.postMessageTransfers = true;
Kode lerroa:     this._readyCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._port = null;
Kode lerroa:     this._webWorker = null;
Kode lerroa:     this._messageHandler = null;
Kode lerroa:     if (port) {
Kode lerroa:       pdfWorkerPorts.set(port, this);
Kode lerroa:       this._initializeFromPort(port);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this._initialize();
Kode lerroa:   }
Kode lerroa:   PDFWorker.prototype = {
Kode lerroa:     get promise() {
Kode lerroa:       return this._readyCapability.promise;
Kode lerroa:     },
Kode lerroa:     get port() {
Kode lerroa:       return this._port;
Kode lerroa:     },
Kode lerroa:     get messageHandler() {
Kode lerroa:       return this._messageHandler;
Kode lerroa:     },
Kode lerroa:     _initializeFromPort: function PDFWorker_initializeFromPort(port) {
Kode lerroa:       this._port = port;
Kode lerroa:       this._messageHandler = new _util.MessageHandler('main', 'worker', port);
Kode lerroa:       this._messageHandler.on('ready', function () {});
Kode lerroa:       this._readyCapability.resolve();
Kode lerroa:     },
Kode lerroa:     _initialize: function PDFWorker_initialize() {
Kode lerroa:       var _this6 = this;
Kode lerroa: 
Kode lerroa:       if (!isWorkerDisabled && !(0, _dom_utils.getDefaultSetting)('disableWorker') && typeof Worker !== 'undefined') {
Kode lerroa:         var workerSrc = getWorkerSrc();
Kode lerroa:         try {
Kode lerroa:           if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
Kode lerroa:             workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
Kode lerroa:           }
Kode lerroa:           var worker = new Worker(workerSrc);
Kode lerroa:           var messageHandler = new _util.MessageHandler('main', 'worker', worker);
Kode lerroa:           var terminateEarly = function terminateEarly() {
Kode lerroa:             worker.removeEventListener('error', onWorkerError);
Kode lerroa:             messageHandler.destroy();
Kode lerroa:             worker.terminate();
Kode lerroa:             if (_this6.destroyed) {
Kode lerroa:               _this6._readyCapability.reject(new Error('Worker was destroyed'));
Kode lerroa:             } else {
Kode lerroa:               _this6._setupFakeWorker();
Kode lerroa:             }
Kode lerroa:           };
Kode lerroa:           var onWorkerError = function onWorkerError() {
Kode lerroa:             if (!_this6._webWorker) {
Kode lerroa:               terminateEarly();
Kode lerroa:             }
Kode lerroa:           };
Kode lerroa:           worker.addEventListener('error', onWorkerError);
Kode lerroa:           messageHandler.on('test', function (data) {
Kode lerroa:             worker.removeEventListener('error', onWorkerError);
Kode lerroa:             if (_this6.destroyed) {
Kode lerroa:               terminateEarly();
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             var supportTypedArray = data && data.supportTypedArray;
Kode lerroa:             if (supportTypedArray) {
Kode lerroa:               _this6._messageHandler = messageHandler;
Kode lerroa:               _this6._port = worker;
Kode lerroa:               _this6._webWorker = worker;
Kode lerroa:               if (!data.supportTransfers) {
Kode lerroa:                 _this6.postMessageTransfers = false;
Kode lerroa:                 isPostMessageTransfersDisabled = true;
Kode lerroa:               }
Kode lerroa:               _this6._readyCapability.resolve();
Kode lerroa:               messageHandler.send('configure', { verbosity: (0, _util.getVerbosityLevel)() });
Kode lerroa:             } else {
Kode lerroa:               _this6._setupFakeWorker();
Kode lerroa:               messageHandler.destroy();
Kode lerroa:               worker.terminate();
Kode lerroa:             }
Kode lerroa:           });
Kode lerroa:           messageHandler.on('console_log', function (data) {
Kode lerroa:             console.log.apply(console, data);
Kode lerroa:           });
Kode lerroa:           messageHandler.on('console_error', function (data) {
Kode lerroa:             console.error.apply(console, data);
Kode lerroa:           });
Kode lerroa:           messageHandler.on('ready', function (data) {
Kode lerroa:             worker.removeEventListener('error', onWorkerError);
Kode lerroa:             if (_this6.destroyed) {
Kode lerroa:               terminateEarly();
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             try {
Kode lerroa:               sendTest();
Kode lerroa:             } catch (e) {
Kode lerroa:               _this6._setupFakeWorker();
Kode lerroa:             }
Kode lerroa:           });
Kode lerroa:           var sendTest = function sendTest() {
Kode lerroa:             var postMessageTransfers = (0, _dom_utils.getDefaultSetting)('postMessageTransfers') && !isPostMessageTransfersDisabled;
Kode lerroa:             var testObj = new Uint8Array([postMessageTransfers ? 255 : 0]);
Kode lerroa:             try {
Kode lerroa:               messageHandler.send('test', testObj, [testObj.buffer]);
Kode lerroa:             } catch (ex) {
Kode lerroa:               (0, _util.info)('Cannot use postMessage transfers');
Kode lerroa:               testObj[0] = 0;
Kode lerroa:               messageHandler.send('test', testObj);
Kode lerroa:             }
Kode lerroa:           };
Kode lerroa:           sendTest();
Kode lerroa:           return;
Kode lerroa:         } catch (e) {
Kode lerroa:           (0, _util.info)('The worker has been disabled.');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this._setupFakeWorker();
Kode lerroa:     },
Kode lerroa:     _setupFakeWorker: function PDFWorker_setupFakeWorker() {
Kode lerroa:       var _this7 = this;
Kode lerroa: 
Kode lerroa:       if (!isWorkerDisabled && !(0, _dom_utils.getDefaultSetting)('disableWorker')) {
Kode lerroa:         (0, _util.warn)('Setting up fake worker.');
Kode lerroa:         isWorkerDisabled = true;
Kode lerroa:       }
Kode lerroa:       setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {
Kode lerroa:         if (_this7.destroyed) {
Kode lerroa:           _this7._readyCapability.reject(new Error('Worker was destroyed'));
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var isTypedArraysPresent = Uint8Array !== Float32Array;
Kode lerroa:         var port = new LoopbackPort(isTypedArraysPresent);
Kode lerroa:         _this7._port = port;
Kode lerroa:         var id = 'fake' + nextFakeWorkerId++;
Kode lerroa:         var workerHandler = new _util.MessageHandler(id + '_worker', id, port);
Kode lerroa:         WorkerMessageHandler.setup(workerHandler, port);
Kode lerroa:         var messageHandler = new _util.MessageHandler(id, id + '_worker', port);
Kode lerroa:         _this7._messageHandler = messageHandler;
Kode lerroa:         _this7._readyCapability.resolve();
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     destroy: function PDFWorker_destroy() {
Kode lerroa:       this.destroyed = true;
Kode lerroa:       if (this._webWorker) {
Kode lerroa:         this._webWorker.terminate();
Kode lerroa:         this._webWorker = null;
Kode lerroa:       }
Kode lerroa:       pdfWorkerPorts.delete(this._port);
Kode lerroa:       this._port = null;
Kode lerroa:       if (this._messageHandler) {
Kode lerroa:         this._messageHandler.destroy();
Kode lerroa:         this._messageHandler = null;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   PDFWorker.fromPort = function (port) {
Kode lerroa:     if (pdfWorkerPorts.has(port)) {
Kode lerroa:       return pdfWorkerPorts.get(port);
Kode lerroa:     }
Kode lerroa:     return new PDFWorker(null, port);
Kode lerroa:   };
Kode lerroa:   return PDFWorker;
Kode lerroa: }();
Kode lerroa: var WorkerTransport = function WorkerTransportClosure() {
Kode lerroa:   function WorkerTransport(messageHandler, loadingTask, networkStream, CMapReaderFactory) {
Kode lerroa:     this.messageHandler = messageHandler;
Kode lerroa:     this.loadingTask = loadingTask;
Kode lerroa:     this.commonObjs = new PDFObjects();
Kode lerroa:     this.fontLoader = new _font_loader.FontLoader(loadingTask.docId);
Kode lerroa:     this.CMapReaderFactory = new CMapReaderFactory({
Kode lerroa:       baseUrl: (0, _dom_utils.getDefaultSetting)('cMapUrl'),
Kode lerroa:       isCompressed: (0, _dom_utils.getDefaultSetting)('cMapPacked')
Kode lerroa:     });
Kode lerroa:     this.destroyed = false;
Kode lerroa:     this.destroyCapability = null;
Kode lerroa:     this._passwordCapability = null;
Kode lerroa:     this._networkStream = networkStream;
Kode lerroa:     this._fullReader = null;
Kode lerroa:     this._lastProgress = null;
Kode lerroa:     this.pageCache = [];
Kode lerroa:     this.pagePromises = [];
Kode lerroa:     this.downloadInfoCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this.setupMessageHandler();
Kode lerroa:   }
Kode lerroa:   WorkerTransport.prototype = {
Kode lerroa:     destroy: function WorkerTransport_destroy() {
Kode lerroa:       var _this8 = this;
Kode lerroa: 
Kode lerroa:       if (this.destroyCapability) {
Kode lerroa:         return this.destroyCapability.promise;
Kode lerroa:       }
Kode lerroa:       this.destroyed = true;
Kode lerroa:       this.destroyCapability = (0, _util.createPromiseCapability)();
Kode lerroa:       if (this._passwordCapability) {
Kode lerroa:         this._passwordCapability.reject(new Error('Worker was destroyed during onPassword callback'));
Kode lerroa:       }
Kode lerroa:       var waitOn = [];
Kode lerroa:       this.pageCache.forEach(function (page) {
Kode lerroa:         if (page) {
Kode lerroa:           waitOn.push(page._destroy());
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       this.pageCache = [];
Kode lerroa:       this.pagePromises = [];
Kode lerroa:       var terminated = this.messageHandler.sendWithPromise('Terminate', null);
Kode lerroa:       waitOn.push(terminated);
Kode lerroa:       Promise.all(waitOn).then(function () {
Kode lerroa:         _this8.fontLoader.clear();
Kode lerroa:         if (_this8._networkStream) {
Kode lerroa:           _this8._networkStream.cancelAllRequests();
Kode lerroa:         }
Kode lerroa:         if (_this8.messageHandler) {
Kode lerroa:           _this8.messageHandler.destroy();
Kode lerroa:           _this8.messageHandler = null;
Kode lerroa:         }
Kode lerroa:         _this8.destroyCapability.resolve();
Kode lerroa:       }, this.destroyCapability.reject);
Kode lerroa:       return this.destroyCapability.promise;
Kode lerroa:     },
Kode lerroa:     setupMessageHandler: function WorkerTransport_setupMessageHandler() {
Kode lerroa:       var messageHandler = this.messageHandler;
Kode lerroa:       var loadingTask = this.loadingTask;
Kode lerroa:       messageHandler.on('GetReader', function (data, sink) {
Kode lerroa:         var _this9 = this;
Kode lerroa: 
Kode lerroa:         (0, _util.assert)(this._networkStream);
Kode lerroa:         this._fullReader = this._networkStream.getFullReader();
Kode lerroa:         this._fullReader.onProgress = function (evt) {
Kode lerroa:           _this9._lastProgress = {
Kode lerroa:             loaded: evt.loaded,
Kode lerroa:             total: evt.total
Kode lerroa:           };
Kode lerroa:         };
Kode lerroa:         sink.onPull = function () {
Kode lerroa:           _this9._fullReader.read().then(function (_ref2) {
Kode lerroa:             var value = _ref2.value,
Kode lerroa:                 done = _ref2.done;
Kode lerroa: 
Kode lerroa:             if (done) {
Kode lerroa:               sink.close();
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             (0, _util.assert)((0, _util.isArrayBuffer)(value));
Kode lerroa:             sink.enqueue(new Uint8Array(value), 1, [value]);
Kode lerroa:           }).catch(function (reason) {
Kode lerroa:             sink.error(reason);
Kode lerroa:           });
Kode lerroa:         };
Kode lerroa:         sink.onCancel = function (reason) {
Kode lerroa:           _this9._fullReader.cancel(reason);
Kode lerroa:         };
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('ReaderHeadersReady', function (data) {
Kode lerroa:         var _this10 = this;
Kode lerroa: 
Kode lerroa:         var headersCapability = (0, _util.createPromiseCapability)();
Kode lerroa:         var fullReader = this._fullReader;
Kode lerroa:         fullReader.headersReady.then(function () {
Kode lerroa:           if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
Kode lerroa:             if (_this10._lastProgress) {
Kode lerroa:               var _loadingTask = _this10.loadingTask;
Kode lerroa:               if (_loadingTask.onProgress) {
Kode lerroa:                 _loadingTask.onProgress(_this10._lastProgress);
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             fullReader.onProgress = function (evt) {
Kode lerroa:               var loadingTask = _this10.loadingTask;
Kode lerroa:               if (loadingTask.onProgress) {
Kode lerroa:                 loadingTask.onProgress({
Kode lerroa:                   loaded: evt.loaded,
Kode lerroa:                   total: evt.total
Kode lerroa:                 });
Kode lerroa:               }
Kode lerroa:             };
Kode lerroa:           }
Kode lerroa:           headersCapability.resolve({
Kode lerroa:             isStreamingSupported: fullReader.isStreamingSupported,
Kode lerroa:             isRangeSupported: fullReader.isRangeSupported,
Kode lerroa:             contentLength: fullReader.contentLength
Kode lerroa:           });
Kode lerroa:         }, headersCapability.reject);
Kode lerroa:         return headersCapability.promise;
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('GetRangeReader', function (data, sink) {
Kode lerroa:         (0, _util.assert)(this._networkStream);
Kode lerroa:         var _rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
Kode lerroa:         sink.onPull = function () {
Kode lerroa:           _rangeReader.read().then(function (_ref3) {
Kode lerroa:             var value = _ref3.value,
Kode lerroa:                 done = _ref3.done;
Kode lerroa: 
Kode lerroa:             if (done) {
Kode lerroa:               sink.close();
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             (0, _util.assert)((0, _util.isArrayBuffer)(value));
Kode lerroa:             sink.enqueue(new Uint8Array(value), 1, [value]);
Kode lerroa:           }).catch(function (reason) {
Kode lerroa:             sink.error(reason);
Kode lerroa:           });
Kode lerroa:         };
Kode lerroa:         sink.onCancel = function (reason) {
Kode lerroa:           _rangeReader.cancel(reason);
Kode lerroa:         };
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('GetDoc', function transportDoc(data) {
Kode lerroa:         var pdfInfo = data.pdfInfo;
Kode lerroa:         this.numPages = data.pdfInfo.numPages;
Kode lerroa:         var loadingTask = this.loadingTask;
Kode lerroa:         var pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask);
Kode lerroa:         this.pdfDocument = pdfDocument;
Kode lerroa:         loadingTask._capability.resolve(pdfDocument);
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('PasswordRequest', function transportPasswordRequest(exception) {
Kode lerroa:         var _this11 = this;
Kode lerroa: 
Kode lerroa:         this._passwordCapability = (0, _util.createPromiseCapability)();
Kode lerroa:         if (loadingTask.onPassword) {
Kode lerroa:           var updatePassword = function updatePassword(password) {
Kode lerroa:             _this11._passwordCapability.resolve({ password: password });
Kode lerroa:           };
Kode lerroa:           loadingTask.onPassword(updatePassword, exception.code);
Kode lerroa:         } else {
Kode lerroa:           this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
Kode lerroa:         }
Kode lerroa:         return this._passwordCapability.promise;
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('PasswordException', function transportPasswordException(exception) {
Kode lerroa:         loadingTask._capability.reject(new _util.PasswordException(exception.message, exception.code));
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {
Kode lerroa:         this.loadingTask._capability.reject(new _util.InvalidPDFException(exception.message));
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('MissingPDF', function transportMissingPDF(exception) {
Kode lerroa:         this.loadingTask._capability.reject(new _util.MissingPDFException(exception.message));
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('UnexpectedResponse', function transportUnexpectedResponse(exception) {
Kode lerroa:         this.loadingTask._capability.reject(new _util.UnexpectedResponseException(exception.message, exception.status));
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('UnknownError', function transportUnknownError(exception) {
Kode lerroa:         this.loadingTask._capability.reject(new _util.UnknownErrorException(exception.message, exception.details));
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('DataLoaded', function transportPage(data) {
Kode lerroa:         this.downloadInfoCapability.resolve(data);
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('PDFManagerReady', function transportPage(data) {}, this);
Kode lerroa:       messageHandler.on('StartRenderPage', function transportRender(data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var page = this.pageCache[data.pageIndex];
Kode lerroa:         page.stats.timeEnd('Page Request');
Kode lerroa:         page._startRenderPage(data.transparency, data.intent);
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('RenderPageChunk', function transportRender(data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var page = this.pageCache[data.pageIndex];
Kode lerroa:         page._renderPageChunk(data.operatorList, data.intent);
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('commonobj', function transportObj(data) {
Kode lerroa:         var _this12 = this;
Kode lerroa: 
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var id = data[0];
Kode lerroa:         var type = data[1];
Kode lerroa:         if (this.commonObjs.hasData(id)) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         switch (type) {
Kode lerroa:           case 'Font':
Kode lerroa:             var exportedData = data[2];
Kode lerroa:             if ('error' in exportedData) {
Kode lerroa:               var exportedError = exportedData.error;
Kode lerroa:               (0, _util.warn)('Error during font loading: ' + exportedError);
Kode lerroa:               this.commonObjs.resolve(id, exportedError);
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:             var fontRegistry = null;
Kode lerroa:             if ((0, _dom_utils.getDefaultSetting)('pdfBug') && _global_scope2.default.FontInspector && _global_scope2.default['FontInspector'].enabled) {
Kode lerroa:               fontRegistry = {
Kode lerroa:                 registerFont: function registerFont(font, url) {
Kode lerroa:                   _global_scope2.default['FontInspector'].fontAdded(font, url);
Kode lerroa:                 }
Kode lerroa:               };
Kode lerroa:             }
Kode lerroa:             var font = new _font_loader.FontFaceObject(exportedData, {
Kode lerroa:               isEvalSupported: (0, _dom_utils.getDefaultSetting)('isEvalSupported'),
Kode lerroa:               disableFontFace: (0, _dom_utils.getDefaultSetting)('disableFontFace'),
Kode lerroa:               fontRegistry: fontRegistry
Kode lerroa:             });
Kode lerroa:             var fontReady = function fontReady(fontObjs) {
Kode lerroa:               _this12.commonObjs.resolve(id, font);
Kode lerroa:             };
Kode lerroa:             this.fontLoader.bind([font], fontReady);
Kode lerroa:             break;
Kode lerroa:           case 'FontPath':
Kode lerroa:             this.commonObjs.resolve(id, data[2]);
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             throw new Error('Got unknown common object type ' + type);
Kode lerroa:         }
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('obj', function transportObj(data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var id = data[0];
Kode lerroa:         var pageIndex = data[1];
Kode lerroa:         var type = data[2];
Kode lerroa:         var pageProxy = this.pageCache[pageIndex];
Kode lerroa:         var imageData;
Kode lerroa:         if (pageProxy.objs.hasData(id)) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         switch (type) {
Kode lerroa:           case 'JpegStream':
Kode lerroa:             imageData = data[3];
Kode lerroa:             (0, _util.loadJpegStream)(id, imageData, pageProxy.objs);
Kode lerroa:             break;
Kode lerroa:           case 'Image':
Kode lerroa:             imageData = data[3];
Kode lerroa:             pageProxy.objs.resolve(id, imageData);
Kode lerroa:             var MAX_IMAGE_SIZE_TO_STORE = 8000000;
Kode lerroa:             if (imageData && 'data' in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
Kode lerroa:               pageProxy.cleanupAfterRender = true;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             throw new Error('Got unknown object type ' + type);
Kode lerroa:         }
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('DocProgress', function transportDocProgress(data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var loadingTask = this.loadingTask;
Kode lerroa:         if (loadingTask.onProgress) {
Kode lerroa:           loadingTask.onProgress({
Kode lerroa:             loaded: data.loaded,
Kode lerroa:             total: data.total
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('PageError', function transportError(data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var page = this.pageCache[data.pageNum - 1];
Kode lerroa:         var intentState = page.intentStates[data.intent];
Kode lerroa:         if (intentState.displayReadyCapability) {
Kode lerroa:           intentState.displayReadyCapability.reject(data.error);
Kode lerroa:         } else {
Kode lerroa:           throw new Error(data.error);
Kode lerroa:         }
Kode lerroa:         if (intentState.operatorList) {
Kode lerroa:           intentState.operatorList.lastChunk = true;
Kode lerroa:           for (var i = 0; i < intentState.renderTasks.length; i++) {
Kode lerroa:             intentState.renderTasks[i].operatorListChanged();
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('UnsupportedFeature', function transportUnsupportedFeature(data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var featureId = data.featureId;
Kode lerroa:         var loadingTask = this.loadingTask;
Kode lerroa:         if (loadingTask.onUnsupportedFeature) {
Kode lerroa:           loadingTask.onUnsupportedFeature(featureId);
Kode lerroa:         }
Kode lerroa:         _UnsupportedManager.notify(featureId);
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('JpegDecode', function (data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return Promise.reject(new Error('Worker was destroyed'));
Kode lerroa:         }
Kode lerroa:         if (typeof document === 'undefined') {
Kode lerroa:           return Promise.reject(new Error('"document" is not defined.'));
Kode lerroa:         }
Kode lerroa:         var imageUrl = data[0];
Kode lerroa:         var components = data[1];
Kode lerroa:         if (components !== 3 && components !== 1) {
Kode lerroa:           return Promise.reject(new Error('Only 3 components or 1 component can be returned'));
Kode lerroa:         }
Kode lerroa:         return new Promise(function (resolve, reject) {
Kode lerroa:           var img = new Image();
Kode lerroa:           img.onload = function () {
Kode lerroa:             var width = img.width;
Kode lerroa:             var height = img.height;
Kode lerroa:             var size = width * height;
Kode lerroa:             var rgbaLength = size * 4;
Kode lerroa:             var buf = new Uint8Array(size * components);
Kode lerroa:             var tmpCanvas = document.createElement('canvas');
Kode lerroa:             tmpCanvas.width = width;
Kode lerroa:             tmpCanvas.height = height;
Kode lerroa:             var tmpCtx = tmpCanvas.getContext('2d');
Kode lerroa:             tmpCtx.drawImage(img, 0, 0);
Kode lerroa:             var data = tmpCtx.getImageData(0, 0, width, height).data;
Kode lerroa:             var i, j;
Kode lerroa:             if (components === 3) {
Kode lerroa:               for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
Kode lerroa:                 buf[j] = data[i];
Kode lerroa:                 buf[j + 1] = data[i + 1];
Kode lerroa:                 buf[j + 2] = data[i + 2];
Kode lerroa:               }
Kode lerroa:             } else if (components === 1) {
Kode lerroa:               for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {
Kode lerroa:                 buf[j] = data[i];
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             resolve({
Kode lerroa:               data: buf,
Kode lerroa:               width: width,
Kode lerroa:               height: height
Kode lerroa:             });
Kode lerroa:           };
Kode lerroa:           img.onerror = function () {
Kode lerroa:             reject(new Error('JpegDecode failed to load image'));
Kode lerroa:           };
Kode lerroa:           img.src = imageUrl;
Kode lerroa:         });
Kode lerroa:       }, this);
Kode lerroa:       messageHandler.on('FetchBuiltInCMap', function (data) {
Kode lerroa:         if (this.destroyed) {
Kode lerroa:           return Promise.reject(new Error('Worker was destroyed'));
Kode lerroa:         }
Kode lerroa:         return this.CMapReaderFactory.fetch({ name: data.name });
Kode lerroa:       }, this);
Kode lerroa:     },
Kode lerroa:     getData: function WorkerTransport_getData() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetData', null);
Kode lerroa:     },
Kode lerroa:     getPage: function WorkerTransport_getPage(pageNumber, capability) {
Kode lerroa:       var _this13 = this;
Kode lerroa: 
Kode lerroa:       if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this.numPages) {
Kode lerroa:         return Promise.reject(new Error('Invalid page request'));
Kode lerroa:       }
Kode lerroa:       var pageIndex = pageNumber - 1;
Kode lerroa:       if (pageIndex in this.pagePromises) {
Kode lerroa:         return this.pagePromises[pageIndex];
Kode lerroa:       }
Kode lerroa:       var promise = this.messageHandler.sendWithPromise('GetPage', { pageIndex: pageIndex }).then(function (pageInfo) {
Kode lerroa:         if (_this13.destroyed) {
Kode lerroa:           throw new Error('Transport destroyed');
Kode lerroa:         }
Kode lerroa:         var page = new PDFPageProxy(pageIndex, pageInfo, _this13);
Kode lerroa:         _this13.pageCache[pageIndex] = page;
Kode lerroa:         return page;
Kode lerroa:       });
Kode lerroa:       this.pagePromises[pageIndex] = promise;
Kode lerroa:       return promise;
Kode lerroa:     },
Kode lerroa:     getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetPageIndex', { ref: ref }).catch(function (reason) {
Kode lerroa:         return Promise.reject(new Error(reason));
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getAnnotations: function WorkerTransport_getAnnotations(pageIndex, intent) {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetAnnotations', {
Kode lerroa:         pageIndex: pageIndex,
Kode lerroa:         intent: intent
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getDestinations: function WorkerTransport_getDestinations() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetDestinations', null);
Kode lerroa:     },
Kode lerroa:     getDestination: function WorkerTransport_getDestination(id) {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetDestination', { id: id });
Kode lerroa:     },
Kode lerroa:     getPageLabels: function WorkerTransport_getPageLabels() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetPageLabels', null);
Kode lerroa:     },
Kode lerroa:     getPageMode: function getPageMode() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetPageMode', null);
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     getAttachments: function WorkerTransport_getAttachments() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetAttachments', null);
Kode lerroa:     },
Kode lerroa:     getJavaScript: function WorkerTransport_getJavaScript() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetJavaScript', null);
Kode lerroa:     },
Kode lerroa:     getOutline: function WorkerTransport_getOutline() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetOutline', null);
Kode lerroa:     },
Kode lerroa:     getMetadata: function WorkerTransport_getMetadata() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetMetadata', null).then(function transportMetadata(results) {
Kode lerroa:         return {
Kode lerroa:           info: results[0],
Kode lerroa:           metadata: results[1] ? new _metadata.Metadata(results[1]) : null
Kode lerroa:         };
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getStats: function WorkerTransport_getStats() {
Kode lerroa:       return this.messageHandler.sendWithPromise('GetStats', null);
Kode lerroa:     },
Kode lerroa:     startCleanup: function WorkerTransport_startCleanup() {
Kode lerroa:       var _this14 = this;
Kode lerroa: 
Kode lerroa:       this.messageHandler.sendWithPromise('Cleanup', null).then(function () {
Kode lerroa:         for (var i = 0, ii = _this14.pageCache.length; i < ii; i++) {
Kode lerroa:           var page = _this14.pageCache[i];
Kode lerroa:           if (page) {
Kode lerroa:             page.cleanup();
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         _this14.commonObjs.clear();
Kode lerroa:         _this14.fontLoader.clear();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return WorkerTransport;
Kode lerroa: }();
Kode lerroa: var PDFObjects = function PDFObjectsClosure() {
Kode lerroa:   function PDFObjects() {
Kode lerroa:     this.objs = Object.create(null);
Kode lerroa:   }
Kode lerroa:   PDFObjects.prototype = {
Kode lerroa:     ensureObj: function PDFObjects_ensureObj(objId) {
Kode lerroa:       if (this.objs[objId]) {
Kode lerroa:         return this.objs[objId];
Kode lerroa:       }
Kode lerroa:       var obj = {
Kode lerroa:         capability: (0, _util.createPromiseCapability)(),
Kode lerroa:         data: null,
Kode lerroa:         resolved: false
Kode lerroa:       };
Kode lerroa:       this.objs[objId] = obj;
Kode lerroa:       return obj;
Kode lerroa:     },
Kode lerroa:     get: function PDFObjects_get(objId, callback) {
Kode lerroa:       if (callback) {
Kode lerroa:         this.ensureObj(objId).capability.promise.then(callback);
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var obj = this.objs[objId];
Kode lerroa:       if (!obj || !obj.resolved) {
Kode lerroa:         throw new Error('Requesting object that isn\'t resolved yet ' + objId);
Kode lerroa:       }
Kode lerroa:       return obj.data;
Kode lerroa:     },
Kode lerroa:     resolve: function PDFObjects_resolve(objId, data) {
Kode lerroa:       var obj = this.ensureObj(objId);
Kode lerroa:       obj.resolved = true;
Kode lerroa:       obj.data = data;
Kode lerroa:       obj.capability.resolve(data);
Kode lerroa:     },
Kode lerroa:     isResolved: function PDFObjects_isResolved(objId) {
Kode lerroa:       var objs = this.objs;
Kode lerroa:       if (!objs[objId]) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       return objs[objId].resolved;
Kode lerroa:     },
Kode lerroa:     hasData: function PDFObjects_hasData(objId) {
Kode lerroa:       return this.isResolved(objId);
Kode lerroa:     },
Kode lerroa:     getData: function PDFObjects_getData(objId) {
Kode lerroa:       var objs = this.objs;
Kode lerroa:       if (!objs[objId] || !objs[objId].resolved) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       return objs[objId].data;
Kode lerroa:     },
Kode lerroa:     clear: function PDFObjects_clear() {
Kode lerroa:       this.objs = Object.create(null);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDFObjects;
Kode lerroa: }();
Kode lerroa: var RenderTask = function RenderTaskClosure() {
Kode lerroa:   function RenderTask(internalRenderTask) {
Kode lerroa:     this._internalRenderTask = internalRenderTask;
Kode lerroa:     this.onContinue = null;
Kode lerroa:   }
Kode lerroa:   RenderTask.prototype = {
Kode lerroa:     get promise() {
Kode lerroa:       return this._internalRenderTask.capability.promise;
Kode lerroa:     },
Kode lerroa:     cancel: function RenderTask_cancel() {
Kode lerroa:       this._internalRenderTask.cancel();
Kode lerroa:     },
Kode lerroa:     then: function RenderTask_then(onFulfilled, onRejected) {
Kode lerroa:       return this.promise.then.apply(this.promise, arguments);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return RenderTask;
Kode lerroa: }();
Kode lerroa: var InternalRenderTask = function InternalRenderTaskClosure() {
Kode lerroa:   var canvasInRendering = new WeakMap();
Kode lerroa:   function InternalRenderTask(callback, params, objs, commonObjs, operatorList, pageNumber, canvasFactory) {
Kode lerroa:     this.callback = callback;
Kode lerroa:     this.params = params;
Kode lerroa:     this.objs = objs;
Kode lerroa:     this.commonObjs = commonObjs;
Kode lerroa:     this.operatorListIdx = null;
Kode lerroa:     this.operatorList = operatorList;
Kode lerroa:     this.pageNumber = pageNumber;
Kode lerroa:     this.canvasFactory = canvasFactory;
Kode lerroa:     this.running = false;
Kode lerroa:     this.graphicsReadyCallback = null;
Kode lerroa:     this.graphicsReady = false;
Kode lerroa:     this.useRequestAnimationFrame = false;
Kode lerroa:     this.cancelled = false;
Kode lerroa:     this.capability = (0, _util.createPromiseCapability)();
Kode lerroa:     this.task = new RenderTask(this);
Kode lerroa:     this._continueBound = this._continue.bind(this);
Kode lerroa:     this._scheduleNextBound = this._scheduleNext.bind(this);
Kode lerroa:     this._nextBound = this._next.bind(this);
Kode lerroa:     this._canvas = params.canvasContext.canvas;
Kode lerroa:   }
Kode lerroa:   InternalRenderTask.prototype = {
Kode lerroa:     initializeGraphics: function InternalRenderTask_initializeGraphics(transparency) {
Kode lerroa:       if (this._canvas) {
Kode lerroa:         if (canvasInRendering.has(this._canvas)) {
Kode lerroa:           throw new Error('Cannot use the same canvas during multiple render() operations. ' + 'Use different canvas or ensure previous operations were ' + 'cancelled or completed.');
Kode lerroa:         }
Kode lerroa:         canvasInRendering.set(this._canvas, this);
Kode lerroa:       }
Kode lerroa:       if (this.cancelled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if ((0, _dom_utils.getDefaultSetting)('pdfBug') && _global_scope2.default.StepperManager && _global_scope2.default.StepperManager.enabled) {
Kode lerroa:         this.stepper = _global_scope2.default.StepperManager.create(this.pageNumber - 1);
Kode lerroa:         this.stepper.init(this.operatorList);
Kode lerroa:         this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
Kode lerroa:       }
Kode lerroa:       var params = this.params;
Kode lerroa:       this.gfx = new _canvas.CanvasGraphics(params.canvasContext, this.commonObjs, this.objs, this.canvasFactory, params.imageLayer);
Kode lerroa:       this.gfx.beginDrawing({
Kode lerroa:         transform: params.transform,
Kode lerroa:         viewport: params.viewport,
Kode lerroa:         transparency: transparency,
Kode lerroa:         background: params.background
Kode lerroa:       });
Kode lerroa:       this.operatorListIdx = 0;
Kode lerroa:       this.graphicsReady = true;
Kode lerroa:       if (this.graphicsReadyCallback) {
Kode lerroa:         this.graphicsReadyCallback();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     cancel: function InternalRenderTask_cancel() {
Kode lerroa:       this.running = false;
Kode lerroa:       this.cancelled = true;
Kode lerroa:       if (this._canvas) {
Kode lerroa:         canvasInRendering.delete(this._canvas);
Kode lerroa:       }
Kode lerroa:       if ((0, _dom_utils.getDefaultSetting)('pdfjsNext')) {
Kode lerroa:         this.callback(new _dom_utils.RenderingCancelledException('Rendering cancelled, page ' + this.pageNumber, 'canvas'));
Kode lerroa:       } else {
Kode lerroa:         this.callback('cancelled');
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     operatorListChanged: function InternalRenderTask_operatorListChanged() {
Kode lerroa:       if (!this.graphicsReady) {
Kode lerroa:         if (!this.graphicsReadyCallback) {
Kode lerroa:           this.graphicsReadyCallback = this._continueBound;
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.stepper) {
Kode lerroa:         this.stepper.updateOperatorList(this.operatorList);
Kode lerroa:       }
Kode lerroa:       if (this.running) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._continue();
Kode lerroa:     },
Kode lerroa:     _continue: function InternalRenderTask__continue() {
Kode lerroa:       this.running = true;
Kode lerroa:       if (this.cancelled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.task.onContinue) {
Kode lerroa:         this.task.onContinue(this._scheduleNextBound);
Kode lerroa:       } else {
Kode lerroa:         this._scheduleNext();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     _scheduleNext: function InternalRenderTask__scheduleNext() {
Kode lerroa:       if (this.useRequestAnimationFrame && typeof window !== 'undefined') {
Kode lerroa:         window.requestAnimationFrame(this._nextBound);
Kode lerroa:       } else {
Kode lerroa:         Promise.resolve(undefined).then(this._nextBound);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     _next: function InternalRenderTask__next() {
Kode lerroa:       if (this.cancelled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
Kode lerroa:       if (this.operatorListIdx === this.operatorList.argsArray.length) {
Kode lerroa:         this.running = false;
Kode lerroa:         if (this.operatorList.lastChunk) {
Kode lerroa:           this.gfx.endDrawing();
Kode lerroa:           if (this._canvas) {
Kode lerroa:             canvasInRendering.delete(this._canvas);
Kode lerroa:           }
Kode lerroa:           this.callback();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return InternalRenderTask;
Kode lerroa: }();
Kode lerroa: var _UnsupportedManager = function UnsupportedManagerClosure() {
Kode lerroa:   var listeners = [];
Kode lerroa:   return {
Kode lerroa:     listen: function listen(cb) {
Kode lerroa:       (0, _util.deprecated)('Global UnsupportedManager.listen is used: ' + ' use PDFDocumentLoadingTask.onUnsupportedFeature instead');
Kode lerroa:       listeners.push(cb);
Kode lerroa:     },
Kode lerroa:     notify: function notify(featureId) {
Kode lerroa:       for (var i = 0, ii = listeners.length; i < ii; i++) {
Kode lerroa:         listeners[i](featureId);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }();
Kode lerroa: var version, build;
Kode lerroa: {
Kode lerroa:   exports.version = version = '1.10.100';
Kode lerroa:   exports.build = build = 'ea29ec83';
Kode lerroa: }
Kode lerroa: exports.getDocument = getDocument;
Kode lerroa: exports.LoopbackPort = LoopbackPort;
Kode lerroa: exports.PDFDataRangeTransport = PDFDataRangeTransport;
Kode lerroa: exports.PDFWorker = PDFWorker;
Kode lerroa: exports.PDFDocumentProxy = PDFDocumentProxy;
Kode lerroa: exports.PDFPageProxy = PDFPageProxy;
Kode lerroa: exports.setPDFNetworkStreamClass = setPDFNetworkStreamClass;
Kode lerroa: exports._UnsupportedManager = _UnsupportedManager;
Kode lerroa: exports.version = version;
Kode lerroa: exports.build = build;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 70 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.WebGLUtils = undefined;
Kode lerroa: 
Kode lerroa: var _dom_utils = __w_pdfjs_require__(15);
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var WebGLUtils = function WebGLUtilsClosure() {
Kode lerroa:   function loadShader(gl, code, shaderType) {
Kode lerroa:     var shader = gl.createShader(shaderType);
Kode lerroa:     gl.shaderSource(shader, code);
Kode lerroa:     gl.compileShader(shader);
Kode lerroa:     var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
Kode lerroa:     if (!compiled) {
Kode lerroa:       var errorMsg = gl.getShaderInfoLog(shader);
Kode lerroa:       throw new Error('Error during shader compilation: ' + errorMsg);
Kode lerroa:     }
Kode lerroa:     return shader;
Kode lerroa:   }
Kode lerroa:   function createVertexShader(gl, code) {
Kode lerroa:     return loadShader(gl, code, gl.VERTEX_SHADER);
Kode lerroa:   }
Kode lerroa:   function createFragmentShader(gl, code) {
Kode lerroa:     return loadShader(gl, code, gl.FRAGMENT_SHADER);
Kode lerroa:   }
Kode lerroa:   function createProgram(gl, shaders) {
Kode lerroa:     var program = gl.createProgram();
Kode lerroa:     for (var i = 0, ii = shaders.length; i < ii; ++i) {
Kode lerroa:       gl.attachShader(program, shaders[i]);
Kode lerroa:     }
Kode lerroa:     gl.linkProgram(program);
Kode lerroa:     var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
Kode lerroa:     if (!linked) {
Kode lerroa:       var errorMsg = gl.getProgramInfoLog(program);
Kode lerroa:       throw new Error('Error during program linking: ' + errorMsg);
Kode lerroa:     }
Kode lerroa:     return program;
Kode lerroa:   }
Kode lerroa:   function createTexture(gl, image, textureId) {
Kode lerroa:     gl.activeTexture(textureId);
Kode lerroa:     var texture = gl.createTexture();
Kode lerroa:     gl.bindTexture(gl.TEXTURE_2D, texture);
Kode lerroa:     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
Kode lerroa:     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
Kode lerroa:     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
Kode lerroa:     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
Kode lerroa:     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
Kode lerroa:     return texture;
Kode lerroa:   }
Kode lerroa:   var currentGL, currentCanvas;
Kode lerroa:   function generateGL() {
Kode lerroa:     if (currentGL) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     currentCanvas = document.createElement('canvas');
Kode lerroa:     currentGL = currentCanvas.getContext('webgl', { premultipliedalpha: false });
Kode lerroa:   }
Kode lerroa:   var smaskVertexShaderCode = '\
Kode lerroa:   attribute vec2 a_position;                                    \
Kode lerroa:   attribute vec2 a_texCoord;                                    \
Kode lerroa:                                                                 \
Kode lerroa:   uniform vec2 u_resolution;                                    \
Kode lerroa:                                                                 \
Kode lerroa:   varying vec2 v_texCoord;                                      \
Kode lerroa:                                                                 \
Kode lerroa:   void main() {                                                 \
Kode lerroa:     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
Kode lerroa:     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
Kode lerroa:                                                                 \
Kode lerroa:     v_texCoord = a_texCoord;                                    \
Kode lerroa:   }                                                             ';
Kode lerroa:   var smaskFragmentShaderCode = '\
Kode lerroa:   precision mediump float;                                      \
Kode lerroa:                                                                 \
Kode lerroa:   uniform vec4 u_backdrop;                                      \
Kode lerroa:   uniform int u_subtype;                                        \
Kode lerroa:   uniform sampler2D u_image;                                    \
Kode lerroa:   uniform sampler2D u_mask;                                     \
Kode lerroa:                                                                 \
Kode lerroa:   varying vec2 v_texCoord;                                      \
Kode lerroa:                                                                 \
Kode lerroa:   void main() {                                                 \
Kode lerroa:     vec4 imageColor = texture2D(u_image, v_texCoord);           \
Kode lerroa:     vec4 maskColor = texture2D(u_mask, v_texCoord);             \
Kode lerroa:     if (u_backdrop.a > 0.0) {                                   \
Kode lerroa:       maskColor.rgb = maskColor.rgb * maskColor.a +             \
Kode lerroa:                       u_backdrop.rgb * (1.0 - maskColor.a);     \
Kode lerroa:     }                                                           \
Kode lerroa:     float lum;                                                  \
Kode lerroa:     if (u_subtype == 0) {                                       \
Kode lerroa:       lum = maskColor.a;                                        \
Kode lerroa:     } else {                                                    \
Kode lerroa:       lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
Kode lerroa:             maskColor.b * 0.11;                                 \
Kode lerroa:     }                                                           \
Kode lerroa:     imageColor.a *= lum;                                        \
Kode lerroa:     imageColor.rgb *= imageColor.a;                             \
Kode lerroa:     gl_FragColor = imageColor;                                  \
Kode lerroa:   }                                                             ';
Kode lerroa:   var smaskCache = null;
Kode lerroa:   function initSmaskGL() {
Kode lerroa:     var canvas, gl;
Kode lerroa:     generateGL();
Kode lerroa:     canvas = currentCanvas;
Kode lerroa:     currentCanvas = null;
Kode lerroa:     gl = currentGL;
Kode lerroa:     currentGL = null;
Kode lerroa:     var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
Kode lerroa:     var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
Kode lerroa:     var program = createProgram(gl, [vertexShader, fragmentShader]);
Kode lerroa:     gl.useProgram(program);
Kode lerroa:     var cache = {};
Kode lerroa:     cache.gl = gl;
Kode lerroa:     cache.canvas = canvas;
Kode lerroa:     cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
Kode lerroa:     cache.positionLocation = gl.getAttribLocation(program, 'a_position');
Kode lerroa:     cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');
Kode lerroa:     cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');
Kode lerroa:     var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
Kode lerroa:     var texLayerLocation = gl.getUniformLocation(program, 'u_image');
Kode lerroa:     var texMaskLocation = gl.getUniformLocation(program, 'u_mask');
Kode lerroa:     var texCoordBuffer = gl.createBuffer();
Kode lerroa:     gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
Kode lerroa:     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
Kode lerroa:     gl.enableVertexAttribArray(texCoordLocation);
Kode lerroa:     gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
Kode lerroa:     gl.uniform1i(texLayerLocation, 0);
Kode lerroa:     gl.uniform1i(texMaskLocation, 1);
Kode lerroa:     smaskCache = cache;
Kode lerroa:   }
Kode lerroa:   function composeSMask(layer, mask, properties) {
Kode lerroa:     var width = layer.width,
Kode lerroa:         height = layer.height;
Kode lerroa:     if (!smaskCache) {
Kode lerroa:       initSmaskGL();
Kode lerroa:     }
Kode lerroa:     var cache = smaskCache,
Kode lerroa:         canvas = cache.canvas,
Kode lerroa:         gl = cache.gl;
Kode lerroa:     canvas.width = width;
Kode lerroa:     canvas.height = height;
Kode lerroa:     gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
Kode lerroa:     gl.uniform2f(cache.resolutionLocation, width, height);
Kode lerroa:     if (properties.backdrop) {
Kode lerroa:       gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
Kode lerroa:     } else {
Kode lerroa:       gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
Kode lerroa:     }
Kode lerroa:     gl.uniform1i(cache.subtypeLocation, properties.subtype === 'Luminosity' ? 1 : 0);
Kode lerroa:     var texture = createTexture(gl, layer, gl.TEXTURE0);
Kode lerroa:     var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
Kode lerroa:     var buffer = gl.createBuffer();
Kode lerroa:     gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
Kode lerroa:     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
Kode lerroa:     gl.enableVertexAttribArray(cache.positionLocation);
Kode lerroa:     gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
Kode lerroa:     gl.clearColor(0, 0, 0, 0);
Kode lerroa:     gl.enable(gl.BLEND);
Kode lerroa:     gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
Kode lerroa:     gl.clear(gl.COLOR_BUFFER_BIT);
Kode lerroa:     gl.drawArrays(gl.TRIANGLES, 0, 6);
Kode lerroa:     gl.flush();
Kode lerroa:     gl.deleteTexture(texture);
Kode lerroa:     gl.deleteTexture(maskTexture);
Kode lerroa:     gl.deleteBuffer(buffer);
Kode lerroa:     return canvas;
Kode lerroa:   }
Kode lerroa:   var figuresVertexShaderCode = '\
Kode lerroa:   attribute vec2 a_position;                                    \
Kode lerroa:   attribute vec3 a_color;                                       \
Kode lerroa:                                                                 \
Kode lerroa:   uniform vec2 u_resolution;                                    \
Kode lerroa:   uniform vec2 u_scale;                                         \
Kode lerroa:   uniform vec2 u_offset;                                        \
Kode lerroa:                                                                 \
Kode lerroa:   varying vec4 v_color;                                         \
Kode lerroa:                                                                 \
Kode lerroa:   void main() {                                                 \
Kode lerroa:     vec2 position = (a_position + u_offset) * u_scale;          \
Kode lerroa:     vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
Kode lerroa:     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
Kode lerroa:                                                                 \
Kode lerroa:     v_color = vec4(a_color / 255.0, 1.0);                       \
Kode lerroa:   }                                                             ';
Kode lerroa:   var figuresFragmentShaderCode = '\
Kode lerroa:   precision mediump float;                                      \
Kode lerroa:                                                                 \
Kode lerroa:   varying vec4 v_color;                                         \
Kode lerroa:                                                                 \
Kode lerroa:   void main() {                                                 \
Kode lerroa:     gl_FragColor = v_color;                                     \
Kode lerroa:   }                                                             ';
Kode lerroa:   var figuresCache = null;
Kode lerroa:   function initFiguresGL() {
Kode lerroa:     var canvas, gl;
Kode lerroa:     generateGL();
Kode lerroa:     canvas = currentCanvas;
Kode lerroa:     currentCanvas = null;
Kode lerroa:     gl = currentGL;
Kode lerroa:     currentGL = null;
Kode lerroa:     var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
Kode lerroa:     var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
Kode lerroa:     var program = createProgram(gl, [vertexShader, fragmentShader]);
Kode lerroa:     gl.useProgram(program);
Kode lerroa:     var cache = {};
Kode lerroa:     cache.gl = gl;
Kode lerroa:     cache.canvas = canvas;
Kode lerroa:     cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
Kode lerroa:     cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');
Kode lerroa:     cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');
Kode lerroa:     cache.positionLocation = gl.getAttribLocation(program, 'a_position');
Kode lerroa:     cache.colorLocation = gl.getAttribLocation(program, 'a_color');
Kode lerroa:     figuresCache = cache;
Kode lerroa:   }
Kode lerroa:   function drawFigures(width, height, backgroundColor, figures, context) {
Kode lerroa:     if (!figuresCache) {
Kode lerroa:       initFiguresGL();
Kode lerroa:     }
Kode lerroa:     var cache = figuresCache,
Kode lerroa:         canvas = cache.canvas,
Kode lerroa:         gl = cache.gl;
Kode lerroa:     canvas.width = width;
Kode lerroa:     canvas.height = height;
Kode lerroa:     gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
Kode lerroa:     gl.uniform2f(cache.resolutionLocation, width, height);
Kode lerroa:     var count = 0;
Kode lerroa:     var i, ii, rows;
Kode lerroa:     for (i = 0, ii = figures.length; i < ii; i++) {
Kode lerroa:       switch (figures[i].type) {
Kode lerroa:         case 'lattice':
Kode lerroa:           rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
Kode lerroa:           count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
Kode lerroa:           break;
Kode lerroa:         case 'triangles':
Kode lerroa:           count += figures[i].coords.length;
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var coords = new Float32Array(count * 2);
Kode lerroa:     var colors = new Uint8Array(count * 3);
Kode lerroa:     var coordsMap = context.coords,
Kode lerroa:         colorsMap = context.colors;
Kode lerroa:     var pIndex = 0,
Kode lerroa:         cIndex = 0;
Kode lerroa:     for (i = 0, ii = figures.length; i < ii; i++) {
Kode lerroa:       var figure = figures[i],
Kode lerroa:           ps = figure.coords,
Kode lerroa:           cs = figure.colors;
Kode lerroa:       switch (figure.type) {
Kode lerroa:         case 'lattice':
Kode lerroa:           var cols = figure.verticesPerRow;
Kode lerroa:           rows = ps.length / cols | 0;
Kode lerroa:           for (var row = 1; row < rows; row++) {
Kode lerroa:             var offset = row * cols + 1;
Kode lerroa:             for (var col = 1; col < cols; col++, offset++) {
Kode lerroa:               coords[pIndex] = coordsMap[ps[offset - cols - 1]];
Kode lerroa:               coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
Kode lerroa:               coords[pIndex + 2] = coordsMap[ps[offset - cols]];
Kode lerroa:               coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
Kode lerroa:               coords[pIndex + 4] = coordsMap[ps[offset - 1]];
Kode lerroa:               coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
Kode lerroa:               colors[cIndex] = colorsMap[cs[offset - cols - 1]];
Kode lerroa:               colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
Kode lerroa:               colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
Kode lerroa:               colors[cIndex + 3] = colorsMap[cs[offset - cols]];
Kode lerroa:               colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
Kode lerroa:               colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
Kode lerroa:               colors[cIndex + 6] = colorsMap[cs[offset - 1]];
Kode lerroa:               colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
Kode lerroa:               colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
Kode lerroa:               coords[pIndex + 6] = coords[pIndex + 2];
Kode lerroa:               coords[pIndex + 7] = coords[pIndex + 3];
Kode lerroa:               coords[pIndex + 8] = coords[pIndex + 4];
Kode lerroa:               coords[pIndex + 9] = coords[pIndex + 5];
Kode lerroa:               coords[pIndex + 10] = coordsMap[ps[offset]];
Kode lerroa:               coords[pIndex + 11] = coordsMap[ps[offset] + 1];
Kode lerroa:               colors[cIndex + 9] = colors[cIndex + 3];
Kode lerroa:               colors[cIndex + 10] = colors[cIndex + 4];
Kode lerroa:               colors[cIndex + 11] = colors[cIndex + 5];
Kode lerroa:               colors[cIndex + 12] = colors[cIndex + 6];
Kode lerroa:               colors[cIndex + 13] = colors[cIndex + 7];
Kode lerroa:               colors[cIndex + 14] = colors[cIndex + 8];
Kode lerroa:               colors[cIndex + 15] = colorsMap[cs[offset]];
Kode lerroa:               colors[cIndex + 16] = colorsMap[cs[offset] + 1];
Kode lerroa:               colors[cIndex + 17] = colorsMap[cs[offset] + 2];
Kode lerroa:               pIndex += 12;
Kode lerroa:               cIndex += 18;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'triangles':
Kode lerroa:           for (var j = 0, jj = ps.length; j < jj; j++) {
Kode lerroa:             coords[pIndex] = coordsMap[ps[j]];
Kode lerroa:             coords[pIndex + 1] = coordsMap[ps[j] + 1];
Kode lerroa:             colors[cIndex] = colorsMap[cs[j]];
Kode lerroa:             colors[cIndex + 1] = colorsMap[cs[j] + 1];
Kode lerroa:             colors[cIndex + 2] = colorsMap[cs[j] + 2];
Kode lerroa:             pIndex += 2;
Kode lerroa:             cIndex += 3;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (backgroundColor) {
Kode lerroa:       gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
Kode lerroa:     } else {
Kode lerroa:       gl.clearColor(0, 0, 0, 0);
Kode lerroa:     }
Kode lerroa:     gl.clear(gl.COLOR_BUFFER_BIT);
Kode lerroa:     var coordsBuffer = gl.createBuffer();
Kode lerroa:     gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
Kode lerroa:     gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
Kode lerroa:     gl.enableVertexAttribArray(cache.positionLocation);
Kode lerroa:     gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
Kode lerroa:     var colorsBuffer = gl.createBuffer();
Kode lerroa:     gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
Kode lerroa:     gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
Kode lerroa:     gl.enableVertexAttribArray(cache.colorLocation);
Kode lerroa:     gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
Kode lerroa:     gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
Kode lerroa:     gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
Kode lerroa:     gl.drawArrays(gl.TRIANGLES, 0, count);
Kode lerroa:     gl.flush();
Kode lerroa:     gl.deleteBuffer(coordsBuffer);
Kode lerroa:     gl.deleteBuffer(colorsBuffer);
Kode lerroa:     return canvas;
Kode lerroa:   }
Kode lerroa:   function cleanup() {
Kode lerroa:     if (smaskCache && smaskCache.canvas) {
Kode lerroa:       smaskCache.canvas.width = 0;
Kode lerroa:       smaskCache.canvas.height = 0;
Kode lerroa:     }
Kode lerroa:     if (figuresCache && figuresCache.canvas) {
Kode lerroa:       figuresCache.canvas.width = 0;
Kode lerroa:       figuresCache.canvas.height = 0;
Kode lerroa:     }
Kode lerroa:     smaskCache = null;
Kode lerroa:     figuresCache = null;
Kode lerroa:   }
Kode lerroa:   return {
Kode lerroa:     get isEnabled() {
Kode lerroa:       if ((0, _dom_utils.getDefaultSetting)('disableWebGL')) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       var enabled = false;
Kode lerroa:       try {
Kode lerroa:         generateGL();
Kode lerroa:         enabled = !!currentGL;
Kode lerroa:       } catch (e) {}
Kode lerroa:       return (0, _util.shadow)(this, 'isEnabled', enabled);
Kode lerroa:     },
Kode lerroa:     composeSMask: composeSMask,
Kode lerroa:     drawFigures: drawFigures,
Kode lerroa:     clear: cleanup
Kode lerroa:   };
Kode lerroa: }();
Kode lerroa: exports.WebGLUtils = WebGLUtils;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 71 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.Metadata = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _xml_parser = __w_pdfjs_require__(122);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var Metadata = function () {
Kode lerroa:   function Metadata(data) {
Kode lerroa:     _classCallCheck(this, Metadata);
Kode lerroa: 
Kode lerroa:     (0, _util.assert)(typeof data === 'string', 'Metadata: input is not a string');
Kode lerroa:     data = this._repair(data);
Kode lerroa:     var parser = new _xml_parser.SimpleXMLParser();
Kode lerroa:     var xmlDocument = parser.parseFromString(data);
Kode lerroa:     this._metadata = Object.create(null);
Kode lerroa:     if (xmlDocument) {
Kode lerroa:       this._parse(xmlDocument);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(Metadata, [{
Kode lerroa:     key: '_repair',
Kode lerroa:     value: function _repair(data) {
Kode lerroa:       return data.replace(/>\\376\\377([^<]+)/g, function (all, codes) {
Kode lerroa:         var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
Kode lerroa:           return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
Kode lerroa:         });
Kode lerroa:         var chars = '';
Kode lerroa:         for (var i = 0, ii = bytes.length; i < ii; i += 2) {
Kode lerroa:           var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
Kode lerroa:           if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
Kode lerroa:             chars += String.fromCharCode(code);
Kode lerroa:           } else {
Kode lerroa:             chars += '&#x' + (0x10000 + code).toString(16).substring(1) + ';';
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return '>' + chars;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_parse',
Kode lerroa:     value: function _parse(xmlDocument) {
Kode lerroa:       var rdf = xmlDocument.documentElement;
Kode lerroa:       if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
Kode lerroa:         rdf = rdf.firstChild;
Kode lerroa:         while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
Kode lerroa:           rdf = rdf.nextSibling;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
Kode lerroa:       if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var children = rdf.childNodes;
Kode lerroa:       for (var i = 0, ii = children.length; i < ii; i++) {
Kode lerroa:         var desc = children[i];
Kode lerroa:         if (desc.nodeName.toLowerCase() !== 'rdf:description') {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {
Kode lerroa:           if (desc.childNodes[j].nodeName.toLowerCase() !== '#text') {
Kode lerroa:             var entry = desc.childNodes[j];
Kode lerroa:             var name = entry.nodeName.toLowerCase();
Kode lerroa:             this._metadata[name] = entry.textContent.trim();
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'get',
Kode lerroa:     value: function get(name) {
Kode lerroa:       return this._metadata[name] || null;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getAll',
Kode lerroa:     value: function getAll() {
Kode lerroa:       return this._metadata;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'has',
Kode lerroa:     value: function has(name) {
Kode lerroa:       return typeof this._metadata[name] !== 'undefined';
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'metadata',
Kode lerroa:     get: function get() {
Kode lerroa:       (0, _util.deprecated)('`metadata` getter; use `getAll()` instead.');
Kode lerroa:       return this.getAll();
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return Metadata;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.Metadata = Metadata;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 72 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.AnnotationLayer = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _dom_utils = __w_pdfjs_require__(15);
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
Kode lerroa: 
Kode lerroa: function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var AnnotationElementFactory = function () {
Kode lerroa:   function AnnotationElementFactory() {
Kode lerroa:     _classCallCheck(this, AnnotationElementFactory);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(AnnotationElementFactory, null, [{
Kode lerroa:     key: 'create',
Kode lerroa:     value: function create(parameters) {
Kode lerroa:       var subtype = parameters.data.annotationType;
Kode lerroa:       switch (subtype) {
Kode lerroa:         case _util.AnnotationType.LINK:
Kode lerroa:           return new LinkAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.TEXT:
Kode lerroa:           return new TextAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.WIDGET:
Kode lerroa:           var fieldType = parameters.data.fieldType;
Kode lerroa:           switch (fieldType) {
Kode lerroa:             case 'Tx':
Kode lerroa:               return new TextWidgetAnnotationElement(parameters);
Kode lerroa:             case 'Btn':
Kode lerroa:               if (parameters.data.radioButton) {
Kode lerroa:                 return new RadioButtonWidgetAnnotationElement(parameters);
Kode lerroa:               } else if (parameters.data.checkBox) {
Kode lerroa:                 return new CheckboxWidgetAnnotationElement(parameters);
Kode lerroa:               }
Kode lerroa:               (0, _util.warn)('Unimplemented button widget annotation: pushbutton');
Kode lerroa:               break;
Kode lerroa:             case 'Ch':
Kode lerroa:               return new ChoiceWidgetAnnotationElement(parameters);
Kode lerroa:           }
Kode lerroa:           return new WidgetAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.POPUP:
Kode lerroa:           return new PopupAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.LINE:
Kode lerroa:           return new LineAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.SQUARE:
Kode lerroa:           return new SquareAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.CIRCLE:
Kode lerroa:           return new CircleAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.POLYLINE:
Kode lerroa:           return new PolylineAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.POLYGON:
Kode lerroa:           return new PolygonAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.HIGHLIGHT:
Kode lerroa:           return new HighlightAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.UNDERLINE:
Kode lerroa:           return new UnderlineAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.SQUIGGLY:
Kode lerroa:           return new SquigglyAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.STRIKEOUT:
Kode lerroa:           return new StrikeOutAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.STAMP:
Kode lerroa:           return new StampAnnotationElement(parameters);
Kode lerroa:         case _util.AnnotationType.FILEATTACHMENT:
Kode lerroa:           return new FileAttachmentAnnotationElement(parameters);
Kode lerroa:         default:
Kode lerroa:           return new AnnotationElement(parameters);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return AnnotationElementFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var AnnotationElement = function () {
Kode lerroa:   function AnnotationElement(parameters) {
Kode lerroa:     var isRenderable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa:     var ignoreBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, AnnotationElement);
Kode lerroa: 
Kode lerroa:     this.isRenderable = isRenderable;
Kode lerroa:     this.data = parameters.data;
Kode lerroa:     this.layer = parameters.layer;
Kode lerroa:     this.page = parameters.page;
Kode lerroa:     this.viewport = parameters.viewport;
Kode lerroa:     this.linkService = parameters.linkService;
Kode lerroa:     this.downloadManager = parameters.downloadManager;
Kode lerroa:     this.imageResourcesPath = parameters.imageResourcesPath;
Kode lerroa:     this.renderInteractiveForms = parameters.renderInteractiveForms;
Kode lerroa:     this.svgFactory = parameters.svgFactory;
Kode lerroa:     if (isRenderable) {
Kode lerroa:       this.container = this._createContainer(ignoreBorder);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(AnnotationElement, [{
Kode lerroa:     key: '_createContainer',
Kode lerroa:     value: function _createContainer() {
Kode lerroa:       var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       var data = this.data,
Kode lerroa:           page = this.page,
Kode lerroa:           viewport = this.viewport;
Kode lerroa:       var container = document.createElement('section');
Kode lerroa:       var width = data.rect[2] - data.rect[0];
Kode lerroa:       var height = data.rect[3] - data.rect[1];
Kode lerroa:       container.setAttribute('data-annotation-id', data.id);
Kode lerroa:       var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
Kode lerroa:       _dom_utils.CustomStyle.setProp('transform', container, 'matrix(' + viewport.transform.join(',') + ')');
Kode lerroa:       _dom_utils.CustomStyle.setProp('transformOrigin', container, -rect[0] + 'px ' + -rect[1] + 'px');
Kode lerroa:       if (!ignoreBorder && data.borderStyle.width > 0) {
Kode lerroa:         container.style.borderWidth = data.borderStyle.width + 'px';
Kode lerroa:         if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
Kode lerroa:           width = width - 2 * data.borderStyle.width;
Kode lerroa:           height = height - 2 * data.borderStyle.width;
Kode lerroa:         }
Kode lerroa:         var horizontalRadius = data.borderStyle.horizontalCornerRadius;
Kode lerroa:         var verticalRadius = data.borderStyle.verticalCornerRadius;
Kode lerroa:         if (horizontalRadius > 0 || verticalRadius > 0) {
Kode lerroa:           var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';
Kode lerroa:           _dom_utils.CustomStyle.setProp('borderRadius', container, radius);
Kode lerroa:         }
Kode lerroa:         switch (data.borderStyle.style) {
Kode lerroa:           case _util.AnnotationBorderStyleType.SOLID:
Kode lerroa:             container.style.borderStyle = 'solid';
Kode lerroa:             break;
Kode lerroa:           case _util.AnnotationBorderStyleType.DASHED:
Kode lerroa:             container.style.borderStyle = 'dashed';
Kode lerroa:             break;
Kode lerroa:           case _util.AnnotationBorderStyleType.BEVELED:
Kode lerroa:             (0, _util.warn)('Unimplemented border style: beveled');
Kode lerroa:             break;
Kode lerroa:           case _util.AnnotationBorderStyleType.INSET:
Kode lerroa:             (0, _util.warn)('Unimplemented border style: inset');
Kode lerroa:             break;
Kode lerroa:           case _util.AnnotationBorderStyleType.UNDERLINE:
Kode lerroa:             container.style.borderBottomStyle = 'solid';
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         if (data.color) {
Kode lerroa:           container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
Kode lerroa:         } else {
Kode lerroa:           container.style.borderWidth = 0;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       container.style.left = rect[0] + 'px';
Kode lerroa:       container.style.top = rect[1] + 'px';
Kode lerroa:       container.style.width = width + 'px';
Kode lerroa:       container.style.height = height + 'px';
Kode lerroa:       return container;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_createPopup',
Kode lerroa:     value: function _createPopup(container, trigger, data) {
Kode lerroa:       if (!trigger) {
Kode lerroa:         trigger = document.createElement('div');
Kode lerroa:         trigger.style.height = container.style.height;
Kode lerroa:         trigger.style.width = container.style.width;
Kode lerroa:         container.appendChild(trigger);
Kode lerroa:       }
Kode lerroa:       var popupElement = new PopupElement({
Kode lerroa:         container: container,
Kode lerroa:         trigger: trigger,
Kode lerroa:         color: data.color,
Kode lerroa:         title: data.title,
Kode lerroa:         contents: data.contents,
Kode lerroa:         hideWrapper: true
Kode lerroa:       });
Kode lerroa:       var popup = popupElement.render();
Kode lerroa:       popup.style.left = container.style.width;
Kode lerroa:       container.appendChild(popup);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       throw new Error('Abstract method `AnnotationElement.render` called');
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return AnnotationElement;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var LinkAnnotationElement = function (_AnnotationElement) {
Kode lerroa:   _inherits(LinkAnnotationElement, _AnnotationElement);
Kode lerroa: 
Kode lerroa:   function LinkAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, LinkAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
Kode lerroa:     return _possibleConstructorReturn(this, (LinkAnnotationElement.__proto__ || Object.getPrototypeOf(LinkAnnotationElement)).call(this, parameters, isRenderable));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(LinkAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'linkAnnotation';
Kode lerroa:       var link = document.createElement('a');
Kode lerroa:       (0, _dom_utils.addLinkAttributes)(link, {
Kode lerroa:         url: this.data.url,
Kode lerroa:         target: this.data.newWindow ? _dom_utils.LinkTarget.BLANK : undefined
Kode lerroa:       });
Kode lerroa:       if (!this.data.url) {
Kode lerroa:         if (this.data.action) {
Kode lerroa:           this._bindNamedAction(link, this.data.action);
Kode lerroa:         } else {
Kode lerroa:           this._bindLink(link, this.data.dest);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(link);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindLink',
Kode lerroa:     value: function _bindLink(link, destination) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       link.href = this.linkService.getDestinationHash(destination);
Kode lerroa:       link.onclick = function () {
Kode lerroa:         if (destination) {
Kode lerroa:           _this2.linkService.navigateTo(destination);
Kode lerroa:         }
Kode lerroa:         return false;
Kode lerroa:       };
Kode lerroa:       if (destination) {
Kode lerroa:         link.className = 'internalLink';
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindNamedAction',
Kode lerroa:     value: function _bindNamedAction(link, action) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       link.href = this.linkService.getAnchorUrl('');
Kode lerroa:       link.onclick = function () {
Kode lerroa:         _this3.linkService.executeNamedAction(action);
Kode lerroa:         return false;
Kode lerroa:       };
Kode lerroa:       link.className = 'internalLink';
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return LinkAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var TextAnnotationElement = function (_AnnotationElement2) {
Kode lerroa:   _inherits(TextAnnotationElement, _AnnotationElement2);
Kode lerroa: 
Kode lerroa:   function TextAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, TextAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (TextAnnotationElement.__proto__ || Object.getPrototypeOf(TextAnnotationElement)).call(this, parameters, isRenderable));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(TextAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'textAnnotation';
Kode lerroa:       var image = document.createElement('img');
Kode lerroa:       image.style.height = this.container.style.height;
Kode lerroa:       image.style.width = this.container.style.width;
Kode lerroa:       image.src = this.imageResourcesPath + 'annotation-' + this.data.name.toLowerCase() + '.svg';
Kode lerroa:       image.alt = '[{{type}} Annotation]';
Kode lerroa:       image.dataset.l10nId = 'text_annotation_type';
Kode lerroa:       image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
Kode lerroa:       if (!this.data.hasPopup) {
Kode lerroa:         this._createPopup(this.container, image, this.data);
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(image);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return TextAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var WidgetAnnotationElement = function (_AnnotationElement3) {
Kode lerroa:   _inherits(WidgetAnnotationElement, _AnnotationElement3);
Kode lerroa: 
Kode lerroa:   function WidgetAnnotationElement() {
Kode lerroa:     _classCallCheck(this, WidgetAnnotationElement);
Kode lerroa: 
Kode lerroa:     return _possibleConstructorReturn(this, (WidgetAnnotationElement.__proto__ || Object.getPrototypeOf(WidgetAnnotationElement)).apply(this, arguments));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(WidgetAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return WidgetAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var TextWidgetAnnotationElement = function (_WidgetAnnotationElem) {
Kode lerroa:   _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);
Kode lerroa: 
Kode lerroa:   function TextWidgetAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, TextWidgetAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
Kode lerroa:     return _possibleConstructorReturn(this, (TextWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(TextWidgetAnnotationElement)).call(this, parameters, isRenderable));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(TextWidgetAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       var TEXT_ALIGNMENT = ['left', 'center', 'right'];
Kode lerroa:       this.container.className = 'textWidgetAnnotation';
Kode lerroa:       var element = null;
Kode lerroa:       if (this.renderInteractiveForms) {
Kode lerroa:         if (this.data.multiLine) {
Kode lerroa:           element = document.createElement('textarea');
Kode lerroa:           element.textContent = this.data.fieldValue;
Kode lerroa:         } else {
Kode lerroa:           element = document.createElement('input');
Kode lerroa:           element.type = 'text';
Kode lerroa:           element.setAttribute('value', this.data.fieldValue);
Kode lerroa:         }
Kode lerroa:         element.disabled = this.data.readOnly;
Kode lerroa:         if (this.data.maxLen !== null) {
Kode lerroa:           element.maxLength = this.data.maxLen;
Kode lerroa:         }
Kode lerroa:         if (this.data.comb) {
Kode lerroa:           var fieldWidth = this.data.rect[2] - this.data.rect[0];
Kode lerroa:           var combWidth = fieldWidth / this.data.maxLen;
Kode lerroa:           element.classList.add('comb');
Kode lerroa:           element.style.letterSpacing = 'calc(' + combWidth + 'px - 1ch)';
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         element = document.createElement('div');
Kode lerroa:         element.textContent = this.data.fieldValue;
Kode lerroa:         element.style.verticalAlign = 'middle';
Kode lerroa:         element.style.display = 'table-cell';
Kode lerroa:         var font = null;
Kode lerroa:         if (this.data.fontRefName) {
Kode lerroa:           font = this.page.commonObjs.getData(this.data.fontRefName);
Kode lerroa:         }
Kode lerroa:         this._setTextStyle(element, font);
Kode lerroa:       }
Kode lerroa:       if (this.data.textAlignment !== null) {
Kode lerroa:         element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(element);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setTextStyle',
Kode lerroa:     value: function _setTextStyle(element, font) {
Kode lerroa:       var style = element.style;
Kode lerroa:       style.fontSize = this.data.fontSize + 'px';
Kode lerroa:       style.direction = this.data.fontDirection < 0 ? 'rtl' : 'ltr';
Kode lerroa:       if (!font) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       style.fontWeight = font.black ? font.bold ? '900' : 'bold' : font.bold ? 'bold' : 'normal';
Kode lerroa:       style.fontStyle = font.italic ? 'italic' : 'normal';
Kode lerroa:       var fontFamily = font.loadedName ? '"' + font.loadedName + '", ' : '';
Kode lerroa:       var fallbackName = font.fallbackName || 'Helvetica, sans-serif';
Kode lerroa:       style.fontFamily = fontFamily + fallbackName;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return TextWidgetAnnotationElement;
Kode lerroa: }(WidgetAnnotationElement);
Kode lerroa: 
Kode lerroa: var CheckboxWidgetAnnotationElement = function (_WidgetAnnotationElem2) {
Kode lerroa:   _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);
Kode lerroa: 
Kode lerroa:   function CheckboxWidgetAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, CheckboxWidgetAnnotationElement);
Kode lerroa: 
Kode lerroa:     return _possibleConstructorReturn(this, (CheckboxWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(CheckboxWidgetAnnotationElement)).call(this, parameters, parameters.renderInteractiveForms));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(CheckboxWidgetAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'buttonWidgetAnnotation checkBox';
Kode lerroa:       var element = document.createElement('input');
Kode lerroa:       element.disabled = this.data.readOnly;
Kode lerroa:       element.type = 'checkbox';
Kode lerroa:       if (this.data.fieldValue && this.data.fieldValue !== 'Off') {
Kode lerroa:         element.setAttribute('checked', true);
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(element);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return CheckboxWidgetAnnotationElement;
Kode lerroa: }(WidgetAnnotationElement);
Kode lerroa: 
Kode lerroa: var RadioButtonWidgetAnnotationElement = function (_WidgetAnnotationElem3) {
Kode lerroa:   _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);
Kode lerroa: 
Kode lerroa:   function RadioButtonWidgetAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, RadioButtonWidgetAnnotationElement);
Kode lerroa: 
Kode lerroa:     return _possibleConstructorReturn(this, (RadioButtonWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(RadioButtonWidgetAnnotationElement)).call(this, parameters, parameters.renderInteractiveForms));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(RadioButtonWidgetAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'buttonWidgetAnnotation radioButton';
Kode lerroa:       var element = document.createElement('input');
Kode lerroa:       element.disabled = this.data.readOnly;
Kode lerroa:       element.type = 'radio';
Kode lerroa:       element.name = this.data.fieldName;
Kode lerroa:       if (this.data.fieldValue === this.data.buttonValue) {
Kode lerroa:         element.setAttribute('checked', true);
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(element);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return RadioButtonWidgetAnnotationElement;
Kode lerroa: }(WidgetAnnotationElement);
Kode lerroa: 
Kode lerroa: var ChoiceWidgetAnnotationElement = function (_WidgetAnnotationElem4) {
Kode lerroa:   _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);
Kode lerroa: 
Kode lerroa:   function ChoiceWidgetAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, ChoiceWidgetAnnotationElement);
Kode lerroa: 
Kode lerroa:     return _possibleConstructorReturn(this, (ChoiceWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(ChoiceWidgetAnnotationElement)).call(this, parameters, parameters.renderInteractiveForms));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(ChoiceWidgetAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'choiceWidgetAnnotation';
Kode lerroa:       var selectElement = document.createElement('select');
Kode lerroa:       selectElement.disabled = this.data.readOnly;
Kode lerroa:       if (!this.data.combo) {
Kode lerroa:         selectElement.size = this.data.options.length;
Kode lerroa:         if (this.data.multiSelect) {
Kode lerroa:           selectElement.multiple = true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (var i = 0, ii = this.data.options.length; i < ii; i++) {
Kode lerroa:         var option = this.data.options[i];
Kode lerroa:         var optionElement = document.createElement('option');
Kode lerroa:         optionElement.textContent = option.displayValue;
Kode lerroa:         optionElement.value = option.exportValue;
Kode lerroa:         if (this.data.fieldValue.indexOf(option.displayValue) >= 0) {
Kode lerroa:           optionElement.setAttribute('selected', true);
Kode lerroa:         }
Kode lerroa:         selectElement.appendChild(optionElement);
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(selectElement);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return ChoiceWidgetAnnotationElement;
Kode lerroa: }(WidgetAnnotationElement);
Kode lerroa: 
Kode lerroa: var PopupAnnotationElement = function (_AnnotationElement4) {
Kode lerroa:   _inherits(PopupAnnotationElement, _AnnotationElement4);
Kode lerroa: 
Kode lerroa:   function PopupAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, PopupAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (PopupAnnotationElement.__proto__ || Object.getPrototypeOf(PopupAnnotationElement)).call(this, parameters, isRenderable));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PopupAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       var IGNORE_TYPES = ['Line', 'Square', 'Circle', 'PolyLine', 'Polygon'];
Kode lerroa:       this.container.className = 'popupAnnotation';
Kode lerroa:       if (IGNORE_TYPES.indexOf(this.data.parentType) >= 0) {
Kode lerroa:         return this.container;
Kode lerroa:       }
Kode lerroa:       var selector = '[data-annotation-id="' + this.data.parentId + '"]';
Kode lerroa:       var parentElement = this.layer.querySelector(selector);
Kode lerroa:       if (!parentElement) {
Kode lerroa:         return this.container;
Kode lerroa:       }
Kode lerroa:       var popup = new PopupElement({
Kode lerroa:         container: this.container,
Kode lerroa:         trigger: parentElement,
Kode lerroa:         color: this.data.color,
Kode lerroa:         title: this.data.title,
Kode lerroa:         contents: this.data.contents
Kode lerroa:       });
Kode lerroa:       var parentLeft = parseFloat(parentElement.style.left);
Kode lerroa:       var parentWidth = parseFloat(parentElement.style.width);
Kode lerroa:       _dom_utils.CustomStyle.setProp('transformOrigin', this.container, -(parentLeft + parentWidth) + 'px -' + parentElement.style.top);
Kode lerroa:       this.container.style.left = parentLeft + parentWidth + 'px';
Kode lerroa:       this.container.appendChild(popup.render());
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PopupAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var PopupElement = function () {
Kode lerroa:   function PopupElement(parameters) {
Kode lerroa:     _classCallCheck(this, PopupElement);
Kode lerroa: 
Kode lerroa:     this.container = parameters.container;
Kode lerroa:     this.trigger = parameters.trigger;
Kode lerroa:     this.color = parameters.color;
Kode lerroa:     this.title = parameters.title;
Kode lerroa:     this.contents = parameters.contents;
Kode lerroa:     this.hideWrapper = parameters.hideWrapper || false;
Kode lerroa:     this.pinned = false;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PopupElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       var BACKGROUND_ENLIGHT = 0.7;
Kode lerroa:       var wrapper = document.createElement('div');
Kode lerroa:       wrapper.className = 'popupWrapper';
Kode lerroa:       this.hideElement = this.hideWrapper ? wrapper : this.container;
Kode lerroa:       this.hideElement.setAttribute('hidden', true);
Kode lerroa:       var popup = document.createElement('div');
Kode lerroa:       popup.className = 'popup';
Kode lerroa:       var color = this.color;
Kode lerroa:       if (color) {
Kode lerroa:         var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
Kode lerroa:         var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
Kode lerroa:         var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
Kode lerroa:         popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);
Kode lerroa:       }
Kode lerroa:       var contents = this._formatContents(this.contents);
Kode lerroa:       var title = document.createElement('h1');
Kode lerroa:       title.textContent = this.title;
Kode lerroa:       this.trigger.addEventListener('click', this._toggle.bind(this));
Kode lerroa:       this.trigger.addEventListener('mouseover', this._show.bind(this, false));
Kode lerroa:       this.trigger.addEventListener('mouseout', this._hide.bind(this, false));
Kode lerroa:       popup.addEventListener('click', this._hide.bind(this, true));
Kode lerroa:       popup.appendChild(title);
Kode lerroa:       popup.appendChild(contents);
Kode lerroa:       wrapper.appendChild(popup);
Kode lerroa:       return wrapper;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_formatContents',
Kode lerroa:     value: function _formatContents(contents) {
Kode lerroa:       var p = document.createElement('p');
Kode lerroa:       var lines = contents.split(/(?:\r\n?|\n)/);
Kode lerroa:       for (var i = 0, ii = lines.length; i < ii; ++i) {
Kode lerroa:         var line = lines[i];
Kode lerroa:         p.appendChild(document.createTextNode(line));
Kode lerroa:         if (i < ii - 1) {
Kode lerroa:           p.appendChild(document.createElement('br'));
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return p;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_toggle',
Kode lerroa:     value: function _toggle() {
Kode lerroa:       if (this.pinned) {
Kode lerroa:         this._hide(true);
Kode lerroa:       } else {
Kode lerroa:         this._show(true);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_show',
Kode lerroa:     value: function _show() {
Kode lerroa:       var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       if (pin) {
Kode lerroa:         this.pinned = true;
Kode lerroa:       }
Kode lerroa:       if (this.hideElement.hasAttribute('hidden')) {
Kode lerroa:         this.hideElement.removeAttribute('hidden');
Kode lerroa:         this.container.style.zIndex += 1;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_hide',
Kode lerroa:     value: function _hide() {
Kode lerroa:       var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
Kode lerroa: 
Kode lerroa:       if (unpin) {
Kode lerroa:         this.pinned = false;
Kode lerroa:       }
Kode lerroa:       if (!this.hideElement.hasAttribute('hidden') && !this.pinned) {
Kode lerroa:         this.hideElement.setAttribute('hidden', true);
Kode lerroa:         this.container.style.zIndex -= 1;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PopupElement;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var LineAnnotationElement = function (_AnnotationElement5) {
Kode lerroa:   _inherits(LineAnnotationElement, _AnnotationElement5);
Kode lerroa: 
Kode lerroa:   function LineAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, LineAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (LineAnnotationElement.__proto__ || Object.getPrototypeOf(LineAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(LineAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'lineAnnotation';
Kode lerroa:       var data = this.data;
Kode lerroa:       var width = data.rect[2] - data.rect[0];
Kode lerroa:       var height = data.rect[3] - data.rect[1];
Kode lerroa:       var svg = this.svgFactory.create(width, height);
Kode lerroa:       var line = this.svgFactory.createElement('svg:line');
Kode lerroa:       line.setAttribute('x1', data.rect[2] - data.lineCoordinates[0]);
Kode lerroa:       line.setAttribute('y1', data.rect[3] - data.lineCoordinates[1]);
Kode lerroa:       line.setAttribute('x2', data.rect[2] - data.lineCoordinates[2]);
Kode lerroa:       line.setAttribute('y2', data.rect[3] - data.lineCoordinates[3]);
Kode lerroa:       line.setAttribute('stroke-width', data.borderStyle.width);
Kode lerroa:       line.setAttribute('stroke', 'transparent');
Kode lerroa:       svg.appendChild(line);
Kode lerroa:       this.container.append(svg);
Kode lerroa:       this._createPopup(this.container, line, data);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return LineAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var SquareAnnotationElement = function (_AnnotationElement6) {
Kode lerroa:   _inherits(SquareAnnotationElement, _AnnotationElement6);
Kode lerroa: 
Kode lerroa:   function SquareAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, SquareAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (SquareAnnotationElement.__proto__ || Object.getPrototypeOf(SquareAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(SquareAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'squareAnnotation';
Kode lerroa:       var data = this.data;
Kode lerroa:       var width = data.rect[2] - data.rect[0];
Kode lerroa:       var height = data.rect[3] - data.rect[1];
Kode lerroa:       var svg = this.svgFactory.create(width, height);
Kode lerroa:       var borderWidth = data.borderStyle.width;
Kode lerroa:       var square = this.svgFactory.createElement('svg:rect');
Kode lerroa:       square.setAttribute('x', borderWidth / 2);
Kode lerroa:       square.setAttribute('y', borderWidth / 2);
Kode lerroa:       square.setAttribute('width', width - borderWidth);
Kode lerroa:       square.setAttribute('height', height - borderWidth);
Kode lerroa:       square.setAttribute('stroke-width', borderWidth);
Kode lerroa:       square.setAttribute('stroke', 'transparent');
Kode lerroa:       square.setAttribute('fill', 'none');
Kode lerroa:       svg.appendChild(square);
Kode lerroa:       this.container.append(svg);
Kode lerroa:       this._createPopup(this.container, square, data);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return SquareAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var CircleAnnotationElement = function (_AnnotationElement7) {
Kode lerroa:   _inherits(CircleAnnotationElement, _AnnotationElement7);
Kode lerroa: 
Kode lerroa:   function CircleAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, CircleAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (CircleAnnotationElement.__proto__ || Object.getPrototypeOf(CircleAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(CircleAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'circleAnnotation';
Kode lerroa:       var data = this.data;
Kode lerroa:       var width = data.rect[2] - data.rect[0];
Kode lerroa:       var height = data.rect[3] - data.rect[1];
Kode lerroa:       var svg = this.svgFactory.create(width, height);
Kode lerroa:       var borderWidth = data.borderStyle.width;
Kode lerroa:       var circle = this.svgFactory.createElement('svg:ellipse');
Kode lerroa:       circle.setAttribute('cx', width / 2);
Kode lerroa:       circle.setAttribute('cy', height / 2);
Kode lerroa:       circle.setAttribute('rx', width / 2 - borderWidth / 2);
Kode lerroa:       circle.setAttribute('ry', height / 2 - borderWidth / 2);
Kode lerroa:       circle.setAttribute('stroke-width', borderWidth);
Kode lerroa:       circle.setAttribute('stroke', 'transparent');
Kode lerroa:       circle.setAttribute('fill', 'none');
Kode lerroa:       svg.appendChild(circle);
Kode lerroa:       this.container.append(svg);
Kode lerroa:       this._createPopup(this.container, circle, data);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return CircleAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var PolylineAnnotationElement = function (_AnnotationElement8) {
Kode lerroa:   _inherits(PolylineAnnotationElement, _AnnotationElement8);
Kode lerroa: 
Kode lerroa:   function PolylineAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, PolylineAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa: 
Kode lerroa:     var _this14 = _possibleConstructorReturn(this, (PolylineAnnotationElement.__proto__ || Object.getPrototypeOf(PolylineAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa: 
Kode lerroa:     _this14.containerClassName = 'polylineAnnotation';
Kode lerroa:     _this14.svgElementName = 'svg:polyline';
Kode lerroa:     return _this14;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PolylineAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = this.containerClassName;
Kode lerroa:       var data = this.data;
Kode lerroa:       var width = data.rect[2] - data.rect[0];
Kode lerroa:       var height = data.rect[3] - data.rect[1];
Kode lerroa:       var svg = this.svgFactory.create(width, height);
Kode lerroa:       var vertices = data.vertices;
Kode lerroa:       var points = [];
Kode lerroa:       for (var i = 0, ii = vertices.length; i < ii; i++) {
Kode lerroa:         var x = vertices[i].x - data.rect[0];
Kode lerroa:         var y = data.rect[3] - vertices[i].y;
Kode lerroa:         points.push(x + ',' + y);
Kode lerroa:       }
Kode lerroa:       points = points.join(' ');
Kode lerroa:       var borderWidth = data.borderStyle.width;
Kode lerroa:       var polyline = this.svgFactory.createElement(this.svgElementName);
Kode lerroa:       polyline.setAttribute('points', points);
Kode lerroa:       polyline.setAttribute('stroke-width', borderWidth);
Kode lerroa:       polyline.setAttribute('stroke', 'transparent');
Kode lerroa:       polyline.setAttribute('fill', 'none');
Kode lerroa:       svg.appendChild(polyline);
Kode lerroa:       this.container.append(svg);
Kode lerroa:       this._createPopup(this.container, polyline, data);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PolylineAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var PolygonAnnotationElement = function (_PolylineAnnotationEl) {
Kode lerroa:   _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);
Kode lerroa: 
Kode lerroa:   function PolygonAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, PolygonAnnotationElement);
Kode lerroa: 
Kode lerroa:     var _this15 = _possibleConstructorReturn(this, (PolygonAnnotationElement.__proto__ || Object.getPrototypeOf(PolygonAnnotationElement)).call(this, parameters));
Kode lerroa: 
Kode lerroa:     _this15.containerClassName = 'polygonAnnotation';
Kode lerroa:     _this15.svgElementName = 'svg:polygon';
Kode lerroa:     return _this15;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   return PolygonAnnotationElement;
Kode lerroa: }(PolylineAnnotationElement);
Kode lerroa: 
Kode lerroa: var HighlightAnnotationElement = function (_AnnotationElement9) {
Kode lerroa:   _inherits(HighlightAnnotationElement, _AnnotationElement9);
Kode lerroa: 
Kode lerroa:   function HighlightAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, HighlightAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (HighlightAnnotationElement.__proto__ || Object.getPrototypeOf(HighlightAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(HighlightAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'highlightAnnotation';
Kode lerroa:       if (!this.data.hasPopup) {
Kode lerroa:         this._createPopup(this.container, null, this.data);
Kode lerroa:       }
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return HighlightAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var UnderlineAnnotationElement = function (_AnnotationElement10) {
Kode lerroa:   _inherits(UnderlineAnnotationElement, _AnnotationElement10);
Kode lerroa: 
Kode lerroa:   function UnderlineAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, UnderlineAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (UnderlineAnnotationElement.__proto__ || Object.getPrototypeOf(UnderlineAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(UnderlineAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'underlineAnnotation';
Kode lerroa:       if (!this.data.hasPopup) {
Kode lerroa:         this._createPopup(this.container, null, this.data);
Kode lerroa:       }
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return UnderlineAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var SquigglyAnnotationElement = function (_AnnotationElement11) {
Kode lerroa:   _inherits(SquigglyAnnotationElement, _AnnotationElement11);
Kode lerroa: 
Kode lerroa:   function SquigglyAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, SquigglyAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (SquigglyAnnotationElement.__proto__ || Object.getPrototypeOf(SquigglyAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(SquigglyAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'squigglyAnnotation';
Kode lerroa:       if (!this.data.hasPopup) {
Kode lerroa:         this._createPopup(this.container, null, this.data);
Kode lerroa:       }
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return SquigglyAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var StrikeOutAnnotationElement = function (_AnnotationElement12) {
Kode lerroa:   _inherits(StrikeOutAnnotationElement, _AnnotationElement12);
Kode lerroa: 
Kode lerroa:   function StrikeOutAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, StrikeOutAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (StrikeOutAnnotationElement.__proto__ || Object.getPrototypeOf(StrikeOutAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(StrikeOutAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'strikeoutAnnotation';
Kode lerroa:       if (!this.data.hasPopup) {
Kode lerroa:         this._createPopup(this.container, null, this.data);
Kode lerroa:       }
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return StrikeOutAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var StampAnnotationElement = function (_AnnotationElement13) {
Kode lerroa:   _inherits(StampAnnotationElement, _AnnotationElement13);
Kode lerroa: 
Kode lerroa:   function StampAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, StampAnnotationElement);
Kode lerroa: 
Kode lerroa:     var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
Kode lerroa:     return _possibleConstructorReturn(this, (StampAnnotationElement.__proto__ || Object.getPrototypeOf(StampAnnotationElement)).call(this, parameters, isRenderable, true));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(StampAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'stampAnnotation';
Kode lerroa:       if (!this.data.hasPopup) {
Kode lerroa:         this._createPopup(this.container, null, this.data);
Kode lerroa:       }
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return StampAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var FileAttachmentAnnotationElement = function (_AnnotationElement14) {
Kode lerroa:   _inherits(FileAttachmentAnnotationElement, _AnnotationElement14);
Kode lerroa: 
Kode lerroa:   function FileAttachmentAnnotationElement(parameters) {
Kode lerroa:     _classCallCheck(this, FileAttachmentAnnotationElement);
Kode lerroa: 
Kode lerroa:     var _this21 = _possibleConstructorReturn(this, (FileAttachmentAnnotationElement.__proto__ || Object.getPrototypeOf(FileAttachmentAnnotationElement)).call(this, parameters, true));
Kode lerroa: 
Kode lerroa:     var file = _this21.data.file;
Kode lerroa:     _this21.filename = (0, _dom_utils.getFilenameFromUrl)(file.filename);
Kode lerroa:     _this21.content = file.content;
Kode lerroa:     _this21.linkService.onFileAttachmentAnnotation({
Kode lerroa:       id: (0, _util.stringToPDFString)(file.filename),
Kode lerroa:       filename: file.filename,
Kode lerroa:       content: file.content
Kode lerroa:     });
Kode lerroa:     return _this21;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(FileAttachmentAnnotationElement, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       this.container.className = 'fileAttachmentAnnotation';
Kode lerroa:       var trigger = document.createElement('div');
Kode lerroa:       trigger.style.height = this.container.style.height;
Kode lerroa:       trigger.style.width = this.container.style.width;
Kode lerroa:       trigger.addEventListener('dblclick', this._download.bind(this));
Kode lerroa:       if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
Kode lerroa:         this._createPopup(this.container, trigger, this.data);
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(trigger);
Kode lerroa:       return this.container;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_download',
Kode lerroa:     value: function _download() {
Kode lerroa:       if (!this.downloadManager) {
Kode lerroa:         (0, _util.warn)('Download cannot be started due to unavailable download manager');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.downloadManager.downloadData(this.content, this.filename, '');
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return FileAttachmentAnnotationElement;
Kode lerroa: }(AnnotationElement);
Kode lerroa: 
Kode lerroa: var AnnotationLayer = function () {
Kode lerroa:   function AnnotationLayer() {
Kode lerroa:     _classCallCheck(this, AnnotationLayer);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(AnnotationLayer, null, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render(parameters) {
Kode lerroa:       for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
Kode lerroa:         var data = parameters.annotations[i];
Kode lerroa:         if (!data) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var element = AnnotationElementFactory.create({
Kode lerroa:           data: data,
Kode lerroa:           layer: parameters.div,
Kode lerroa:           page: parameters.page,
Kode lerroa:           viewport: parameters.viewport,
Kode lerroa:           linkService: parameters.linkService,
Kode lerroa:           downloadManager: parameters.downloadManager,
Kode lerroa:           imageResourcesPath: parameters.imageResourcesPath || (0, _dom_utils.getDefaultSetting)('imageResourcesPath'),
Kode lerroa:           renderInteractiveForms: parameters.renderInteractiveForms || false,
Kode lerroa:           svgFactory: new _dom_utils.DOMSVGFactory()
Kode lerroa:         });
Kode lerroa:         if (element.isRenderable) {
Kode lerroa:           parameters.div.appendChild(element.render());
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'update',
Kode lerroa:     value: function update(parameters) {
Kode lerroa:       for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
Kode lerroa:         var data = parameters.annotations[i];
Kode lerroa:         var element = parameters.div.querySelector('[data-annotation-id="' + data.id + '"]');
Kode lerroa:         if (element) {
Kode lerroa:           _dom_utils.CustomStyle.setProp('transform', element, 'matrix(' + parameters.viewport.transform.join(',') + ')');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       parameters.div.removeAttribute('hidden');
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return AnnotationLayer;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.AnnotationLayer = AnnotationLayer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 73 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.renderTextLayer = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _dom_utils = __w_pdfjs_require__(15);
Kode lerroa: 
Kode lerroa: var renderTextLayer = function renderTextLayerClosure() {
Kode lerroa:   var MAX_TEXT_DIVS_TO_RENDER = 100000;
Kode lerroa:   var NonWhitespaceRegexp = /\S/;
Kode lerroa:   function isAllWhitespace(str) {
Kode lerroa:     return !NonWhitespaceRegexp.test(str);
Kode lerroa:   }
Kode lerroa:   var styleBuf = ['left: ', 0, 'px; top: ', 0, 'px; font-size: ', 0, 'px; font-family: ', '', ';'];
Kode lerroa:   function appendText(task, geom, styles) {
Kode lerroa:     var textDiv = document.createElement('div');
Kode lerroa:     var textDivProperties = {
Kode lerroa:       style: null,
Kode lerroa:       angle: 0,
Kode lerroa:       canvasWidth: 0,
Kode lerroa:       isWhitespace: false,
Kode lerroa:       originalTransform: null,
Kode lerroa:       paddingBottom: 0,
Kode lerroa:       paddingLeft: 0,
Kode lerroa:       paddingRight: 0,
Kode lerroa:       paddingTop: 0,
Kode lerroa:       scale: 1
Kode lerroa:     };
Kode lerroa:     task._textDivs.push(textDiv);
Kode lerroa:     if (isAllWhitespace(geom.str)) {
Kode lerroa:       textDivProperties.isWhitespace = true;
Kode lerroa:       task._textDivProperties.set(textDiv, textDivProperties);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var tx = _util.Util.transform(task._viewport.transform, geom.transform);
Kode lerroa:     var angle = Math.atan2(tx[1], tx[0]);
Kode lerroa:     var style = styles[geom.fontName];
Kode lerroa:     if (style.vertical) {
Kode lerroa:       angle += Math.PI / 2;
Kode lerroa:     }
Kode lerroa:     var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
Kode lerroa:     var fontAscent = fontHeight;
Kode lerroa:     if (style.ascent) {
Kode lerroa:       fontAscent = style.ascent * fontAscent;
Kode lerroa:     } else if (style.descent) {
Kode lerroa:       fontAscent = (1 + style.descent) * fontAscent;
Kode lerroa:     }
Kode lerroa:     var left;
Kode lerroa:     var top;
Kode lerroa:     if (angle === 0) {
Kode lerroa:       left = tx[4];
Kode lerroa:       top = tx[5] - fontAscent;
Kode lerroa:     } else {
Kode lerroa:       left = tx[4] + fontAscent * Math.sin(angle);
Kode lerroa:       top = tx[5] - fontAscent * Math.cos(angle);
Kode lerroa:     }
Kode lerroa:     styleBuf[1] = left;
Kode lerroa:     styleBuf[3] = top;
Kode lerroa:     styleBuf[5] = fontHeight;
Kode lerroa:     styleBuf[7] = style.fontFamily;
Kode lerroa:     textDivProperties.style = styleBuf.join('');
Kode lerroa:     textDiv.setAttribute('style', textDivProperties.style);
Kode lerroa:     textDiv.textContent = geom.str;
Kode lerroa:     if ((0, _dom_utils.getDefaultSetting)('pdfBug')) {
Kode lerroa:       textDiv.dataset.fontName = geom.fontName;
Kode lerroa:     }
Kode lerroa:     if (angle !== 0) {
Kode lerroa:       textDivProperties.angle = angle * (180 / Math.PI);
Kode lerroa:     }
Kode lerroa:     if (geom.str.length > 1) {
Kode lerroa:       if (style.vertical) {
Kode lerroa:         textDivProperties.canvasWidth = geom.height * task._viewport.scale;
Kode lerroa:       } else {
Kode lerroa:         textDivProperties.canvasWidth = geom.width * task._viewport.scale;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     task._textDivProperties.set(textDiv, textDivProperties);
Kode lerroa:     if (task._textContentStream) {
Kode lerroa:       task._layoutText(textDiv);
Kode lerroa:     }
Kode lerroa:     if (task._enhanceTextSelection) {
Kode lerroa:       var angleCos = 1,
Kode lerroa:           angleSin = 0;
Kode lerroa:       if (angle !== 0) {
Kode lerroa:         angleCos = Math.cos(angle);
Kode lerroa:         angleSin = Math.sin(angle);
Kode lerroa:       }
Kode lerroa:       var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
Kode lerroa:       var divHeight = fontHeight;
Kode lerroa:       var m, b;
Kode lerroa:       if (angle !== 0) {
Kode lerroa:         m = [angleCos, angleSin, -angleSin, angleCos, left, top];
Kode lerroa:         b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
Kode lerroa:       } else {
Kode lerroa:         b = [left, top, left + divWidth, top + divHeight];
Kode lerroa:       }
Kode lerroa:       task._bounds.push({
Kode lerroa:         left: b[0],
Kode lerroa:         top: b[1],
Kode lerroa:         right: b[2],
Kode lerroa:         bottom: b[3],
Kode lerroa:         div: textDiv,
Kode lerroa:         size: [divWidth, divHeight],
Kode lerroa:         m: m
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function render(task) {
Kode lerroa:     if (task._canceled) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var textDivs = task._textDivs;
Kode lerroa:     var capability = task._capability;
Kode lerroa:     var textDivsLength = textDivs.length;
Kode lerroa:     if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
Kode lerroa:       task._renderingDone = true;
Kode lerroa:       capability.resolve();
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!task._textContentStream) {
Kode lerroa:       for (var i = 0; i < textDivsLength; i++) {
Kode lerroa:         task._layoutText(textDivs[i]);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     task._renderingDone = true;
Kode lerroa:     capability.resolve();
Kode lerroa:   }
Kode lerroa:   function expand(task) {
Kode lerroa:     var bounds = task._bounds;
Kode lerroa:     var viewport = task._viewport;
Kode lerroa:     var expanded = expandBounds(viewport.width, viewport.height, bounds);
Kode lerroa:     for (var i = 0; i < expanded.length; i++) {
Kode lerroa:       var div = bounds[i].div;
Kode lerroa:       var divProperties = task._textDivProperties.get(div);
Kode lerroa:       if (divProperties.angle === 0) {
Kode lerroa:         divProperties.paddingLeft = bounds[i].left - expanded[i].left;
Kode lerroa:         divProperties.paddingTop = bounds[i].top - expanded[i].top;
Kode lerroa:         divProperties.paddingRight = expanded[i].right - bounds[i].right;
Kode lerroa:         divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
Kode lerroa:         task._textDivProperties.set(div, divProperties);
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       var e = expanded[i],
Kode lerroa:           b = bounds[i];
Kode lerroa:       var m = b.m,
Kode lerroa:           c = m[0],
Kode lerroa:           s = m[1];
Kode lerroa:       var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
Kode lerroa:       var ts = new Float64Array(64);
Kode lerroa:       points.forEach(function (p, i) {
Kode lerroa:         var t = _util.Util.applyTransform(p, m);
Kode lerroa:         ts[i + 0] = c && (e.left - t[0]) / c;
Kode lerroa:         ts[i + 4] = s && (e.top - t[1]) / s;
Kode lerroa:         ts[i + 8] = c && (e.right - t[0]) / c;
Kode lerroa:         ts[i + 12] = s && (e.bottom - t[1]) / s;
Kode lerroa:         ts[i + 16] = s && (e.left - t[0]) / -s;
Kode lerroa:         ts[i + 20] = c && (e.top - t[1]) / c;
Kode lerroa:         ts[i + 24] = s && (e.right - t[0]) / -s;
Kode lerroa:         ts[i + 28] = c && (e.bottom - t[1]) / c;
Kode lerroa:         ts[i + 32] = c && (e.left - t[0]) / -c;
Kode lerroa:         ts[i + 36] = s && (e.top - t[1]) / -s;
Kode lerroa:         ts[i + 40] = c && (e.right - t[0]) / -c;
Kode lerroa:         ts[i + 44] = s && (e.bottom - t[1]) / -s;
Kode lerroa:         ts[i + 48] = s && (e.left - t[0]) / s;
Kode lerroa:         ts[i + 52] = c && (e.top - t[1]) / -c;
Kode lerroa:         ts[i + 56] = s && (e.right - t[0]) / s;
Kode lerroa:         ts[i + 60] = c && (e.bottom - t[1]) / -c;
Kode lerroa:       });
Kode lerroa:       var findPositiveMin = function findPositiveMin(ts, offset, count) {
Kode lerroa:         var result = 0;
Kode lerroa:         for (var i = 0; i < count; i++) {
Kode lerroa:           var t = ts[offset++];
Kode lerroa:           if (t > 0) {
Kode lerroa:             result = result ? Math.min(t, result) : t;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return result;
Kode lerroa:       };
Kode lerroa:       var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
Kode lerroa:       divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
Kode lerroa:       divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
Kode lerroa:       divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
Kode lerroa:       divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
Kode lerroa:       task._textDivProperties.set(div, divProperties);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function expandBounds(width, height, boxes) {
Kode lerroa:     var bounds = boxes.map(function (box, i) {
Kode lerroa:       return {
Kode lerroa:         x1: box.left,
Kode lerroa:         y1: box.top,
Kode lerroa:         x2: box.right,
Kode lerroa:         y2: box.bottom,
Kode lerroa:         index: i,
Kode lerroa:         x1New: undefined,
Kode lerroa:         x2New: undefined
Kode lerroa:       };
Kode lerroa:     });
Kode lerroa:     expandBoundsLTR(width, bounds);
Kode lerroa:     var expanded = new Array(boxes.length);
Kode lerroa:     bounds.forEach(function (b) {
Kode lerroa:       var i = b.index;
Kode lerroa:       expanded[i] = {
Kode lerroa:         left: b.x1New,
Kode lerroa:         top: 0,
Kode lerroa:         right: b.x2New,
Kode lerroa:         bottom: 0
Kode lerroa:       };
Kode lerroa:     });
Kode lerroa:     boxes.map(function (box, i) {
Kode lerroa:       var e = expanded[i],
Kode lerroa:           b = bounds[i];
Kode lerroa:       b.x1 = box.top;
Kode lerroa:       b.y1 = width - e.right;
Kode lerroa:       b.x2 = box.bottom;
Kode lerroa:       b.y2 = width - e.left;
Kode lerroa:       b.index = i;
Kode lerroa:       b.x1New = undefined;
Kode lerroa:       b.x2New = undefined;
Kode lerroa:     });
Kode lerroa:     expandBoundsLTR(height, bounds);
Kode lerroa:     bounds.forEach(function (b) {
Kode lerroa:       var i = b.index;
Kode lerroa:       expanded[i].top = b.x1New;
Kode lerroa:       expanded[i].bottom = b.x2New;
Kode lerroa:     });
Kode lerroa:     return expanded;
Kode lerroa:   }
Kode lerroa:   function expandBoundsLTR(width, bounds) {
Kode lerroa:     bounds.sort(function (a, b) {
Kode lerroa:       return a.x1 - b.x1 || a.index - b.index;
Kode lerroa:     });
Kode lerroa:     var fakeBoundary = {
Kode lerroa:       x1: -Infinity,
Kode lerroa:       y1: -Infinity,
Kode lerroa:       x2: 0,
Kode lerroa:       y2: Infinity,
Kode lerroa:       index: -1,
Kode lerroa:       x1New: 0,
Kode lerroa:       x2New: 0
Kode lerroa:     };
Kode lerroa:     var horizon = [{
Kode lerroa:       start: -Infinity,
Kode lerroa:       end: Infinity,
Kode lerroa:       boundary: fakeBoundary
Kode lerroa:     }];
Kode lerroa:     bounds.forEach(function (boundary) {
Kode lerroa:       var i = 0;
Kode lerroa:       while (i < horizon.length && horizon[i].end <= boundary.y1) {
Kode lerroa:         i++;
Kode lerroa:       }
Kode lerroa:       var j = horizon.length - 1;
Kode lerroa:       while (j >= 0 && horizon[j].start >= boundary.y2) {
Kode lerroa:         j--;
Kode lerroa:       }
Kode lerroa:       var horizonPart, affectedBoundary;
Kode lerroa:       var q,
Kode lerroa:           k,
Kode lerroa:           maxXNew = -Infinity;
Kode lerroa:       for (q = i; q <= j; q++) {
Kode lerroa:         horizonPart = horizon[q];
Kode lerroa:         affectedBoundary = horizonPart.boundary;
Kode lerroa:         var xNew;
Kode lerroa:         if (affectedBoundary.x2 > boundary.x1) {
Kode lerroa:           xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
Kode lerroa:         } else if (affectedBoundary.x2New === undefined) {
Kode lerroa:           xNew = (affectedBoundary.x2 + boundary.x1) / 2;
Kode lerroa:         } else {
Kode lerroa:           xNew = affectedBoundary.x2New;
Kode lerroa:         }
Kode lerroa:         if (xNew > maxXNew) {
Kode lerroa:           maxXNew = xNew;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       boundary.x1New = maxXNew;
Kode lerroa:       for (q = i; q <= j; q++) {
Kode lerroa:         horizonPart = horizon[q];
Kode lerroa:         affectedBoundary = horizonPart.boundary;
Kode lerroa:         if (affectedBoundary.x2New === undefined) {
Kode lerroa:           if (affectedBoundary.x2 > boundary.x1) {
Kode lerroa:             if (affectedBoundary.index > boundary.index) {
Kode lerroa:               affectedBoundary.x2New = affectedBoundary.x2;
Kode lerroa:             }
Kode lerroa:           } else {
Kode lerroa:             affectedBoundary.x2New = maxXNew;
Kode lerroa:           }
Kode lerroa:         } else if (affectedBoundary.x2New > maxXNew) {
Kode lerroa:           affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var changedHorizon = [],
Kode lerroa:           lastBoundary = null;
Kode lerroa:       for (q = i; q <= j; q++) {
Kode lerroa:         horizonPart = horizon[q];
Kode lerroa:         affectedBoundary = horizonPart.boundary;
Kode lerroa:         var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
Kode lerroa:         if (lastBoundary === useBoundary) {
Kode lerroa:           changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
Kode lerroa:         } else {
Kode lerroa:           changedHorizon.push({
Kode lerroa:             start: horizonPart.start,
Kode lerroa:             end: horizonPart.end,
Kode lerroa:             boundary: useBoundary
Kode lerroa:           });
Kode lerroa:           lastBoundary = useBoundary;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (horizon[i].start < boundary.y1) {
Kode lerroa:         changedHorizon[0].start = boundary.y1;
Kode lerroa:         changedHorizon.unshift({
Kode lerroa:           start: horizon[i].start,
Kode lerroa:           end: boundary.y1,
Kode lerroa:           boundary: horizon[i].boundary
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       if (boundary.y2 < horizon[j].end) {
Kode lerroa:         changedHorizon[changedHorizon.length - 1].end = boundary.y2;
Kode lerroa:         changedHorizon.push({
Kode lerroa:           start: boundary.y2,
Kode lerroa:           end: horizon[j].end,
Kode lerroa:           boundary: horizon[j].boundary
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       for (q = i; q <= j; q++) {
Kode lerroa:         horizonPart = horizon[q];
Kode lerroa:         affectedBoundary = horizonPart.boundary;
Kode lerroa:         if (affectedBoundary.x2New !== undefined) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var used = false;
Kode lerroa:         for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
Kode lerroa:           used = horizon[k].boundary === affectedBoundary;
Kode lerroa:         }
Kode lerroa:         for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
Kode lerroa:           used = horizon[k].boundary === affectedBoundary;
Kode lerroa:         }
Kode lerroa:         for (k = 0; !used && k < changedHorizon.length; k++) {
Kode lerroa:           used = changedHorizon[k].boundary === affectedBoundary;
Kode lerroa:         }
Kode lerroa:         if (!used) {
Kode lerroa:           affectedBoundary.x2New = maxXNew;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
Kode lerroa:     });
Kode lerroa:     horizon.forEach(function (horizonPart) {
Kode lerroa:       var affectedBoundary = horizonPart.boundary;
Kode lerroa:       if (affectedBoundary.x2New === undefined) {
Kode lerroa:         affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function TextLayerRenderTask(_ref) {
Kode lerroa:     var textContent = _ref.textContent,
Kode lerroa:         textContentStream = _ref.textContentStream,
Kode lerroa:         container = _ref.container,
Kode lerroa:         viewport = _ref.viewport,
Kode lerroa:         textDivs = _ref.textDivs,
Kode lerroa:         textContentItemsStr = _ref.textContentItemsStr,
Kode lerroa:         enhanceTextSelection = _ref.enhanceTextSelection;
Kode lerroa: 
Kode lerroa:     this._textContent = textContent;
Kode lerroa:     this._textContentStream = textContentStream;
Kode lerroa:     this._container = container;
Kode lerroa:     this._viewport = viewport;
Kode lerroa:     this._textDivs = textDivs || [];
Kode lerroa:     this._textContentItemsStr = textContentItemsStr || [];
Kode lerroa:     this._enhanceTextSelection = !!enhanceTextSelection;
Kode lerroa:     this._reader = null;
Kode lerroa:     this._layoutTextLastFontSize = null;
Kode lerroa:     this._layoutTextLastFontFamily = null;
Kode lerroa:     this._layoutTextCtx = null;
Kode lerroa:     this._textDivProperties = new WeakMap();
Kode lerroa:     this._renderingDone = false;
Kode lerroa:     this._canceled = false;
Kode lerroa:     this._capability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._renderTimer = null;
Kode lerroa:     this._bounds = [];
Kode lerroa:   }
Kode lerroa:   TextLayerRenderTask.prototype = {
Kode lerroa:     get promise() {
Kode lerroa:       return this._capability.promise;
Kode lerroa:     },
Kode lerroa:     cancel: function TextLayer_cancel() {
Kode lerroa:       if (this._reader) {
Kode lerroa:         this._reader.cancel(new _util.AbortException('text layer task cancelled'));
Kode lerroa:         this._reader = null;
Kode lerroa:       }
Kode lerroa:       this._canceled = true;
Kode lerroa:       if (this._renderTimer !== null) {
Kode lerroa:         clearTimeout(this._renderTimer);
Kode lerroa:         this._renderTimer = null;
Kode lerroa:       }
Kode lerroa:       this._capability.reject('canceled');
Kode lerroa:     },
Kode lerroa:     _processItems: function _processItems(items, styleCache) {
Kode lerroa:       for (var i = 0, len = items.length; i < len; i++) {
Kode lerroa:         this._textContentItemsStr.push(items[i].str);
Kode lerroa:         appendText(this, items[i], styleCache);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     _layoutText: function _layoutText(textDiv) {
Kode lerroa:       var textLayerFrag = this._container;
Kode lerroa:       var textDivProperties = this._textDivProperties.get(textDiv);
Kode lerroa:       if (textDivProperties.isWhitespace) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var fontSize = textDiv.style.fontSize;
Kode lerroa:       var fontFamily = textDiv.style.fontFamily;
Kode lerroa:       if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
Kode lerroa:         this._layoutTextCtx.font = fontSize + ' ' + fontFamily;
Kode lerroa:         this._lastFontSize = fontSize;
Kode lerroa:         this._lastFontFamily = fontFamily;
Kode lerroa:       }
Kode lerroa:       var width = this._layoutTextCtx.measureText(textDiv.textContent).width;
Kode lerroa:       var transform = '';
Kode lerroa:       if (textDivProperties.canvasWidth !== 0 && width > 0) {
Kode lerroa:         textDivProperties.scale = textDivProperties.canvasWidth / width;
Kode lerroa:         transform = 'scaleX(' + textDivProperties.scale + ')';
Kode lerroa:       }
Kode lerroa:       if (textDivProperties.angle !== 0) {
Kode lerroa:         transform = 'rotate(' + textDivProperties.angle + 'deg) ' + transform;
Kode lerroa:       }
Kode lerroa:       if (transform !== '') {
Kode lerroa:         textDivProperties.originalTransform = transform;
Kode lerroa:         _dom_utils.CustomStyle.setProp('transform', textDiv, transform);
Kode lerroa:       }
Kode lerroa:       this._textDivProperties.set(textDiv, textDivProperties);
Kode lerroa:       textLayerFrag.appendChild(textDiv);
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     _render: function TextLayer_render(timeout) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var capability = (0, _util.createPromiseCapability)();
Kode lerroa:       var styleCache = Object.create(null);
Kode lerroa:       var canvas = document.createElement('canvas');
Kode lerroa:       canvas.mozOpaque = true;
Kode lerroa:       this._layoutTextCtx = canvas.getContext('2d', { alpha: false });
Kode lerroa:       if (this._textContent) {
Kode lerroa:         var textItems = this._textContent.items;
Kode lerroa:         var textStyles = this._textContent.styles;
Kode lerroa:         this._processItems(textItems, textStyles);
Kode lerroa:         capability.resolve();
Kode lerroa:       } else if (this._textContentStream) {
Kode lerroa:         var pump = function pump() {
Kode lerroa:           _this._reader.read().then(function (_ref2) {
Kode lerroa:             var value = _ref2.value,
Kode lerroa:                 done = _ref2.done;
Kode lerroa: 
Kode lerroa:             if (done) {
Kode lerroa:               capability.resolve();
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             _util.Util.extendObj(styleCache, value.styles);
Kode lerroa:             _this._processItems(value.items, styleCache);
Kode lerroa:             pump();
Kode lerroa:           }, capability.reject);
Kode lerroa:         };
Kode lerroa:         this._reader = this._textContentStream.getReader();
Kode lerroa:         pump();
Kode lerroa:       } else {
Kode lerroa:         throw new Error('Neither "textContent" nor "textContentStream"' + ' parameters specified.');
Kode lerroa:       }
Kode lerroa:       capability.promise.then(function () {
Kode lerroa:         styleCache = null;
Kode lerroa:         if (!timeout) {
Kode lerroa:           render(_this);
Kode lerroa:         } else {
Kode lerroa:           _this._renderTimer = setTimeout(function () {
Kode lerroa:             render(_this);
Kode lerroa:             _this._renderTimer = null;
Kode lerroa:           }, timeout);
Kode lerroa:         }
Kode lerroa:       }, this._capability.reject);
Kode lerroa:     },
Kode lerroa:     expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
Kode lerroa:       if (!this._enhanceTextSelection || !this._renderingDone) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._bounds !== null) {
Kode lerroa:         expand(this);
Kode lerroa:         this._bounds = null;
Kode lerroa:       }
Kode lerroa:       for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
Kode lerroa:         var div = this._textDivs[i];
Kode lerroa:         var divProperties = this._textDivProperties.get(div);
Kode lerroa:         if (divProperties.isWhitespace) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (expandDivs) {
Kode lerroa:           var transform = '',
Kode lerroa:               padding = '';
Kode lerroa:           if (divProperties.scale !== 1) {
Kode lerroa:             transform = 'scaleX(' + divProperties.scale + ')';
Kode lerroa:           }
Kode lerroa:           if (divProperties.angle !== 0) {
Kode lerroa:             transform = 'rotate(' + divProperties.angle + 'deg) ' + transform;
Kode lerroa:           }
Kode lerroa:           if (divProperties.paddingLeft !== 0) {
Kode lerroa:             padding += ' padding-left: ' + divProperties.paddingLeft / divProperties.scale + 'px;';
Kode lerroa:             transform += ' translateX(' + -divProperties.paddingLeft / divProperties.scale + 'px)';
Kode lerroa:           }
Kode lerroa:           if (divProperties.paddingTop !== 0) {
Kode lerroa:             padding += ' padding-top: ' + divProperties.paddingTop + 'px;';
Kode lerroa:             transform += ' translateY(' + -divProperties.paddingTop + 'px)';
Kode lerroa:           }
Kode lerroa:           if (divProperties.paddingRight !== 0) {
Kode lerroa:             padding += ' padding-right: ' + divProperties.paddingRight / divProperties.scale + 'px;';
Kode lerroa:           }
Kode lerroa:           if (divProperties.paddingBottom !== 0) {
Kode lerroa:             padding += ' padding-bottom: ' + divProperties.paddingBottom + 'px;';
Kode lerroa:           }
Kode lerroa:           if (padding !== '') {
Kode lerroa:             div.setAttribute('style', divProperties.style + padding);
Kode lerroa:           }
Kode lerroa:           if (transform !== '') {
Kode lerroa:             _dom_utils.CustomStyle.setProp('transform', div, transform);
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           div.style.padding = 0;
Kode lerroa:           _dom_utils.CustomStyle.setProp('transform', div, divProperties.originalTransform || '');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   function renderTextLayer(renderParameters) {
Kode lerroa:     var task = new TextLayerRenderTask({
Kode lerroa:       textContent: renderParameters.textContent,
Kode lerroa:       textContentStream: renderParameters.textContentStream,
Kode lerroa:       container: renderParameters.container,
Kode lerroa:       viewport: renderParameters.viewport,
Kode lerroa:       textDivs: renderParameters.textDivs,
Kode lerroa:       textContentItemsStr: renderParameters.textContentItemsStr,
Kode lerroa:       enhanceTextSelection: renderParameters.enhanceTextSelection
Kode lerroa:     });
Kode lerroa:     task._render(renderParameters.timeout);
Kode lerroa:     return task;
Kode lerroa:   }
Kode lerroa:   return renderTextLayer;
Kode lerroa: }();
Kode lerroa: exports.renderTextLayer = renderTextLayer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 74 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.SVGGraphics = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _dom_utils = __w_pdfjs_require__(15);
Kode lerroa: 
Kode lerroa: var SVGGraphics = function SVGGraphics() {
Kode lerroa:   throw new Error('Not implemented: SVGGraphics');
Kode lerroa: };
Kode lerroa: {
Kode lerroa:   var SVG_DEFAULTS = {
Kode lerroa:     fontStyle: 'normal',
Kode lerroa:     fontWeight: 'normal',
Kode lerroa:     fillColor: '#000000'
Kode lerroa:   };
Kode lerroa:   var convertImgDataToPng = function convertImgDataToPngClosure() {
Kode lerroa:     var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
Kode lerroa:     var CHUNK_WRAPPER_SIZE = 12;
Kode lerroa:     var crcTable = new Int32Array(256);
Kode lerroa:     for (var i = 0; i < 256; i++) {
Kode lerroa:       var c = i;
Kode lerroa:       for (var h = 0; h < 8; h++) {
Kode lerroa:         if (c & 1) {
Kode lerroa:           c = 0xedB88320 ^ c >> 1 & 0x7fffffff;
Kode lerroa:         } else {
Kode lerroa:           c = c >> 1 & 0x7fffffff;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       crcTable[i] = c;
Kode lerroa:     }
Kode lerroa:     function crc32(data, start, end) {
Kode lerroa:       var crc = -1;
Kode lerroa:       for (var i = start; i < end; i++) {
Kode lerroa:         var a = (crc ^ data[i]) & 0xff;
Kode lerroa:         var b = crcTable[a];
Kode lerroa:         crc = crc >>> 8 ^ b;
Kode lerroa:       }
Kode lerroa:       return crc ^ -1;
Kode lerroa:     }
Kode lerroa:     function writePngChunk(type, body, data, offset) {
Kode lerroa:       var p = offset;
Kode lerroa:       var len = body.length;
Kode lerroa:       data[p] = len >> 24 & 0xff;
Kode lerroa:       data[p + 1] = len >> 16 & 0xff;
Kode lerroa:       data[p + 2] = len >> 8 & 0xff;
Kode lerroa:       data[p + 3] = len & 0xff;
Kode lerroa:       p += 4;
Kode lerroa:       data[p] = type.charCodeAt(0) & 0xff;
Kode lerroa:       data[p + 1] = type.charCodeAt(1) & 0xff;
Kode lerroa:       data[p + 2] = type.charCodeAt(2) & 0xff;
Kode lerroa:       data[p + 3] = type.charCodeAt(3) & 0xff;
Kode lerroa:       p += 4;
Kode lerroa:       data.set(body, p);
Kode lerroa:       p += body.length;
Kode lerroa:       var crc = crc32(data, offset + 4, p);
Kode lerroa:       data[p] = crc >> 24 & 0xff;
Kode lerroa:       data[p + 1] = crc >> 16 & 0xff;
Kode lerroa:       data[p + 2] = crc >> 8 & 0xff;
Kode lerroa:       data[p + 3] = crc & 0xff;
Kode lerroa:     }
Kode lerroa:     function adler32(data, start, end) {
Kode lerroa:       var a = 1;
Kode lerroa:       var b = 0;
Kode lerroa:       for (var i = start; i < end; ++i) {
Kode lerroa:         a = (a + (data[i] & 0xff)) % 65521;
Kode lerroa:         b = (b + a) % 65521;
Kode lerroa:       }
Kode lerroa:       return b << 16 | a;
Kode lerroa:     }
Kode lerroa:     function deflateSync(literals) {
Kode lerroa:       if (!(0, _util.isNodeJS)()) {
Kode lerroa:         return deflateSyncUncompressed(literals);
Kode lerroa:       }
Kode lerroa:       try {
Kode lerroa:         var input;
Kode lerroa:         if (parseInt(process.versions.node) >= 8) {
Kode lerroa:           input = literals;
Kode lerroa:         } else {
Kode lerroa:           input = new Buffer(literals);
Kode lerroa:         }
Kode lerroa:         var output = require('zlib').deflateSync(input, { level: 9 });
Kode lerroa:         return output instanceof Uint8Array ? output : new Uint8Array(output);
Kode lerroa:       } catch (e) {
Kode lerroa:         (0, _util.warn)('Not compressing PNG because zlib.deflateSync is unavailable: ' + e);
Kode lerroa:       }
Kode lerroa:       return deflateSyncUncompressed(literals);
Kode lerroa:     }
Kode lerroa:     function deflateSyncUncompressed(literals) {
Kode lerroa:       var len = literals.length;
Kode lerroa:       var maxBlockLength = 0xFFFF;
Kode lerroa:       var deflateBlocks = Math.ceil(len / maxBlockLength);
Kode lerroa:       var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
Kode lerroa:       var pi = 0;
Kode lerroa:       idat[pi++] = 0x78;
Kode lerroa:       idat[pi++] = 0x9c;
Kode lerroa:       var pos = 0;
Kode lerroa:       while (len > maxBlockLength) {
Kode lerroa:         idat[pi++] = 0x00;
Kode lerroa:         idat[pi++] = 0xff;
Kode lerroa:         idat[pi++] = 0xff;
Kode lerroa:         idat[pi++] = 0x00;
Kode lerroa:         idat[pi++] = 0x00;
Kode lerroa:         idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
Kode lerroa:         pi += maxBlockLength;
Kode lerroa:         pos += maxBlockLength;
Kode lerroa:         len -= maxBlockLength;
Kode lerroa:       }
Kode lerroa:       idat[pi++] = 0x01;
Kode lerroa:       idat[pi++] = len & 0xff;
Kode lerroa:       idat[pi++] = len >> 8 & 0xff;
Kode lerroa:       idat[pi++] = ~len & 0xffff & 0xff;
Kode lerroa:       idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
Kode lerroa:       idat.set(literals.subarray(pos), pi);
Kode lerroa:       pi += literals.length - pos;
Kode lerroa:       var adler = adler32(literals, 0, literals.length);
Kode lerroa:       idat[pi++] = adler >> 24 & 0xff;
Kode lerroa:       idat[pi++] = adler >> 16 & 0xff;
Kode lerroa:       idat[pi++] = adler >> 8 & 0xff;
Kode lerroa:       idat[pi++] = adler & 0xff;
Kode lerroa:       return idat;
Kode lerroa:     }
Kode lerroa:     function encode(imgData, kind, forceDataSchema) {
Kode lerroa:       var width = imgData.width;
Kode lerroa:       var height = imgData.height;
Kode lerroa:       var bitDepth, colorType, lineSize;
Kode lerroa:       var bytes = imgData.data;
Kode lerroa:       switch (kind) {
Kode lerroa:         case _util.ImageKind.GRAYSCALE_1BPP:
Kode lerroa:           colorType = 0;
Kode lerroa:           bitDepth = 1;
Kode lerroa:           lineSize = width + 7 >> 3;
Kode lerroa:           break;
Kode lerroa:         case _util.ImageKind.RGB_24BPP:
Kode lerroa:           colorType = 2;
Kode lerroa:           bitDepth = 8;
Kode lerroa:           lineSize = width * 3;
Kode lerroa:           break;
Kode lerroa:         case _util.ImageKind.RGBA_32BPP:
Kode lerroa:           colorType = 6;
Kode lerroa:           bitDepth = 8;
Kode lerroa:           lineSize = width * 4;
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           throw new Error('invalid format');
Kode lerroa:       }
Kode lerroa:       var literals = new Uint8Array((1 + lineSize) * height);
Kode lerroa:       var offsetLiterals = 0,
Kode lerroa:           offsetBytes = 0;
Kode lerroa:       var y, i;
Kode lerroa:       for (y = 0; y < height; ++y) {
Kode lerroa:         literals[offsetLiterals++] = 0;
Kode lerroa:         literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
Kode lerroa:         offsetBytes += lineSize;
Kode lerroa:         offsetLiterals += lineSize;
Kode lerroa:       }
Kode lerroa:       if (kind === _util.ImageKind.GRAYSCALE_1BPP) {
Kode lerroa:         offsetLiterals = 0;
Kode lerroa:         for (y = 0; y < height; y++) {
Kode lerroa:           offsetLiterals++;
Kode lerroa:           for (i = 0; i < lineSize; i++) {
Kode lerroa:             literals[offsetLiterals++] ^= 0xFF;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
Kode lerroa:       var idat = deflateSync(literals);
Kode lerroa:       var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
Kode lerroa:       var data = new Uint8Array(pngLength);
Kode lerroa:       var offset = 0;
Kode lerroa:       data.set(PNG_HEADER, offset);
Kode lerroa:       offset += PNG_HEADER.length;
Kode lerroa:       writePngChunk('IHDR', ihdr, data, offset);
Kode lerroa:       offset += CHUNK_WRAPPER_SIZE + ihdr.length;
Kode lerroa:       writePngChunk('IDATA', idat, data, offset);
Kode lerroa:       offset += CHUNK_WRAPPER_SIZE + idat.length;
Kode lerroa:       writePngChunk('IEND', new Uint8Array(0), data, offset);
Kode lerroa:       return (0, _util.createObjectURL)(data, 'image/png', forceDataSchema);
Kode lerroa:     }
Kode lerroa:     return function convertImgDataToPng(imgData, forceDataSchema) {
Kode lerroa:       var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
Kode lerroa:       return encode(imgData, kind, forceDataSchema);
Kode lerroa:     };
Kode lerroa:   }();
Kode lerroa:   var SVGExtraState = function SVGExtraStateClosure() {
Kode lerroa:     function SVGExtraState() {
Kode lerroa:       this.fontSizeScale = 1;
Kode lerroa:       this.fontWeight = SVG_DEFAULTS.fontWeight;
Kode lerroa:       this.fontSize = 0;
Kode lerroa:       this.textMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:       this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
Kode lerroa:       this.leading = 0;
Kode lerroa:       this.x = 0;
Kode lerroa:       this.y = 0;
Kode lerroa:       this.lineX = 0;
Kode lerroa:       this.lineY = 0;
Kode lerroa:       this.charSpacing = 0;
Kode lerroa:       this.wordSpacing = 0;
Kode lerroa:       this.textHScale = 1;
Kode lerroa:       this.textRise = 0;
Kode lerroa:       this.fillColor = SVG_DEFAULTS.fillColor;
Kode lerroa:       this.strokeColor = '#000000';
Kode lerroa:       this.fillAlpha = 1;
Kode lerroa:       this.strokeAlpha = 1;
Kode lerroa:       this.lineWidth = 1;
Kode lerroa:       this.lineJoin = '';
Kode lerroa:       this.lineCap = '';
Kode lerroa:       this.miterLimit = 0;
Kode lerroa:       this.dashArray = [];
Kode lerroa:       this.dashPhase = 0;
Kode lerroa:       this.dependencies = [];
Kode lerroa:       this.activeClipUrl = null;
Kode lerroa:       this.clipGroup = null;
Kode lerroa:       this.maskId = '';
Kode lerroa:     }
Kode lerroa:     SVGExtraState.prototype = {
Kode lerroa:       clone: function SVGExtraState_clone() {
Kode lerroa:         return Object.create(this);
Kode lerroa:       },
Kode lerroa:       setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {
Kode lerroa:         this.x = x;
Kode lerroa:         this.y = y;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return SVGExtraState;
Kode lerroa:   }();
Kode lerroa:   exports.SVGGraphics = SVGGraphics = function SVGGraphicsClosure() {
Kode lerroa:     function opListToTree(opList) {
Kode lerroa:       var opTree = [];
Kode lerroa:       var tmp = [];
Kode lerroa:       var opListLen = opList.length;
Kode lerroa:       for (var x = 0; x < opListLen; x++) {
Kode lerroa:         if (opList[x].fn === 'save') {
Kode lerroa:           opTree.push({
Kode lerroa:             'fnId': 92,
Kode lerroa:             'fn': 'group',
Kode lerroa:             'items': []
Kode lerroa:           });
Kode lerroa:           tmp.push(opTree);
Kode lerroa:           opTree = opTree[opTree.length - 1].items;
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (opList[x].fn === 'restore') {
Kode lerroa:           opTree = tmp.pop();
Kode lerroa:         } else {
Kode lerroa:           opTree.push(opList[x]);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return opTree;
Kode lerroa:     }
Kode lerroa:     function pf(value) {
Kode lerroa:       if (Number.isInteger(value)) {
Kode lerroa:         return value.toString();
Kode lerroa:       }
Kode lerroa:       var s = value.toFixed(10);
Kode lerroa:       var i = s.length - 1;
Kode lerroa:       if (s[i] !== '0') {
Kode lerroa:         return s;
Kode lerroa:       }
Kode lerroa:       do {
Kode lerroa:         i--;
Kode lerroa:       } while (s[i] === '0');
Kode lerroa:       return s.substr(0, s[i] === '.' ? i : i + 1);
Kode lerroa:     }
Kode lerroa:     function pm(m) {
Kode lerroa:       if (m[4] === 0 && m[5] === 0) {
Kode lerroa:         if (m[1] === 0 && m[2] === 0) {
Kode lerroa:           if (m[0] === 1 && m[3] === 1) {
Kode lerroa:             return '';
Kode lerroa:           }
Kode lerroa:           return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';
Kode lerroa:         }
Kode lerroa:         if (m[0] === m[3] && m[1] === -m[2]) {
Kode lerroa:           var a = Math.acos(m[0]) * 180 / Math.PI;
Kode lerroa:           return 'rotate(' + pf(a) + ')';
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
Kode lerroa:           return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' + pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';
Kode lerroa:     }
Kode lerroa:     function SVGGraphics(commonObjs, objs, forceDataSchema) {
Kode lerroa:       this.svgFactory = new _dom_utils.DOMSVGFactory();
Kode lerroa:       this.current = new SVGExtraState();
Kode lerroa:       this.transformMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:       this.transformStack = [];
Kode lerroa:       this.extraStack = [];
Kode lerroa:       this.commonObjs = commonObjs;
Kode lerroa:       this.objs = objs;
Kode lerroa:       this.pendingClip = null;
Kode lerroa:       this.pendingEOFill = false;
Kode lerroa:       this.embedFonts = false;
Kode lerroa:       this.embeddedFonts = Object.create(null);
Kode lerroa:       this.cssStyle = null;
Kode lerroa:       this.forceDataSchema = !!forceDataSchema;
Kode lerroa:     }
Kode lerroa:     var XML_NS = 'http://www.w3.org/XML/1998/namespace';
Kode lerroa:     var XLINK_NS = 'http://www.w3.org/1999/xlink';
Kode lerroa:     var LINE_CAP_STYLES = ['butt', 'round', 'square'];
Kode lerroa:     var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
Kode lerroa:     var clipCount = 0;
Kode lerroa:     var maskCount = 0;
Kode lerroa:     SVGGraphics.prototype = {
Kode lerroa:       save: function SVGGraphics_save() {
Kode lerroa:         this.transformStack.push(this.transformMatrix);
Kode lerroa:         var old = this.current;
Kode lerroa:         this.extraStack.push(old);
Kode lerroa:         this.current = old.clone();
Kode lerroa:       },
Kode lerroa:       restore: function SVGGraphics_restore() {
Kode lerroa:         this.transformMatrix = this.transformStack.pop();
Kode lerroa:         this.current = this.extraStack.pop();
Kode lerroa:         this.pendingClip = null;
Kode lerroa:         this.tgrp = null;
Kode lerroa:       },
Kode lerroa:       group: function SVGGraphics_group(items) {
Kode lerroa:         this.save();
Kode lerroa:         this.executeOpTree(items);
Kode lerroa:         this.restore();
Kode lerroa:       },
Kode lerroa:       loadDependencies: function SVGGraphics_loadDependencies(operatorList) {
Kode lerroa:         var _this = this;
Kode lerroa: 
Kode lerroa:         var fnArray = operatorList.fnArray;
Kode lerroa:         var fnArrayLen = fnArray.length;
Kode lerroa:         var argsArray = operatorList.argsArray;
Kode lerroa:         for (var i = 0; i < fnArrayLen; i++) {
Kode lerroa:           if (_util.OPS.dependency === fnArray[i]) {
Kode lerroa:             var deps = argsArray[i];
Kode lerroa:             for (var n = 0, nn = deps.length; n < nn; n++) {
Kode lerroa:               var obj = deps[n];
Kode lerroa:               var common = obj.substring(0, 2) === 'g_';
Kode lerroa:               var promise;
Kode lerroa:               if (common) {
Kode lerroa:                 promise = new Promise(function (resolve) {
Kode lerroa:                   _this.commonObjs.get(obj, resolve);
Kode lerroa:                 });
Kode lerroa:               } else {
Kode lerroa:                 promise = new Promise(function (resolve) {
Kode lerroa:                   _this.objs.get(obj, resolve);
Kode lerroa:                 });
Kode lerroa:               }
Kode lerroa:               this.current.dependencies.push(promise);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return Promise.all(this.current.dependencies);
Kode lerroa:       },
Kode lerroa:       transform: function SVGGraphics_transform(a, b, c, d, e, f) {
Kode lerroa:         var transformMatrix = [a, b, c, d, e, f];
Kode lerroa:         this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
Kode lerroa:         this.tgrp = null;
Kode lerroa:       },
Kode lerroa:       getSVG: function SVGGraphics_getSVG(operatorList, viewport) {
Kode lerroa:         var _this2 = this;
Kode lerroa: 
Kode lerroa:         this.viewport = viewport;
Kode lerroa:         var svgElement = this._initialize(viewport);
Kode lerroa:         return this.loadDependencies(operatorList).then(function () {
Kode lerroa:           _this2.transformMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:           var opTree = _this2.convertOpList(operatorList);
Kode lerroa:           _this2.executeOpTree(opTree);
Kode lerroa:           return svgElement;
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa:       convertOpList: function SVGGraphics_convertOpList(operatorList) {
Kode lerroa:         var argsArray = operatorList.argsArray;
Kode lerroa:         var fnArray = operatorList.fnArray;
Kode lerroa:         var fnArrayLen = fnArray.length;
Kode lerroa:         var REVOPS = [];
Kode lerroa:         var opList = [];
Kode lerroa:         for (var op in _util.OPS) {
Kode lerroa:           REVOPS[_util.OPS[op]] = op;
Kode lerroa:         }
Kode lerroa:         for (var x = 0; x < fnArrayLen; x++) {
Kode lerroa:           var fnId = fnArray[x];
Kode lerroa:           opList.push({
Kode lerroa:             'fnId': fnId,
Kode lerroa:             'fn': REVOPS[fnId],
Kode lerroa:             'args': argsArray[x]
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         return opListToTree(opList);
Kode lerroa:       },
Kode lerroa:       executeOpTree: function SVGGraphics_executeOpTree(opTree) {
Kode lerroa:         var opTreeLen = opTree.length;
Kode lerroa:         for (var x = 0; x < opTreeLen; x++) {
Kode lerroa:           var fn = opTree[x].fn;
Kode lerroa:           var fnId = opTree[x].fnId;
Kode lerroa:           var args = opTree[x].args;
Kode lerroa:           switch (fnId | 0) {
Kode lerroa:             case _util.OPS.beginText:
Kode lerroa:               this.beginText();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLeading:
Kode lerroa:               this.setLeading(args);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLeadingMoveText:
Kode lerroa:               this.setLeadingMoveText(args[0], args[1]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFont:
Kode lerroa:               this.setFont(args);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.showText:
Kode lerroa:               this.showText(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.showSpacedText:
Kode lerroa:               this.showText(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.endText:
Kode lerroa:               this.endText();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.moveText:
Kode lerroa:               this.moveText(args[0], args[1]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setCharSpacing:
Kode lerroa:               this.setCharSpacing(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setWordSpacing:
Kode lerroa:               this.setWordSpacing(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setHScale:
Kode lerroa:               this.setHScale(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setTextMatrix:
Kode lerroa:               this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setTextRise:
Kode lerroa:               this.setTextRise(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLineWidth:
Kode lerroa:               this.setLineWidth(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLineJoin:
Kode lerroa:               this.setLineJoin(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLineCap:
Kode lerroa:               this.setLineCap(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setMiterLimit:
Kode lerroa:               this.setMiterLimit(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFillRGBColor:
Kode lerroa:               this.setFillRGBColor(args[0], args[1], args[2]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setStrokeRGBColor:
Kode lerroa:               this.setStrokeRGBColor(args[0], args[1], args[2]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setDash:
Kode lerroa:               this.setDash(args[0], args[1]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setGState:
Kode lerroa:               this.setGState(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.fill:
Kode lerroa:               this.fill();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.eoFill:
Kode lerroa:               this.eoFill();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.stroke:
Kode lerroa:               this.stroke();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.fillStroke:
Kode lerroa:               this.fillStroke();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.eoFillStroke:
Kode lerroa:               this.eoFillStroke();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.clip:
Kode lerroa:               this.clip('nonzero');
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.eoClip:
Kode lerroa:               this.clip('evenodd');
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintSolidColorImageMask:
Kode lerroa:               this.paintSolidColorImageMask();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintJpegXObject:
Kode lerroa:               this.paintJpegXObject(args[0], args[1], args[2]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintImageXObject:
Kode lerroa:               this.paintImageXObject(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintInlineImageXObject:
Kode lerroa:               this.paintInlineImageXObject(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintImageMaskXObject:
Kode lerroa:               this.paintImageMaskXObject(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintFormXObjectBegin:
Kode lerroa:               this.paintFormXObjectBegin(args[0], args[1]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintFormXObjectEnd:
Kode lerroa:               this.paintFormXObjectEnd();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.closePath:
Kode lerroa:               this.closePath();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.closeStroke:
Kode lerroa:               this.closeStroke();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.closeFillStroke:
Kode lerroa:               this.closeFillStroke();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.nextLine:
Kode lerroa:               this.nextLine();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.transform:
Kode lerroa:               this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.constructPath:
Kode lerroa:               this.constructPath(args[0], args[1]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.endPath:
Kode lerroa:               this.endPath();
Kode lerroa:               break;
Kode lerroa:             case 92:
Kode lerroa:               this.group(opTree[x].items);
Kode lerroa:               break;
Kode lerroa:             default:
Kode lerroa:               (0, _util.warn)('Unimplemented operator ' + fn);
Kode lerroa:               break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {
Kode lerroa:         this.current.wordSpacing = wordSpacing;
Kode lerroa:       },
Kode lerroa:       setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {
Kode lerroa:         this.current.charSpacing = charSpacing;
Kode lerroa:       },
Kode lerroa:       nextLine: function SVGGraphics_nextLine() {
Kode lerroa:         this.moveText(0, this.current.leading);
Kode lerroa:       },
Kode lerroa:       setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {
Kode lerroa:         var current = this.current;
Kode lerroa:         this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];
Kode lerroa:         this.current.x = this.current.lineX = 0;
Kode lerroa:         this.current.y = this.current.lineY = 0;
Kode lerroa:         current.xcoords = [];
Kode lerroa:         current.tspan = this.svgFactory.createElement('svg:tspan');
Kode lerroa:         current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
Kode lerroa:         current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
Kode lerroa:         current.tspan.setAttributeNS(null, 'y', pf(-current.y));
Kode lerroa:         current.txtElement = this.svgFactory.createElement('svg:text');
Kode lerroa:         current.txtElement.appendChild(current.tspan);
Kode lerroa:       },
Kode lerroa:       beginText: function SVGGraphics_beginText() {
Kode lerroa:         this.current.x = this.current.lineX = 0;
Kode lerroa:         this.current.y = this.current.lineY = 0;
Kode lerroa:         this.current.textMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:         this.current.lineMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:         this.current.tspan = this.svgFactory.createElement('svg:tspan');
Kode lerroa:         this.current.txtElement = this.svgFactory.createElement('svg:text');
Kode lerroa:         this.current.txtgrp = this.svgFactory.createElement('svg:g');
Kode lerroa:         this.current.xcoords = [];
Kode lerroa:       },
Kode lerroa:       moveText: function SVGGraphics_moveText(x, y) {
Kode lerroa:         var current = this.current;
Kode lerroa:         this.current.x = this.current.lineX += x;
Kode lerroa:         this.current.y = this.current.lineY += y;
Kode lerroa:         current.xcoords = [];
Kode lerroa:         current.tspan = this.svgFactory.createElement('svg:tspan');
Kode lerroa:         current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
Kode lerroa:         current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
Kode lerroa:         current.tspan.setAttributeNS(null, 'y', pf(-current.y));
Kode lerroa:       },
Kode lerroa:       showText: function SVGGraphics_showText(glyphs) {
Kode lerroa:         var current = this.current;
Kode lerroa:         var font = current.font;
Kode lerroa:         var fontSize = current.fontSize;
Kode lerroa:         if (fontSize === 0) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var charSpacing = current.charSpacing;
Kode lerroa:         var wordSpacing = current.wordSpacing;
Kode lerroa:         var fontDirection = current.fontDirection;
Kode lerroa:         var textHScale = current.textHScale * fontDirection;
Kode lerroa:         var glyphsLength = glyphs.length;
Kode lerroa:         var vertical = font.vertical;
Kode lerroa:         var widthAdvanceScale = fontSize * current.fontMatrix[0];
Kode lerroa:         var x = 0,
Kode lerroa:             i;
Kode lerroa:         for (i = 0; i < glyphsLength; ++i) {
Kode lerroa:           var glyph = glyphs[i];
Kode lerroa:           if (glyph === null) {
Kode lerroa:             x += fontDirection * wordSpacing;
Kode lerroa:             continue;
Kode lerroa:           } else if ((0, _util.isNum)(glyph)) {
Kode lerroa:             x += -glyph * fontSize * 0.001;
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           var width = glyph.width;
Kode lerroa:           var character = glyph.fontChar;
Kode lerroa:           var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
Kode lerroa:           var charWidth = width * widthAdvanceScale + spacing * fontDirection;
Kode lerroa:           if (!glyph.isInFont && !font.missingFile) {
Kode lerroa:             x += charWidth;
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           current.xcoords.push(current.x + x * textHScale);
Kode lerroa:           current.tspan.textContent += character;
Kode lerroa:           x += charWidth;
Kode lerroa:         }
Kode lerroa:         if (vertical) {
Kode lerroa:           current.y -= x * textHScale;
Kode lerroa:         } else {
Kode lerroa:           current.x += x * textHScale;
Kode lerroa:         }
Kode lerroa:         current.tspan.setAttributeNS(null, 'x', current.xcoords.map(pf).join(' '));
Kode lerroa:         current.tspan.setAttributeNS(null, 'y', pf(-current.y));
Kode lerroa:         current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
Kode lerroa:         current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
Kode lerroa:         if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
Kode lerroa:           current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);
Kode lerroa:         }
Kode lerroa:         if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
Kode lerroa:           current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);
Kode lerroa:         }
Kode lerroa:         if (current.fillColor !== SVG_DEFAULTS.fillColor) {
Kode lerroa:           current.tspan.setAttributeNS(null, 'fill', current.fillColor);
Kode lerroa:         }
Kode lerroa:         var textMatrix = current.textMatrix;
Kode lerroa:         if (current.textRise !== 0) {
Kode lerroa:           textMatrix = textMatrix.slice();
Kode lerroa:           textMatrix[5] += current.textRise;
Kode lerroa:         }
Kode lerroa:         current.txtElement.setAttributeNS(null, 'transform', pm(textMatrix) + ' scale(1, -1)');
Kode lerroa:         current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');
Kode lerroa:         current.txtElement.appendChild(current.tspan);
Kode lerroa:         current.txtgrp.appendChild(current.txtElement);
Kode lerroa:         this._ensureTransformGroup().appendChild(current.txtElement);
Kode lerroa:       },
Kode lerroa:       setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {
Kode lerroa:         this.setLeading(-y);
Kode lerroa:         this.moveText(x, y);
Kode lerroa:       },
Kode lerroa:       addFontStyle: function SVGGraphics_addFontStyle(fontObj) {
Kode lerroa:         if (!this.cssStyle) {
Kode lerroa:           this.cssStyle = this.svgFactory.createElement('svg:style');
Kode lerroa:           this.cssStyle.setAttributeNS(null, 'type', 'text/css');
Kode lerroa:           this.defs.appendChild(this.cssStyle);
Kode lerroa:         }
Kode lerroa:         var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
Kode lerroa:         this.cssStyle.textContent += '@font-face { font-family: "' + fontObj.loadedName + '";' + ' src: url(' + url + '); }\n';
Kode lerroa:       },
Kode lerroa:       setFont: function SVGGraphics_setFont(details) {
Kode lerroa:         var current = this.current;
Kode lerroa:         var fontObj = this.commonObjs.get(details[0]);
Kode lerroa:         var size = details[1];
Kode lerroa:         this.current.font = fontObj;
Kode lerroa:         if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
Kode lerroa:           this.addFontStyle(fontObj);
Kode lerroa:           this.embeddedFonts[fontObj.loadedName] = fontObj;
Kode lerroa:         }
Kode lerroa:         current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
Kode lerroa:         var bold = fontObj.black ? fontObj.bold ? 'bolder' : 'bold' : fontObj.bold ? 'bold' : 'normal';
Kode lerroa:         var italic = fontObj.italic ? 'italic' : 'normal';
Kode lerroa:         if (size < 0) {
Kode lerroa:           size = -size;
Kode lerroa:           current.fontDirection = -1;
Kode lerroa:         } else {
Kode lerroa:           current.fontDirection = 1;
Kode lerroa:         }
Kode lerroa:         current.fontSize = size;
Kode lerroa:         current.fontFamily = fontObj.loadedName;
Kode lerroa:         current.fontWeight = bold;
Kode lerroa:         current.fontStyle = italic;
Kode lerroa:         current.tspan = this.svgFactory.createElement('svg:tspan');
Kode lerroa:         current.tspan.setAttributeNS(null, 'y', pf(-current.y));
Kode lerroa:         current.xcoords = [];
Kode lerroa:       },
Kode lerroa:       endText: function SVGGraphics_endText() {},
Kode lerroa:       setLineWidth: function SVGGraphics_setLineWidth(width) {
Kode lerroa:         this.current.lineWidth = width;
Kode lerroa:       },
Kode lerroa:       setLineCap: function SVGGraphics_setLineCap(style) {
Kode lerroa:         this.current.lineCap = LINE_CAP_STYLES[style];
Kode lerroa:       },
Kode lerroa:       setLineJoin: function SVGGraphics_setLineJoin(style) {
Kode lerroa:         this.current.lineJoin = LINE_JOIN_STYLES[style];
Kode lerroa:       },
Kode lerroa:       setMiterLimit: function SVGGraphics_setMiterLimit(limit) {
Kode lerroa:         this.current.miterLimit = limit;
Kode lerroa:       },
Kode lerroa:       setStrokeAlpha: function SVGGraphics_setStrokeAlpha(strokeAlpha) {
Kode lerroa:         this.current.strokeAlpha = strokeAlpha;
Kode lerroa:       },
Kode lerroa:       setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {
Kode lerroa:         var color = _util.Util.makeCssRgb(r, g, b);
Kode lerroa:         this.current.strokeColor = color;
Kode lerroa:       },
Kode lerroa:       setFillAlpha: function SVGGraphics_setFillAlpha(fillAlpha) {
Kode lerroa:         this.current.fillAlpha = fillAlpha;
Kode lerroa:       },
Kode lerroa:       setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {
Kode lerroa:         var color = _util.Util.makeCssRgb(r, g, b);
Kode lerroa:         this.current.fillColor = color;
Kode lerroa:         this.current.tspan = this.svgFactory.createElement('svg:tspan');
Kode lerroa:         this.current.xcoords = [];
Kode lerroa:       },
Kode lerroa:       setDash: function SVGGraphics_setDash(dashArray, dashPhase) {
Kode lerroa:         this.current.dashArray = dashArray;
Kode lerroa:         this.current.dashPhase = dashPhase;
Kode lerroa:       },
Kode lerroa:       constructPath: function SVGGraphics_constructPath(ops, args) {
Kode lerroa:         var current = this.current;
Kode lerroa:         var x = current.x,
Kode lerroa:             y = current.y;
Kode lerroa:         current.path = this.svgFactory.createElement('svg:path');
Kode lerroa:         var d = [];
Kode lerroa:         var opLength = ops.length;
Kode lerroa:         for (var i = 0, j = 0; i < opLength; i++) {
Kode lerroa:           switch (ops[i] | 0) {
Kode lerroa:             case _util.OPS.rectangle:
Kode lerroa:               x = args[j++];
Kode lerroa:               y = args[j++];
Kode lerroa:               var width = args[j++];
Kode lerroa:               var height = args[j++];
Kode lerroa:               var xw = x + width;
Kode lerroa:               var yh = y + height;
Kode lerroa:               d.push('M', pf(x), pf(y), 'L', pf(xw), pf(y), 'L', pf(xw), pf(yh), 'L', pf(x), pf(yh), 'Z');
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.moveTo:
Kode lerroa:               x = args[j++];
Kode lerroa:               y = args[j++];
Kode lerroa:               d.push('M', pf(x), pf(y));
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.lineTo:
Kode lerroa:               x = args[j++];
Kode lerroa:               y = args[j++];
Kode lerroa:               d.push('L', pf(x), pf(y));
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.curveTo:
Kode lerroa:               x = args[j + 4];
Kode lerroa:               y = args[j + 5];
Kode lerroa:               d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
Kode lerroa:               j += 6;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.curveTo2:
Kode lerroa:               x = args[j + 2];
Kode lerroa:               y = args[j + 3];
Kode lerroa:               d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
Kode lerroa:               j += 4;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.curveTo3:
Kode lerroa:               x = args[j + 2];
Kode lerroa:               y = args[j + 3];
Kode lerroa:               d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
Kode lerroa:               j += 4;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.closePath:
Kode lerroa:               d.push('Z');
Kode lerroa:               break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         current.path.setAttributeNS(null, 'd', d.join(' '));
Kode lerroa:         current.path.setAttributeNS(null, 'fill', 'none');
Kode lerroa:         this._ensureTransformGroup().appendChild(current.path);
Kode lerroa:         current.element = current.path;
Kode lerroa:         current.setCurrentPoint(x, y);
Kode lerroa:       },
Kode lerroa:       endPath: function SVGGraphics_endPath() {
Kode lerroa:         if (!this.pendingClip) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var current = this.current;
Kode lerroa:         var clipId = 'clippath' + clipCount;
Kode lerroa:         clipCount++;
Kode lerroa:         var clipPath = this.svgFactory.createElement('svg:clipPath');
Kode lerroa:         clipPath.setAttributeNS(null, 'id', clipId);
Kode lerroa:         clipPath.setAttributeNS(null, 'transform', pm(this.transformMatrix));
Kode lerroa:         var clipElement = current.element.cloneNode();
Kode lerroa:         if (this.pendingClip === 'evenodd') {
Kode lerroa:           clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');
Kode lerroa:         } else {
Kode lerroa:           clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');
Kode lerroa:         }
Kode lerroa:         this.pendingClip = null;
Kode lerroa:         clipPath.appendChild(clipElement);
Kode lerroa:         this.defs.appendChild(clipPath);
Kode lerroa:         if (current.activeClipUrl) {
Kode lerroa:           current.clipGroup = null;
Kode lerroa:           this.extraStack.forEach(function (prev) {
Kode lerroa:             prev.clipGroup = null;
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         current.activeClipUrl = 'url(#' + clipId + ')';
Kode lerroa:         this.tgrp = null;
Kode lerroa:       },
Kode lerroa:       clip: function SVGGraphics_clip(type) {
Kode lerroa:         this.pendingClip = type;
Kode lerroa:       },
Kode lerroa:       closePath: function SVGGraphics_closePath() {
Kode lerroa:         var current = this.current;
Kode lerroa:         var d = current.path.getAttributeNS(null, 'd');
Kode lerroa:         d += 'Z';
Kode lerroa:         current.path.setAttributeNS(null, 'd', d);
Kode lerroa:       },
Kode lerroa:       setLeading: function SVGGraphics_setLeading(leading) {
Kode lerroa:         this.current.leading = -leading;
Kode lerroa:       },
Kode lerroa:       setTextRise: function SVGGraphics_setTextRise(textRise) {
Kode lerroa:         this.current.textRise = textRise;
Kode lerroa:       },
Kode lerroa:       setHScale: function SVGGraphics_setHScale(scale) {
Kode lerroa:         this.current.textHScale = scale / 100;
Kode lerroa:       },
Kode lerroa:       setGState: function SVGGraphics_setGState(states) {
Kode lerroa:         for (var i = 0, ii = states.length; i < ii; i++) {
Kode lerroa:           var state = states[i];
Kode lerroa:           var key = state[0];
Kode lerroa:           var value = state[1];
Kode lerroa:           switch (key) {
Kode lerroa:             case 'LW':
Kode lerroa:               this.setLineWidth(value);
Kode lerroa:               break;
Kode lerroa:             case 'LC':
Kode lerroa:               this.setLineCap(value);
Kode lerroa:               break;
Kode lerroa:             case 'LJ':
Kode lerroa:               this.setLineJoin(value);
Kode lerroa:               break;
Kode lerroa:             case 'ML':
Kode lerroa:               this.setMiterLimit(value);
Kode lerroa:               break;
Kode lerroa:             case 'D':
Kode lerroa:               this.setDash(value[0], value[1]);
Kode lerroa:               break;
Kode lerroa:             case 'Font':
Kode lerroa:               this.setFont(value);
Kode lerroa:               break;
Kode lerroa:             case 'CA':
Kode lerroa:               this.setStrokeAlpha(value);
Kode lerroa:               break;
Kode lerroa:             case 'ca':
Kode lerroa:               this.setFillAlpha(value);
Kode lerroa:               break;
Kode lerroa:             default:
Kode lerroa:               (0, _util.warn)('Unimplemented graphic state ' + key);
Kode lerroa:               break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       fill: function SVGGraphics_fill() {
Kode lerroa:         var current = this.current;
Kode lerroa:         current.element.setAttributeNS(null, 'fill', current.fillColor);
Kode lerroa:         current.element.setAttributeNS(null, 'fill-opacity', current.fillAlpha);
Kode lerroa:       },
Kode lerroa:       stroke: function SVGGraphics_stroke() {
Kode lerroa:         var current = this.current;
Kode lerroa:         current.element.setAttributeNS(null, 'stroke', current.strokeColor);
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-opacity', current.strokeAlpha);
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-miterlimit', pf(current.miterLimit));
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-linecap', current.lineCap);
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-width', pf(current.lineWidth) + 'px');
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-dasharray', current.dashArray.map(pf).join(' '));
Kode lerroa:         current.element.setAttributeNS(null, 'stroke-dashoffset', pf(current.dashPhase) + 'px');
Kode lerroa:         current.element.setAttributeNS(null, 'fill', 'none');
Kode lerroa:       },
Kode lerroa:       eoFill: function SVGGraphics_eoFill() {
Kode lerroa:         this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
Kode lerroa:         this.fill();
Kode lerroa:       },
Kode lerroa:       fillStroke: function SVGGraphics_fillStroke() {
Kode lerroa:         this.stroke();
Kode lerroa:         this.fill();
Kode lerroa:       },
Kode lerroa:       eoFillStroke: function SVGGraphics_eoFillStroke() {
Kode lerroa:         this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
Kode lerroa:         this.fillStroke();
Kode lerroa:       },
Kode lerroa:       closeStroke: function SVGGraphics_closeStroke() {
Kode lerroa:         this.closePath();
Kode lerroa:         this.stroke();
Kode lerroa:       },
Kode lerroa:       closeFillStroke: function SVGGraphics_closeFillStroke() {
Kode lerroa:         this.closePath();
Kode lerroa:         this.fillStroke();
Kode lerroa:       },
Kode lerroa:       paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {
Kode lerroa:         var current = this.current;
Kode lerroa:         var rect = this.svgFactory.createElement('svg:rect');
Kode lerroa:         rect.setAttributeNS(null, 'x', '0');
Kode lerroa:         rect.setAttributeNS(null, 'y', '0');
Kode lerroa:         rect.setAttributeNS(null, 'width', '1px');
Kode lerroa:         rect.setAttributeNS(null, 'height', '1px');
Kode lerroa:         rect.setAttributeNS(null, 'fill', current.fillColor);
Kode lerroa:         this._ensureTransformGroup().appendChild(rect);
Kode lerroa:       },
Kode lerroa:       paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {
Kode lerroa:         var imgObj = this.objs.get(objId);
Kode lerroa:         var imgEl = this.svgFactory.createElement('svg:image');
Kode lerroa:         imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);
Kode lerroa:         imgEl.setAttributeNS(null, 'width', pf(w));
Kode lerroa:         imgEl.setAttributeNS(null, 'height', pf(h));
Kode lerroa:         imgEl.setAttributeNS(null, 'x', '0');
Kode lerroa:         imgEl.setAttributeNS(null, 'y', pf(-h));
Kode lerroa:         imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');
Kode lerroa:         this._ensureTransformGroup().appendChild(imgEl);
Kode lerroa:       },
Kode lerroa:       paintImageXObject: function SVGGraphics_paintImageXObject(objId) {
Kode lerroa:         var imgData = this.objs.get(objId);
Kode lerroa:         if (!imgData) {
Kode lerroa:           (0, _util.warn)('Dependent image isn\'t ready yet');
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this.paintInlineImageXObject(imgData);
Kode lerroa:       },
Kode lerroa:       paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {
Kode lerroa:         var width = imgData.width;
Kode lerroa:         var height = imgData.height;
Kode lerroa:         var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema);
Kode lerroa:         var cliprect = this.svgFactory.createElement('svg:rect');
Kode lerroa:         cliprect.setAttributeNS(null, 'x', '0');
Kode lerroa:         cliprect.setAttributeNS(null, 'y', '0');
Kode lerroa:         cliprect.setAttributeNS(null, 'width', pf(width));
Kode lerroa:         cliprect.setAttributeNS(null, 'height', pf(height));
Kode lerroa:         this.current.element = cliprect;
Kode lerroa:         this.clip('nonzero');
Kode lerroa:         var imgEl = this.svgFactory.createElement('svg:image');
Kode lerroa:         imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);
Kode lerroa:         imgEl.setAttributeNS(null, 'x', '0');
Kode lerroa:         imgEl.setAttributeNS(null, 'y', pf(-height));
Kode lerroa:         imgEl.setAttributeNS(null, 'width', pf(width) + 'px');
Kode lerroa:         imgEl.setAttributeNS(null, 'height', pf(height) + 'px');
Kode lerroa:         imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / width) + ' ' + pf(-1 / height) + ')');
Kode lerroa:         if (mask) {
Kode lerroa:           mask.appendChild(imgEl);
Kode lerroa:         } else {
Kode lerroa:           this._ensureTransformGroup().appendChild(imgEl);
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {
Kode lerroa:         var current = this.current;
Kode lerroa:         var width = imgData.width;
Kode lerroa:         var height = imgData.height;
Kode lerroa:         var fillColor = current.fillColor;
Kode lerroa:         current.maskId = 'mask' + maskCount++;
Kode lerroa:         var mask = this.svgFactory.createElement('svg:mask');
Kode lerroa:         mask.setAttributeNS(null, 'id', current.maskId);
Kode lerroa:         var rect = this.svgFactory.createElement('svg:rect');
Kode lerroa:         rect.setAttributeNS(null, 'x', '0');
Kode lerroa:         rect.setAttributeNS(null, 'y', '0');
Kode lerroa:         rect.setAttributeNS(null, 'width', pf(width));
Kode lerroa:         rect.setAttributeNS(null, 'height', pf(height));
Kode lerroa:         rect.setAttributeNS(null, 'fill', fillColor);
Kode lerroa:         rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId + ')');
Kode lerroa:         this.defs.appendChild(mask);
Kode lerroa:         this._ensureTransformGroup().appendChild(rect);
Kode lerroa:         this.paintInlineImageXObject(imgData, mask);
Kode lerroa:       },
Kode lerroa:       paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {
Kode lerroa:         if (Array.isArray(matrix) && matrix.length === 6) {
Kode lerroa:           this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
Kode lerroa:         }
Kode lerroa:         if (Array.isArray(bbox) && bbox.length === 4) {
Kode lerroa:           var width = bbox[2] - bbox[0];
Kode lerroa:           var height = bbox[3] - bbox[1];
Kode lerroa:           var cliprect = this.svgFactory.createElement('svg:rect');
Kode lerroa:           cliprect.setAttributeNS(null, 'x', bbox[0]);
Kode lerroa:           cliprect.setAttributeNS(null, 'y', bbox[1]);
Kode lerroa:           cliprect.setAttributeNS(null, 'width', pf(width));
Kode lerroa:           cliprect.setAttributeNS(null, 'height', pf(height));
Kode lerroa:           this.current.element = cliprect;
Kode lerroa:           this.clip('nonzero');
Kode lerroa:           this.endPath();
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {},
Kode lerroa:       _initialize: function _initialize(viewport) {
Kode lerroa:         var svg = this.svgFactory.create(viewport.width, viewport.height);
Kode lerroa:         var definitions = this.svgFactory.createElement('svg:defs');
Kode lerroa:         svg.appendChild(definitions);
Kode lerroa:         this.defs = definitions;
Kode lerroa:         var rootGroup = this.svgFactory.createElement('svg:g');
Kode lerroa:         rootGroup.setAttributeNS(null, 'transform', pm(viewport.transform));
Kode lerroa:         svg.appendChild(rootGroup);
Kode lerroa:         this.svg = rootGroup;
Kode lerroa:         return svg;
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       _ensureClipGroup: function SVGGraphics_ensureClipGroup() {
Kode lerroa:         if (!this.current.clipGroup) {
Kode lerroa:           var clipGroup = this.svgFactory.createElement('svg:g');
Kode lerroa:           clipGroup.setAttributeNS(null, 'clip-path', this.current.activeClipUrl);
Kode lerroa:           this.svg.appendChild(clipGroup);
Kode lerroa:           this.current.clipGroup = clipGroup;
Kode lerroa:         }
Kode lerroa:         return this.current.clipGroup;
Kode lerroa:       },
Kode lerroa:       _ensureTransformGroup: function SVGGraphics_ensureTransformGroup() {
Kode lerroa:         if (!this.tgrp) {
Kode lerroa:           this.tgrp = this.svgFactory.createElement('svg:g');
Kode lerroa:           this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
Kode lerroa:           if (this.current.activeClipUrl) {
Kode lerroa:             this._ensureClipGroup().appendChild(this.tgrp);
Kode lerroa:           } else {
Kode lerroa:             this.svg.appendChild(this.tgrp);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return this.tgrp;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return SVGGraphics;
Kode lerroa:   }();
Kode lerroa: }
Kode lerroa: exports.SVGGraphics = SVGGraphics;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 75 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var pdfjsVersion = '1.10.100';
Kode lerroa: var pdfjsBuild = 'ea29ec83';
Kode lerroa: var pdfjsSharedUtil = __w_pdfjs_require__(0);
Kode lerroa: var pdfjsDisplayGlobal = __w_pdfjs_require__(118);
Kode lerroa: var pdfjsDisplayAPI = __w_pdfjs_require__(69);
Kode lerroa: var pdfjsDisplayTextLayer = __w_pdfjs_require__(73);
Kode lerroa: var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__(72);
Kode lerroa: var pdfjsDisplayDOMUtils = __w_pdfjs_require__(15);
Kode lerroa: var pdfjsDisplaySVG = __w_pdfjs_require__(74);
Kode lerroa: {
Kode lerroa:   if (pdfjsSharedUtil.isNodeJS()) {
Kode lerroa:     var PDFNodeStream = __w_pdfjs_require__(124).PDFNodeStream;
Kode lerroa:     pdfjsDisplayAPI.setPDFNetworkStreamClass(PDFNodeStream);
Kode lerroa:   } else if (typeof Response !== 'undefined' && 'body' in Response.prototype && typeof ReadableStream !== 'undefined') {
Kode lerroa:     var PDFFetchStream = __w_pdfjs_require__(125).PDFFetchStream;
Kode lerroa:     pdfjsDisplayAPI.setPDFNetworkStreamClass(PDFFetchStream);
Kode lerroa:   } else {
Kode lerroa:     var PDFNetworkStream = __w_pdfjs_require__(126).PDFNetworkStream;
Kode lerroa:     pdfjsDisplayAPI.setPDFNetworkStreamClass(PDFNetworkStream);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: exports.PDFJS = pdfjsDisplayGlobal.PDFJS;
Kode lerroa: exports.build = pdfjsDisplayAPI.build;
Kode lerroa: exports.version = pdfjsDisplayAPI.version;
Kode lerroa: exports.getDocument = pdfjsDisplayAPI.getDocument;
Kode lerroa: exports.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
Kode lerroa: exports.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
Kode lerroa: exports.PDFWorker = pdfjsDisplayAPI.PDFWorker;
Kode lerroa: exports.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
Kode lerroa: exports.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
Kode lerroa: exports.CustomStyle = pdfjsDisplayDOMUtils.CustomStyle;
Kode lerroa: exports.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
Kode lerroa: exports.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
Kode lerroa: exports.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
Kode lerroa: exports.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
Kode lerroa: exports.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
Kode lerroa: exports.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
Kode lerroa: exports.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
Kode lerroa: exports.OPS = pdfjsSharedUtil.OPS;
Kode lerroa: exports.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
Kode lerroa: exports.isValidUrl = pdfjsDisplayDOMUtils.isValidUrl;
Kode lerroa: exports.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
Kode lerroa: exports.createObjectURL = pdfjsSharedUtil.createObjectURL;
Kode lerroa: exports.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
Kode lerroa: exports.shadow = pdfjsSharedUtil.shadow;
Kode lerroa: exports.createBlob = pdfjsSharedUtil.createBlob;
Kode lerroa: exports.RenderingCancelledException = pdfjsDisplayDOMUtils.RenderingCancelledException;
Kode lerroa: exports.getFilenameFromUrl = pdfjsDisplayDOMUtils.getFilenameFromUrl;
Kode lerroa: exports.addLinkAttributes = pdfjsDisplayDOMUtils.addLinkAttributes;
Kode lerroa: exports.StatTimer = pdfjsSharedUtil.StatTimer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 76 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: if (typeof PDFJS === 'undefined' || !PDFJS.compatibilityChecked) {
Kode lerroa:   var globalScope = __w_pdfjs_require__(20);
Kode lerroa:   var userAgent = typeof navigator !== 'undefined' && navigator.userAgent || '';
Kode lerroa:   var isAndroid = /Android/.test(userAgent);
Kode lerroa:   var isAndroidPre3 = /Android\s[0-2][^\d]/.test(userAgent);
Kode lerroa:   var isAndroidPre5 = /Android\s[0-4][^\d]/.test(userAgent);
Kode lerroa:   var isChrome = userAgent.indexOf('Chrom') >= 0;
Kode lerroa:   var isChromeWithRangeBug = /Chrome\/(39|40)\./.test(userAgent);
Kode lerroa:   var isIOSChrome = userAgent.indexOf('CriOS') >= 0;
Kode lerroa:   var isIE = userAgent.indexOf('Trident') >= 0;
Kode lerroa:   var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);
Kode lerroa:   var isOpera = userAgent.indexOf('Opera') >= 0;
Kode lerroa:   var isSafari = /Safari\//.test(userAgent) && !/(Chrome\/|Android\s)/.test(userAgent);
Kode lerroa:   var hasDOM = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object';
Kode lerroa:   if (typeof PDFJS === 'undefined') {
Kode lerroa:     globalScope.PDFJS = {};
Kode lerroa:   }
Kode lerroa:   PDFJS.compatibilityChecked = true;
Kode lerroa:   (function checkTypedArrayCompatibility() {
Kode lerroa:     if (typeof Uint8ClampedArray === 'undefined') {
Kode lerroa:       globalScope.Uint8ClampedArray = __w_pdfjs_require__(77);
Kode lerroa:     }
Kode lerroa:     if (typeof Uint8Array !== 'undefined') {
Kode lerroa:       if (typeof Uint8Array.prototype.subarray === 'undefined') {
Kode lerroa:         Uint8Array.prototype.subarray = function subarray(start, end) {
Kode lerroa:           return new Uint8Array(this.slice(start, end));
Kode lerroa:         };
Kode lerroa:         Float32Array.prototype.subarray = function subarray(start, end) {
Kode lerroa:           return new Float32Array(this.slice(start, end));
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:       if (typeof Float64Array === 'undefined') {
Kode lerroa:         globalScope.Float64Array = Float32Array;
Kode lerroa:       }
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     function subarray(start, end) {
Kode lerroa:       return new TypedArray(this.slice(start, end));
Kode lerroa:     }
Kode lerroa:     function setArrayOffset(array, offset) {
Kode lerroa:       if (arguments.length < 2) {
Kode lerroa:         offset = 0;
Kode lerroa:       }
Kode lerroa:       for (var i = 0, n = array.length; i < n; ++i, ++offset) {
Kode lerroa:         this[offset] = array[i] & 0xFF;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     function Uint32ArrayView(buffer, length) {
Kode lerroa:       this.buffer = buffer;
Kode lerroa:       this.byteLength = buffer.length;
Kode lerroa:       this.length = length;
Kode lerroa:       ensureUint32ArrayViewProps(this.length);
Kode lerroa:     }
Kode lerroa:     Uint32ArrayView.prototype = Object.create(null);
Kode lerroa:     var uint32ArrayViewSetters = 0;
Kode lerroa:     function createUint32ArrayProp(index) {
Kode lerroa:       return {
Kode lerroa:         get: function get() {
Kode lerroa:           var buffer = this.buffer,
Kode lerroa:               offset = index << 2;
Kode lerroa:           return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24) >>> 0;
Kode lerroa:         },
Kode lerroa:         set: function set(value) {
Kode lerroa:           var buffer = this.buffer,
Kode lerroa:               offset = index << 2;
Kode lerroa:           buffer[offset] = value & 255;
Kode lerroa:           buffer[offset + 1] = value >> 8 & 255;
Kode lerroa:           buffer[offset + 2] = value >> 16 & 255;
Kode lerroa:           buffer[offset + 3] = value >>> 24 & 255;
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     function ensureUint32ArrayViewProps(length) {
Kode lerroa:       while (uint32ArrayViewSetters < length) {
Kode lerroa:         Object.defineProperty(Uint32ArrayView.prototype, uint32ArrayViewSetters, createUint32ArrayProp(uint32ArrayViewSetters));
Kode lerroa:         uint32ArrayViewSetters++;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     function TypedArray(arg1) {
Kode lerroa:       var result, i, n;
Kode lerroa:       if (typeof arg1 === 'number') {
Kode lerroa:         result = [];
Kode lerroa:         for (i = 0; i < arg1; ++i) {
Kode lerroa:           result[i] = 0;
Kode lerroa:         }
Kode lerroa:       } else if ('slice' in arg1) {
Kode lerroa:         result = arg1.slice(0);
Kode lerroa:       } else {
Kode lerroa:         result = [];
Kode lerroa:         for (i = 0, n = arg1.length; i < n; ++i) {
Kode lerroa:           result[i] = arg1[i];
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       result.subarray = subarray;
Kode lerroa:       result.buffer = result;
Kode lerroa:       result.byteLength = result.length;
Kode lerroa:       result.set = setArrayOffset;
Kode lerroa:       if ((typeof arg1 === 'undefined' ? 'undefined' : _typeof(arg1)) === 'object' && arg1.buffer) {
Kode lerroa:         result.buffer = arg1.buffer;
Kode lerroa:       }
Kode lerroa:       return result;
Kode lerroa:     }
Kode lerroa:     globalScope.Uint8Array = TypedArray;
Kode lerroa:     globalScope.Int8Array = TypedArray;
Kode lerroa:     globalScope.Int32Array = TypedArray;
Kode lerroa:     globalScope.Uint16Array = TypedArray;
Kode lerroa:     globalScope.Float32Array = TypedArray;
Kode lerroa:     globalScope.Float64Array = TypedArray;
Kode lerroa:     globalScope.Uint32Array = function () {
Kode lerroa:       if (arguments.length === 3) {
Kode lerroa:         if (arguments[1] !== 0) {
Kode lerroa:           throw new Error('offset !== 0 is not supported');
Kode lerroa:         }
Kode lerroa:         return new Uint32ArrayView(arguments[0], arguments[2]);
Kode lerroa:       }
Kode lerroa:       return TypedArray.apply(this, arguments);
Kode lerroa:     };
Kode lerroa:   })();
Kode lerroa:   (function canvasPixelArrayBuffer() {
Kode lerroa:     if (!hasDOM || !window.CanvasPixelArray) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var cpaProto = window.CanvasPixelArray.prototype;
Kode lerroa:     if ('buffer' in cpaProto) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Object.defineProperty(cpaProto, 'buffer', {
Kode lerroa:       get: function get() {
Kode lerroa:         return this;
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       enumerable: false,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:     Object.defineProperty(cpaProto, 'byteLength', {
Kode lerroa:       get: function get() {
Kode lerroa:         return this.length;
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       enumerable: false,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:   })();
Kode lerroa:   (function normalizeURLObject() {
Kode lerroa:     if (!globalScope.URL) {
Kode lerroa:       globalScope.URL = globalScope.webkitURL;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkObjectDefinePropertyCompatibility() {
Kode lerroa:     if (typeof Object.defineProperty !== 'undefined') {
Kode lerroa:       var definePropertyPossible = true;
Kode lerroa:       try {
Kode lerroa:         if (hasDOM) {
Kode lerroa:           Object.defineProperty(new Image(), 'id', { value: 'test' });
Kode lerroa:         }
Kode lerroa:         var Test = function Test() {};
Kode lerroa:         Test.prototype = {
Kode lerroa:           get id() {}
Kode lerroa:         };
Kode lerroa:         Object.defineProperty(new Test(), 'id', {
Kode lerroa:           value: '',
Kode lerroa:           configurable: true,
Kode lerroa:           enumerable: true,
Kode lerroa:           writable: false
Kode lerroa:         });
Kode lerroa:       } catch (e) {
Kode lerroa:         definePropertyPossible = false;
Kode lerroa:       }
Kode lerroa:       if (definePropertyPossible) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     Object.defineProperty = function objectDefineProperty(obj, name, def) {
Kode lerroa:       delete obj[name];
Kode lerroa:       if ('get' in def) {
Kode lerroa:         obj.__defineGetter__(name, def['get']);
Kode lerroa:       }
Kode lerroa:       if ('set' in def) {
Kode lerroa:         obj.__defineSetter__(name, def['set']);
Kode lerroa:       }
Kode lerroa:       if ('value' in def) {
Kode lerroa:         obj.__defineSetter__(name, function objectDefinePropertySetter(value) {
Kode lerroa:           this.__defineGetter__(name, function objectDefinePropertyGetter() {
Kode lerroa:             return value;
Kode lerroa:           });
Kode lerroa:           return value;
Kode lerroa:         });
Kode lerroa:         obj[name] = def.value;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:   })();
Kode lerroa:   (function checkXMLHttpRequestResponseCompatibility() {
Kode lerroa:     if (typeof XMLHttpRequest === 'undefined') {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var xhrPrototype = XMLHttpRequest.prototype;
Kode lerroa:     var xhr = new XMLHttpRequest();
Kode lerroa:     if (!('overrideMimeType' in xhr)) {
Kode lerroa:       Object.defineProperty(xhrPrototype, 'overrideMimeType', {
Kode lerroa:         value: function xmlHttpRequestOverrideMimeType(mimeType) {}
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     if ('responseType' in xhr) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Object.defineProperty(xhrPrototype, 'responseType', {
Kode lerroa:       get: function xmlHttpRequestGetResponseType() {
Kode lerroa:         return this._responseType || 'text';
Kode lerroa:       },
Kode lerroa:       set: function xmlHttpRequestSetResponseType(value) {
Kode lerroa:         if (value === 'text' || value === 'arraybuffer') {
Kode lerroa:           this._responseType = value;
Kode lerroa:           if (value === 'arraybuffer' && typeof this.overrideMimeType === 'function') {
Kode lerroa:             this.overrideMimeType('text/plain; charset=x-user-defined');
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     if (typeof VBArray !== 'undefined') {
Kode lerroa:       Object.defineProperty(xhrPrototype, 'response', {
Kode lerroa:         get: function xmlHttpRequestResponseGet() {
Kode lerroa:           if (this.responseType === 'arraybuffer') {
Kode lerroa:             return new Uint8Array(new VBArray(this.responseBody).toArray());
Kode lerroa:           }
Kode lerroa:           return this.responseText;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Object.defineProperty(xhrPrototype, 'response', {
Kode lerroa:       get: function xmlHttpRequestResponseGet() {
Kode lerroa:         if (this.responseType !== 'arraybuffer') {
Kode lerroa:           return this.responseText;
Kode lerroa:         }
Kode lerroa:         var text = this.responseText;
Kode lerroa:         var i,
Kode lerroa:             n = text.length;
Kode lerroa:         var result = new Uint8Array(n);
Kode lerroa:         for (i = 0; i < n; ++i) {
Kode lerroa:           result[i] = text.charCodeAt(i) & 0xFF;
Kode lerroa:         }
Kode lerroa:         return result.buffer;
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:   })();
Kode lerroa:   (function checkWindowBtoaCompatibility() {
Kode lerroa:     if ('btoa' in globalScope) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
Kode lerroa:     globalScope.btoa = function (chars) {
Kode lerroa:       var buffer = '';
Kode lerroa:       var i, n;
Kode lerroa:       for (i = 0, n = chars.length; i < n; i += 3) {
Kode lerroa:         var b1 = chars.charCodeAt(i) & 0xFF;
Kode lerroa:         var b2 = chars.charCodeAt(i + 1) & 0xFF;
Kode lerroa:         var b3 = chars.charCodeAt(i + 2) & 0xFF;
Kode lerroa:         var d1 = b1 >> 2,
Kode lerroa:             d2 = (b1 & 3) << 4 | b2 >> 4;
Kode lerroa:         var d3 = i + 1 < n ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
Kode lerroa:         var d4 = i + 2 < n ? b3 & 0x3F : 64;
Kode lerroa:         buffer += digits.charAt(d1) + digits.charAt(d2) + digits.charAt(d3) + digits.charAt(d4);
Kode lerroa:       }
Kode lerroa:       return buffer;
Kode lerroa:     };
Kode lerroa:   })();
Kode lerroa:   (function checkWindowAtobCompatibility() {
Kode lerroa:     if ('atob' in globalScope) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
Kode lerroa:     globalScope.atob = function (input) {
Kode lerroa:       input = input.replace(/=+$/, '');
Kode lerroa:       if (input.length % 4 === 1) {
Kode lerroa:         throw new Error('bad atob input');
Kode lerroa:       }
Kode lerroa:       for (var bc = 0, bs, buffer, idx = 0, output = ''; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
Kode lerroa:         buffer = digits.indexOf(buffer);
Kode lerroa:       }
Kode lerroa:       return output;
Kode lerroa:     };
Kode lerroa:   })();
Kode lerroa:   (function checkFunctionPrototypeBindCompatibility() {
Kode lerroa:     if (typeof Function.prototype.bind !== 'undefined') {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Function.prototype.bind = function functionPrototypeBind(obj) {
Kode lerroa:       var fn = this,
Kode lerroa:           headArgs = Array.prototype.slice.call(arguments, 1);
Kode lerroa:       var bound = function functionPrototypeBindBound() {
Kode lerroa:         var args = headArgs.concat(Array.prototype.slice.call(arguments));
Kode lerroa:         return fn.apply(obj, args);
Kode lerroa:       };
Kode lerroa:       return bound;
Kode lerroa:     };
Kode lerroa:   })();
Kode lerroa:   (function checkDatasetProperty() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var div = document.createElement('div');
Kode lerroa:     if ('dataset' in div) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Object.defineProperty(HTMLElement.prototype, 'dataset', {
Kode lerroa:       get: function get() {
Kode lerroa:         if (this._dataset) {
Kode lerroa:           return this._dataset;
Kode lerroa:         }
Kode lerroa:         var dataset = {};
Kode lerroa:         for (var j = 0, jj = this.attributes.length; j < jj; j++) {
Kode lerroa:           var attribute = this.attributes[j];
Kode lerroa:           if (attribute.name.substring(0, 5) !== 'data-') {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           var key = attribute.name.substring(5).replace(/\-([a-z])/g, function (all, ch) {
Kode lerroa:             return ch.toUpperCase();
Kode lerroa:           });
Kode lerroa:           dataset[key] = attribute.value;
Kode lerroa:         }
Kode lerroa:         Object.defineProperty(this, '_dataset', {
Kode lerroa:           value: dataset,
Kode lerroa:           writable: false,
Kode lerroa:           enumerable: false
Kode lerroa:         });
Kode lerroa:         return dataset;
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       enumerable: true
Kode lerroa:     });
Kode lerroa:   })();
Kode lerroa:   (function checkClassListProperty() {
Kode lerroa:     function changeList(element, itemName, add, remove) {
Kode lerroa:       var s = element.className || '';
Kode lerroa:       var list = s.split(/\s+/g);
Kode lerroa:       if (list[0] === '') {
Kode lerroa:         list.shift();
Kode lerroa:       }
Kode lerroa:       var index = list.indexOf(itemName);
Kode lerroa:       if (index < 0 && add) {
Kode lerroa:         list.push(itemName);
Kode lerroa:       }
Kode lerroa:       if (index >= 0 && remove) {
Kode lerroa:         list.splice(index, 1);
Kode lerroa:       }
Kode lerroa:       element.className = list.join(' ');
Kode lerroa:       return index >= 0;
Kode lerroa:     }
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var div = document.createElement('div');
Kode lerroa:     if ('classList' in div) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var classListPrototype = {
Kode lerroa:       add: function add(name) {
Kode lerroa:         changeList(this.element, name, true, false);
Kode lerroa:       },
Kode lerroa:       contains: function contains(name) {
Kode lerroa:         return changeList(this.element, name, false, false);
Kode lerroa:       },
Kode lerroa:       remove: function remove(name) {
Kode lerroa:         changeList(this.element, name, false, true);
Kode lerroa:       },
Kode lerroa:       toggle: function toggle(name) {
Kode lerroa:         changeList(this.element, name, true, true);
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     Object.defineProperty(HTMLElement.prototype, 'classList', {
Kode lerroa:       get: function get() {
Kode lerroa:         if (this._classList) {
Kode lerroa:           return this._classList;
Kode lerroa:         }
Kode lerroa:         var classList = Object.create(classListPrototype, {
Kode lerroa:           element: {
Kode lerroa:             value: this,
Kode lerroa:             writable: false,
Kode lerroa:             enumerable: true
Kode lerroa:           }
Kode lerroa:         });
Kode lerroa:         Object.defineProperty(this, '_classList', {
Kode lerroa:           value: classList,
Kode lerroa:           writable: false,
Kode lerroa:           enumerable: false
Kode lerroa:         });
Kode lerroa:         return classList;
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       enumerable: true
Kode lerroa:     });
Kode lerroa:   })();
Kode lerroa:   (function checkWorkerConsoleCompatibility() {
Kode lerroa:     if (typeof importScripts === 'undefined' || 'console' in globalScope) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var consoleTimer = {};
Kode lerroa:     var workerConsole = {
Kode lerroa:       log: function log() {
Kode lerroa:         var args = Array.prototype.slice.call(arguments);
Kode lerroa:         globalScope.postMessage({
Kode lerroa:           targetName: 'main',
Kode lerroa:           action: 'console_log',
Kode lerroa:           data: args
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa:       error: function error() {
Kode lerroa:         var args = Array.prototype.slice.call(arguments);
Kode lerroa:         globalScope.postMessage({
Kode lerroa:           targetName: 'main',
Kode lerroa:           action: 'console_error',
Kode lerroa:           data: args
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa:       time: function time(name) {
Kode lerroa:         consoleTimer[name] = Date.now();
Kode lerroa:       },
Kode lerroa:       timeEnd: function timeEnd(name) {
Kode lerroa:         var time = consoleTimer[name];
Kode lerroa:         if (!time) {
Kode lerroa:           throw new Error('Unknown timer name ' + name);
Kode lerroa:         }
Kode lerroa:         this.log('Timer:', name, Date.now() - time);
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     globalScope.console = workerConsole;
Kode lerroa:   })();
Kode lerroa:   (function checkConsoleCompatibility() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!('console' in window)) {
Kode lerroa:       window.console = {
Kode lerroa:         log: function log() {},
Kode lerroa:         error: function error() {},
Kode lerroa:         warn: function warn() {}
Kode lerroa:       };
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!('bind' in console.log)) {
Kode lerroa:       console.log = function (fn) {
Kode lerroa:         return function (msg) {
Kode lerroa:           return fn(msg);
Kode lerroa:         };
Kode lerroa:       }(console.log);
Kode lerroa:       console.error = function (fn) {
Kode lerroa:         return function (msg) {
Kode lerroa:           return fn(msg);
Kode lerroa:         };
Kode lerroa:       }(console.error);
Kode lerroa:       console.warn = function (fn) {
Kode lerroa:         return function (msg) {
Kode lerroa:           return fn(msg);
Kode lerroa:         };
Kode lerroa:       }(console.warn);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkOnClickCompatibility() {
Kode lerroa:     function ignoreIfTargetDisabled(event) {
Kode lerroa:       if (isDisabled(event.target)) {
Kode lerroa:         event.stopPropagation();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     function isDisabled(node) {
Kode lerroa:       return node.disabled || node.parentNode && isDisabled(node.parentNode);
Kode lerroa:     }
Kode lerroa:     if (isOpera) {
Kode lerroa:       document.addEventListener('click', ignoreIfTargetDisabled, true);
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkOnBlobSupport() {
Kode lerroa:     if (isIE || isIOSChrome) {
Kode lerroa:       PDFJS.disableCreateObjectURL = true;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkNavigatorLanguage() {
Kode lerroa:     if (typeof navigator === 'undefined') {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if ('language' in navigator) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     PDFJS.locale = navigator.userLanguage || 'en-US';
Kode lerroa:   })();
Kode lerroa:   (function checkRangeRequests() {
Kode lerroa:     if (isSafari || isAndroidPre3 || isChromeWithRangeBug || isIOS) {
Kode lerroa:       PDFJS.disableRange = true;
Kode lerroa:       PDFJS.disableStream = true;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkHistoryManipulation() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!history.pushState || isAndroidPre3) {
Kode lerroa:       PDFJS.disableHistory = true;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkSetPresenceInImageData() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (window.CanvasPixelArray) {
Kode lerroa:       if (typeof window.CanvasPixelArray.prototype.set !== 'function') {
Kode lerroa:         window.CanvasPixelArray.prototype.set = function (arr) {
Kode lerroa:           for (var i = 0, ii = this.length; i < ii; i++) {
Kode lerroa:             this[i] = arr[i];
Kode lerroa:           }
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       var polyfill = false,
Kode lerroa:           versionMatch;
Kode lerroa:       if (isChrome) {
Kode lerroa:         versionMatch = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
Kode lerroa:         polyfill = versionMatch && parseInt(versionMatch[2]) < 21;
Kode lerroa:       } else if (isAndroid) {
Kode lerroa:         polyfill = isAndroidPre5;
Kode lerroa:       } else if (isSafari) {
Kode lerroa:         versionMatch = userAgent.match(/Version\/([0-9]+)\.([0-9]+)\.([0-9]+) Safari\//);
Kode lerroa:         polyfill = versionMatch && parseInt(versionMatch[1]) < 6;
Kode lerroa:       }
Kode lerroa:       if (polyfill) {
Kode lerroa:         var contextPrototype = window.CanvasRenderingContext2D.prototype;
Kode lerroa:         var createImageData = contextPrototype.createImageData;
Kode lerroa:         contextPrototype.createImageData = function (w, h) {
Kode lerroa:           var imageData = createImageData.call(this, w, h);
Kode lerroa:           imageData.data.set = function (arr) {
Kode lerroa:             for (var i = 0, ii = this.length; i < ii; i++) {
Kode lerroa:               this[i] = arr[i];
Kode lerroa:             }
Kode lerroa:           };
Kode lerroa:           return imageData;
Kode lerroa:         };
Kode lerroa:         contextPrototype = null;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkRequestAnimationFrame() {
Kode lerroa:     function installFakeAnimationFrameFunctions() {
Kode lerroa:       window.requestAnimationFrame = function (callback) {
Kode lerroa:         return window.setTimeout(callback, 20);
Kode lerroa:       };
Kode lerroa:       window.cancelAnimationFrame = function (timeoutID) {
Kode lerroa:         window.clearTimeout(timeoutID);
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (isIOS) {
Kode lerroa:       installFakeAnimationFrameFunctions();
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if ('requestAnimationFrame' in window) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
Kode lerroa:     if (window.requestAnimationFrame) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     installFakeAnimationFrameFunctions();
Kode lerroa:   })();
Kode lerroa:   (function checkCanvasSizeLimitation() {
Kode lerroa:     if (isIOS || isAndroid) {
Kode lerroa:       PDFJS.maxCanvasPixels = 5242880;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkFullscreenSupport() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (isIE && window.parent !== window) {
Kode lerroa:       PDFJS.disableFullscreen = true;
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkCurrentScript() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if ('currentScript' in document) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Object.defineProperty(document, 'currentScript', {
Kode lerroa:       get: function get() {
Kode lerroa:         var scripts = document.getElementsByTagName('script');
Kode lerroa:         return scripts[scripts.length - 1];
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       enumerable: true,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:   })();
Kode lerroa:   (function checkInputTypeNumberAssign() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var el = document.createElement('input');
Kode lerroa:     try {
Kode lerroa:       el.type = 'number';
Kode lerroa:     } catch (ex) {
Kode lerroa:       var inputProto = el.constructor.prototype;
Kode lerroa:       var typeProperty = Object.getOwnPropertyDescriptor(inputProto, 'type');
Kode lerroa:       Object.defineProperty(inputProto, 'type', {
Kode lerroa:         get: function get() {
Kode lerroa:           return typeProperty.get.call(this);
Kode lerroa:         },
Kode lerroa:         set: function set(value) {
Kode lerroa:           typeProperty.set.call(this, value === 'number' ? 'text' : value);
Kode lerroa:         },
Kode lerroa: 
Kode lerroa:         enumerable: true,
Kode lerroa:         configurable: true
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   })();
Kode lerroa:   (function checkDocumentReadyState() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!document.attachEvent) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var documentProto = document.constructor.prototype;
Kode lerroa:     var readyStateProto = Object.getOwnPropertyDescriptor(documentProto, 'readyState');
Kode lerroa:     Object.defineProperty(documentProto, 'readyState', {
Kode lerroa:       get: function get() {
Kode lerroa:         var value = readyStateProto.get.call(this);
Kode lerroa:         return value === 'interactive' ? 'loading' : value;
Kode lerroa:       },
Kode lerroa:       set: function set(value) {
Kode lerroa:         readyStateProto.set.call(this, value);
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       enumerable: true,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:   })();
Kode lerroa:   (function checkChildNodeRemove() {
Kode lerroa:     if (!hasDOM) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (typeof Element.prototype.remove !== 'undefined') {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Element.prototype.remove = function () {
Kode lerroa:       if (this.parentNode) {
Kode lerroa:         this.parentNode.removeChild(this);
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:   })();
Kode lerroa:   (function checkNumberIsNaN() {
Kode lerroa:     if (Number.isNaN) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Number.isNaN = __w_pdfjs_require__(89);
Kode lerroa:   })();
Kode lerroa:   (function checkNumberIsInteger() {
Kode lerroa:     if (Number.isInteger) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     Number.isInteger = __w_pdfjs_require__(91);
Kode lerroa:   })();
Kode lerroa:   (function checkPromise() {
Kode lerroa:     if (globalScope.Promise) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     globalScope.Promise = __w_pdfjs_require__(94);
Kode lerroa:   })();
Kode lerroa:   (function checkWeakMap() {
Kode lerroa:     if (globalScope.WeakMap) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     globalScope.WeakMap = __w_pdfjs_require__(104);
Kode lerroa:   })();
Kode lerroa:   (function checkURLConstructor() {
Kode lerroa:     var hasWorkingUrl = false;
Kode lerroa:     try {
Kode lerroa:       if (typeof URL === 'function' && _typeof(URL.prototype) === 'object' && 'origin' in URL.prototype) {
Kode lerroa:         var u = new URL('b', 'http://a');
Kode lerroa:         u.pathname = 'c%20d';
Kode lerroa:         hasWorkingUrl = u.href === 'http://a/c%20d';
Kode lerroa:       }
Kode lerroa:     } catch (e) {}
Kode lerroa:     if (hasWorkingUrl) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var relative = Object.create(null);
Kode lerroa:     relative['ftp'] = 21;
Kode lerroa:     relative['file'] = 0;
Kode lerroa:     relative['gopher'] = 70;
Kode lerroa:     relative['http'] = 80;
Kode lerroa:     relative['https'] = 443;
Kode lerroa:     relative['ws'] = 80;
Kode lerroa:     relative['wss'] = 443;
Kode lerroa:     var relativePathDotMapping = Object.create(null);
Kode lerroa:     relativePathDotMapping['%2e'] = '.';
Kode lerroa:     relativePathDotMapping['.%2e'] = '..';
Kode lerroa:     relativePathDotMapping['%2e.'] = '..';
Kode lerroa:     relativePathDotMapping['%2e%2e'] = '..';
Kode lerroa:     function isRelativeScheme(scheme) {
Kode lerroa:       return relative[scheme] !== undefined;
Kode lerroa:     }
Kode lerroa:     function invalid() {
Kode lerroa:       clear.call(this);
Kode lerroa:       this._isInvalid = true;
Kode lerroa:     }
Kode lerroa:     function IDNAToASCII(h) {
Kode lerroa:       if (h === '') {
Kode lerroa:         invalid.call(this);
Kode lerroa:       }
Kode lerroa:       return h.toLowerCase();
Kode lerroa:     }
Kode lerroa:     function percentEscape(c) {
Kode lerroa:       var unicode = c.charCodeAt(0);
Kode lerroa:       if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) === -1) {
Kode lerroa:         return c;
Kode lerroa:       }
Kode lerroa:       return encodeURIComponent(c);
Kode lerroa:     }
Kode lerroa:     function percentEscapeQuery(c) {
Kode lerroa:       var unicode = c.charCodeAt(0);
Kode lerroa:       if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) === -1) {
Kode lerroa:         return c;
Kode lerroa:       }
Kode lerroa:       return encodeURIComponent(c);
Kode lerroa:     }
Kode lerroa:     var EOF,
Kode lerroa:         ALPHA = /[a-zA-Z]/,
Kode lerroa:         ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
Kode lerroa:     function parse(input, stateOverride, base) {
Kode lerroa:       function err(message) {
Kode lerroa:         errors.push(message);
Kode lerroa:       }
Kode lerroa:       var state = stateOverride || 'scheme start',
Kode lerroa:           cursor = 0,
Kode lerroa:           buffer = '',
Kode lerroa:           seenAt = false,
Kode lerroa:           seenBracket = false,
Kode lerroa:           errors = [];
Kode lerroa:       loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
Kode lerroa:         var c = input[cursor];
Kode lerroa:         switch (state) {
Kode lerroa:           case 'scheme start':
Kode lerroa:             if (c && ALPHA.test(c)) {
Kode lerroa:               buffer += c.toLowerCase();
Kode lerroa:               state = 'scheme';
Kode lerroa:             } else if (!stateOverride) {
Kode lerroa:               buffer = '';
Kode lerroa:               state = 'no scheme';
Kode lerroa:               continue;
Kode lerroa:             } else {
Kode lerroa:               err('Invalid scheme.');
Kode lerroa:               break loop;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'scheme':
Kode lerroa:             if (c && ALPHANUMERIC.test(c)) {
Kode lerroa:               buffer += c.toLowerCase();
Kode lerroa:             } else if (c === ':') {
Kode lerroa:               this._scheme = buffer;
Kode lerroa:               buffer = '';
Kode lerroa:               if (stateOverride) {
Kode lerroa:                 break loop;
Kode lerroa:               }
Kode lerroa:               if (isRelativeScheme(this._scheme)) {
Kode lerroa:                 this._isRelative = true;
Kode lerroa:               }
Kode lerroa:               if (this._scheme === 'file') {
Kode lerroa:                 state = 'relative';
Kode lerroa:               } else if (this._isRelative && base && base._scheme === this._scheme) {
Kode lerroa:                 state = 'relative or authority';
Kode lerroa:               } else if (this._isRelative) {
Kode lerroa:                 state = 'authority first slash';
Kode lerroa:               } else {
Kode lerroa:                 state = 'scheme data';
Kode lerroa:               }
Kode lerroa:             } else if (!stateOverride) {
Kode lerroa:               buffer = '';
Kode lerroa:               cursor = 0;
Kode lerroa:               state = 'no scheme';
Kode lerroa:               continue;
Kode lerroa:             } else if (c === EOF) {
Kode lerroa:               break loop;
Kode lerroa:             } else {
Kode lerroa:               err('Code point not allowed in scheme: ' + c);
Kode lerroa:               break loop;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'scheme data':
Kode lerroa:             if (c === '?') {
Kode lerroa:               this._query = '?';
Kode lerroa:               state = 'query';
Kode lerroa:             } else if (c === '#') {
Kode lerroa:               this._fragment = '#';
Kode lerroa:               state = 'fragment';
Kode lerroa:             } else {
Kode lerroa:               if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
Kode lerroa:                 this._schemeData += percentEscape(c);
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'no scheme':
Kode lerroa:             if (!base || !isRelativeScheme(base._scheme)) {
Kode lerroa:               err('Missing scheme.');
Kode lerroa:               invalid.call(this);
Kode lerroa:             } else {
Kode lerroa:               state = 'relative';
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'relative or authority':
Kode lerroa:             if (c === '/' && input[cursor + 1] === '/') {
Kode lerroa:               state = 'authority ignore slashes';
Kode lerroa:             } else {
Kode lerroa:               err('Expected /, got: ' + c);
Kode lerroa:               state = 'relative';
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'relative':
Kode lerroa:             this._isRelative = true;
Kode lerroa:             if (this._scheme !== 'file') {
Kode lerroa:               this._scheme = base._scheme;
Kode lerroa:             }
Kode lerroa:             if (c === EOF) {
Kode lerroa:               this._host = base._host;
Kode lerroa:               this._port = base._port;
Kode lerroa:               this._path = base._path.slice();
Kode lerroa:               this._query = base._query;
Kode lerroa:               this._username = base._username;
Kode lerroa:               this._password = base._password;
Kode lerroa:               break loop;
Kode lerroa:             } else if (c === '/' || c === '\\') {
Kode lerroa:               if (c === '\\') {
Kode lerroa:                 err('\\ is an invalid code point.');
Kode lerroa:               }
Kode lerroa:               state = 'relative slash';
Kode lerroa:             } else if (c === '?') {
Kode lerroa:               this._host = base._host;
Kode lerroa:               this._port = base._port;
Kode lerroa:               this._path = base._path.slice();
Kode lerroa:               this._query = '?';
Kode lerroa:               this._username = base._username;
Kode lerroa:               this._password = base._password;
Kode lerroa:               state = 'query';
Kode lerroa:             } else if (c === '#') {
Kode lerroa:               this._host = base._host;
Kode lerroa:               this._port = base._port;
Kode lerroa:               this._path = base._path.slice();
Kode lerroa:               this._query = base._query;
Kode lerroa:               this._fragment = '#';
Kode lerroa:               this._username = base._username;
Kode lerroa:               this._password = base._password;
Kode lerroa:               state = 'fragment';
Kode lerroa:             } else {
Kode lerroa:               var nextC = input[cursor + 1];
Kode lerroa:               var nextNextC = input[cursor + 2];
Kode lerroa:               if (this._scheme !== 'file' || !ALPHA.test(c) || nextC !== ':' && nextC !== '|' || nextNextC !== EOF && nextNextC !== '/' && nextNextC !== '\\' && nextNextC !== '?' && nextNextC !== '#') {
Kode lerroa:                 this._host = base._host;
Kode lerroa:                 this._port = base._port;
Kode lerroa:                 this._username = base._username;
Kode lerroa:                 this._password = base._password;
Kode lerroa:                 this._path = base._path.slice();
Kode lerroa:                 this._path.pop();
Kode lerroa:               }
Kode lerroa:               state = 'relative path';
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'relative slash':
Kode lerroa:             if (c === '/' || c === '\\') {
Kode lerroa:               if (c === '\\') {
Kode lerroa:                 err('\\ is an invalid code point.');
Kode lerroa:               }
Kode lerroa:               if (this._scheme === 'file') {
Kode lerroa:                 state = 'file host';
Kode lerroa:               } else {
Kode lerroa:                 state = 'authority ignore slashes';
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               if (this._scheme !== 'file') {
Kode lerroa:                 this._host = base._host;
Kode lerroa:                 this._port = base._port;
Kode lerroa:                 this._username = base._username;
Kode lerroa:                 this._password = base._password;
Kode lerroa:               }
Kode lerroa:               state = 'relative path';
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'authority first slash':
Kode lerroa:             if (c === '/') {
Kode lerroa:               state = 'authority second slash';
Kode lerroa:             } else {
Kode lerroa:               err('Expected \'/\', got: ' + c);
Kode lerroa:               state = 'authority ignore slashes';
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'authority second slash':
Kode lerroa:             state = 'authority ignore slashes';
Kode lerroa:             if (c !== '/') {
Kode lerroa:               err('Expected \'/\', got: ' + c);
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'authority ignore slashes':
Kode lerroa:             if (c !== '/' && c !== '\\') {
Kode lerroa:               state = 'authority';
Kode lerroa:               continue;
Kode lerroa:             } else {
Kode lerroa:               err('Expected authority, got: ' + c);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'authority':
Kode lerroa:             if (c === '@') {
Kode lerroa:               if (seenAt) {
Kode lerroa:                 err('@ already seen.');
Kode lerroa:                 buffer += '%40';
Kode lerroa:               }
Kode lerroa:               seenAt = true;
Kode lerroa:               for (var i = 0; i < buffer.length; i++) {
Kode lerroa:                 var cp = buffer[i];
Kode lerroa:                 if (cp === '\t' || cp === '\n' || cp === '\r') {
Kode lerroa:                   err('Invalid whitespace in authority.');
Kode lerroa:                   continue;
Kode lerroa:                 }
Kode lerroa:                 if (cp === ':' && this._password === null) {
Kode lerroa:                   this._password = '';
Kode lerroa:                   continue;
Kode lerroa:                 }
Kode lerroa:                 var tempC = percentEscape(cp);
Kode lerroa:                 if (this._password !== null) {
Kode lerroa:                   this._password += tempC;
Kode lerroa:                 } else {
Kode lerroa:                   this._username += tempC;
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:               buffer = '';
Kode lerroa:             } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
Kode lerroa:               cursor -= buffer.length;
Kode lerroa:               buffer = '';
Kode lerroa:               state = 'host';
Kode lerroa:               continue;
Kode lerroa:             } else {
Kode lerroa:               buffer += c;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'file host':
Kode lerroa:             if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
Kode lerroa:               if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ':' || buffer[1] === '|')) {
Kode lerroa:                 state = 'relative path';
Kode lerroa:               } else if (buffer.length === 0) {
Kode lerroa:                 state = 'relative path start';
Kode lerroa:               } else {
Kode lerroa:                 this._host = IDNAToASCII.call(this, buffer);
Kode lerroa:                 buffer = '';
Kode lerroa:                 state = 'relative path start';
Kode lerroa:               }
Kode lerroa:               continue;
Kode lerroa:             } else if (c === '\t' || c === '\n' || c === '\r') {
Kode lerroa:               err('Invalid whitespace in file host.');
Kode lerroa:             } else {
Kode lerroa:               buffer += c;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'host':
Kode lerroa:           case 'hostname':
Kode lerroa:             if (c === ':' && !seenBracket) {
Kode lerroa:               this._host = IDNAToASCII.call(this, buffer);
Kode lerroa:               buffer = '';
Kode lerroa:               state = 'port';
Kode lerroa:               if (stateOverride === 'hostname') {
Kode lerroa:                 break loop;
Kode lerroa:               }
Kode lerroa:             } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
Kode lerroa:               this._host = IDNAToASCII.call(this, buffer);
Kode lerroa:               buffer = '';
Kode lerroa:               state = 'relative path start';
Kode lerroa:               if (stateOverride) {
Kode lerroa:                 break loop;
Kode lerroa:               }
Kode lerroa:               continue;
Kode lerroa:             } else if (c !== '\t' && c !== '\n' && c !== '\r') {
Kode lerroa:               if (c === '[') {
Kode lerroa:                 seenBracket = true;
Kode lerroa:               } else if (c === ']') {
Kode lerroa:                 seenBracket = false;
Kode lerroa:               }
Kode lerroa:               buffer += c;
Kode lerroa:             } else {
Kode lerroa:               err('Invalid code point in host/hostname: ' + c);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'port':
Kode lerroa:             if (/[0-9]/.test(c)) {
Kode lerroa:               buffer += c;
Kode lerroa:             } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#' || stateOverride) {
Kode lerroa:               if (buffer !== '') {
Kode lerroa:                 var temp = parseInt(buffer, 10);
Kode lerroa:                 if (temp !== relative[this._scheme]) {
Kode lerroa:                   this._port = temp + '';
Kode lerroa:                 }
Kode lerroa:                 buffer = '';
Kode lerroa:               }
Kode lerroa:               if (stateOverride) {
Kode lerroa:                 break loop;
Kode lerroa:               }
Kode lerroa:               state = 'relative path start';
Kode lerroa:               continue;
Kode lerroa:             } else if (c === '\t' || c === '\n' || c === '\r') {
Kode lerroa:               err('Invalid code point in port: ' + c);
Kode lerroa:             } else {
Kode lerroa:               invalid.call(this);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'relative path start':
Kode lerroa:             if (c === '\\') {
Kode lerroa:               err('\'\\\' not allowed in path.');
Kode lerroa:             }
Kode lerroa:             state = 'relative path';
Kode lerroa:             if (c !== '/' && c !== '\\') {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'relative path':
Kode lerroa:             if (c === EOF || c === '/' || c === '\\' || !stateOverride && (c === '?' || c === '#')) {
Kode lerroa:               if (c === '\\') {
Kode lerroa:                 err('\\ not allowed in relative path.');
Kode lerroa:               }
Kode lerroa:               var tmp;
Kode lerroa:               if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
Kode lerroa:                 buffer = tmp;
Kode lerroa:               }
Kode lerroa:               if (buffer === '..') {
Kode lerroa:                 this._path.pop();
Kode lerroa:                 if (c !== '/' && c !== '\\') {
Kode lerroa:                   this._path.push('');
Kode lerroa:                 }
Kode lerroa:               } else if (buffer === '.' && c !== '/' && c !== '\\') {
Kode lerroa:                 this._path.push('');
Kode lerroa:               } else if (buffer !== '.') {
Kode lerroa:                 if (this._scheme === 'file' && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === '|') {
Kode lerroa:                   buffer = buffer[0] + ':';
Kode lerroa:                 }
Kode lerroa:                 this._path.push(buffer);
Kode lerroa:               }
Kode lerroa:               buffer = '';
Kode lerroa:               if (c === '?') {
Kode lerroa:                 this._query = '?';
Kode lerroa:                 state = 'query';
Kode lerroa:               } else if (c === '#') {
Kode lerroa:                 this._fragment = '#';
Kode lerroa:                 state = 'fragment';
Kode lerroa:               }
Kode lerroa:             } else if (c !== '\t' && c !== '\n' && c !== '\r') {
Kode lerroa:               buffer += percentEscape(c);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'query':
Kode lerroa:             if (!stateOverride && c === '#') {
Kode lerroa:               this._fragment = '#';
Kode lerroa:               state = 'fragment';
Kode lerroa:             } else if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
Kode lerroa:               this._query += percentEscapeQuery(c);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'fragment':
Kode lerroa:             if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
Kode lerroa:               this._fragment += c;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         cursor++;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     function clear() {
Kode lerroa:       this._scheme = '';
Kode lerroa:       this._schemeData = '';
Kode lerroa:       this._username = '';
Kode lerroa:       this._password = null;
Kode lerroa:       this._host = '';
Kode lerroa:       this._port = '';
Kode lerroa:       this._path = [];
Kode lerroa:       this._query = '';
Kode lerroa:       this._fragment = '';
Kode lerroa:       this._isInvalid = false;
Kode lerroa:       this._isRelative = false;
Kode lerroa:     }
Kode lerroa:     function JURL(url, base) {
Kode lerroa:       if (base !== undefined && !(base instanceof JURL)) {
Kode lerroa:         base = new JURL(String(base));
Kode lerroa:       }
Kode lerroa:       this._url = url;
Kode lerroa:       clear.call(this);
Kode lerroa:       var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
Kode lerroa:       parse.call(this, input, null, base);
Kode lerroa:     }
Kode lerroa:     JURL.prototype = {
Kode lerroa:       toString: function toString() {
Kode lerroa:         return this.href;
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       get href() {
Kode lerroa:         if (this._isInvalid) {
Kode lerroa:           return this._url;
Kode lerroa:         }
Kode lerroa:         var authority = '';
Kode lerroa:         if (this._username !== '' || this._password !== null) {
Kode lerroa:           authority = this._username + (this._password !== null ? ':' + this._password : '') + '@';
Kode lerroa:         }
Kode lerroa:         return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;
Kode lerroa:       },
Kode lerroa:       set href(value) {
Kode lerroa:         clear.call(this);
Kode lerroa:         parse.call(this, value);
Kode lerroa:       },
Kode lerroa:       get protocol() {
Kode lerroa:         return this._scheme + ':';
Kode lerroa:       },
Kode lerroa:       set protocol(value) {
Kode lerroa:         if (this._isInvalid) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         parse.call(this, value + ':', 'scheme start');
Kode lerroa:       },
Kode lerroa:       get host() {
Kode lerroa:         return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
Kode lerroa:       },
Kode lerroa:       set host(value) {
Kode lerroa:         if (this._isInvalid || !this._isRelative) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         parse.call(this, value, 'host');
Kode lerroa:       },
Kode lerroa:       get hostname() {
Kode lerroa:         return this._host;
Kode lerroa:       },
Kode lerroa:       set hostname(value) {
Kode lerroa:         if (this._isInvalid || !this._isRelative) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         parse.call(this, value, 'hostname');
Kode lerroa:       },
Kode lerroa:       get port() {
Kode lerroa:         return this._port;
Kode lerroa:       },
Kode lerroa:       set port(value) {
Kode lerroa:         if (this._isInvalid || !this._isRelative) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         parse.call(this, value, 'port');
Kode lerroa:       },
Kode lerroa:       get pathname() {
Kode lerroa:         return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
Kode lerroa:       },
Kode lerroa:       set pathname(value) {
Kode lerroa:         if (this._isInvalid || !this._isRelative) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this._path = [];
Kode lerroa:         parse.call(this, value, 'relative path start');
Kode lerroa:       },
Kode lerroa:       get search() {
Kode lerroa:         return this._isInvalid || !this._query || this._query === '?' ? '' : this._query;
Kode lerroa:       },
Kode lerroa:       set search(value) {
Kode lerroa:         if (this._isInvalid || !this._isRelative) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this._query = '?';
Kode lerroa:         if (value[0] === '?') {
Kode lerroa:           value = value.slice(1);
Kode lerroa:         }
Kode lerroa:         parse.call(this, value, 'query');
Kode lerroa:       },
Kode lerroa:       get hash() {
Kode lerroa:         return this._isInvalid || !this._fragment || this._fragment === '#' ? '' : this._fragment;
Kode lerroa:       },
Kode lerroa:       set hash(value) {
Kode lerroa:         if (this._isInvalid) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this._fragment = '#';
Kode lerroa:         if (value[0] === '#') {
Kode lerroa:           value = value.slice(1);
Kode lerroa:         }
Kode lerroa:         parse.call(this, value, 'fragment');
Kode lerroa:       },
Kode lerroa:       get origin() {
Kode lerroa:         var host;
Kode lerroa:         if (this._isInvalid || !this._scheme) {
Kode lerroa:           return '';
Kode lerroa:         }
Kode lerroa:         switch (this._scheme) {
Kode lerroa:           case 'data':
Kode lerroa:           case 'file':
Kode lerroa:           case 'javascript':
Kode lerroa:           case 'mailto':
Kode lerroa:             return 'null';
Kode lerroa:           case 'blob':
Kode lerroa:             try {
Kode lerroa:               return new JURL(this._schemeData).origin || 'null';
Kode lerroa:             } catch (_) {}
Kode lerroa:             return 'null';
Kode lerroa:         }
Kode lerroa:         host = this.host;
Kode lerroa:         if (!host) {
Kode lerroa:           return '';
Kode lerroa:         }
Kode lerroa:         return this._scheme + '://' + host;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     var OriginalURL = globalScope.URL;
Kode lerroa:     if (OriginalURL) {
Kode lerroa:       JURL.createObjectURL = function (blob) {
Kode lerroa:         return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
Kode lerroa:       };
Kode lerroa:       JURL.revokeObjectURL = function (url) {
Kode lerroa:         OriginalURL.revokeObjectURL(url);
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     globalScope.URL = JURL;
Kode lerroa:   })();
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 77 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(78);
Kode lerroa: module.exports = __w_pdfjs_require__(4).Uint8ClampedArray;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 78 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(79)('Uint8', 1, function (init) {
Kode lerroa:   return function Uint8ClampedArray(data, byteOffset, length) {
Kode lerroa:     return init(this, data, byteOffset, length);
Kode lerroa:   };
Kode lerroa: }, true);
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 79 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: if (__w_pdfjs_require__(8)) {
Kode lerroa:   var LIBRARY = __w_pdfjs_require__(21);
Kode lerroa:   var global = __w_pdfjs_require__(1);
Kode lerroa:   var fails = __w_pdfjs_require__(9);
Kode lerroa:   var $export = __w_pdfjs_require__(5);
Kode lerroa:   var $typed = __w_pdfjs_require__(46);
Kode lerroa:   var $buffer = __w_pdfjs_require__(80);
Kode lerroa:   var ctx = __w_pdfjs_require__(11);
Kode lerroa:   var anInstance = __w_pdfjs_require__(24);
Kode lerroa:   var propertyDesc = __w_pdfjs_require__(27);
Kode lerroa:   var hide = __w_pdfjs_require__(6);
Kode lerroa:   var redefineAll = __w_pdfjs_require__(23);
Kode lerroa:   var toInteger = __w_pdfjs_require__(17);
Kode lerroa:   var toLength = __w_pdfjs_require__(12);
Kode lerroa:   var toIndex = __w_pdfjs_require__(47);
Kode lerroa:   var toAbsoluteIndex = __w_pdfjs_require__(29);
Kode lerroa:   var toPrimitive = __w_pdfjs_require__(33);
Kode lerroa:   var has = __w_pdfjs_require__(10);
Kode lerroa:   var classof = __w_pdfjs_require__(30);
Kode lerroa:   var isObject = __w_pdfjs_require__(2);
Kode lerroa:   var toObject = __w_pdfjs_require__(18);
Kode lerroa:   var isArrayIter = __w_pdfjs_require__(53);
Kode lerroa:   var create = __w_pdfjs_require__(54);
Kode lerroa:   var getPrototypeOf = __w_pdfjs_require__(56);
Kode lerroa:   var gOPN = __w_pdfjs_require__(48).f;
Kode lerroa:   var getIterFn = __w_pdfjs_require__(57);
Kode lerroa:   var uid = __w_pdfjs_require__(16);
Kode lerroa:   var wks = __w_pdfjs_require__(3);
Kode lerroa:   var createArrayMethod = __w_pdfjs_require__(39);
Kode lerroa:   var createArrayIncludes = __w_pdfjs_require__(50);
Kode lerroa:   var speciesConstructor = __w_pdfjs_require__(40);
Kode lerroa:   var ArrayIterators = __w_pdfjs_require__(58);
Kode lerroa:   var Iterators = __w_pdfjs_require__(19);
Kode lerroa:   var $iterDetect = __w_pdfjs_require__(41);
Kode lerroa:   var setSpecies = __w_pdfjs_require__(60);
Kode lerroa:   var arrayFill = __w_pdfjs_require__(52);
Kode lerroa:   var arrayCopyWithin = __w_pdfjs_require__(88);
Kode lerroa:   var $DP = __w_pdfjs_require__(13);
Kode lerroa:   var $GOPD = __w_pdfjs_require__(61);
Kode lerroa:   var dP = $DP.f;
Kode lerroa:   var gOPD = $GOPD.f;
Kode lerroa:   var RangeError = global.RangeError;
Kode lerroa:   var TypeError = global.TypeError;
Kode lerroa:   var Uint8Array = global.Uint8Array;
Kode lerroa:   var ARRAY_BUFFER = 'ArrayBuffer';
Kode lerroa:   var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
Kode lerroa:   var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
Kode lerroa:   var PROTOTYPE = 'prototype';
Kode lerroa:   var ArrayProto = Array[PROTOTYPE];
Kode lerroa:   var $ArrayBuffer = $buffer.ArrayBuffer;
Kode lerroa:   var $DataView = $buffer.DataView;
Kode lerroa:   var arrayForEach = createArrayMethod(0);
Kode lerroa:   var arrayFilter = createArrayMethod(2);
Kode lerroa:   var arraySome = createArrayMethod(3);
Kode lerroa:   var arrayEvery = createArrayMethod(4);
Kode lerroa:   var arrayFind = createArrayMethod(5);
Kode lerroa:   var arrayFindIndex = createArrayMethod(6);
Kode lerroa:   var arrayIncludes = createArrayIncludes(true);
Kode lerroa:   var arrayIndexOf = createArrayIncludes(false);
Kode lerroa:   var arrayValues = ArrayIterators.values;
Kode lerroa:   var arrayKeys = ArrayIterators.keys;
Kode lerroa:   var arrayEntries = ArrayIterators.entries;
Kode lerroa:   var arrayLastIndexOf = ArrayProto.lastIndexOf;
Kode lerroa:   var arrayReduce = ArrayProto.reduce;
Kode lerroa:   var arrayReduceRight = ArrayProto.reduceRight;
Kode lerroa:   var arrayJoin = ArrayProto.join;
Kode lerroa:   var arraySort = ArrayProto.sort;
Kode lerroa:   var arraySlice = ArrayProto.slice;
Kode lerroa:   var arrayToString = ArrayProto.toString;
Kode lerroa:   var arrayToLocaleString = ArrayProto.toLocaleString;
Kode lerroa:   var ITERATOR = wks('iterator');
Kode lerroa:   var TAG = wks('toStringTag');
Kode lerroa:   var TYPED_CONSTRUCTOR = uid('typed_constructor');
Kode lerroa:   var DEF_CONSTRUCTOR = uid('def_constructor');
Kode lerroa:   var ALL_CONSTRUCTORS = $typed.CONSTR;
Kode lerroa:   var TYPED_ARRAY = $typed.TYPED;
Kode lerroa:   var VIEW = $typed.VIEW;
Kode lerroa:   var WRONG_LENGTH = 'Wrong length!';
Kode lerroa:   var $map = createArrayMethod(1, function (O, length) {
Kode lerroa:     return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
Kode lerroa:   });
Kode lerroa:   var LITTLE_ENDIAN = fails(function () {
Kode lerroa:     return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
Kode lerroa:   });
Kode lerroa:   var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
Kode lerroa:     new Uint8Array(1).set({});
Kode lerroa:   });
Kode lerroa:   var toOffset = function toOffset(it, BYTES) {
Kode lerroa:     var offset = toInteger(it);
Kode lerroa:     if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
Kode lerroa:     return offset;
Kode lerroa:   };
Kode lerroa:   var validate = function validate(it) {
Kode lerroa:     if (isObject(it) && TYPED_ARRAY in it) return it;
Kode lerroa:     throw TypeError(it + ' is not a typed array!');
Kode lerroa:   };
Kode lerroa:   var allocate = function allocate(C, length) {
Kode lerroa:     if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
Kode lerroa:       throw TypeError('It is not a typed array constructor!');
Kode lerroa:     }
Kode lerroa:     return new C(length);
Kode lerroa:   };
Kode lerroa:   var speciesFromList = function speciesFromList(O, list) {
Kode lerroa:     return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
Kode lerroa:   };
Kode lerroa:   var fromList = function fromList(C, list) {
Kode lerroa:     var index = 0;
Kode lerroa:     var length = list.length;
Kode lerroa:     var result = allocate(C, length);
Kode lerroa:     while (length > index) {
Kode lerroa:       result[index] = list[index++];
Kode lerroa:     }return result;
Kode lerroa:   };
Kode lerroa:   var addGetter = function addGetter(it, key, internal) {
Kode lerroa:     dP(it, key, {
Kode lerroa:       get: function get() {
Kode lerroa:         return this._d[internal];
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:   };
Kode lerroa:   var $from = function from(source) {
Kode lerroa:     var O = toObject(source);
Kode lerroa:     var aLen = arguments.length;
Kode lerroa:     var mapfn = aLen > 1 ? arguments[1] : undefined;
Kode lerroa:     var mapping = mapfn !== undefined;
Kode lerroa:     var iterFn = getIterFn(O);
Kode lerroa:     var i, length, values, result, step, iterator;
Kode lerroa:     if (iterFn != undefined && !isArrayIter(iterFn)) {
Kode lerroa:       for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
Kode lerroa:         values.push(step.value);
Kode lerroa:       }
Kode lerroa:       O = values;
Kode lerroa:     }
Kode lerroa:     if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
Kode lerroa:     for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
Kode lerroa:       result[i] = mapping ? mapfn(O[i], i) : O[i];
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   };
Kode lerroa:   var $of = function of() {
Kode lerroa:     var index = 0;
Kode lerroa:     var length = arguments.length;
Kode lerroa:     var result = allocate(this, length);
Kode lerroa:     while (length > index) {
Kode lerroa:       result[index] = arguments[index++];
Kode lerroa:     }return result;
Kode lerroa:   };
Kode lerroa:   var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
Kode lerroa:     arrayToLocaleString.call(new Uint8Array(1));
Kode lerroa:   });
Kode lerroa:   var $toLocaleString = function toLocaleString() {
Kode lerroa:     return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
Kode lerroa:   };
Kode lerroa:   var proto = {
Kode lerroa:     copyWithin: function copyWithin(target, start) {
Kode lerroa:       return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
Kode lerroa:     },
Kode lerroa:     every: function every(callbackfn) {
Kode lerroa:       return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     fill: function fill(value) {
Kode lerroa:       return arrayFill.apply(validate(this), arguments);
Kode lerroa:     },
Kode lerroa:     filter: function filter(callbackfn) {
Kode lerroa:       return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
Kode lerroa:     },
Kode lerroa:     find: function find(predicate) {
Kode lerroa:       return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     findIndex: function findIndex(predicate) {
Kode lerroa:       return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     forEach: function forEach(callbackfn) {
Kode lerroa:       arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     indexOf: function indexOf(searchElement) {
Kode lerroa:       return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     includes: function includes(searchElement) {
Kode lerroa:       return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     join: function join(separator) {
Kode lerroa:       return arrayJoin.apply(validate(this), arguments);
Kode lerroa:     },
Kode lerroa:     lastIndexOf: function lastIndexOf(searchElement) {
Kode lerroa:       return arrayLastIndexOf.apply(validate(this), arguments);
Kode lerroa:     },
Kode lerroa:     map: function map(mapfn) {
Kode lerroa:       return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     reduce: function reduce(callbackfn) {
Kode lerroa:       return arrayReduce.apply(validate(this), arguments);
Kode lerroa:     },
Kode lerroa:     reduceRight: function reduceRight(callbackfn) {
Kode lerroa:       return arrayReduceRight.apply(validate(this), arguments);
Kode lerroa:     },
Kode lerroa:     reverse: function reverse() {
Kode lerroa:       var that = this;
Kode lerroa:       var length = validate(that).length;
Kode lerroa:       var middle = Math.floor(length / 2);
Kode lerroa:       var index = 0;
Kode lerroa:       var value;
Kode lerroa:       while (index < middle) {
Kode lerroa:         value = that[index];
Kode lerroa:         that[index++] = that[--length];
Kode lerroa:         that[length] = value;
Kode lerroa:       }
Kode lerroa:       return that;
Kode lerroa:     },
Kode lerroa:     some: function some(callbackfn) {
Kode lerroa:       return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
Kode lerroa:     },
Kode lerroa:     sort: function sort(comparefn) {
Kode lerroa:       return arraySort.call(validate(this), comparefn);
Kode lerroa:     },
Kode lerroa:     subarray: function subarray(begin, end) {
Kode lerroa:       var O = validate(this);
Kode lerroa:       var length = O.length;
Kode lerroa:       var $begin = toAbsoluteIndex(begin, length);
Kode lerroa:       return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   var $slice = function slice(start, end) {
Kode lerroa:     return speciesFromList(this, arraySlice.call(validate(this), start, end));
Kode lerroa:   };
Kode lerroa:   var $set = function set(arrayLike) {
Kode lerroa:     validate(this);
Kode lerroa:     var offset = toOffset(arguments[1], 1);
Kode lerroa:     var length = this.length;
Kode lerroa:     var src = toObject(arrayLike);
Kode lerroa:     var len = toLength(src.length);
Kode lerroa:     var index = 0;
Kode lerroa:     if (len + offset > length) throw RangeError(WRONG_LENGTH);
Kode lerroa:     while (index < len) {
Kode lerroa:       this[offset + index] = src[index++];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   var $iterators = {
Kode lerroa:     entries: function entries() {
Kode lerroa:       return arrayEntries.call(validate(this));
Kode lerroa:     },
Kode lerroa:     keys: function keys() {
Kode lerroa:       return arrayKeys.call(validate(this));
Kode lerroa:     },
Kode lerroa:     values: function values() {
Kode lerroa:       return arrayValues.call(validate(this));
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   var isTAIndex = function isTAIndex(target, key) {
Kode lerroa:     return isObject(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
Kode lerroa:   };
Kode lerroa:   var $getDesc = function getOwnPropertyDescriptor(target, key) {
Kode lerroa:     return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
Kode lerroa:   };
Kode lerroa:   var $setDesc = function defineProperty(target, key, desc) {
Kode lerroa:     if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
Kode lerroa:       target[key] = desc.value;
Kode lerroa:       return target;
Kode lerroa:     }
Kode lerroa:     return dP(target, key, desc);
Kode lerroa:   };
Kode lerroa:   if (!ALL_CONSTRUCTORS) {
Kode lerroa:     $GOPD.f = $getDesc;
Kode lerroa:     $DP.f = $setDesc;
Kode lerroa:   }
Kode lerroa:   $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
Kode lerroa:     getOwnPropertyDescriptor: $getDesc,
Kode lerroa:     defineProperty: $setDesc
Kode lerroa:   });
Kode lerroa:   if (fails(function () {
Kode lerroa:     arrayToString.call({});
Kode lerroa:   })) {
Kode lerroa:     arrayToString = arrayToLocaleString = function toString() {
Kode lerroa:       return arrayJoin.call(this);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   var $TypedArrayPrototype$ = redefineAll({}, proto);
Kode lerroa:   redefineAll($TypedArrayPrototype$, $iterators);
Kode lerroa:   hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
Kode lerroa:   redefineAll($TypedArrayPrototype$, {
Kode lerroa:     slice: $slice,
Kode lerroa:     set: $set,
Kode lerroa:     constructor: function constructor() {},
Kode lerroa:     toString: arrayToString,
Kode lerroa:     toLocaleString: $toLocaleString
Kode lerroa:   });
Kode lerroa:   addGetter($TypedArrayPrototype$, 'buffer', 'b');
Kode lerroa:   addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
Kode lerroa:   addGetter($TypedArrayPrototype$, 'byteLength', 'l');
Kode lerroa:   addGetter($TypedArrayPrototype$, 'length', 'e');
Kode lerroa:   dP($TypedArrayPrototype$, TAG, {
Kode lerroa:     get: function get() {
Kode lerroa:       return this[TYPED_ARRAY];
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa:   module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
Kode lerroa:     CLAMPED = !!CLAMPED;
Kode lerroa:     var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
Kode lerroa:     var GETTER = 'get' + KEY;
Kode lerroa:     var SETTER = 'set' + KEY;
Kode lerroa:     var TypedArray = global[NAME];
Kode lerroa:     var Base = TypedArray || {};
Kode lerroa:     var TAC = TypedArray && getPrototypeOf(TypedArray);
Kode lerroa:     var FORCED = !TypedArray || !$typed.ABV;
Kode lerroa:     var O = {};
Kode lerroa:     var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
Kode lerroa:     var getter = function getter(that, index) {
Kode lerroa:       var data = that._d;
Kode lerroa:       return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
Kode lerroa:     };
Kode lerroa:     var setter = function setter(that, index, value) {
Kode lerroa:       var data = that._d;
Kode lerroa:       if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
Kode lerroa:       data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
Kode lerroa:     };
Kode lerroa:     var addElement = function addElement(that, index) {
Kode lerroa:       dP(that, index, {
Kode lerroa:         get: function get() {
Kode lerroa:           return getter(this, index);
Kode lerroa:         },
Kode lerroa:         set: function set(value) {
Kode lerroa:           return setter(this, index, value);
Kode lerroa:         },
Kode lerroa:         enumerable: true
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     if (FORCED) {
Kode lerroa:       TypedArray = wrapper(function (that, data, $offset, $length) {
Kode lerroa:         anInstance(that, TypedArray, NAME, '_d');
Kode lerroa:         var index = 0;
Kode lerroa:         var offset = 0;
Kode lerroa:         var buffer, byteLength, length, klass;
Kode lerroa:         if (!isObject(data)) {
Kode lerroa:           length = toIndex(data);
Kode lerroa:           byteLength = length * BYTES;
Kode lerroa:           buffer = new $ArrayBuffer(byteLength);
Kode lerroa:         } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
Kode lerroa:           buffer = data;
Kode lerroa:           offset = toOffset($offset, BYTES);
Kode lerroa:           var $len = data.byteLength;
Kode lerroa:           if ($length === undefined) {
Kode lerroa:             if ($len % BYTES) throw RangeError(WRONG_LENGTH);
Kode lerroa:             byteLength = $len - offset;
Kode lerroa:             if (byteLength < 0) throw RangeError(WRONG_LENGTH);
Kode lerroa:           } else {
Kode lerroa:             byteLength = toLength($length) * BYTES;
Kode lerroa:             if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
Kode lerroa:           }
Kode lerroa:           length = byteLength / BYTES;
Kode lerroa:         } else if (TYPED_ARRAY in data) {
Kode lerroa:           return fromList(TypedArray, data);
Kode lerroa:         } else {
Kode lerroa:           return $from.call(TypedArray, data);
Kode lerroa:         }
Kode lerroa:         hide(that, '_d', {
Kode lerroa:           b: buffer,
Kode lerroa:           o: offset,
Kode lerroa:           l: byteLength,
Kode lerroa:           e: length,
Kode lerroa:           v: new $DataView(buffer)
Kode lerroa:         });
Kode lerroa:         while (index < length) {
Kode lerroa:           addElement(that, index++);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
Kode lerroa:       hide(TypedArrayPrototype, 'constructor', TypedArray);
Kode lerroa:     } else if (!fails(function () {
Kode lerroa:       TypedArray(1);
Kode lerroa:     }) || !fails(function () {
Kode lerroa:       new TypedArray(-1);
Kode lerroa:     }) || !$iterDetect(function (iter) {
Kode lerroa:       new TypedArray();
Kode lerroa:       new TypedArray(null);
Kode lerroa:       new TypedArray(1.5);
Kode lerroa:       new TypedArray(iter);
Kode lerroa:     }, true)) {
Kode lerroa:       TypedArray = wrapper(function (that, data, $offset, $length) {
Kode lerroa:         anInstance(that, TypedArray, NAME);
Kode lerroa:         var klass;
Kode lerroa:         if (!isObject(data)) return new Base(toIndex(data));
Kode lerroa:         if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
Kode lerroa:           return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
Kode lerroa:         }
Kode lerroa:         if (TYPED_ARRAY in data) return fromList(TypedArray, data);
Kode lerroa:         return $from.call(TypedArray, data);
Kode lerroa:       });
Kode lerroa:       arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
Kode lerroa:         if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
Kode lerroa:       });
Kode lerroa:       TypedArray[PROTOTYPE] = TypedArrayPrototype;
Kode lerroa:       if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
Kode lerroa:     }
Kode lerroa:     var $nativeIterator = TypedArrayPrototype[ITERATOR];
Kode lerroa:     var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
Kode lerroa:     var $iterator = $iterators.values;
Kode lerroa:     hide(TypedArray, TYPED_CONSTRUCTOR, true);
Kode lerroa:     hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
Kode lerroa:     hide(TypedArrayPrototype, VIEW, true);
Kode lerroa:     hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
Kode lerroa:     if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
Kode lerroa:       dP(TypedArrayPrototype, TAG, {
Kode lerroa:         get: function get() {
Kode lerroa:           return NAME;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     O[NAME] = TypedArray;
Kode lerroa:     $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
Kode lerroa:     $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES });
Kode lerroa:     $export($export.S + $export.F * fails(function () {
Kode lerroa:       Base.of.call(TypedArray, 1);
Kode lerroa:     }), NAME, {
Kode lerroa:       from: $from,
Kode lerroa:       of: $of
Kode lerroa:     });
Kode lerroa:     if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
Kode lerroa:     $export($export.P, NAME, proto);
Kode lerroa:     setSpecies(NAME);
Kode lerroa:     $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });
Kode lerroa:     $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
Kode lerroa:     if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
Kode lerroa:     $export($export.P + $export.F * fails(function () {
Kode lerroa:       new TypedArray(1).slice();
Kode lerroa:     }), NAME, { slice: $slice });
Kode lerroa:     $export($export.P + $export.F * (fails(function () {
Kode lerroa:       return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
Kode lerroa:     }) || !fails(function () {
Kode lerroa:       TypedArrayPrototype.toLocaleString.call([1, 2]);
Kode lerroa:     })), NAME, { toLocaleString: $toLocaleString });
Kode lerroa:     Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
Kode lerroa:     if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
Kode lerroa:   };
Kode lerroa: } else module.exports = function () {};
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 80 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var DESCRIPTORS = __w_pdfjs_require__(8);
Kode lerroa: var LIBRARY = __w_pdfjs_require__(21);
Kode lerroa: var $typed = __w_pdfjs_require__(46);
Kode lerroa: var hide = __w_pdfjs_require__(6);
Kode lerroa: var redefineAll = __w_pdfjs_require__(23);
Kode lerroa: var fails = __w_pdfjs_require__(9);
Kode lerroa: var anInstance = __w_pdfjs_require__(24);
Kode lerroa: var toInteger = __w_pdfjs_require__(17);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: var toIndex = __w_pdfjs_require__(47);
Kode lerroa: var gOPN = __w_pdfjs_require__(48).f;
Kode lerroa: var dP = __w_pdfjs_require__(13).f;
Kode lerroa: var arrayFill = __w_pdfjs_require__(52);
Kode lerroa: var setToStringTag = __w_pdfjs_require__(26);
Kode lerroa: var ARRAY_BUFFER = 'ArrayBuffer';
Kode lerroa: var DATA_VIEW = 'DataView';
Kode lerroa: var PROTOTYPE = 'prototype';
Kode lerroa: var WRONG_LENGTH = 'Wrong length!';
Kode lerroa: var WRONG_INDEX = 'Wrong index!';
Kode lerroa: var $ArrayBuffer = global[ARRAY_BUFFER];
Kode lerroa: var $DataView = global[DATA_VIEW];
Kode lerroa: var Math = global.Math;
Kode lerroa: var RangeError = global.RangeError;
Kode lerroa: var Infinity = global.Infinity;
Kode lerroa: var BaseBuffer = $ArrayBuffer;
Kode lerroa: var abs = Math.abs;
Kode lerroa: var pow = Math.pow;
Kode lerroa: var floor = Math.floor;
Kode lerroa: var log = Math.log;
Kode lerroa: var LN2 = Math.LN2;
Kode lerroa: var BUFFER = 'buffer';
Kode lerroa: var BYTE_LENGTH = 'byteLength';
Kode lerroa: var BYTE_OFFSET = 'byteOffset';
Kode lerroa: var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
Kode lerroa: var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
Kode lerroa: var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
Kode lerroa: function packIEEE754(value, mLen, nBytes) {
Kode lerroa:   var buffer = new Array(nBytes);
Kode lerroa:   var eLen = nBytes * 8 - mLen - 1;
Kode lerroa:   var eMax = (1 << eLen) - 1;
Kode lerroa:   var eBias = eMax >> 1;
Kode lerroa:   var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
Kode lerroa:   var i = 0;
Kode lerroa:   var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
Kode lerroa:   var e, m, c;
Kode lerroa:   value = abs(value);
Kode lerroa:   if (value != value || value === Infinity) {
Kode lerroa:     m = value != value ? 1 : 0;
Kode lerroa:     e = eMax;
Kode lerroa:   } else {
Kode lerroa:     e = floor(log(value) / LN2);
Kode lerroa:     if (value * (c = pow(2, -e)) < 1) {
Kode lerroa:       e--;
Kode lerroa:       c *= 2;
Kode lerroa:     }
Kode lerroa:     if (e + eBias >= 1) {
Kode lerroa:       value += rt / c;
Kode lerroa:     } else {
Kode lerroa:       value += rt * pow(2, 1 - eBias);
Kode lerroa:     }
Kode lerroa:     if (value * c >= 2) {
Kode lerroa:       e++;
Kode lerroa:       c /= 2;
Kode lerroa:     }
Kode lerroa:     if (e + eBias >= eMax) {
Kode lerroa:       m = 0;
Kode lerroa:       e = eMax;
Kode lerroa:     } else if (e + eBias >= 1) {
Kode lerroa:       m = (value * c - 1) * pow(2, mLen);
Kode lerroa:       e = e + eBias;
Kode lerroa:     } else {
Kode lerroa:       m = value * pow(2, eBias - 1) * pow(2, mLen);
Kode lerroa:       e = 0;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
Kode lerroa:   e = e << mLen | m;
Kode lerroa:   eLen += mLen;
Kode lerroa:   for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
Kode lerroa:   buffer[--i] |= s * 128;
Kode lerroa:   return buffer;
Kode lerroa: }
Kode lerroa: function unpackIEEE754(buffer, mLen, nBytes) {
Kode lerroa:   var eLen = nBytes * 8 - mLen - 1;
Kode lerroa:   var eMax = (1 << eLen) - 1;
Kode lerroa:   var eBias = eMax >> 1;
Kode lerroa:   var nBits = eLen - 7;
Kode lerroa:   var i = nBytes - 1;
Kode lerroa:   var s = buffer[i--];
Kode lerroa:   var e = s & 127;
Kode lerroa:   var m;
Kode lerroa:   s >>= 7;
Kode lerroa:   for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
Kode lerroa:   m = e & (1 << -nBits) - 1;
Kode lerroa:   e >>= -nBits;
Kode lerroa:   nBits += mLen;
Kode lerroa:   for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
Kode lerroa:   if (e === 0) {
Kode lerroa:     e = 1 - eBias;
Kode lerroa:   } else if (e === eMax) {
Kode lerroa:     return m ? NaN : s ? -Infinity : Infinity;
Kode lerroa:   } else {
Kode lerroa:     m = m + pow(2, mLen);
Kode lerroa:     e = e - eBias;
Kode lerroa:   }
Kode lerroa:   return (s ? -1 : 1) * m * pow(2, e - mLen);
Kode lerroa: }
Kode lerroa: function unpackI32(bytes) {
Kode lerroa:   return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
Kode lerroa: }
Kode lerroa: function packI8(it) {
Kode lerroa:   return [it & 0xff];
Kode lerroa: }
Kode lerroa: function packI16(it) {
Kode lerroa:   return [it & 0xff, it >> 8 & 0xff];
Kode lerroa: }
Kode lerroa: function packI32(it) {
Kode lerroa:   return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
Kode lerroa: }
Kode lerroa: function packF64(it) {
Kode lerroa:   return packIEEE754(it, 52, 8);
Kode lerroa: }
Kode lerroa: function packF32(it) {
Kode lerroa:   return packIEEE754(it, 23, 4);
Kode lerroa: }
Kode lerroa: function addGetter(C, key, internal) {
Kode lerroa:   dP(C[PROTOTYPE], key, {
Kode lerroa:     get: function get() {
Kode lerroa:       return this[internal];
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function get(view, bytes, index, isLittleEndian) {
Kode lerroa:   var numIndex = +index;
Kode lerroa:   var intIndex = toIndex(numIndex);
Kode lerroa:   if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
Kode lerroa:   var store = view[$BUFFER]._b;
Kode lerroa:   var start = intIndex + view[$OFFSET];
Kode lerroa:   var pack = store.slice(start, start + bytes);
Kode lerroa:   return isLittleEndian ? pack : pack.reverse();
Kode lerroa: }
Kode lerroa: function set(view, bytes, index, conversion, value, isLittleEndian) {
Kode lerroa:   var numIndex = +index;
Kode lerroa:   var intIndex = toIndex(numIndex);
Kode lerroa:   if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
Kode lerroa:   var store = view[$BUFFER]._b;
Kode lerroa:   var start = intIndex + view[$OFFSET];
Kode lerroa:   var pack = conversion(+value);
Kode lerroa:   for (var i = 0; i < bytes; i++) {
Kode lerroa:     store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: if (!$typed.ABV) {
Kode lerroa:   $ArrayBuffer = function ArrayBuffer(length) {
Kode lerroa:     anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
Kode lerroa:     var byteLength = toIndex(length);
Kode lerroa:     this._b = arrayFill.call(new Array(byteLength), 0);
Kode lerroa:     this[$LENGTH] = byteLength;
Kode lerroa:   };
Kode lerroa:   $DataView = function DataView(buffer, byteOffset, byteLength) {
Kode lerroa:     anInstance(this, $DataView, DATA_VIEW);
Kode lerroa:     anInstance(buffer, $ArrayBuffer, DATA_VIEW);
Kode lerroa:     var bufferLength = buffer[$LENGTH];
Kode lerroa:     var offset = toInteger(byteOffset);
Kode lerroa:     if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
Kode lerroa:     byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
Kode lerroa:     if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
Kode lerroa:     this[$BUFFER] = buffer;
Kode lerroa:     this[$OFFSET] = offset;
Kode lerroa:     this[$LENGTH] = byteLength;
Kode lerroa:   };
Kode lerroa:   if (DESCRIPTORS) {
Kode lerroa:     addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
Kode lerroa:     addGetter($DataView, BUFFER, '_b');
Kode lerroa:     addGetter($DataView, BYTE_LENGTH, '_l');
Kode lerroa:     addGetter($DataView, BYTE_OFFSET, '_o');
Kode lerroa:   }
Kode lerroa:   redefineAll($DataView[PROTOTYPE], {
Kode lerroa:     getInt8: function getInt8(byteOffset) {
Kode lerroa:       return get(this, 1, byteOffset)[0] << 24 >> 24;
Kode lerroa:     },
Kode lerroa:     getUint8: function getUint8(byteOffset) {
Kode lerroa:       return get(this, 1, byteOffset)[0];
Kode lerroa:     },
Kode lerroa:     getInt16: function getInt16(byteOffset) {
Kode lerroa:       var bytes = get(this, 2, byteOffset, arguments[1]);
Kode lerroa:       return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
Kode lerroa:     },
Kode lerroa:     getUint16: function getUint16(byteOffset) {
Kode lerroa:       var bytes = get(this, 2, byteOffset, arguments[1]);
Kode lerroa:       return bytes[1] << 8 | bytes[0];
Kode lerroa:     },
Kode lerroa:     getInt32: function getInt32(byteOffset) {
Kode lerroa:       return unpackI32(get(this, 4, byteOffset, arguments[1]));
Kode lerroa:     },
Kode lerroa:     getUint32: function getUint32(byteOffset) {
Kode lerroa:       return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
Kode lerroa:     },
Kode lerroa:     getFloat32: function getFloat32(byteOffset) {
Kode lerroa:       return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
Kode lerroa:     },
Kode lerroa:     getFloat64: function getFloat64(byteOffset) {
Kode lerroa:       return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
Kode lerroa:     },
Kode lerroa:     setInt8: function setInt8(byteOffset, value) {
Kode lerroa:       set(this, 1, byteOffset, packI8, value);
Kode lerroa:     },
Kode lerroa:     setUint8: function setUint8(byteOffset, value) {
Kode lerroa:       set(this, 1, byteOffset, packI8, value);
Kode lerroa:     },
Kode lerroa:     setInt16: function setInt16(byteOffset, value) {
Kode lerroa:       set(this, 2, byteOffset, packI16, value, arguments[2]);
Kode lerroa:     },
Kode lerroa:     setUint16: function setUint16(byteOffset, value) {
Kode lerroa:       set(this, 2, byteOffset, packI16, value, arguments[2]);
Kode lerroa:     },
Kode lerroa:     setInt32: function setInt32(byteOffset, value) {
Kode lerroa:       set(this, 4, byteOffset, packI32, value, arguments[2]);
Kode lerroa:     },
Kode lerroa:     setUint32: function setUint32(byteOffset, value) {
Kode lerroa:       set(this, 4, byteOffset, packI32, value, arguments[2]);
Kode lerroa:     },
Kode lerroa:     setFloat32: function setFloat32(byteOffset, value) {
Kode lerroa:       set(this, 4, byteOffset, packF32, value, arguments[2]);
Kode lerroa:     },
Kode lerroa:     setFloat64: function setFloat64(byteOffset, value) {
Kode lerroa:       set(this, 8, byteOffset, packF64, value, arguments[2]);
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: } else {
Kode lerroa:   if (!fails(function () {
Kode lerroa:     $ArrayBuffer(1);
Kode lerroa:   }) || !fails(function () {
Kode lerroa:     new $ArrayBuffer(-1);
Kode lerroa:   }) || fails(function () {
Kode lerroa:     new $ArrayBuffer();
Kode lerroa:     new $ArrayBuffer(1.5);
Kode lerroa:     new $ArrayBuffer(NaN);
Kode lerroa:     return $ArrayBuffer.name != ARRAY_BUFFER;
Kode lerroa:   })) {
Kode lerroa:     $ArrayBuffer = function ArrayBuffer(length) {
Kode lerroa:       anInstance(this, $ArrayBuffer);
Kode lerroa:       return new BaseBuffer(toIndex(length));
Kode lerroa:     };
Kode lerroa:     var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
Kode lerroa:     for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
Kode lerroa:       if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
Kode lerroa:     }
Kode lerroa:     if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
Kode lerroa:   }
Kode lerroa:   var view = new $DataView(new $ArrayBuffer(2));
Kode lerroa:   var $setInt8 = $DataView[PROTOTYPE].setInt8;
Kode lerroa:   view.setInt8(0, 2147483648);
Kode lerroa:   view.setInt8(1, 2147483649);
Kode lerroa:   if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
Kode lerroa:     setInt8: function setInt8(byteOffset, value) {
Kode lerroa:       $setInt8.call(this, byteOffset, value << 24 >> 24);
Kode lerroa:     },
Kode lerroa:     setUint8: function setUint8(byteOffset, value) {
Kode lerroa:       $setInt8.call(this, byteOffset, value << 24 >> 24);
Kode lerroa:     }
Kode lerroa:   }, true);
Kode lerroa: }
Kode lerroa: setToStringTag($ArrayBuffer, ARRAY_BUFFER);
Kode lerroa: setToStringTag($DataView, DATA_VIEW);
Kode lerroa: hide($DataView[PROTOTYPE], $typed.VIEW, true);
Kode lerroa: exports[ARRAY_BUFFER] = $ArrayBuffer;
Kode lerroa: exports[DATA_VIEW] = $DataView;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 81 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var dP = __w_pdfjs_require__(13);
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var getKeys = __w_pdfjs_require__(38);
Kode lerroa: module.exports = __w_pdfjs_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
Kode lerroa:   anObject(O);
Kode lerroa:   var keys = getKeys(Properties);
Kode lerroa:   var length = keys.length;
Kode lerroa:   var i = 0;
Kode lerroa:   var P;
Kode lerroa:   while (length > i) {
Kode lerroa:     dP.f(O, P = keys[i++], Properties[P]);
Kode lerroa:   }return O;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 82 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var speciesConstructor = __w_pdfjs_require__(83);
Kode lerroa: module.exports = function (original, length) {
Kode lerroa:   return new (speciesConstructor(original))(length);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 83 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var isArray = __w_pdfjs_require__(84);
Kode lerroa: var SPECIES = __w_pdfjs_require__(3)('species');
Kode lerroa: module.exports = function (original) {
Kode lerroa:   var C;
Kode lerroa:   if (isArray(original)) {
Kode lerroa:     C = original.constructor;
Kode lerroa:     if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
Kode lerroa:     if (isObject(C)) {
Kode lerroa:       C = C[SPECIES];
Kode lerroa:       if (C === null) C = undefined;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return C === undefined ? Array : C;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 84 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var cof = __w_pdfjs_require__(25);
Kode lerroa: module.exports = Array.isArray || function isArray(arg) {
Kode lerroa:   return cof(arg) == 'Array';
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 85 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var UNSCOPABLES = __w_pdfjs_require__(3)('unscopables');
Kode lerroa: var ArrayProto = Array.prototype;
Kode lerroa: if (ArrayProto[UNSCOPABLES] == undefined) __w_pdfjs_require__(6)(ArrayProto, UNSCOPABLES, {});
Kode lerroa: module.exports = function (key) {
Kode lerroa:   ArrayProto[UNSCOPABLES][key] = true;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 86 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (done, value) {
Kode lerroa:   return {
Kode lerroa:     value: value,
Kode lerroa:     done: !!done
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 87 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var create = __w_pdfjs_require__(54);
Kode lerroa: var descriptor = __w_pdfjs_require__(27);
Kode lerroa: var setToStringTag = __w_pdfjs_require__(26);
Kode lerroa: var IteratorPrototype = {};
Kode lerroa: __w_pdfjs_require__(6)(IteratorPrototype, __w_pdfjs_require__(3)('iterator'), function () {
Kode lerroa:   return this;
Kode lerroa: });
Kode lerroa: module.exports = function (Constructor, NAME, next) {
Kode lerroa:   Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
Kode lerroa:   setToStringTag(Constructor, NAME + ' Iterator');
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 88 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toObject = __w_pdfjs_require__(18);
Kode lerroa: var toAbsoluteIndex = __w_pdfjs_require__(29);
Kode lerroa: var toLength = __w_pdfjs_require__(12);
Kode lerroa: module.exports = [].copyWithin || function copyWithin(target, start) {
Kode lerroa:   var O = toObject(this);
Kode lerroa:   var len = toLength(O.length);
Kode lerroa:   var to = toAbsoluteIndex(target, len);
Kode lerroa:   var from = toAbsoluteIndex(start, len);
Kode lerroa:   var end = arguments.length > 2 ? arguments[2] : undefined;
Kode lerroa:   var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
Kode lerroa:   var inc = 1;
Kode lerroa:   if (from < to && to < from + count) {
Kode lerroa:     inc = -1;
Kode lerroa:     from += count - 1;
Kode lerroa:     to += count - 1;
Kode lerroa:   }
Kode lerroa:   while (count-- > 0) {
Kode lerroa:     if (from in O) O[to] = O[from];else delete O[to];
Kode lerroa:     to += inc;
Kode lerroa:     from += inc;
Kode lerroa:   }
Kode lerroa:   return O;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 89 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(90);
Kode lerroa: module.exports = __w_pdfjs_require__(4).Number.isNaN;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 90 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: $export($export.S, 'Number', {
Kode lerroa:   isNaN: function isNaN(number) {
Kode lerroa:     return number != number;
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 91 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(92);
Kode lerroa: module.exports = __w_pdfjs_require__(4).Number.isInteger;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 92 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: $export($export.S, 'Number', { isInteger: __w_pdfjs_require__(93) });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 93 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var floor = Math.floor;
Kode lerroa: module.exports = function isInteger(it) {
Kode lerroa:   return !isObject(it) && isFinite(it) && floor(it) === it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 94 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(63);
Kode lerroa: __w_pdfjs_require__(95);
Kode lerroa: __w_pdfjs_require__(64);
Kode lerroa: __w_pdfjs_require__(97);
Kode lerroa: __w_pdfjs_require__(102);
Kode lerroa: __w_pdfjs_require__(103);
Kode lerroa: module.exports = __w_pdfjs_require__(4).Promise;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 95 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $at = __w_pdfjs_require__(96)(true);
Kode lerroa: __w_pdfjs_require__(59)(String, 'String', function (iterated) {
Kode lerroa:   this._t = String(iterated);
Kode lerroa:   this._i = 0;
Kode lerroa: }, function () {
Kode lerroa:   var O = this._t;
Kode lerroa:   var index = this._i;
Kode lerroa:   var point;
Kode lerroa:   if (index >= O.length) return {
Kode lerroa:     value: undefined,
Kode lerroa:     done: true
Kode lerroa:   };
Kode lerroa:   point = $at(O, index);
Kode lerroa:   this._i += point.length;
Kode lerroa:   return {
Kode lerroa:     value: point,
Kode lerroa:     done: false
Kode lerroa:   };
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 96 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(17);
Kode lerroa: var defined = __w_pdfjs_require__(35);
Kode lerroa: module.exports = function (TO_STRING) {
Kode lerroa:   return function (that, pos) {
Kode lerroa:     var s = String(defined(that));
Kode lerroa:     var i = toInteger(pos);
Kode lerroa:     var l = s.length;
Kode lerroa:     var a, b;
Kode lerroa:     if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
Kode lerroa:     a = s.charCodeAt(i);
Kode lerroa:     return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 97 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var LIBRARY = __w_pdfjs_require__(21);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var ctx = __w_pdfjs_require__(11);
Kode lerroa: var classof = __w_pdfjs_require__(30);
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: var anInstance = __w_pdfjs_require__(24);
Kode lerroa: var forOf = __w_pdfjs_require__(31);
Kode lerroa: var speciesConstructor = __w_pdfjs_require__(40);
Kode lerroa: var task = __w_pdfjs_require__(65).set;
Kode lerroa: var microtask = __w_pdfjs_require__(100)();
Kode lerroa: var newPromiseCapabilityModule = __w_pdfjs_require__(42);
Kode lerroa: var perform = __w_pdfjs_require__(66);
Kode lerroa: var userAgent = __w_pdfjs_require__(101);
Kode lerroa: var promiseResolve = __w_pdfjs_require__(67);
Kode lerroa: var PROMISE = 'Promise';
Kode lerroa: var TypeError = global.TypeError;
Kode lerroa: var process = global.process;
Kode lerroa: var versions = process && process.versions;
Kode lerroa: var v8 = versions && versions.v8 || '';
Kode lerroa: var $Promise = global[PROMISE];
Kode lerroa: var isNode = classof(process) == 'process';
Kode lerroa: var empty = function empty() {};
Kode lerroa: var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
Kode lerroa: var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
Kode lerroa: var USE_NATIVE = !!function () {
Kode lerroa:   try {
Kode lerroa:     var promise = $Promise.resolve(1);
Kode lerroa:     var FakePromise = (promise.constructor = {})[__w_pdfjs_require__(3)('species')] = function (exec) {
Kode lerroa:       exec(empty, empty);
Kode lerroa:     };
Kode lerroa:     return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
Kode lerroa:   } catch (e) {}
Kode lerroa: }();
Kode lerroa: var isThenable = function isThenable(it) {
Kode lerroa:   var then;
Kode lerroa:   return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
Kode lerroa: };
Kode lerroa: var notify = function notify(promise, isReject) {
Kode lerroa:   if (promise._n) return;
Kode lerroa:   promise._n = true;
Kode lerroa:   var chain = promise._c;
Kode lerroa:   microtask(function () {
Kode lerroa:     var value = promise._v;
Kode lerroa:     var ok = promise._s == 1;
Kode lerroa:     var i = 0;
Kode lerroa:     var run = function run(reaction) {
Kode lerroa:       var handler = ok ? reaction.ok : reaction.fail;
Kode lerroa:       var resolve = reaction.resolve;
Kode lerroa:       var reject = reaction.reject;
Kode lerroa:       var domain = reaction.domain;
Kode lerroa:       var result, then, exited;
Kode lerroa:       try {
Kode lerroa:         if (handler) {
Kode lerroa:           if (!ok) {
Kode lerroa:             if (promise._h == 2) onHandleUnhandled(promise);
Kode lerroa:             promise._h = 1;
Kode lerroa:           }
Kode lerroa:           if (handler === true) result = value;else {
Kode lerroa:             if (domain) domain.enter();
Kode lerroa:             result = handler(value);
Kode lerroa:             if (domain) {
Kode lerroa:               domain.exit();
Kode lerroa:               exited = true;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           if (result === reaction.promise) {
Kode lerroa:             reject(TypeError('Promise-chain cycle'));
Kode lerroa:           } else if (then = isThenable(result)) {
Kode lerroa:             then.call(result, resolve, reject);
Kode lerroa:           } else resolve(result);
Kode lerroa:         } else reject(value);
Kode lerroa:       } catch (e) {
Kode lerroa:         if (domain && !exited) domain.exit();
Kode lerroa:         reject(e);
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     while (chain.length > i) {
Kode lerroa:       run(chain[i++]);
Kode lerroa:     }promise._c = [];
Kode lerroa:     promise._n = false;
Kode lerroa:     if (isReject && !promise._h) onUnhandled(promise);
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: var onUnhandled = function onUnhandled(promise) {
Kode lerroa:   task.call(global, function () {
Kode lerroa:     var value = promise._v;
Kode lerroa:     var unhandled = isUnhandled(promise);
Kode lerroa:     var result, handler, console;
Kode lerroa:     if (unhandled) {
Kode lerroa:       result = perform(function () {
Kode lerroa:         if (isNode) {
Kode lerroa:           process.emit('unhandledRejection', value, promise);
Kode lerroa:         } else if (handler = global.onunhandledrejection) {
Kode lerroa:           handler({
Kode lerroa:             promise: promise,
Kode lerroa:             reason: value
Kode lerroa:           });
Kode lerroa:         } else if ((console = global.console) && console.error) {
Kode lerroa:           console.error('Unhandled promise rejection', value);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       promise._h = isNode || isUnhandled(promise) ? 2 : 1;
Kode lerroa:     }
Kode lerroa:     promise._a = undefined;
Kode lerroa:     if (unhandled && result.e) throw result.v;
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: var isUnhandled = function isUnhandled(promise) {
Kode lerroa:   return promise._h !== 1 && (promise._a || promise._c).length === 0;
Kode lerroa: };
Kode lerroa: var onHandleUnhandled = function onHandleUnhandled(promise) {
Kode lerroa:   task.call(global, function () {
Kode lerroa:     var handler;
Kode lerroa:     if (isNode) {
Kode lerroa:       process.emit('rejectionHandled', promise);
Kode lerroa:     } else if (handler = global.onrejectionhandled) {
Kode lerroa:       handler({
Kode lerroa:         promise: promise,
Kode lerroa:         reason: promise._v
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: var $reject = function $reject(value) {
Kode lerroa:   var promise = this;
Kode lerroa:   if (promise._d) return;
Kode lerroa:   promise._d = true;
Kode lerroa:   promise = promise._w || promise;
Kode lerroa:   promise._v = value;
Kode lerroa:   promise._s = 2;
Kode lerroa:   if (!promise._a) promise._a = promise._c.slice();
Kode lerroa:   notify(promise, true);
Kode lerroa: };
Kode lerroa: var $resolve = function $resolve(value) {
Kode lerroa:   var promise = this;
Kode lerroa:   var then;
Kode lerroa:   if (promise._d) return;
Kode lerroa:   promise._d = true;
Kode lerroa:   promise = promise._w || promise;
Kode lerroa:   try {
Kode lerroa:     if (promise === value) throw TypeError("Promise can't be resolved itself");
Kode lerroa:     if (then = isThenable(value)) {
Kode lerroa:       microtask(function () {
Kode lerroa:         var wrapper = {
Kode lerroa:           _w: promise,
Kode lerroa:           _d: false
Kode lerroa:         };
Kode lerroa:         try {
Kode lerroa:           then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
Kode lerroa:         } catch (e) {
Kode lerroa:           $reject.call(wrapper, e);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     } else {
Kode lerroa:       promise._v = value;
Kode lerroa:       promise._s = 1;
Kode lerroa:       notify(promise, false);
Kode lerroa:     }
Kode lerroa:   } catch (e) {
Kode lerroa:     $reject.call({
Kode lerroa:       _w: promise,
Kode lerroa:       _d: false
Kode lerroa:     }, e);
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: if (!USE_NATIVE) {
Kode lerroa:   $Promise = function Promise(executor) {
Kode lerroa:     anInstance(this, $Promise, PROMISE, '_h');
Kode lerroa:     aFunction(executor);
Kode lerroa:     Internal.call(this);
Kode lerroa:     try {
Kode lerroa:       executor(ctx($resolve, this, 1), ctx($reject, this, 1));
Kode lerroa:     } catch (err) {
Kode lerroa:       $reject.call(this, err);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Internal = function Promise(executor) {
Kode lerroa:     this._c = [];
Kode lerroa:     this._a = undefined;
Kode lerroa:     this._s = 0;
Kode lerroa:     this._d = false;
Kode lerroa:     this._v = undefined;
Kode lerroa:     this._h = 0;
Kode lerroa:     this._n = false;
Kode lerroa:   };
Kode lerroa:   Internal.prototype = __w_pdfjs_require__(23)($Promise.prototype, {
Kode lerroa:     then: function then(onFulfilled, onRejected) {
Kode lerroa:       var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
Kode lerroa:       reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
Kode lerroa:       reaction.fail = typeof onRejected == 'function' && onRejected;
Kode lerroa:       reaction.domain = isNode ? process.domain : undefined;
Kode lerroa:       this._c.push(reaction);
Kode lerroa:       if (this._a) this._a.push(reaction);
Kode lerroa:       if (this._s) notify(this, false);
Kode lerroa:       return reaction.promise;
Kode lerroa:     },
Kode lerroa:     'catch': function _catch(onRejected) {
Kode lerroa:       return this.then(undefined, onRejected);
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa:   OwnPromiseCapability = function OwnPromiseCapability() {
Kode lerroa:     var promise = new Internal();
Kode lerroa:     this.promise = promise;
Kode lerroa:     this.resolve = ctx($resolve, promise, 1);
Kode lerroa:     this.reject = ctx($reject, promise, 1);
Kode lerroa:   };
Kode lerroa:   newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
Kode lerroa:     return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
Kode lerroa: __w_pdfjs_require__(26)($Promise, PROMISE);
Kode lerroa: __w_pdfjs_require__(60)(PROMISE);
Kode lerroa: Wrapper = __w_pdfjs_require__(4)[PROMISE];
Kode lerroa: $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
Kode lerroa:   reject: function reject(r) {
Kode lerroa:     var capability = newPromiseCapability(this);
Kode lerroa:     var $$reject = capability.reject;
Kode lerroa:     $$reject(r);
Kode lerroa:     return capability.promise;
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
Kode lerroa:   resolve: function resolve(x) {
Kode lerroa:     return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: $export($export.S + $export.F * !(USE_NATIVE && __w_pdfjs_require__(41)(function (iter) {
Kode lerroa:   $Promise.all(iter)['catch'](empty);
Kode lerroa: })), PROMISE, {
Kode lerroa:   all: function all(iterable) {
Kode lerroa:     var C = this;
Kode lerroa:     var capability = newPromiseCapability(C);
Kode lerroa:     var resolve = capability.resolve;
Kode lerroa:     var reject = capability.reject;
Kode lerroa:     var result = perform(function () {
Kode lerroa:       var values = [];
Kode lerroa:       var index = 0;
Kode lerroa:       var remaining = 1;
Kode lerroa:       forOf(iterable, false, function (promise) {
Kode lerroa:         var $index = index++;
Kode lerroa:         var alreadyCalled = false;
Kode lerroa:         values.push(undefined);
Kode lerroa:         remaining++;
Kode lerroa:         C.resolve(promise).then(function (value) {
Kode lerroa:           if (alreadyCalled) return;
Kode lerroa:           alreadyCalled = true;
Kode lerroa:           values[$index] = value;
Kode lerroa:           --remaining || resolve(values);
Kode lerroa:         }, reject);
Kode lerroa:       });
Kode lerroa:       --remaining || resolve(values);
Kode lerroa:     });
Kode lerroa:     if (result.e) reject(result.v);
Kode lerroa:     return capability.promise;
Kode lerroa:   },
Kode lerroa:   race: function race(iterable) {
Kode lerroa:     var C = this;
Kode lerroa:     var capability = newPromiseCapability(C);
Kode lerroa:     var reject = capability.reject;
Kode lerroa:     var result = perform(function () {
Kode lerroa:       forOf(iterable, false, function (promise) {
Kode lerroa:         C.resolve(promise).then(capability.resolve, reject);
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     if (result.e) reject(result.v);
Kode lerroa:     return capability.promise;
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 98 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: module.exports = function (iterator, fn, value, entries) {
Kode lerroa:   try {
Kode lerroa:     return entries ? fn(anObject(value)[0], value[1]) : fn(value);
Kode lerroa:   } catch (e) {
Kode lerroa:     var ret = iterator['return'];
Kode lerroa:     if (ret !== undefined) anObject(ret.call(iterator));
Kode lerroa:     throw e;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 99 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (fn, args, that) {
Kode lerroa:   var un = that === undefined;
Kode lerroa:   switch (args.length) {
Kode lerroa:     case 0:
Kode lerroa:       return un ? fn() : fn.call(that);
Kode lerroa:     case 1:
Kode lerroa:       return un ? fn(args[0]) : fn.call(that, args[0]);
Kode lerroa:     case 2:
Kode lerroa:       return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
Kode lerroa:     case 3:
Kode lerroa:       return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
Kode lerroa:     case 4:
Kode lerroa:       return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
Kode lerroa:   }
Kode lerroa:   return fn.apply(that, args);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 100 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var macrotask = __w_pdfjs_require__(65).set;
Kode lerroa: var Observer = global.MutationObserver || global.WebKitMutationObserver;
Kode lerroa: var process = global.process;
Kode lerroa: var Promise = global.Promise;
Kode lerroa: var isNode = __w_pdfjs_require__(25)(process) == 'process';
Kode lerroa: module.exports = function () {
Kode lerroa:   var head, last, notify;
Kode lerroa:   var flush = function flush() {
Kode lerroa:     var parent, fn;
Kode lerroa:     if (isNode && (parent = process.domain)) parent.exit();
Kode lerroa:     while (head) {
Kode lerroa:       fn = head.fn;
Kode lerroa:       head = head.next;
Kode lerroa:       try {
Kode lerroa:         fn();
Kode lerroa:       } catch (e) {
Kode lerroa:         if (head) notify();else last = undefined;
Kode lerroa:         throw e;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     last = undefined;
Kode lerroa:     if (parent) parent.enter();
Kode lerroa:   };
Kode lerroa:   if (isNode) {
Kode lerroa:     notify = function notify() {
Kode lerroa:       process.nextTick(flush);
Kode lerroa:     };
Kode lerroa:   } else if (Observer && !(global.navigator && global.navigator.standalone)) {
Kode lerroa:     var toggle = true;
Kode lerroa:     var node = document.createTextNode('');
Kode lerroa:     new Observer(flush).observe(node, { characterData: true });
Kode lerroa:     notify = function notify() {
Kode lerroa:       node.data = toggle = !toggle;
Kode lerroa:     };
Kode lerroa:   } else if (Promise && Promise.resolve) {
Kode lerroa:     var promise = Promise.resolve(undefined);
Kode lerroa:     notify = function notify() {
Kode lerroa:       promise.then(flush);
Kode lerroa:     };
Kode lerroa:   } else {
Kode lerroa:     notify = function notify() {
Kode lerroa:       macrotask.call(global, flush);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   return function (fn) {
Kode lerroa:     var task = {
Kode lerroa:       fn: fn,
Kode lerroa:       next: undefined
Kode lerroa:     };
Kode lerroa:     if (last) last.next = task;
Kode lerroa:     if (!head) {
Kode lerroa:       head = task;
Kode lerroa:       notify();
Kode lerroa:     }
Kode lerroa:     last = task;
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 101 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var navigator = global.navigator;
Kode lerroa: module.exports = navigator && navigator.userAgent || '';
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 102 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: var core = __w_pdfjs_require__(4);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var speciesConstructor = __w_pdfjs_require__(40);
Kode lerroa: var promiseResolve = __w_pdfjs_require__(67);
Kode lerroa: $export($export.P + $export.R, 'Promise', {
Kode lerroa:   'finally': function _finally(onFinally) {
Kode lerroa:     var C = speciesConstructor(this, core.Promise || global.Promise);
Kode lerroa:     var isFunction = typeof onFinally == 'function';
Kode lerroa:     return this.then(isFunction ? function (x) {
Kode lerroa:       return promiseResolve(C, onFinally()).then(function () {
Kode lerroa:         return x;
Kode lerroa:       });
Kode lerroa:     } : onFinally, isFunction ? function (e) {
Kode lerroa:       return promiseResolve(C, onFinally()).then(function () {
Kode lerroa:         throw e;
Kode lerroa:       });
Kode lerroa:     } : onFinally);
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 103 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: var newPromiseCapability = __w_pdfjs_require__(42);
Kode lerroa: var perform = __w_pdfjs_require__(66);
Kode lerroa: $export($export.S, 'Promise', {
Kode lerroa:   'try': function _try(callbackfn) {
Kode lerroa:     var promiseCapability = newPromiseCapability.f(this);
Kode lerroa:     var result = perform(callbackfn);
Kode lerroa:     (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
Kode lerroa:     return promiseCapability.promise;
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 104 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(63);
Kode lerroa: __w_pdfjs_require__(64);
Kode lerroa: __w_pdfjs_require__(105);
Kode lerroa: __w_pdfjs_require__(112);
Kode lerroa: __w_pdfjs_require__(114);
Kode lerroa: module.exports = __w_pdfjs_require__(4).WeakMap;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 105 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var each = __w_pdfjs_require__(39)(0);
Kode lerroa: var redefine = __w_pdfjs_require__(14);
Kode lerroa: var meta = __w_pdfjs_require__(43);
Kode lerroa: var assign = __w_pdfjs_require__(106);
Kode lerroa: var weak = __w_pdfjs_require__(108);
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var fails = __w_pdfjs_require__(9);
Kode lerroa: var validate = __w_pdfjs_require__(68);
Kode lerroa: var WEAK_MAP = 'WeakMap';
Kode lerroa: var getWeak = meta.getWeak;
Kode lerroa: var isExtensible = Object.isExtensible;
Kode lerroa: var uncaughtFrozenStore = weak.ufstore;
Kode lerroa: var tmp = {};
Kode lerroa: var InternalMap;
Kode lerroa: var wrapper = function wrapper(get) {
Kode lerroa:   return function WeakMap() {
Kode lerroa:     return get(this, arguments.length > 0 ? arguments[0] : undefined);
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: var methods = {
Kode lerroa:   get: function get(key) {
Kode lerroa:     if (isObject(key)) {
Kode lerroa:       var data = getWeak(key);
Kode lerroa:       if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
Kode lerroa:       return data ? data[this._i] : undefined;
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   set: function set(key, value) {
Kode lerroa:     return weak.def(validate(this, WEAK_MAP), key, value);
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var $WeakMap = module.exports = __w_pdfjs_require__(109)(WEAK_MAP, wrapper, methods, weak, true, true);
Kode lerroa: if (fails(function () {
Kode lerroa:   return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
Kode lerroa: })) {
Kode lerroa:   InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
Kode lerroa:   assign(InternalMap.prototype, methods);
Kode lerroa:   meta.NEED = true;
Kode lerroa:   each(['delete', 'has', 'get', 'set'], function (key) {
Kode lerroa:     var proto = $WeakMap.prototype;
Kode lerroa:     var method = proto[key];
Kode lerroa:     redefine(proto, key, function (a, b) {
Kode lerroa:       if (isObject(a) && !isExtensible(a)) {
Kode lerroa:         if (!this._f) this._f = new InternalMap();
Kode lerroa:         var result = this._f[key](a, b);
Kode lerroa:         return key == 'set' ? this : result;
Kode lerroa:       }
Kode lerroa:       return method.call(this, a, b);
Kode lerroa:     });
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 106 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var getKeys = __w_pdfjs_require__(38);
Kode lerroa: var gOPS = __w_pdfjs_require__(107);
Kode lerroa: var pIE = __w_pdfjs_require__(62);
Kode lerroa: var toObject = __w_pdfjs_require__(18);
Kode lerroa: var IObject = __w_pdfjs_require__(34);
Kode lerroa: var $assign = Object.assign;
Kode lerroa: module.exports = !$assign || __w_pdfjs_require__(9)(function () {
Kode lerroa:   var A = {};
Kode lerroa:   var B = {};
Kode lerroa:   var S = Symbol();
Kode lerroa:   var K = 'abcdefghijklmnopqrst';
Kode lerroa:   A[S] = 7;
Kode lerroa:   K.split('').forEach(function (k) {
Kode lerroa:     B[k] = k;
Kode lerroa:   });
Kode lerroa:   return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
Kode lerroa: }) ? function assign(target, source) {
Kode lerroa:   var T = toObject(target);
Kode lerroa:   var aLen = arguments.length;
Kode lerroa:   var index = 1;
Kode lerroa:   var getSymbols = gOPS.f;
Kode lerroa:   var isEnum = pIE.f;
Kode lerroa:   while (aLen > index) {
Kode lerroa:     var S = IObject(arguments[index++]);
Kode lerroa:     var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
Kode lerroa:     var length = keys.length;
Kode lerroa:     var j = 0;
Kode lerroa:     var key;
Kode lerroa:     while (length > j) {
Kode lerroa:       if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return T;
Kode lerroa: } : $assign;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 107 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: exports.f = Object.getOwnPropertySymbols;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 108 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var redefineAll = __w_pdfjs_require__(23);
Kode lerroa: var getWeak = __w_pdfjs_require__(43).getWeak;
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var anInstance = __w_pdfjs_require__(24);
Kode lerroa: var forOf = __w_pdfjs_require__(31);
Kode lerroa: var createArrayMethod = __w_pdfjs_require__(39);
Kode lerroa: var $has = __w_pdfjs_require__(10);
Kode lerroa: var validate = __w_pdfjs_require__(68);
Kode lerroa: var arrayFind = createArrayMethod(5);
Kode lerroa: var arrayFindIndex = createArrayMethod(6);
Kode lerroa: var id = 0;
Kode lerroa: var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
Kode lerroa:   return that._l || (that._l = new UncaughtFrozenStore());
Kode lerroa: };
Kode lerroa: var UncaughtFrozenStore = function UncaughtFrozenStore() {
Kode lerroa:   this.a = [];
Kode lerroa: };
Kode lerroa: var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
Kode lerroa:   return arrayFind(store.a, function (it) {
Kode lerroa:     return it[0] === key;
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: UncaughtFrozenStore.prototype = {
Kode lerroa:   get: function get(key) {
Kode lerroa:     var entry = findUncaughtFrozen(this, key);
Kode lerroa:     if (entry) return entry[1];
Kode lerroa:   },
Kode lerroa:   has: function has(key) {
Kode lerroa:     return !!findUncaughtFrozen(this, key);
Kode lerroa:   },
Kode lerroa:   set: function set(key, value) {
Kode lerroa:     var entry = findUncaughtFrozen(this, key);
Kode lerroa:     if (entry) entry[1] = value;else this.a.push([key, value]);
Kode lerroa:   },
Kode lerroa:   'delete': function _delete(key) {
Kode lerroa:     var index = arrayFindIndex(this.a, function (it) {
Kode lerroa:       return it[0] === key;
Kode lerroa:     });
Kode lerroa:     if (~index) this.a.splice(index, 1);
Kode lerroa:     return !!~index;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: module.exports = {
Kode lerroa:   getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
Kode lerroa:     var C = wrapper(function (that, iterable) {
Kode lerroa:       anInstance(that, C, NAME, '_i');
Kode lerroa:       that._t = NAME;
Kode lerroa:       that._i = id++;
Kode lerroa:       that._l = undefined;
Kode lerroa:       if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
Kode lerroa:     });
Kode lerroa:     redefineAll(C.prototype, {
Kode lerroa:       'delete': function _delete(key) {
Kode lerroa:         if (!isObject(key)) return false;
Kode lerroa:         var data = getWeak(key);
Kode lerroa:         if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
Kode lerroa:         return data && $has(data, this._i) && delete data[this._i];
Kode lerroa:       },
Kode lerroa:       has: function has(key) {
Kode lerroa:         if (!isObject(key)) return false;
Kode lerroa:         var data = getWeak(key);
Kode lerroa:         if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
Kode lerroa:         return data && $has(data, this._i);
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     return C;
Kode lerroa:   },
Kode lerroa:   def: function def(that, key, value) {
Kode lerroa:     var data = getWeak(anObject(key), true);
Kode lerroa:     if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
Kode lerroa:     return that;
Kode lerroa:   },
Kode lerroa:   ufstore: uncaughtFrozenStore
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 109 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: var redefine = __w_pdfjs_require__(14);
Kode lerroa: var redefineAll = __w_pdfjs_require__(23);
Kode lerroa: var meta = __w_pdfjs_require__(43);
Kode lerroa: var forOf = __w_pdfjs_require__(31);
Kode lerroa: var anInstance = __w_pdfjs_require__(24);
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var fails = __w_pdfjs_require__(9);
Kode lerroa: var $iterDetect = __w_pdfjs_require__(41);
Kode lerroa: var setToStringTag = __w_pdfjs_require__(26);
Kode lerroa: var inheritIfRequired = __w_pdfjs_require__(110);
Kode lerroa: module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
Kode lerroa:   var Base = global[NAME];
Kode lerroa:   var C = Base;
Kode lerroa:   var ADDER = IS_MAP ? 'set' : 'add';
Kode lerroa:   var proto = C && C.prototype;
Kode lerroa:   var O = {};
Kode lerroa:   var fixMethod = function fixMethod(KEY) {
Kode lerroa:     var fn = proto[KEY];
Kode lerroa:     redefine(proto, KEY, KEY == 'delete' ? function (a) {
Kode lerroa:       return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
Kode lerroa:     } : KEY == 'has' ? function has(a) {
Kode lerroa:       return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
Kode lerroa:     } : KEY == 'get' ? function get(a) {
Kode lerroa:       return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
Kode lerroa:     } : KEY == 'add' ? function add(a) {
Kode lerroa:       fn.call(this, a === 0 ? 0 : a);
Kode lerroa:       return this;
Kode lerroa:     } : function set(a, b) {
Kode lerroa:       fn.call(this, a === 0 ? 0 : a, b);
Kode lerroa:       return this;
Kode lerroa:     });
Kode lerroa:   };
Kode lerroa:   if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
Kode lerroa:     new C().entries().next();
Kode lerroa:   }))) {
Kode lerroa:     C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
Kode lerroa:     redefineAll(C.prototype, methods);
Kode lerroa:     meta.NEED = true;
Kode lerroa:   } else {
Kode lerroa:     var instance = new C();
Kode lerroa:     var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
Kode lerroa:     var THROWS_ON_PRIMITIVES = fails(function () {
Kode lerroa:       instance.has(1);
Kode lerroa:     });
Kode lerroa:     var ACCEPT_ITERABLES = $iterDetect(function (iter) {
Kode lerroa:       new C(iter);
Kode lerroa:     });
Kode lerroa:     var BUGGY_ZERO = !IS_WEAK && fails(function () {
Kode lerroa:       var $instance = new C();
Kode lerroa:       var index = 5;
Kode lerroa:       while (index--) {
Kode lerroa:         $instance[ADDER](index, index);
Kode lerroa:       }return !$instance.has(-0);
Kode lerroa:     });
Kode lerroa:     if (!ACCEPT_ITERABLES) {
Kode lerroa:       C = wrapper(function (target, iterable) {
Kode lerroa:         anInstance(target, C, NAME);
Kode lerroa:         var that = inheritIfRequired(new Base(), target, C);
Kode lerroa:         if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
Kode lerroa:         return that;
Kode lerroa:       });
Kode lerroa:       C.prototype = proto;
Kode lerroa:       proto.constructor = C;
Kode lerroa:     }
Kode lerroa:     if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
Kode lerroa:       fixMethod('delete');
Kode lerroa:       fixMethod('has');
Kode lerroa:       IS_MAP && fixMethod('get');
Kode lerroa:     }
Kode lerroa:     if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
Kode lerroa:     if (IS_WEAK && proto.clear) delete proto.clear;
Kode lerroa:   }
Kode lerroa:   setToStringTag(C, NAME);
Kode lerroa:   O[NAME] = C;
Kode lerroa:   $export($export.G + $export.W + $export.F * (C != Base), O);
Kode lerroa:   if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
Kode lerroa:   return C;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 110 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var setPrototypeOf = __w_pdfjs_require__(111).set;
Kode lerroa: module.exports = function (that, target, C) {
Kode lerroa:   var S = target.constructor;
Kode lerroa:   var P;
Kode lerroa:   if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
Kode lerroa:     setPrototypeOf(that, P);
Kode lerroa:   }
Kode lerroa:   return that;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 111 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(2);
Kode lerroa: var anObject = __w_pdfjs_require__(7);
Kode lerroa: var check = function check(O, proto) {
Kode lerroa:   anObject(O);
Kode lerroa:   if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
Kode lerroa: };
Kode lerroa: module.exports = {
Kode lerroa:   set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
Kode lerroa:     try {
Kode lerroa:       set = __w_pdfjs_require__(11)(Function.call, __w_pdfjs_require__(61).f(Object.prototype, '__proto__').set, 2);
Kode lerroa:       set(test, []);
Kode lerroa:       buggy = !(test instanceof Array);
Kode lerroa:     } catch (e) {
Kode lerroa:       buggy = true;
Kode lerroa:     }
Kode lerroa:     return function setPrototypeOf(O, proto) {
Kode lerroa:       check(O, proto);
Kode lerroa:       if (buggy) O.__proto__ = proto;else set(O, proto);
Kode lerroa:       return O;
Kode lerroa:     };
Kode lerroa:   }({}, false) : undefined),
Kode lerroa:   check: check
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 112 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(113)('WeakMap');
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 113 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: module.exports = function (COLLECTION) {
Kode lerroa:   $export($export.S, COLLECTION, {
Kode lerroa:     of: function of() {
Kode lerroa:       var length = arguments.length;
Kode lerroa:       var A = new Array(length);
Kode lerroa:       while (length--) {
Kode lerroa:         A[length] = arguments[length];
Kode lerroa:       }return new this(A);
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 114 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(115)('WeakMap');
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 115 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $export = __w_pdfjs_require__(5);
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: var ctx = __w_pdfjs_require__(11);
Kode lerroa: var forOf = __w_pdfjs_require__(31);
Kode lerroa: module.exports = function (COLLECTION) {
Kode lerroa:   $export($export.S, COLLECTION, {
Kode lerroa:     from: function from(source) {
Kode lerroa:       var mapFn = arguments[1];
Kode lerroa:       var mapping, A, n, cb;
Kode lerroa:       aFunction(this);
Kode lerroa:       mapping = mapFn !== undefined;
Kode lerroa:       if (mapping) aFunction(mapFn);
Kode lerroa:       if (source == undefined) return new this();
Kode lerroa:       A = [];
Kode lerroa:       if (mapping) {
Kode lerroa:         n = 0;
Kode lerroa:         cb = ctx(mapFn, arguments[2], 2);
Kode lerroa:         forOf(source, false, function (nextItem) {
Kode lerroa:           A.push(cb(nextItem, n++));
Kode lerroa:         });
Kode lerroa:       } else {
Kode lerroa:         forOf(source, false, A.push, A);
Kode lerroa:       }
Kode lerroa:       return new this(A);
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 116 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isReadableStreamSupported = false;
Kode lerroa: if (typeof ReadableStream !== 'undefined') {
Kode lerroa:   try {
Kode lerroa:     new ReadableStream({
Kode lerroa:       start: function start(controller) {
Kode lerroa:         controller.close();
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     isReadableStreamSupported = true;
Kode lerroa:   } catch (e) {}
Kode lerroa: }
Kode lerroa: if (isReadableStreamSupported) {
Kode lerroa:   exports.ReadableStream = ReadableStream;
Kode lerroa: } else {
Kode lerroa:   exports.ReadableStream = __w_pdfjs_require__(117).ReadableStream;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 117 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: (function (e, a) {
Kode lerroa:   for (var i in a) {
Kode lerroa:     e[i] = a[i];
Kode lerroa:   }
Kode lerroa: })(exports, function (modules) {
Kode lerroa:   var installedModules = {};
Kode lerroa:   function __w_pdfjs_require__(moduleId) {
Kode lerroa:     if (installedModules[moduleId]) return installedModules[moduleId].exports;
Kode lerroa:     var module = installedModules[moduleId] = {
Kode lerroa:       i: moduleId,
Kode lerroa:       l: false,
Kode lerroa:       exports: {}
Kode lerroa:     };
Kode lerroa:     modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
Kode lerroa:     module.l = true;
Kode lerroa:     return module.exports;
Kode lerroa:   }
Kode lerroa:   __w_pdfjs_require__.m = modules;
Kode lerroa:   __w_pdfjs_require__.c = installedModules;
Kode lerroa:   __w_pdfjs_require__.i = function (value) {
Kode lerroa:     return value;
Kode lerroa:   };
Kode lerroa:   __w_pdfjs_require__.d = function (exports, name, getter) {
Kode lerroa:     if (!__w_pdfjs_require__.o(exports, name)) {
Kode lerroa:       Object.defineProperty(exports, name, {
Kode lerroa:         configurable: false,
Kode lerroa:         enumerable: true,
Kode lerroa:         get: getter
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   __w_pdfjs_require__.n = function (module) {
Kode lerroa:     var getter = module && module.__esModule ? function getDefault() {
Kode lerroa:       return module['default'];
Kode lerroa:     } : function getModuleExports() {
Kode lerroa:       return module;
Kode lerroa:     };
Kode lerroa:     __w_pdfjs_require__.d(getter, 'a', getter);
Kode lerroa:     return getter;
Kode lerroa:   };
Kode lerroa:   __w_pdfjs_require__.o = function (object, property) {
Kode lerroa:     return Object.prototype.hasOwnProperty.call(object, property);
Kode lerroa:   };
Kode lerroa:   __w_pdfjs_require__.p = "";
Kode lerroa:   return __w_pdfjs_require__(__w_pdfjs_require__.s = 7);
Kode lerroa: }([function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
Kode lerroa:     return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
Kode lerroa:   } : function (obj) {
Kode lerroa:     return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
Kode lerroa:   };
Kode lerroa:   var _require = __w_pdfjs_require__(1),
Kode lerroa:       assert = _require.assert;
Kode lerroa:   function IsPropertyKey(argument) {
Kode lerroa:     return typeof argument === 'string' || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol';
Kode lerroa:   }
Kode lerroa:   exports.typeIsObject = function (x) {
Kode lerroa:     return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function';
Kode lerroa:   };
Kode lerroa:   exports.createDataProperty = function (o, p, v) {
Kode lerroa:     assert(exports.typeIsObject(o));
Kode lerroa:     Object.defineProperty(o, p, {
Kode lerroa:       value: v,
Kode lerroa:       writable: true,
Kode lerroa:       enumerable: true,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:   };
Kode lerroa:   exports.createArrayFromList = function (elements) {
Kode lerroa:     return elements.slice();
Kode lerroa:   };
Kode lerroa:   exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {
Kode lerroa:     new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
Kode lerroa:   };
Kode lerroa:   exports.CreateIterResultObject = function (value, done) {
Kode lerroa:     assert(typeof done === 'boolean');
Kode lerroa:     var obj = {};
Kode lerroa:     Object.defineProperty(obj, 'value', {
Kode lerroa:       value: value,
Kode lerroa:       enumerable: true,
Kode lerroa:       writable: true,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:     Object.defineProperty(obj, 'done', {
Kode lerroa:       value: done,
Kode lerroa:       enumerable: true,
Kode lerroa:       writable: true,
Kode lerroa:       configurable: true
Kode lerroa:     });
Kode lerroa:     return obj;
Kode lerroa:   };
Kode lerroa:   exports.IsFiniteNonNegativeNumber = function (v) {
Kode lerroa:     if (Number.isNaN(v)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (v === Infinity) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (v < 0) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   };
Kode lerroa:   function Call(F, V, args) {
Kode lerroa:     if (typeof F !== 'function') {
Kode lerroa:       throw new TypeError('Argument is not a function');
Kode lerroa:     }
Kode lerroa:     return Function.prototype.apply.call(F, V, args);
Kode lerroa:   }
Kode lerroa:   exports.InvokeOrNoop = function (O, P, args) {
Kode lerroa:     assert(O !== undefined);
Kode lerroa:     assert(IsPropertyKey(P));
Kode lerroa:     assert(Array.isArray(args));
Kode lerroa:     var method = O[P];
Kode lerroa:     if (method === undefined) {
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     return Call(method, O, args);
Kode lerroa:   };
Kode lerroa:   exports.PromiseInvokeOrNoop = function (O, P, args) {
Kode lerroa:     assert(O !== undefined);
Kode lerroa:     assert(IsPropertyKey(P));
Kode lerroa:     assert(Array.isArray(args));
Kode lerroa:     try {
Kode lerroa:       return Promise.resolve(exports.InvokeOrNoop(O, P, args));
Kode lerroa:     } catch (returnValueE) {
Kode lerroa:       return Promise.reject(returnValueE);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   exports.PromiseInvokeOrPerformFallback = function (O, P, args, F, argsF) {
Kode lerroa:     assert(O !== undefined);
Kode lerroa:     assert(IsPropertyKey(P));
Kode lerroa:     assert(Array.isArray(args));
Kode lerroa:     assert(Array.isArray(argsF));
Kode lerroa:     var method = void 0;
Kode lerroa:     try {
Kode lerroa:       method = O[P];
Kode lerroa:     } catch (methodE) {
Kode lerroa:       return Promise.reject(methodE);
Kode lerroa:     }
Kode lerroa:     if (method === undefined) {
Kode lerroa:       return F.apply(null, argsF);
Kode lerroa:     }
Kode lerroa:     try {
Kode lerroa:       return Promise.resolve(Call(method, O, args));
Kode lerroa:     } catch (e) {
Kode lerroa:       return Promise.reject(e);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   exports.TransferArrayBuffer = function (O) {
Kode lerroa:     return O.slice();
Kode lerroa:   };
Kode lerroa:   exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {
Kode lerroa:     highWaterMark = Number(highWaterMark);
Kode lerroa:     if (Number.isNaN(highWaterMark) || highWaterMark < 0) {
Kode lerroa:       throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');
Kode lerroa:     }
Kode lerroa:     return highWaterMark;
Kode lerroa:   };
Kode lerroa:   exports.ValidateAndNormalizeQueuingStrategy = function (size, highWaterMark) {
Kode lerroa:     if (size !== undefined && typeof size !== 'function') {
Kode lerroa:       throw new TypeError('size property of a queuing strategy must be a function');
Kode lerroa:     }
Kode lerroa:     highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark);
Kode lerroa:     return {
Kode lerroa:       size: size,
Kode lerroa:       highWaterMark: highWaterMark
Kode lerroa:     };
Kode lerroa:   };
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   function rethrowAssertionErrorRejection(e) {
Kode lerroa:     if (e && e.constructor === AssertionError) {
Kode lerroa:       setTimeout(function () {
Kode lerroa:         throw e;
Kode lerroa:       }, 0);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function AssertionError(message) {
Kode lerroa:     this.name = 'AssertionError';
Kode lerroa:     this.message = message || '';
Kode lerroa:     this.stack = new Error().stack;
Kode lerroa:   }
Kode lerroa:   AssertionError.prototype = Object.create(Error.prototype);
Kode lerroa:   AssertionError.prototype.constructor = AssertionError;
Kode lerroa:   function assert(value, message) {
Kode lerroa:     if (!value) {
Kode lerroa:       throw new AssertionError(message);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   module.exports = {
Kode lerroa:     rethrowAssertionErrorRejection: rethrowAssertionErrorRejection,
Kode lerroa:     AssertionError: AssertionError,
Kode lerroa:     assert: assert
Kode lerroa:   };
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   var _createClass = function () {
Kode lerroa:     function defineProperties(target, props) {
Kode lerroa:       for (var i = 0; i < props.length; i++) {
Kode lerroa:         var descriptor = props[i];
Kode lerroa:         descriptor.enumerable = descriptor.enumerable || false;
Kode lerroa:         descriptor.configurable = true;
Kode lerroa:         if ("value" in descriptor) descriptor.writable = true;
Kode lerroa:         Object.defineProperty(target, descriptor.key, descriptor);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return function (Constructor, protoProps, staticProps) {
Kode lerroa:       if (protoProps) defineProperties(Constructor.prototype, protoProps);
Kode lerroa:       if (staticProps) defineProperties(Constructor, staticProps);
Kode lerroa:       return Constructor;
Kode lerroa:     };
Kode lerroa:   }();
Kode lerroa:   function _classCallCheck(instance, Constructor) {
Kode lerroa:     if (!(instance instanceof Constructor)) {
Kode lerroa:       throw new TypeError("Cannot call a class as a function");
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var _require = __w_pdfjs_require__(0),
Kode lerroa:       InvokeOrNoop = _require.InvokeOrNoop,
Kode lerroa:       PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,
Kode lerroa:       ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,
Kode lerroa:       typeIsObject = _require.typeIsObject;
Kode lerroa:   var _require2 = __w_pdfjs_require__(1),
Kode lerroa:       assert = _require2.assert,
Kode lerroa:       rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection;
Kode lerroa:   var _require3 = __w_pdfjs_require__(3),
Kode lerroa:       DequeueValue = _require3.DequeueValue,
Kode lerroa:       EnqueueValueWithSize = _require3.EnqueueValueWithSize,
Kode lerroa:       PeekQueueValue = _require3.PeekQueueValue,
Kode lerroa:       ResetQueue = _require3.ResetQueue;
Kode lerroa:   var WritableStream = function () {
Kode lerroa:     function WritableStream() {
Kode lerroa:       var underlyingSink = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
Kode lerroa:       var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
Kode lerroa:           size = _ref.size,
Kode lerroa:           _ref$highWaterMark = _ref.highWaterMark,
Kode lerroa:           highWaterMark = _ref$highWaterMark === undefined ? 1 : _ref$highWaterMark;
Kode lerroa:       _classCallCheck(this, WritableStream);
Kode lerroa:       this._state = 'writable';
Kode lerroa:       this._storedError = undefined;
Kode lerroa:       this._writer = undefined;
Kode lerroa:       this._writableStreamController = undefined;
Kode lerroa:       this._writeRequests = [];
Kode lerroa:       this._inFlightWriteRequest = undefined;
Kode lerroa:       this._closeRequest = undefined;
Kode lerroa:       this._inFlightCloseRequest = undefined;
Kode lerroa:       this._pendingAbortRequest = undefined;
Kode lerroa:       this._backpressure = false;
Kode lerroa:       var type = underlyingSink.type;
Kode lerroa:       if (type !== undefined) {
Kode lerroa:         throw new RangeError('Invalid type is specified');
Kode lerroa:       }
Kode lerroa:       this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);
Kode lerroa:       this._writableStreamController.__startSteps();
Kode lerroa:     }
Kode lerroa:     _createClass(WritableStream, [{
Kode lerroa:       key: 'abort',
Kode lerroa:       value: function abort(reason) {
Kode lerroa:         if (IsWritableStream(this) === false) {
Kode lerroa:           return Promise.reject(streamBrandCheckException('abort'));
Kode lerroa:         }
Kode lerroa:         if (IsWritableStreamLocked(this) === true) {
Kode lerroa:           return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));
Kode lerroa:         }
Kode lerroa:         return WritableStreamAbort(this, reason);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'getWriter',
Kode lerroa:       value: function getWriter() {
Kode lerroa:         if (IsWritableStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('getWriter');
Kode lerroa:         }
Kode lerroa:         return AcquireWritableStreamDefaultWriter(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'locked',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsWritableStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('locked');
Kode lerroa:         }
Kode lerroa:         return IsWritableStreamLocked(this);
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return WritableStream;
Kode lerroa:   }();
Kode lerroa:   module.exports = {
Kode lerroa:     AcquireWritableStreamDefaultWriter: AcquireWritableStreamDefaultWriter,
Kode lerroa:     IsWritableStream: IsWritableStream,
Kode lerroa:     IsWritableStreamLocked: IsWritableStreamLocked,
Kode lerroa:     WritableStream: WritableStream,
Kode lerroa:     WritableStreamAbort: WritableStreamAbort,
Kode lerroa:     WritableStreamDefaultControllerError: WritableStreamDefaultControllerError,
Kode lerroa:     WritableStreamDefaultWriterCloseWithErrorPropagation: WritableStreamDefaultWriterCloseWithErrorPropagation,
Kode lerroa:     WritableStreamDefaultWriterRelease: WritableStreamDefaultWriterRelease,
Kode lerroa:     WritableStreamDefaultWriterWrite: WritableStreamDefaultWriterWrite,
Kode lerroa:     WritableStreamCloseQueuedOrInFlight: WritableStreamCloseQueuedOrInFlight
Kode lerroa:   };
Kode lerroa:   function AcquireWritableStreamDefaultWriter(stream) {
Kode lerroa:     return new WritableStreamDefaultWriter(stream);
Kode lerroa:   }
Kode lerroa:   function IsWritableStream(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function IsWritableStreamLocked(stream) {
Kode lerroa:     assert(IsWritableStream(stream) === true, 'IsWritableStreamLocked should only be used on known writable streams');
Kode lerroa:     if (stream._writer === undefined) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function WritableStreamAbort(stream, reason) {
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'closed') {
Kode lerroa:       return Promise.resolve(undefined);
Kode lerroa:     }
Kode lerroa:     if (state === 'errored') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     var error = new TypeError('Requested to abort');
Kode lerroa:     if (stream._pendingAbortRequest !== undefined) {
Kode lerroa:       return Promise.reject(error);
Kode lerroa:     }
Kode lerroa:     assert(state === 'writable' || state === 'erroring', 'state must be writable or erroring');
Kode lerroa:     var wasAlreadyErroring = false;
Kode lerroa:     if (state === 'erroring') {
Kode lerroa:       wasAlreadyErroring = true;
Kode lerroa:       reason = undefined;
Kode lerroa:     }
Kode lerroa:     var promise = new Promise(function (resolve, reject) {
Kode lerroa:       stream._pendingAbortRequest = {
Kode lerroa:         _resolve: resolve,
Kode lerroa:         _reject: reject,
Kode lerroa:         _reason: reason,
Kode lerroa:         _wasAlreadyErroring: wasAlreadyErroring
Kode lerroa:       };
Kode lerroa:     });
Kode lerroa:     if (wasAlreadyErroring === false) {
Kode lerroa:       WritableStreamStartErroring(stream, error);
Kode lerroa:     }
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   function WritableStreamAddWriteRequest(stream) {
Kode lerroa:     assert(IsWritableStreamLocked(stream) === true);
Kode lerroa:     assert(stream._state === 'writable');
Kode lerroa:     var promise = new Promise(function (resolve, reject) {
Kode lerroa:       var writeRequest = {
Kode lerroa:         _resolve: resolve,
Kode lerroa:         _reject: reject
Kode lerroa:       };
Kode lerroa:       stream._writeRequests.push(writeRequest);
Kode lerroa:     });
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDealWithRejection(stream, error) {
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'writable') {
Kode lerroa:       WritableStreamStartErroring(stream, error);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     assert(state === 'erroring');
Kode lerroa:     WritableStreamFinishErroring(stream);
Kode lerroa:   }
Kode lerroa:   function WritableStreamStartErroring(stream, reason) {
Kode lerroa:     assert(stream._storedError === undefined, 'stream._storedError === undefined');
Kode lerroa:     assert(stream._state === 'writable', 'state must be writable');
Kode lerroa:     var controller = stream._writableStreamController;
Kode lerroa:     assert(controller !== undefined, 'controller must not be undefined');
Kode lerroa:     stream._state = 'erroring';
Kode lerroa:     stream._storedError = reason;
Kode lerroa:     var writer = stream._writer;
Kode lerroa:     if (writer !== undefined) {
Kode lerroa:       WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
Kode lerroa:     }
Kode lerroa:     if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {
Kode lerroa:       WritableStreamFinishErroring(stream);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function WritableStreamFinishErroring(stream) {
Kode lerroa:     assert(stream._state === 'erroring', 'stream._state === erroring');
Kode lerroa:     assert(WritableStreamHasOperationMarkedInFlight(stream) === false, 'WritableStreamHasOperationMarkedInFlight(stream) === false');
Kode lerroa:     stream._state = 'errored';
Kode lerroa:     stream._writableStreamController.__errorSteps();
Kode lerroa:     var storedError = stream._storedError;
Kode lerroa:     for (var i = 0; i < stream._writeRequests.length; i++) {
Kode lerroa:       var writeRequest = stream._writeRequests[i];
Kode lerroa:       writeRequest._reject(storedError);
Kode lerroa:     }
Kode lerroa:     stream._writeRequests = [];
Kode lerroa:     if (stream._pendingAbortRequest === undefined) {
Kode lerroa:       WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var abortRequest = stream._pendingAbortRequest;
Kode lerroa:     stream._pendingAbortRequest = undefined;
Kode lerroa:     if (abortRequest._wasAlreadyErroring === true) {
Kode lerroa:       abortRequest._reject(storedError);
Kode lerroa:       WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var promise = stream._writableStreamController.__abortSteps(abortRequest._reason);
Kode lerroa:     promise.then(function () {
Kode lerroa:       abortRequest._resolve();
Kode lerroa:       WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
Kode lerroa:     }, function (reason) {
Kode lerroa:       abortRequest._reject(reason);
Kode lerroa:       WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function WritableStreamFinishInFlightWrite(stream) {
Kode lerroa:     assert(stream._inFlightWriteRequest !== undefined);
Kode lerroa:     stream._inFlightWriteRequest._resolve(undefined);
Kode lerroa:     stream._inFlightWriteRequest = undefined;
Kode lerroa:   }
Kode lerroa:   function WritableStreamFinishInFlightWriteWithError(stream, error) {
Kode lerroa:     assert(stream._inFlightWriteRequest !== undefined);
Kode lerroa:     stream._inFlightWriteRequest._reject(error);
Kode lerroa:     stream._inFlightWriteRequest = undefined;
Kode lerroa:     assert(stream._state === 'writable' || stream._state === 'erroring');
Kode lerroa:     WritableStreamDealWithRejection(stream, error);
Kode lerroa:   }
Kode lerroa:   function WritableStreamFinishInFlightClose(stream) {
Kode lerroa:     assert(stream._inFlightCloseRequest !== undefined);
Kode lerroa:     stream._inFlightCloseRequest._resolve(undefined);
Kode lerroa:     stream._inFlightCloseRequest = undefined;
Kode lerroa:     var state = stream._state;
Kode lerroa:     assert(state === 'writable' || state === 'erroring');
Kode lerroa:     if (state === 'erroring') {
Kode lerroa:       stream._storedError = undefined;
Kode lerroa:       if (stream._pendingAbortRequest !== undefined) {
Kode lerroa:         stream._pendingAbortRequest._resolve();
Kode lerroa:         stream._pendingAbortRequest = undefined;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     stream._state = 'closed';
Kode lerroa:     var writer = stream._writer;
Kode lerroa:     if (writer !== undefined) {
Kode lerroa:       defaultWriterClosedPromiseResolve(writer);
Kode lerroa:     }
Kode lerroa:     assert(stream._pendingAbortRequest === undefined, 'stream._pendingAbortRequest === undefined');
Kode lerroa:     assert(stream._storedError === undefined, 'stream._storedError === undefined');
Kode lerroa:   }
Kode lerroa:   function WritableStreamFinishInFlightCloseWithError(stream, error) {
Kode lerroa:     assert(stream._inFlightCloseRequest !== undefined);
Kode lerroa:     stream._inFlightCloseRequest._reject(error);
Kode lerroa:     stream._inFlightCloseRequest = undefined;
Kode lerroa:     assert(stream._state === 'writable' || stream._state === 'erroring');
Kode lerroa:     if (stream._pendingAbortRequest !== undefined) {
Kode lerroa:       stream._pendingAbortRequest._reject(error);
Kode lerroa:       stream._pendingAbortRequest = undefined;
Kode lerroa:     }
Kode lerroa:     WritableStreamDealWithRejection(stream, error);
Kode lerroa:   }
Kode lerroa:   function WritableStreamCloseQueuedOrInFlight(stream) {
Kode lerroa:     if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function WritableStreamHasOperationMarkedInFlight(stream) {
Kode lerroa:     if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function WritableStreamMarkCloseRequestInFlight(stream) {
Kode lerroa:     assert(stream._inFlightCloseRequest === undefined);
Kode lerroa:     assert(stream._closeRequest !== undefined);
Kode lerroa:     stream._inFlightCloseRequest = stream._closeRequest;
Kode lerroa:     stream._closeRequest = undefined;
Kode lerroa:   }
Kode lerroa:   function WritableStreamMarkFirstWriteRequestInFlight(stream) {
Kode lerroa:     assert(stream._inFlightWriteRequest === undefined, 'there must be no pending write request');
Kode lerroa:     assert(stream._writeRequests.length !== 0, 'writeRequests must not be empty');
Kode lerroa:     stream._inFlightWriteRequest = stream._writeRequests.shift();
Kode lerroa:   }
Kode lerroa:   function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
Kode lerroa:     assert(stream._state === 'errored', '_stream_.[[state]] is `"errored"`');
Kode lerroa:     if (stream._closeRequest !== undefined) {
Kode lerroa:       assert(stream._inFlightCloseRequest === undefined);
Kode lerroa:       stream._closeRequest._reject(stream._storedError);
Kode lerroa:       stream._closeRequest = undefined;
Kode lerroa:     }
Kode lerroa:     var writer = stream._writer;
Kode lerroa:     if (writer !== undefined) {
Kode lerroa:       defaultWriterClosedPromiseReject(writer, stream._storedError);
Kode lerroa:       writer._closedPromise.catch(function () {});
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function WritableStreamUpdateBackpressure(stream, backpressure) {
Kode lerroa:     assert(stream._state === 'writable');
Kode lerroa:     assert(WritableStreamCloseQueuedOrInFlight(stream) === false);
Kode lerroa:     var writer = stream._writer;
Kode lerroa:     if (writer !== undefined && backpressure !== stream._backpressure) {
Kode lerroa:       if (backpressure === true) {
Kode lerroa:         defaultWriterReadyPromiseReset(writer);
Kode lerroa:       } else {
Kode lerroa:         assert(backpressure === false);
Kode lerroa:         defaultWriterReadyPromiseResolve(writer);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     stream._backpressure = backpressure;
Kode lerroa:   }
Kode lerroa:   var WritableStreamDefaultWriter = function () {
Kode lerroa:     function WritableStreamDefaultWriter(stream) {
Kode lerroa:       _classCallCheck(this, WritableStreamDefaultWriter);
Kode lerroa:       if (IsWritableStream(stream) === false) {
Kode lerroa:         throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');
Kode lerroa:       }
Kode lerroa:       if (IsWritableStreamLocked(stream) === true) {
Kode lerroa:         throw new TypeError('This stream has already been locked for exclusive writing by another writer');
Kode lerroa:       }
Kode lerroa:       this._ownerWritableStream = stream;
Kode lerroa:       stream._writer = this;
Kode lerroa:       var state = stream._state;
Kode lerroa:       if (state === 'writable') {
Kode lerroa:         if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {
Kode lerroa:           defaultWriterReadyPromiseInitialize(this);
Kode lerroa:         } else {
Kode lerroa:           defaultWriterReadyPromiseInitializeAsResolved(this);
Kode lerroa:         }
Kode lerroa:         defaultWriterClosedPromiseInitialize(this);
Kode lerroa:       } else if (state === 'erroring') {
Kode lerroa:         defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
Kode lerroa:         this._readyPromise.catch(function () {});
Kode lerroa:         defaultWriterClosedPromiseInitialize(this);
Kode lerroa:       } else if (state === 'closed') {
Kode lerroa:         defaultWriterReadyPromiseInitializeAsResolved(this);
Kode lerroa:         defaultWriterClosedPromiseInitializeAsResolved(this);
Kode lerroa:       } else {
Kode lerroa:         assert(state === 'errored', 'state must be errored');
Kode lerroa:         var storedError = stream._storedError;
Kode lerroa:         defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
Kode lerroa:         this._readyPromise.catch(function () {});
Kode lerroa:         defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
Kode lerroa:         this._closedPromise.catch(function () {});
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     _createClass(WritableStreamDefaultWriter, [{
Kode lerroa:       key: 'abort',
Kode lerroa:       value: function abort(reason) {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           return Promise.reject(defaultWriterBrandCheckException('abort'));
Kode lerroa:         }
Kode lerroa:         if (this._ownerWritableStream === undefined) {
Kode lerroa:           return Promise.reject(defaultWriterLockException('abort'));
Kode lerroa:         }
Kode lerroa:         return WritableStreamDefaultWriterAbort(this, reason);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'close',
Kode lerroa:       value: function close() {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           return Promise.reject(defaultWriterBrandCheckException('close'));
Kode lerroa:         }
Kode lerroa:         var stream = this._ownerWritableStream;
Kode lerroa:         if (stream === undefined) {
Kode lerroa:           return Promise.reject(defaultWriterLockException('close'));
Kode lerroa:         }
Kode lerroa:         if (WritableStreamCloseQueuedOrInFlight(stream) === true) {
Kode lerroa:           return Promise.reject(new TypeError('cannot close an already-closing stream'));
Kode lerroa:         }
Kode lerroa:         return WritableStreamDefaultWriterClose(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'releaseLock',
Kode lerroa:       value: function releaseLock() {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           throw defaultWriterBrandCheckException('releaseLock');
Kode lerroa:         }
Kode lerroa:         var stream = this._ownerWritableStream;
Kode lerroa:         if (stream === undefined) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         assert(stream._writer !== undefined);
Kode lerroa:         WritableStreamDefaultWriterRelease(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'write',
Kode lerroa:       value: function write(chunk) {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           return Promise.reject(defaultWriterBrandCheckException('write'));
Kode lerroa:         }
Kode lerroa:         if (this._ownerWritableStream === undefined) {
Kode lerroa:           return Promise.reject(defaultWriterLockException('write to'));
Kode lerroa:         }
Kode lerroa:         return WritableStreamDefaultWriterWrite(this, chunk);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'closed',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           return Promise.reject(defaultWriterBrandCheckException('closed'));
Kode lerroa:         }
Kode lerroa:         return this._closedPromise;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'desiredSize',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           throw defaultWriterBrandCheckException('desiredSize');
Kode lerroa:         }
Kode lerroa:         if (this._ownerWritableStream === undefined) {
Kode lerroa:           throw defaultWriterLockException('desiredSize');
Kode lerroa:         }
Kode lerroa:         return WritableStreamDefaultWriterGetDesiredSize(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'ready',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsWritableStreamDefaultWriter(this) === false) {
Kode lerroa:           return Promise.reject(defaultWriterBrandCheckException('ready'));
Kode lerroa:         }
Kode lerroa:         return this._readyPromise;
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return WritableStreamDefaultWriter;
Kode lerroa:   }();
Kode lerroa:   function IsWritableStreamDefaultWriter(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterAbort(writer, reason) {
Kode lerroa:     var stream = writer._ownerWritableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     return WritableStreamAbort(stream, reason);
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterClose(writer) {
Kode lerroa:     var stream = writer._ownerWritableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'closed' || state === 'errored') {
Kode lerroa:       return Promise.reject(new TypeError('The stream (in ' + state + ' state) is not in the writable state and cannot be closed'));
Kode lerroa:     }
Kode lerroa:     assert(state === 'writable' || state === 'erroring');
Kode lerroa:     assert(WritableStreamCloseQueuedOrInFlight(stream) === false);
Kode lerroa:     var promise = new Promise(function (resolve, reject) {
Kode lerroa:       var closeRequest = {
Kode lerroa:         _resolve: resolve,
Kode lerroa:         _reject: reject
Kode lerroa:       };
Kode lerroa:       stream._closeRequest = closeRequest;
Kode lerroa:     });
Kode lerroa:     if (stream._backpressure === true && state === 'writable') {
Kode lerroa:       defaultWriterReadyPromiseResolve(writer);
Kode lerroa:     }
Kode lerroa:     WritableStreamDefaultControllerClose(stream._writableStreamController);
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
Kode lerroa:     var stream = writer._ownerWritableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {
Kode lerroa:       return Promise.resolve();
Kode lerroa:     }
Kode lerroa:     if (state === 'errored') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     assert(state === 'writable' || state === 'erroring');
Kode lerroa:     return WritableStreamDefaultWriterClose(writer);
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
Kode lerroa:     if (writer._closedPromiseState === 'pending') {
Kode lerroa:       defaultWriterClosedPromiseReject(writer, error);
Kode lerroa:     } else {
Kode lerroa:       defaultWriterClosedPromiseResetToRejected(writer, error);
Kode lerroa:     }
Kode lerroa:     writer._closedPromise.catch(function () {});
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
Kode lerroa:     if (writer._readyPromiseState === 'pending') {
Kode lerroa:       defaultWriterReadyPromiseReject(writer, error);
Kode lerroa:     } else {
Kode lerroa:       defaultWriterReadyPromiseResetToRejected(writer, error);
Kode lerroa:     }
Kode lerroa:     writer._readyPromise.catch(function () {});
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterGetDesiredSize(writer) {
Kode lerroa:     var stream = writer._ownerWritableStream;
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'errored' || state === 'erroring') {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:     if (state === 'closed') {
Kode lerroa:       return 0;
Kode lerroa:     }
Kode lerroa:     return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterRelease(writer) {
Kode lerroa:     var stream = writer._ownerWritableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     assert(stream._writer === writer);
Kode lerroa:     var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\'s closedness');
Kode lerroa:     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
Kode lerroa:     WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
Kode lerroa:     stream._writer = undefined;
Kode lerroa:     writer._ownerWritableStream = undefined;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultWriterWrite(writer, chunk) {
Kode lerroa:     var stream = writer._ownerWritableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     var controller = stream._writableStreamController;
Kode lerroa:     var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
Kode lerroa:     if (stream !== writer._ownerWritableStream) {
Kode lerroa:       return Promise.reject(defaultWriterLockException('write to'));
Kode lerroa:     }
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'errored') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {
Kode lerroa:       return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));
Kode lerroa:     }
Kode lerroa:     if (state === 'erroring') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     assert(state === 'writable');
Kode lerroa:     var promise = WritableStreamAddWriteRequest(stream);
Kode lerroa:     WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   var WritableStreamDefaultController = function () {
Kode lerroa:     function WritableStreamDefaultController(stream, underlyingSink, size, highWaterMark) {
Kode lerroa:       _classCallCheck(this, WritableStreamDefaultController);
Kode lerroa:       if (IsWritableStream(stream) === false) {
Kode lerroa:         throw new TypeError('WritableStreamDefaultController can only be constructed with a WritableStream instance');
Kode lerroa:       }
Kode lerroa:       if (stream._writableStreamController !== undefined) {
Kode lerroa:         throw new TypeError('WritableStreamDefaultController instances can only be created by the WritableStream constructor');
Kode lerroa:       }
Kode lerroa:       this._controlledWritableStream = stream;
Kode lerroa:       this._underlyingSink = underlyingSink;
Kode lerroa:       this._queue = undefined;
Kode lerroa:       this._queueTotalSize = undefined;
Kode lerroa:       ResetQueue(this);
Kode lerroa:       this._started = false;
Kode lerroa:       var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
Kode lerroa:       this._strategySize = normalizedStrategy.size;
Kode lerroa:       this._strategyHWM = normalizedStrategy.highWaterMark;
Kode lerroa:       var backpressure = WritableStreamDefaultControllerGetBackpressure(this);
Kode lerroa:       WritableStreamUpdateBackpressure(stream, backpressure);
Kode lerroa:     }
Kode lerroa:     _createClass(WritableStreamDefaultController, [{
Kode lerroa:       key: 'error',
Kode lerroa:       value: function error(e) {
Kode lerroa:         if (IsWritableStreamDefaultController(this) === false) {
Kode lerroa:           throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');
Kode lerroa:         }
Kode lerroa:         var state = this._controlledWritableStream._state;
Kode lerroa:         if (state !== 'writable') {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         WritableStreamDefaultControllerError(this, e);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__abortSteps',
Kode lerroa:       value: function __abortSteps(reason) {
Kode lerroa:         return PromiseInvokeOrNoop(this._underlyingSink, 'abort', [reason]);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__errorSteps',
Kode lerroa:       value: function __errorSteps() {
Kode lerroa:         ResetQueue(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__startSteps',
Kode lerroa:       value: function __startSteps() {
Kode lerroa:         var _this = this;
Kode lerroa:         var startResult = InvokeOrNoop(this._underlyingSink, 'start', [this]);
Kode lerroa:         var stream = this._controlledWritableStream;
Kode lerroa:         Promise.resolve(startResult).then(function () {
Kode lerroa:           assert(stream._state === 'writable' || stream._state === 'erroring');
Kode lerroa:           _this._started = true;
Kode lerroa:           WritableStreamDefaultControllerAdvanceQueueIfNeeded(_this);
Kode lerroa:         }, function (r) {
Kode lerroa:           assert(stream._state === 'writable' || stream._state === 'erroring');
Kode lerroa:           _this._started = true;
Kode lerroa:           WritableStreamDealWithRejection(stream, r);
Kode lerroa:         }).catch(rethrowAssertionErrorRejection);
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return WritableStreamDefaultController;
Kode lerroa:   }();
Kode lerroa:   function WritableStreamDefaultControllerClose(controller) {
Kode lerroa:     EnqueueValueWithSize(controller, 'close', 0);
Kode lerroa:     WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
Kode lerroa:     var strategySize = controller._strategySize;
Kode lerroa:     if (strategySize === undefined) {
Kode lerroa:       return 1;
Kode lerroa:     }
Kode lerroa:     try {
Kode lerroa:       return strategySize(chunk);
Kode lerroa:     } catch (chunkSizeE) {
Kode lerroa:       WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
Kode lerroa:       return 1;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerGetDesiredSize(controller) {
Kode lerroa:     return controller._strategyHWM - controller._queueTotalSize;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
Kode lerroa:     var writeRecord = { chunk: chunk };
Kode lerroa:     try {
Kode lerroa:       EnqueueValueWithSize(controller, writeRecord, chunkSize);
Kode lerroa:     } catch (enqueueE) {
Kode lerroa:       WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var stream = controller._controlledWritableStream;
Kode lerroa:     if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {
Kode lerroa:       var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
Kode lerroa:       WritableStreamUpdateBackpressure(stream, backpressure);
Kode lerroa:     }
Kode lerroa:     WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
Kode lerroa:   }
Kode lerroa:   function IsWritableStreamDefaultController(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSink')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
Kode lerroa:     var stream = controller._controlledWritableStream;
Kode lerroa:     if (controller._started === false) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (stream._inFlightWriteRequest !== undefined) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'closed' || state === 'errored') {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (state === 'erroring') {
Kode lerroa:       WritableStreamFinishErroring(stream);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (controller._queue.length === 0) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var writeRecord = PeekQueueValue(controller);
Kode lerroa:     if (writeRecord === 'close') {
Kode lerroa:       WritableStreamDefaultControllerProcessClose(controller);
Kode lerroa:     } else {
Kode lerroa:       WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
Kode lerroa:     if (controller._controlledWritableStream._state === 'writable') {
Kode lerroa:       WritableStreamDefaultControllerError(controller, error);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerProcessClose(controller) {
Kode lerroa:     var stream = controller._controlledWritableStream;
Kode lerroa:     WritableStreamMarkCloseRequestInFlight(stream);
Kode lerroa:     DequeueValue(controller);
Kode lerroa:     assert(controller._queue.length === 0, 'queue must be empty once the final write record is dequeued');
Kode lerroa:     var sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'close', []);
Kode lerroa:     sinkClosePromise.then(function () {
Kode lerroa:       WritableStreamFinishInFlightClose(stream);
Kode lerroa:     }, function (reason) {
Kode lerroa:       WritableStreamFinishInFlightCloseWithError(stream, reason);
Kode lerroa:     }).catch(rethrowAssertionErrorRejection);
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
Kode lerroa:     var stream = controller._controlledWritableStream;
Kode lerroa:     WritableStreamMarkFirstWriteRequestInFlight(stream);
Kode lerroa:     var sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'write', [chunk, controller]);
Kode lerroa:     sinkWritePromise.then(function () {
Kode lerroa:       WritableStreamFinishInFlightWrite(stream);
Kode lerroa:       var state = stream._state;
Kode lerroa:       assert(state === 'writable' || state === 'erroring');
Kode lerroa:       DequeueValue(controller);
Kode lerroa:       if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {
Kode lerroa:         var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
Kode lerroa:         WritableStreamUpdateBackpressure(stream, backpressure);
Kode lerroa:       }
Kode lerroa:       WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
Kode lerroa:     }, function (reason) {
Kode lerroa:       WritableStreamFinishInFlightWriteWithError(stream, reason);
Kode lerroa:     }).catch(rethrowAssertionErrorRejection);
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerGetBackpressure(controller) {
Kode lerroa:     var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
Kode lerroa:     return desiredSize <= 0;
Kode lerroa:   }
Kode lerroa:   function WritableStreamDefaultControllerError(controller, error) {
Kode lerroa:     var stream = controller._controlledWritableStream;
Kode lerroa:     assert(stream._state === 'writable');
Kode lerroa:     WritableStreamStartErroring(stream, error);
Kode lerroa:   }
Kode lerroa:   function streamBrandCheckException(name) {
Kode lerroa:     return new TypeError('WritableStream.prototype.' + name + ' can only be used on a WritableStream');
Kode lerroa:   }
Kode lerroa:   function defaultWriterBrandCheckException(name) {
Kode lerroa:     return new TypeError('WritableStreamDefaultWriter.prototype.' + name + ' can only be used on a WritableStreamDefaultWriter');
Kode lerroa:   }
Kode lerroa:   function defaultWriterLockException(name) {
Kode lerroa:     return new TypeError('Cannot ' + name + ' a stream using a released writer');
Kode lerroa:   }
Kode lerroa:   function defaultWriterClosedPromiseInitialize(writer) {
Kode lerroa:     writer._closedPromise = new Promise(function (resolve, reject) {
Kode lerroa:       writer._closedPromise_resolve = resolve;
Kode lerroa:       writer._closedPromise_reject = reject;
Kode lerroa:       writer._closedPromiseState = 'pending';
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
Kode lerroa:     writer._closedPromise = Promise.reject(reason);
Kode lerroa:     writer._closedPromise_resolve = undefined;
Kode lerroa:     writer._closedPromise_reject = undefined;
Kode lerroa:     writer._closedPromiseState = 'rejected';
Kode lerroa:   }
Kode lerroa:   function defaultWriterClosedPromiseInitializeAsResolved(writer) {
Kode lerroa:     writer._closedPromise = Promise.resolve(undefined);
Kode lerroa:     writer._closedPromise_resolve = undefined;
Kode lerroa:     writer._closedPromise_reject = undefined;
Kode lerroa:     writer._closedPromiseState = 'resolved';
Kode lerroa:   }
Kode lerroa:   function defaultWriterClosedPromiseReject(writer, reason) {
Kode lerroa:     assert(writer._closedPromise_resolve !== undefined, 'writer._closedPromise_resolve !== undefined');
Kode lerroa:     assert(writer._closedPromise_reject !== undefined, 'writer._closedPromise_reject !== undefined');
Kode lerroa:     assert(writer._closedPromiseState === 'pending', 'writer._closedPromiseState is pending');
Kode lerroa:     writer._closedPromise_reject(reason);
Kode lerroa:     writer._closedPromise_resolve = undefined;
Kode lerroa:     writer._closedPromise_reject = undefined;
Kode lerroa:     writer._closedPromiseState = 'rejected';
Kode lerroa:   }
Kode lerroa:   function defaultWriterClosedPromiseResetToRejected(writer, reason) {
Kode lerroa:     assert(writer._closedPromise_resolve === undefined, 'writer._closedPromise_resolve === undefined');
Kode lerroa:     assert(writer._closedPromise_reject === undefined, 'writer._closedPromise_reject === undefined');
Kode lerroa:     assert(writer._closedPromiseState !== 'pending', 'writer._closedPromiseState is not pending');
Kode lerroa:     writer._closedPromise = Promise.reject(reason);
Kode lerroa:     writer._closedPromiseState = 'rejected';
Kode lerroa:   }
Kode lerroa:   function defaultWriterClosedPromiseResolve(writer) {
Kode lerroa:     assert(writer._closedPromise_resolve !== undefined, 'writer._closedPromise_resolve !== undefined');
Kode lerroa:     assert(writer._closedPromise_reject !== undefined, 'writer._closedPromise_reject !== undefined');
Kode lerroa:     assert(writer._closedPromiseState === 'pending', 'writer._closedPromiseState is pending');
Kode lerroa:     writer._closedPromise_resolve(undefined);
Kode lerroa:     writer._closedPromise_resolve = undefined;
Kode lerroa:     writer._closedPromise_reject = undefined;
Kode lerroa:     writer._closedPromiseState = 'resolved';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseInitialize(writer) {
Kode lerroa:     writer._readyPromise = new Promise(function (resolve, reject) {
Kode lerroa:       writer._readyPromise_resolve = resolve;
Kode lerroa:       writer._readyPromise_reject = reject;
Kode lerroa:     });
Kode lerroa:     writer._readyPromiseState = 'pending';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
Kode lerroa:     writer._readyPromise = Promise.reject(reason);
Kode lerroa:     writer._readyPromise_resolve = undefined;
Kode lerroa:     writer._readyPromise_reject = undefined;
Kode lerroa:     writer._readyPromiseState = 'rejected';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseInitializeAsResolved(writer) {
Kode lerroa:     writer._readyPromise = Promise.resolve(undefined);
Kode lerroa:     writer._readyPromise_resolve = undefined;
Kode lerroa:     writer._readyPromise_reject = undefined;
Kode lerroa:     writer._readyPromiseState = 'fulfilled';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseReject(writer, reason) {
Kode lerroa:     assert(writer._readyPromise_resolve !== undefined, 'writer._readyPromise_resolve !== undefined');
Kode lerroa:     assert(writer._readyPromise_reject !== undefined, 'writer._readyPromise_reject !== undefined');
Kode lerroa:     writer._readyPromise_reject(reason);
Kode lerroa:     writer._readyPromise_resolve = undefined;
Kode lerroa:     writer._readyPromise_reject = undefined;
Kode lerroa:     writer._readyPromiseState = 'rejected';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseReset(writer) {
Kode lerroa:     assert(writer._readyPromise_resolve === undefined, 'writer._readyPromise_resolve === undefined');
Kode lerroa:     assert(writer._readyPromise_reject === undefined, 'writer._readyPromise_reject === undefined');
Kode lerroa:     writer._readyPromise = new Promise(function (resolve, reject) {
Kode lerroa:       writer._readyPromise_resolve = resolve;
Kode lerroa:       writer._readyPromise_reject = reject;
Kode lerroa:     });
Kode lerroa:     writer._readyPromiseState = 'pending';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseResetToRejected(writer, reason) {
Kode lerroa:     assert(writer._readyPromise_resolve === undefined, 'writer._readyPromise_resolve === undefined');
Kode lerroa:     assert(writer._readyPromise_reject === undefined, 'writer._readyPromise_reject === undefined');
Kode lerroa:     writer._readyPromise = Promise.reject(reason);
Kode lerroa:     writer._readyPromiseState = 'rejected';
Kode lerroa:   }
Kode lerroa:   function defaultWriterReadyPromiseResolve(writer) {
Kode lerroa:     assert(writer._readyPromise_resolve !== undefined, 'writer._readyPromise_resolve !== undefined');
Kode lerroa:     assert(writer._readyPromise_reject !== undefined, 'writer._readyPromise_reject !== undefined');
Kode lerroa:     writer._readyPromise_resolve(undefined);
Kode lerroa:     writer._readyPromise_resolve = undefined;
Kode lerroa:     writer._readyPromise_reject = undefined;
Kode lerroa:     writer._readyPromiseState = 'fulfilled';
Kode lerroa:   }
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   var _require = __w_pdfjs_require__(0),
Kode lerroa:       IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;
Kode lerroa:   var _require2 = __w_pdfjs_require__(1),
Kode lerroa:       assert = _require2.assert;
Kode lerroa:   exports.DequeueValue = function (container) {
Kode lerroa:     assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: DequeueValue should only be used on containers with [[queue]] and [[queueTotalSize]].');
Kode lerroa:     assert(container._queue.length > 0, 'Spec-level failure: should never dequeue from an empty queue.');
Kode lerroa:     var pair = container._queue.shift();
Kode lerroa:     container._queueTotalSize -= pair.size;
Kode lerroa:     if (container._queueTotalSize < 0) {
Kode lerroa:       container._queueTotalSize = 0;
Kode lerroa:     }
Kode lerroa:     return pair.value;
Kode lerroa:   };
Kode lerroa:   exports.EnqueueValueWithSize = function (container, value, size) {
Kode lerroa:     assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: EnqueueValueWithSize should only be used on containers with [[queue]] and ' + '[[queueTotalSize]].');
Kode lerroa:     size = Number(size);
Kode lerroa:     if (!IsFiniteNonNegativeNumber(size)) {
Kode lerroa:       throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
Kode lerroa:     }
Kode lerroa:     container._queue.push({
Kode lerroa:       value: value,
Kode lerroa:       size: size
Kode lerroa:     });
Kode lerroa:     container._queueTotalSize += size;
Kode lerroa:   };
Kode lerroa:   exports.PeekQueueValue = function (container) {
Kode lerroa:     assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: PeekQueueValue should only be used on containers with [[queue]] and [[queueTotalSize]].');
Kode lerroa:     assert(container._queue.length > 0, 'Spec-level failure: should never peek at an empty queue.');
Kode lerroa:     var pair = container._queue[0];
Kode lerroa:     return pair.value;
Kode lerroa:   };
Kode lerroa:   exports.ResetQueue = function (container) {
Kode lerroa:     assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: ResetQueue should only be used on containers with [[queue]] and [[queueTotalSize]].');
Kode lerroa:     container._queue = [];
Kode lerroa:     container._queueTotalSize = 0;
Kode lerroa:   };
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   var _createClass = function () {
Kode lerroa:     function defineProperties(target, props) {
Kode lerroa:       for (var i = 0; i < props.length; i++) {
Kode lerroa:         var descriptor = props[i];
Kode lerroa:         descriptor.enumerable = descriptor.enumerable || false;
Kode lerroa:         descriptor.configurable = true;
Kode lerroa:         if ("value" in descriptor) descriptor.writable = true;
Kode lerroa:         Object.defineProperty(target, descriptor.key, descriptor);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return function (Constructor, protoProps, staticProps) {
Kode lerroa:       if (protoProps) defineProperties(Constructor.prototype, protoProps);
Kode lerroa:       if (staticProps) defineProperties(Constructor, staticProps);
Kode lerroa:       return Constructor;
Kode lerroa:     };
Kode lerroa:   }();
Kode lerroa:   function _classCallCheck(instance, Constructor) {
Kode lerroa:     if (!(instance instanceof Constructor)) {
Kode lerroa:       throw new TypeError("Cannot call a class as a function");
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var _require = __w_pdfjs_require__(0),
Kode lerroa:       ArrayBufferCopy = _require.ArrayBufferCopy,
Kode lerroa:       CreateIterResultObject = _require.CreateIterResultObject,
Kode lerroa:       IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber,
Kode lerroa:       InvokeOrNoop = _require.InvokeOrNoop,
Kode lerroa:       PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,
Kode lerroa:       TransferArrayBuffer = _require.TransferArrayBuffer,
Kode lerroa:       ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,
Kode lerroa:       ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark;
Kode lerroa:   var _require2 = __w_pdfjs_require__(0),
Kode lerroa:       createArrayFromList = _require2.createArrayFromList,
Kode lerroa:       createDataProperty = _require2.createDataProperty,
Kode lerroa:       typeIsObject = _require2.typeIsObject;
Kode lerroa:   var _require3 = __w_pdfjs_require__(1),
Kode lerroa:       assert = _require3.assert,
Kode lerroa:       rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection;
Kode lerroa:   var _require4 = __w_pdfjs_require__(3),
Kode lerroa:       DequeueValue = _require4.DequeueValue,
Kode lerroa:       EnqueueValueWithSize = _require4.EnqueueValueWithSize,
Kode lerroa:       ResetQueue = _require4.ResetQueue;
Kode lerroa:   var _require5 = __w_pdfjs_require__(2),
Kode lerroa:       AcquireWritableStreamDefaultWriter = _require5.AcquireWritableStreamDefaultWriter,
Kode lerroa:       IsWritableStream = _require5.IsWritableStream,
Kode lerroa:       IsWritableStreamLocked = _require5.IsWritableStreamLocked,
Kode lerroa:       WritableStreamAbort = _require5.WritableStreamAbort,
Kode lerroa:       WritableStreamDefaultWriterCloseWithErrorPropagation = _require5.WritableStreamDefaultWriterCloseWithErrorPropagation,
Kode lerroa:       WritableStreamDefaultWriterRelease = _require5.WritableStreamDefaultWriterRelease,
Kode lerroa:       WritableStreamDefaultWriterWrite = _require5.WritableStreamDefaultWriterWrite,
Kode lerroa:       WritableStreamCloseQueuedOrInFlight = _require5.WritableStreamCloseQueuedOrInFlight;
Kode lerroa:   var ReadableStream = function () {
Kode lerroa:     function ReadableStream() {
Kode lerroa:       var underlyingSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
Kode lerroa:       var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
Kode lerroa:           size = _ref.size,
Kode lerroa:           highWaterMark = _ref.highWaterMark;
Kode lerroa:       _classCallCheck(this, ReadableStream);
Kode lerroa:       this._state = 'readable';
Kode lerroa:       this._reader = undefined;
Kode lerroa:       this._storedError = undefined;
Kode lerroa:       this._disturbed = false;
Kode lerroa:       this._readableStreamController = undefined;
Kode lerroa:       var type = underlyingSource.type;
Kode lerroa:       var typeString = String(type);
Kode lerroa:       if (typeString === 'bytes') {
Kode lerroa:         if (highWaterMark === undefined) {
Kode lerroa:           highWaterMark = 0;
Kode lerroa:         }
Kode lerroa:         this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
Kode lerroa:       } else if (type === undefined) {
Kode lerroa:         if (highWaterMark === undefined) {
Kode lerroa:           highWaterMark = 1;
Kode lerroa:         }
Kode lerroa:         this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);
Kode lerroa:       } else {
Kode lerroa:         throw new RangeError('Invalid type is specified');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     _createClass(ReadableStream, [{
Kode lerroa:       key: 'cancel',
Kode lerroa:       value: function cancel(reason) {
Kode lerroa:         if (IsReadableStream(this) === false) {
Kode lerroa:           return Promise.reject(streamBrandCheckException('cancel'));
Kode lerroa:         }
Kode lerroa:         if (IsReadableStreamLocked(this) === true) {
Kode lerroa:           return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));
Kode lerroa:         }
Kode lerroa:         return ReadableStreamCancel(this, reason);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'getReader',
Kode lerroa:       value: function getReader() {
Kode lerroa:         var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
Kode lerroa:             mode = _ref2.mode;
Kode lerroa:         if (IsReadableStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('getReader');
Kode lerroa:         }
Kode lerroa:         if (mode === undefined) {
Kode lerroa:           return AcquireReadableStreamDefaultReader(this);
Kode lerroa:         }
Kode lerroa:         mode = String(mode);
Kode lerroa:         if (mode === 'byob') {
Kode lerroa:           return AcquireReadableStreamBYOBReader(this);
Kode lerroa:         }
Kode lerroa:         throw new RangeError('Invalid mode is specified');
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'pipeThrough',
Kode lerroa:       value: function pipeThrough(_ref3, options) {
Kode lerroa:         var writable = _ref3.writable,
Kode lerroa:             readable = _ref3.readable;
Kode lerroa:         var promise = this.pipeTo(writable, options);
Kode lerroa:         ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);
Kode lerroa:         return readable;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'pipeTo',
Kode lerroa:       value: function pipeTo(dest) {
Kode lerroa:         var _this = this;
Kode lerroa:         var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
Kode lerroa:             preventClose = _ref4.preventClose,
Kode lerroa:             preventAbort = _ref4.preventAbort,
Kode lerroa:             preventCancel = _ref4.preventCancel;
Kode lerroa:         if (IsReadableStream(this) === false) {
Kode lerroa:           return Promise.reject(streamBrandCheckException('pipeTo'));
Kode lerroa:         }
Kode lerroa:         if (IsWritableStream(dest) === false) {
Kode lerroa:           return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\'s first argument must be a WritableStream'));
Kode lerroa:         }
Kode lerroa:         preventClose = Boolean(preventClose);
Kode lerroa:         preventAbort = Boolean(preventAbort);
Kode lerroa:         preventCancel = Boolean(preventCancel);
Kode lerroa:         if (IsReadableStreamLocked(this) === true) {
Kode lerroa:           return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
Kode lerroa:         }
Kode lerroa:         if (IsWritableStreamLocked(dest) === true) {
Kode lerroa:           return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
Kode lerroa:         }
Kode lerroa:         var reader = AcquireReadableStreamDefaultReader(this);
Kode lerroa:         var writer = AcquireWritableStreamDefaultWriter(dest);
Kode lerroa:         var shuttingDown = false;
Kode lerroa:         var currentWrite = Promise.resolve();
Kode lerroa:         return new Promise(function (resolve, reject) {
Kode lerroa:           function pipeLoop() {
Kode lerroa:             currentWrite = Promise.resolve();
Kode lerroa:             if (shuttingDown === true) {
Kode lerroa:               return Promise.resolve();
Kode lerroa:             }
Kode lerroa:             return writer._readyPromise.then(function () {
Kode lerroa:               return ReadableStreamDefaultReaderRead(reader).then(function (_ref5) {
Kode lerroa:                 var value = _ref5.value,
Kode lerroa:                     done = _ref5.done;
Kode lerroa:                 if (done === true) {
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(function () {});
Kode lerroa:               });
Kode lerroa:             }).then(pipeLoop);
Kode lerroa:           }
Kode lerroa:           isOrBecomesErrored(_this, reader._closedPromise, function (storedError) {
Kode lerroa:             if (preventAbort === false) {
Kode lerroa:               shutdownWithAction(function () {
Kode lerroa:                 return WritableStreamAbort(dest, storedError);
Kode lerroa:               }, true, storedError);
Kode lerroa:             } else {
Kode lerroa:               shutdown(true, storedError);
Kode lerroa:             }
Kode lerroa:           });
Kode lerroa:           isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
Kode lerroa:             if (preventCancel === false) {
Kode lerroa:               shutdownWithAction(function () {
Kode lerroa:                 return ReadableStreamCancel(_this, storedError);
Kode lerroa:               }, true, storedError);
Kode lerroa:             } else {
Kode lerroa:               shutdown(true, storedError);
Kode lerroa:             }
Kode lerroa:           });
Kode lerroa:           isOrBecomesClosed(_this, reader._closedPromise, function () {
Kode lerroa:             if (preventClose === false) {
Kode lerroa:               shutdownWithAction(function () {
Kode lerroa:                 return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
Kode lerroa:               });
Kode lerroa:             } else {
Kode lerroa:               shutdown();
Kode lerroa:             }
Kode lerroa:           });
Kode lerroa:           if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {
Kode lerroa:             var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
Kode lerroa:             if (preventCancel === false) {
Kode lerroa:               shutdownWithAction(function () {
Kode lerroa:                 return ReadableStreamCancel(_this, destClosed);
Kode lerroa:               }, true, destClosed);
Kode lerroa:             } else {
Kode lerroa:               shutdown(true, destClosed);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           pipeLoop().catch(function (err) {
Kode lerroa:             currentWrite = Promise.resolve();
Kode lerroa:             rethrowAssertionErrorRejection(err);
Kode lerroa:           });
Kode lerroa:           function waitForWritesToFinish() {
Kode lerroa:             var oldCurrentWrite = currentWrite;
Kode lerroa:             return currentWrite.then(function () {
Kode lerroa:               return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:           function isOrBecomesErrored(stream, promise, action) {
Kode lerroa:             if (stream._state === 'errored') {
Kode lerroa:               action(stream._storedError);
Kode lerroa:             } else {
Kode lerroa:               promise.catch(action).catch(rethrowAssertionErrorRejection);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           function isOrBecomesClosed(stream, promise, action) {
Kode lerroa:             if (stream._state === 'closed') {
Kode lerroa:               action();
Kode lerroa:             } else {
Kode lerroa:               promise.then(action).catch(rethrowAssertionErrorRejection);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           function shutdownWithAction(action, originalIsError, originalError) {
Kode lerroa:             if (shuttingDown === true) {
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             shuttingDown = true;
Kode lerroa:             if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {
Kode lerroa:               waitForWritesToFinish().then(doTheRest);
Kode lerroa:             } else {
Kode lerroa:               doTheRest();
Kode lerroa:             }
Kode lerroa:             function doTheRest() {
Kode lerroa:               action().then(function () {
Kode lerroa:                 return finalize(originalIsError, originalError);
Kode lerroa:               }, function (newError) {
Kode lerroa:                 return finalize(true, newError);
Kode lerroa:               }).catch(rethrowAssertionErrorRejection);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           function shutdown(isError, error) {
Kode lerroa:             if (shuttingDown === true) {
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             shuttingDown = true;
Kode lerroa:             if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {
Kode lerroa:               waitForWritesToFinish().then(function () {
Kode lerroa:                 return finalize(isError, error);
Kode lerroa:               }).catch(rethrowAssertionErrorRejection);
Kode lerroa:             } else {
Kode lerroa:               finalize(isError, error);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           function finalize(isError, error) {
Kode lerroa:             WritableStreamDefaultWriterRelease(writer);
Kode lerroa:             ReadableStreamReaderGenericRelease(reader);
Kode lerroa:             if (isError) {
Kode lerroa:               reject(error);
Kode lerroa:             } else {
Kode lerroa:               resolve(undefined);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'tee',
Kode lerroa:       value: function tee() {
Kode lerroa:         if (IsReadableStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('tee');
Kode lerroa:         }
Kode lerroa:         var branches = ReadableStreamTee(this, false);
Kode lerroa:         return createArrayFromList(branches);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'locked',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsReadableStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('locked');
Kode lerroa:         }
Kode lerroa:         return IsReadableStreamLocked(this);
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return ReadableStream;
Kode lerroa:   }();
Kode lerroa:   module.exports = {
Kode lerroa:     ReadableStream: ReadableStream,
Kode lerroa:     IsReadableStreamDisturbed: IsReadableStreamDisturbed,
Kode lerroa:     ReadableStreamDefaultControllerClose: ReadableStreamDefaultControllerClose,
Kode lerroa:     ReadableStreamDefaultControllerEnqueue: ReadableStreamDefaultControllerEnqueue,
Kode lerroa:     ReadableStreamDefaultControllerError: ReadableStreamDefaultControllerError,
Kode lerroa:     ReadableStreamDefaultControllerGetDesiredSize: ReadableStreamDefaultControllerGetDesiredSize
Kode lerroa:   };
Kode lerroa:   function AcquireReadableStreamBYOBReader(stream) {
Kode lerroa:     return new ReadableStreamBYOBReader(stream);
Kode lerroa:   }
Kode lerroa:   function AcquireReadableStreamDefaultReader(stream) {
Kode lerroa:     return new ReadableStreamDefaultReader(stream);
Kode lerroa:   }
Kode lerroa:   function IsReadableStream(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function IsReadableStreamDisturbed(stream) {
Kode lerroa:     assert(IsReadableStream(stream) === true, 'IsReadableStreamDisturbed should only be used on known readable streams');
Kode lerroa:     return stream._disturbed;
Kode lerroa:   }
Kode lerroa:   function IsReadableStreamLocked(stream) {
Kode lerroa:     assert(IsReadableStream(stream) === true, 'IsReadableStreamLocked should only be used on known readable streams');
Kode lerroa:     if (stream._reader === undefined) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamTee(stream, cloneForBranch2) {
Kode lerroa:     assert(IsReadableStream(stream) === true);
Kode lerroa:     assert(typeof cloneForBranch2 === 'boolean');
Kode lerroa:     var reader = AcquireReadableStreamDefaultReader(stream);
Kode lerroa:     var teeState = {
Kode lerroa:       closedOrErrored: false,
Kode lerroa:       canceled1: false,
Kode lerroa:       canceled2: false,
Kode lerroa:       reason1: undefined,
Kode lerroa:       reason2: undefined
Kode lerroa:     };
Kode lerroa:     teeState.promise = new Promise(function (resolve) {
Kode lerroa:       teeState._resolve = resolve;
Kode lerroa:     });
Kode lerroa:     var pull = create_ReadableStreamTeePullFunction();
Kode lerroa:     pull._reader = reader;
Kode lerroa:     pull._teeState = teeState;
Kode lerroa:     pull._cloneForBranch2 = cloneForBranch2;
Kode lerroa:     var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
Kode lerroa:     cancel1._stream = stream;
Kode lerroa:     cancel1._teeState = teeState;
Kode lerroa:     var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
Kode lerroa:     cancel2._stream = stream;
Kode lerroa:     cancel2._teeState = teeState;
Kode lerroa:     var underlyingSource1 = Object.create(Object.prototype);
Kode lerroa:     createDataProperty(underlyingSource1, 'pull', pull);
Kode lerroa:     createDataProperty(underlyingSource1, 'cancel', cancel1);
Kode lerroa:     var branch1Stream = new ReadableStream(underlyingSource1);
Kode lerroa:     var underlyingSource2 = Object.create(Object.prototype);
Kode lerroa:     createDataProperty(underlyingSource2, 'pull', pull);
Kode lerroa:     createDataProperty(underlyingSource2, 'cancel', cancel2);
Kode lerroa:     var branch2Stream = new ReadableStream(underlyingSource2);
Kode lerroa:     pull._branch1 = branch1Stream._readableStreamController;
Kode lerroa:     pull._branch2 = branch2Stream._readableStreamController;
Kode lerroa:     reader._closedPromise.catch(function (r) {
Kode lerroa:       if (teeState.closedOrErrored === true) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       ReadableStreamDefaultControllerError(pull._branch1, r);
Kode lerroa:       ReadableStreamDefaultControllerError(pull._branch2, r);
Kode lerroa:       teeState.closedOrErrored = true;
Kode lerroa:     });
Kode lerroa:     return [branch1Stream, branch2Stream];
Kode lerroa:   }
Kode lerroa:   function create_ReadableStreamTeePullFunction() {
Kode lerroa:     function f() {
Kode lerroa:       var reader = f._reader,
Kode lerroa:           branch1 = f._branch1,
Kode lerroa:           branch2 = f._branch2,
Kode lerroa:           teeState = f._teeState;
Kode lerroa:       return ReadableStreamDefaultReaderRead(reader).then(function (result) {
Kode lerroa:         assert(typeIsObject(result));
Kode lerroa:         var value = result.value;
Kode lerroa:         var done = result.done;
Kode lerroa:         assert(typeof done === 'boolean');
Kode lerroa:         if (done === true && teeState.closedOrErrored === false) {
Kode lerroa:           if (teeState.canceled1 === false) {
Kode lerroa:             ReadableStreamDefaultControllerClose(branch1);
Kode lerroa:           }
Kode lerroa:           if (teeState.canceled2 === false) {
Kode lerroa:             ReadableStreamDefaultControllerClose(branch2);
Kode lerroa:           }
Kode lerroa:           teeState.closedOrErrored = true;
Kode lerroa:         }
Kode lerroa:         if (teeState.closedOrErrored === true) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var value1 = value;
Kode lerroa:         var value2 = value;
Kode lerroa:         if (teeState.canceled1 === false) {
Kode lerroa:           ReadableStreamDefaultControllerEnqueue(branch1, value1);
Kode lerroa:         }
Kode lerroa:         if (teeState.canceled2 === false) {
Kode lerroa:           ReadableStreamDefaultControllerEnqueue(branch2, value2);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     return f;
Kode lerroa:   }
Kode lerroa:   function create_ReadableStreamTeeBranch1CancelFunction() {
Kode lerroa:     function f(reason) {
Kode lerroa:       var stream = f._stream,
Kode lerroa:           teeState = f._teeState;
Kode lerroa:       teeState.canceled1 = true;
Kode lerroa:       teeState.reason1 = reason;
Kode lerroa:       if (teeState.canceled2 === true) {
Kode lerroa:         var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
Kode lerroa:         var cancelResult = ReadableStreamCancel(stream, compositeReason);
Kode lerroa:         teeState._resolve(cancelResult);
Kode lerroa:       }
Kode lerroa:       return teeState.promise;
Kode lerroa:     }
Kode lerroa:     return f;
Kode lerroa:   }
Kode lerroa:   function create_ReadableStreamTeeBranch2CancelFunction() {
Kode lerroa:     function f(reason) {
Kode lerroa:       var stream = f._stream,
Kode lerroa:           teeState = f._teeState;
Kode lerroa:       teeState.canceled2 = true;
Kode lerroa:       teeState.reason2 = reason;
Kode lerroa:       if (teeState.canceled1 === true) {
Kode lerroa:         var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
Kode lerroa:         var cancelResult = ReadableStreamCancel(stream, compositeReason);
Kode lerroa:         teeState._resolve(cancelResult);
Kode lerroa:       }
Kode lerroa:       return teeState.promise;
Kode lerroa:     }
Kode lerroa:     return f;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamAddReadIntoRequest(stream) {
Kode lerroa:     assert(IsReadableStreamBYOBReader(stream._reader) === true);
Kode lerroa:     assert(stream._state === 'readable' || stream._state === 'closed');
Kode lerroa:     var promise = new Promise(function (resolve, reject) {
Kode lerroa:       var readIntoRequest = {
Kode lerroa:         _resolve: resolve,
Kode lerroa:         _reject: reject
Kode lerroa:       };
Kode lerroa:       stream._reader._readIntoRequests.push(readIntoRequest);
Kode lerroa:     });
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamAddReadRequest(stream) {
Kode lerroa:     assert(IsReadableStreamDefaultReader(stream._reader) === true);
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     var promise = new Promise(function (resolve, reject) {
Kode lerroa:       var readRequest = {
Kode lerroa:         _resolve: resolve,
Kode lerroa:         _reject: reject
Kode lerroa:       };
Kode lerroa:       stream._reader._readRequests.push(readRequest);
Kode lerroa:     });
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamCancel(stream, reason) {
Kode lerroa:     stream._disturbed = true;
Kode lerroa:     if (stream._state === 'closed') {
Kode lerroa:       return Promise.resolve(undefined);
Kode lerroa:     }
Kode lerroa:     if (stream._state === 'errored') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     ReadableStreamClose(stream);
Kode lerroa:     var sourceCancelPromise = stream._readableStreamController.__cancelSteps(reason);
Kode lerroa:     return sourceCancelPromise.then(function () {
Kode lerroa:       return undefined;
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function ReadableStreamClose(stream) {
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     stream._state = 'closed';
Kode lerroa:     var reader = stream._reader;
Kode lerroa:     if (reader === undefined) {
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     if (IsReadableStreamDefaultReader(reader) === true) {
Kode lerroa:       for (var i = 0; i < reader._readRequests.length; i++) {
Kode lerroa:         var _resolve = reader._readRequests[i]._resolve;
Kode lerroa:         _resolve(CreateIterResultObject(undefined, true));
Kode lerroa:       }
Kode lerroa:       reader._readRequests = [];
Kode lerroa:     }
Kode lerroa:     defaultReaderClosedPromiseResolve(reader);
Kode lerroa:     return undefined;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamError(stream, e) {
Kode lerroa:     assert(IsReadableStream(stream) === true, 'stream must be ReadableStream');
Kode lerroa:     assert(stream._state === 'readable', 'state must be readable');
Kode lerroa:     stream._state = 'errored';
Kode lerroa:     stream._storedError = e;
Kode lerroa:     var reader = stream._reader;
Kode lerroa:     if (reader === undefined) {
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     if (IsReadableStreamDefaultReader(reader) === true) {
Kode lerroa:       for (var i = 0; i < reader._readRequests.length; i++) {
Kode lerroa:         var readRequest = reader._readRequests[i];
Kode lerroa:         readRequest._reject(e);
Kode lerroa:       }
Kode lerroa:       reader._readRequests = [];
Kode lerroa:     } else {
Kode lerroa:       assert(IsReadableStreamBYOBReader(reader), 'reader must be ReadableStreamBYOBReader');
Kode lerroa:       for (var _i = 0; _i < reader._readIntoRequests.length; _i++) {
Kode lerroa:         var readIntoRequest = reader._readIntoRequests[_i];
Kode lerroa:         readIntoRequest._reject(e);
Kode lerroa:       }
Kode lerroa:       reader._readIntoRequests = [];
Kode lerroa:     }
Kode lerroa:     defaultReaderClosedPromiseReject(reader, e);
Kode lerroa:     reader._closedPromise.catch(function () {});
Kode lerroa:   }
Kode lerroa:   function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
Kode lerroa:     var reader = stream._reader;
Kode lerroa:     assert(reader._readIntoRequests.length > 0);
Kode lerroa:     var readIntoRequest = reader._readIntoRequests.shift();
Kode lerroa:     readIntoRequest._resolve(CreateIterResultObject(chunk, done));
Kode lerroa:   }
Kode lerroa:   function ReadableStreamFulfillReadRequest(stream, chunk, done) {
Kode lerroa:     var reader = stream._reader;
Kode lerroa:     assert(reader._readRequests.length > 0);
Kode lerroa:     var readRequest = reader._readRequests.shift();
Kode lerroa:     readRequest._resolve(CreateIterResultObject(chunk, done));
Kode lerroa:   }
Kode lerroa:   function ReadableStreamGetNumReadIntoRequests(stream) {
Kode lerroa:     return stream._reader._readIntoRequests.length;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamGetNumReadRequests(stream) {
Kode lerroa:     return stream._reader._readRequests.length;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamHasBYOBReader(stream) {
Kode lerroa:     var reader = stream._reader;
Kode lerroa:     if (reader === undefined) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (IsReadableStreamBYOBReader(reader) === false) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamHasDefaultReader(stream) {
Kode lerroa:     var reader = stream._reader;
Kode lerroa:     if (reader === undefined) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (IsReadableStreamDefaultReader(reader) === false) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   var ReadableStreamDefaultReader = function () {
Kode lerroa:     function ReadableStreamDefaultReader(stream) {
Kode lerroa:       _classCallCheck(this, ReadableStreamDefaultReader);
Kode lerroa:       if (IsReadableStream(stream) === false) {
Kode lerroa:         throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');
Kode lerroa:       }
Kode lerroa:       if (IsReadableStreamLocked(stream) === true) {
Kode lerroa:         throw new TypeError('This stream has already been locked for exclusive reading by another reader');
Kode lerroa:       }
Kode lerroa:       ReadableStreamReaderGenericInitialize(this, stream);
Kode lerroa:       this._readRequests = [];
Kode lerroa:     }
Kode lerroa:     _createClass(ReadableStreamDefaultReader, [{
Kode lerroa:       key: 'cancel',
Kode lerroa:       value: function cancel(reason) {
Kode lerroa:         if (IsReadableStreamDefaultReader(this) === false) {
Kode lerroa:           return Promise.reject(defaultReaderBrandCheckException('cancel'));
Kode lerroa:         }
Kode lerroa:         if (this._ownerReadableStream === undefined) {
Kode lerroa:           return Promise.reject(readerLockException('cancel'));
Kode lerroa:         }
Kode lerroa:         return ReadableStreamReaderGenericCancel(this, reason);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'read',
Kode lerroa:       value: function read() {
Kode lerroa:         if (IsReadableStreamDefaultReader(this) === false) {
Kode lerroa:           return Promise.reject(defaultReaderBrandCheckException('read'));
Kode lerroa:         }
Kode lerroa:         if (this._ownerReadableStream === undefined) {
Kode lerroa:           return Promise.reject(readerLockException('read from'));
Kode lerroa:         }
Kode lerroa:         return ReadableStreamDefaultReaderRead(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'releaseLock',
Kode lerroa:       value: function releaseLock() {
Kode lerroa:         if (IsReadableStreamDefaultReader(this) === false) {
Kode lerroa:           throw defaultReaderBrandCheckException('releaseLock');
Kode lerroa:         }
Kode lerroa:         if (this._ownerReadableStream === undefined) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (this._readRequests.length > 0) {
Kode lerroa:           throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
Kode lerroa:         }
Kode lerroa:         ReadableStreamReaderGenericRelease(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'closed',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsReadableStreamDefaultReader(this) === false) {
Kode lerroa:           return Promise.reject(defaultReaderBrandCheckException('closed'));
Kode lerroa:         }
Kode lerroa:         return this._closedPromise;
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return ReadableStreamDefaultReader;
Kode lerroa:   }();
Kode lerroa:   var ReadableStreamBYOBReader = function () {
Kode lerroa:     function ReadableStreamBYOBReader(stream) {
Kode lerroa:       _classCallCheck(this, ReadableStreamBYOBReader);
Kode lerroa:       if (!IsReadableStream(stream)) {
Kode lerroa:         throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');
Kode lerroa:       }
Kode lerroa:       if (IsReadableByteStreamController(stream._readableStreamController) === false) {
Kode lerroa:         throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
Kode lerroa:       }
Kode lerroa:       if (IsReadableStreamLocked(stream)) {
Kode lerroa:         throw new TypeError('This stream has already been locked for exclusive reading by another reader');
Kode lerroa:       }
Kode lerroa:       ReadableStreamReaderGenericInitialize(this, stream);
Kode lerroa:       this._readIntoRequests = [];
Kode lerroa:     }
Kode lerroa:     _createClass(ReadableStreamBYOBReader, [{
Kode lerroa:       key: 'cancel',
Kode lerroa:       value: function cancel(reason) {
Kode lerroa:         if (!IsReadableStreamBYOBReader(this)) {
Kode lerroa:           return Promise.reject(byobReaderBrandCheckException('cancel'));
Kode lerroa:         }
Kode lerroa:         if (this._ownerReadableStream === undefined) {
Kode lerroa:           return Promise.reject(readerLockException('cancel'));
Kode lerroa:         }
Kode lerroa:         return ReadableStreamReaderGenericCancel(this, reason);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'read',
Kode lerroa:       value: function read(view) {
Kode lerroa:         if (!IsReadableStreamBYOBReader(this)) {
Kode lerroa:           return Promise.reject(byobReaderBrandCheckException('read'));
Kode lerroa:         }
Kode lerroa:         if (this._ownerReadableStream === undefined) {
Kode lerroa:           return Promise.reject(readerLockException('read from'));
Kode lerroa:         }
Kode lerroa:         if (!ArrayBuffer.isView(view)) {
Kode lerroa:           return Promise.reject(new TypeError('view must be an array buffer view'));
Kode lerroa:         }
Kode lerroa:         if (view.byteLength === 0) {
Kode lerroa:           return Promise.reject(new TypeError('view must have non-zero byteLength'));
Kode lerroa:         }
Kode lerroa:         return ReadableStreamBYOBReaderRead(this, view);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'releaseLock',
Kode lerroa:       value: function releaseLock() {
Kode lerroa:         if (!IsReadableStreamBYOBReader(this)) {
Kode lerroa:           throw byobReaderBrandCheckException('releaseLock');
Kode lerroa:         }
Kode lerroa:         if (this._ownerReadableStream === undefined) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (this._readIntoRequests.length > 0) {
Kode lerroa:           throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
Kode lerroa:         }
Kode lerroa:         ReadableStreamReaderGenericRelease(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'closed',
Kode lerroa:       get: function get() {
Kode lerroa:         if (!IsReadableStreamBYOBReader(this)) {
Kode lerroa:           return Promise.reject(byobReaderBrandCheckException('closed'));
Kode lerroa:         }
Kode lerroa:         return this._closedPromise;
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return ReadableStreamBYOBReader;
Kode lerroa:   }();
Kode lerroa:   function IsReadableStreamBYOBReader(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function IsReadableStreamDefaultReader(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamReaderGenericInitialize(reader, stream) {
Kode lerroa:     reader._ownerReadableStream = stream;
Kode lerroa:     stream._reader = reader;
Kode lerroa:     if (stream._state === 'readable') {
Kode lerroa:       defaultReaderClosedPromiseInitialize(reader);
Kode lerroa:     } else if (stream._state === 'closed') {
Kode lerroa:       defaultReaderClosedPromiseInitializeAsResolved(reader);
Kode lerroa:     } else {
Kode lerroa:       assert(stream._state === 'errored', 'state must be errored');
Kode lerroa:       defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
Kode lerroa:       reader._closedPromise.catch(function () {});
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableStreamReaderGenericCancel(reader, reason) {
Kode lerroa:     var stream = reader._ownerReadableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     return ReadableStreamCancel(stream, reason);
Kode lerroa:   }
Kode lerroa:   function ReadableStreamReaderGenericRelease(reader) {
Kode lerroa:     assert(reader._ownerReadableStream !== undefined);
Kode lerroa:     assert(reader._ownerReadableStream._reader === reader);
Kode lerroa:     if (reader._ownerReadableStream._state === 'readable') {
Kode lerroa:       defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
Kode lerroa:     } else {
Kode lerroa:       defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
Kode lerroa:     }
Kode lerroa:     reader._closedPromise.catch(function () {});
Kode lerroa:     reader._ownerReadableStream._reader = undefined;
Kode lerroa:     reader._ownerReadableStream = undefined;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamBYOBReaderRead(reader, view) {
Kode lerroa:     var stream = reader._ownerReadableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     stream._disturbed = true;
Kode lerroa:     if (stream._state === 'errored') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultReaderRead(reader) {
Kode lerroa:     var stream = reader._ownerReadableStream;
Kode lerroa:     assert(stream !== undefined);
Kode lerroa:     stream._disturbed = true;
Kode lerroa:     if (stream._state === 'closed') {
Kode lerroa:       return Promise.resolve(CreateIterResultObject(undefined, true));
Kode lerroa:     }
Kode lerroa:     if (stream._state === 'errored') {
Kode lerroa:       return Promise.reject(stream._storedError);
Kode lerroa:     }
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     return stream._readableStreamController.__pullSteps();
Kode lerroa:   }
Kode lerroa:   var ReadableStreamDefaultController = function () {
Kode lerroa:     function ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark) {
Kode lerroa:       _classCallCheck(this, ReadableStreamDefaultController);
Kode lerroa:       if (IsReadableStream(stream) === false) {
Kode lerroa:         throw new TypeError('ReadableStreamDefaultController can only be constructed with a ReadableStream instance');
Kode lerroa:       }
Kode lerroa:       if (stream._readableStreamController !== undefined) {
Kode lerroa:         throw new TypeError('ReadableStreamDefaultController instances can only be created by the ReadableStream constructor');
Kode lerroa:       }
Kode lerroa:       this._controlledReadableStream = stream;
Kode lerroa:       this._underlyingSource = underlyingSource;
Kode lerroa:       this._queue = undefined;
Kode lerroa:       this._queueTotalSize = undefined;
Kode lerroa:       ResetQueue(this);
Kode lerroa:       this._started = false;
Kode lerroa:       this._closeRequested = false;
Kode lerroa:       this._pullAgain = false;
Kode lerroa:       this._pulling = false;
Kode lerroa:       var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
Kode lerroa:       this._strategySize = normalizedStrategy.size;
Kode lerroa:       this._strategyHWM = normalizedStrategy.highWaterMark;
Kode lerroa:       var controller = this;
Kode lerroa:       var startResult = InvokeOrNoop(underlyingSource, 'start', [this]);
Kode lerroa:       Promise.resolve(startResult).then(function () {
Kode lerroa:         controller._started = true;
Kode lerroa:         assert(controller._pulling === false);
Kode lerroa:         assert(controller._pullAgain === false);
Kode lerroa:         ReadableStreamDefaultControllerCallPullIfNeeded(controller);
Kode lerroa:       }, function (r) {
Kode lerroa:         ReadableStreamDefaultControllerErrorIfNeeded(controller, r);
Kode lerroa:       }).catch(rethrowAssertionErrorRejection);
Kode lerroa:     }
Kode lerroa:     _createClass(ReadableStreamDefaultController, [{
Kode lerroa:       key: 'close',
Kode lerroa:       value: function close() {
Kode lerroa:         if (IsReadableStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('close');
Kode lerroa:         }
Kode lerroa:         if (this._closeRequested === true) {
Kode lerroa:           throw new TypeError('The stream has already been closed; do not close it again!');
Kode lerroa:         }
Kode lerroa:         var state = this._controlledReadableStream._state;
Kode lerroa:         if (state !== 'readable') {
Kode lerroa:           throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be closed');
Kode lerroa:         }
Kode lerroa:         ReadableStreamDefaultControllerClose(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'enqueue',
Kode lerroa:       value: function enqueue(chunk) {
Kode lerroa:         if (IsReadableStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('enqueue');
Kode lerroa:         }
Kode lerroa:         if (this._closeRequested === true) {
Kode lerroa:           throw new TypeError('stream is closed or draining');
Kode lerroa:         }
Kode lerroa:         var state = this._controlledReadableStream._state;
Kode lerroa:         if (state !== 'readable') {
Kode lerroa:           throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be enqueued to');
Kode lerroa:         }
Kode lerroa:         return ReadableStreamDefaultControllerEnqueue(this, chunk);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'error',
Kode lerroa:       value: function error(e) {
Kode lerroa:         if (IsReadableStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('error');
Kode lerroa:         }
Kode lerroa:         var stream = this._controlledReadableStream;
Kode lerroa:         if (stream._state !== 'readable') {
Kode lerroa:           throw new TypeError('The stream is ' + stream._state + ' and so cannot be errored');
Kode lerroa:         }
Kode lerroa:         ReadableStreamDefaultControllerError(this, e);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__cancelSteps',
Kode lerroa:       value: function __cancelSteps(reason) {
Kode lerroa:         ResetQueue(this);
Kode lerroa:         return PromiseInvokeOrNoop(this._underlyingSource, 'cancel', [reason]);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__pullSteps',
Kode lerroa:       value: function __pullSteps() {
Kode lerroa:         var stream = this._controlledReadableStream;
Kode lerroa:         if (this._queue.length > 0) {
Kode lerroa:           var chunk = DequeueValue(this);
Kode lerroa:           if (this._closeRequested === true && this._queue.length === 0) {
Kode lerroa:             ReadableStreamClose(stream);
Kode lerroa:           } else {
Kode lerroa:             ReadableStreamDefaultControllerCallPullIfNeeded(this);
Kode lerroa:           }
Kode lerroa:           return Promise.resolve(CreateIterResultObject(chunk, false));
Kode lerroa:         }
Kode lerroa:         var pendingPromise = ReadableStreamAddReadRequest(stream);
Kode lerroa:         ReadableStreamDefaultControllerCallPullIfNeeded(this);
Kode lerroa:         return pendingPromise;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'desiredSize',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsReadableStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('desiredSize');
Kode lerroa:         }
Kode lerroa:         return ReadableStreamDefaultControllerGetDesiredSize(this);
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return ReadableStreamDefaultController;
Kode lerroa:   }();
Kode lerroa:   function IsReadableStreamDefaultController(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSource')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
Kode lerroa:     var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
Kode lerroa:     if (shouldPull === false) {
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     if (controller._pulling === true) {
Kode lerroa:       controller._pullAgain = true;
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     assert(controller._pullAgain === false);
Kode lerroa:     controller._pulling = true;
Kode lerroa:     var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, 'pull', [controller]);
Kode lerroa:     pullPromise.then(function () {
Kode lerroa:       controller._pulling = false;
Kode lerroa:       if (controller._pullAgain === true) {
Kode lerroa:         controller._pullAgain = false;
Kode lerroa:         return ReadableStreamDefaultControllerCallPullIfNeeded(controller);
Kode lerroa:       }
Kode lerroa:       return undefined;
Kode lerroa:     }, function (e) {
Kode lerroa:       ReadableStreamDefaultControllerErrorIfNeeded(controller, e);
Kode lerroa:     }).catch(rethrowAssertionErrorRejection);
Kode lerroa:     return undefined;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerShouldCallPull(controller) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     if (stream._state === 'closed' || stream._state === 'errored') {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (controller._closeRequested === true) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (controller._started === false) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
Kode lerroa:     if (desiredSize > 0) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerClose(controller) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     assert(controller._closeRequested === false);
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     controller._closeRequested = true;
Kode lerroa:     if (controller._queue.length === 0) {
Kode lerroa:       ReadableStreamClose(stream);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     assert(controller._closeRequested === false);
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
Kode lerroa:       ReadableStreamFulfillReadRequest(stream, chunk, false);
Kode lerroa:     } else {
Kode lerroa:       var chunkSize = 1;
Kode lerroa:       if (controller._strategySize !== undefined) {
Kode lerroa:         var strategySize = controller._strategySize;
Kode lerroa:         try {
Kode lerroa:           chunkSize = strategySize(chunk);
Kode lerroa:         } catch (chunkSizeE) {
Kode lerroa:           ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
Kode lerroa:           throw chunkSizeE;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       try {
Kode lerroa:         EnqueueValueWithSize(controller, chunk, chunkSize);
Kode lerroa:       } catch (enqueueE) {
Kode lerroa:         ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
Kode lerroa:         throw enqueueE;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     ReadableStreamDefaultControllerCallPullIfNeeded(controller);
Kode lerroa:     return undefined;
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerError(controller, e) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     ResetQueue(controller);
Kode lerroa:     ReadableStreamError(stream, e);
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {
Kode lerroa:     if (controller._controlledReadableStream._state === 'readable') {
Kode lerroa:       ReadableStreamDefaultControllerError(controller, e);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableStreamDefaultControllerGetDesiredSize(controller) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'errored') {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:     if (state === 'closed') {
Kode lerroa:       return 0;
Kode lerroa:     }
Kode lerroa:     return controller._strategyHWM - controller._queueTotalSize;
Kode lerroa:   }
Kode lerroa:   var ReadableStreamBYOBRequest = function () {
Kode lerroa:     function ReadableStreamBYOBRequest(controller, view) {
Kode lerroa:       _classCallCheck(this, ReadableStreamBYOBRequest);
Kode lerroa:       this._associatedReadableByteStreamController = controller;
Kode lerroa:       this._view = view;
Kode lerroa:     }
Kode lerroa:     _createClass(ReadableStreamBYOBRequest, [{
Kode lerroa:       key: 'respond',
Kode lerroa:       value: function respond(bytesWritten) {
Kode lerroa:         if (IsReadableStreamBYOBRequest(this) === false) {
Kode lerroa:           throw byobRequestBrandCheckException('respond');
Kode lerroa:         }
Kode lerroa:         if (this._associatedReadableByteStreamController === undefined) {
Kode lerroa:           throw new TypeError('This BYOB request has been invalidated');
Kode lerroa:         }
Kode lerroa:         ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'respondWithNewView',
Kode lerroa:       value: function respondWithNewView(view) {
Kode lerroa:         if (IsReadableStreamBYOBRequest(this) === false) {
Kode lerroa:           throw byobRequestBrandCheckException('respond');
Kode lerroa:         }
Kode lerroa:         if (this._associatedReadableByteStreamController === undefined) {
Kode lerroa:           throw new TypeError('This BYOB request has been invalidated');
Kode lerroa:         }
Kode lerroa:         if (!ArrayBuffer.isView(view)) {
Kode lerroa:           throw new TypeError('You can only respond with array buffer views');
Kode lerroa:         }
Kode lerroa:         ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'view',
Kode lerroa:       get: function get() {
Kode lerroa:         return this._view;
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return ReadableStreamBYOBRequest;
Kode lerroa:   }();
Kode lerroa:   var ReadableByteStreamController = function () {
Kode lerroa:     function ReadableByteStreamController(stream, underlyingByteSource, highWaterMark) {
Kode lerroa:       _classCallCheck(this, ReadableByteStreamController);
Kode lerroa:       if (IsReadableStream(stream) === false) {
Kode lerroa:         throw new TypeError('ReadableByteStreamController can only be constructed with a ReadableStream instance given ' + 'a byte source');
Kode lerroa:       }
Kode lerroa:       if (stream._readableStreamController !== undefined) {
Kode lerroa:         throw new TypeError('ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte ' + 'source');
Kode lerroa:       }
Kode lerroa:       this._controlledReadableStream = stream;
Kode lerroa:       this._underlyingByteSource = underlyingByteSource;
Kode lerroa:       this._pullAgain = false;
Kode lerroa:       this._pulling = false;
Kode lerroa:       ReadableByteStreamControllerClearPendingPullIntos(this);
Kode lerroa:       this._queue = this._queueTotalSize = undefined;
Kode lerroa:       ResetQueue(this);
Kode lerroa:       this._closeRequested = false;
Kode lerroa:       this._started = false;
Kode lerroa:       this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
Kode lerroa:       var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
Kode lerroa:       if (autoAllocateChunkSize !== undefined) {
Kode lerroa:         if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
Kode lerroa:           throw new RangeError('autoAllocateChunkSize must be a positive integer');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this._autoAllocateChunkSize = autoAllocateChunkSize;
Kode lerroa:       this._pendingPullIntos = [];
Kode lerroa:       var controller = this;
Kode lerroa:       var startResult = InvokeOrNoop(underlyingByteSource, 'start', [this]);
Kode lerroa:       Promise.resolve(startResult).then(function () {
Kode lerroa:         controller._started = true;
Kode lerroa:         assert(controller._pulling === false);
Kode lerroa:         assert(controller._pullAgain === false);
Kode lerroa:         ReadableByteStreamControllerCallPullIfNeeded(controller);
Kode lerroa:       }, function (r) {
Kode lerroa:         if (stream._state === 'readable') {
Kode lerroa:           ReadableByteStreamControllerError(controller, r);
Kode lerroa:         }
Kode lerroa:       }).catch(rethrowAssertionErrorRejection);
Kode lerroa:     }
Kode lerroa:     _createClass(ReadableByteStreamController, [{
Kode lerroa:       key: 'close',
Kode lerroa:       value: function close() {
Kode lerroa:         if (IsReadableByteStreamController(this) === false) {
Kode lerroa:           throw byteStreamControllerBrandCheckException('close');
Kode lerroa:         }
Kode lerroa:         if (this._closeRequested === true) {
Kode lerroa:           throw new TypeError('The stream has already been closed; do not close it again!');
Kode lerroa:         }
Kode lerroa:         var state = this._controlledReadableStream._state;
Kode lerroa:         if (state !== 'readable') {
Kode lerroa:           throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be closed');
Kode lerroa:         }
Kode lerroa:         ReadableByteStreamControllerClose(this);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'enqueue',
Kode lerroa:       value: function enqueue(chunk) {
Kode lerroa:         if (IsReadableByteStreamController(this) === false) {
Kode lerroa:           throw byteStreamControllerBrandCheckException('enqueue');
Kode lerroa:         }
Kode lerroa:         if (this._closeRequested === true) {
Kode lerroa:           throw new TypeError('stream is closed or draining');
Kode lerroa:         }
Kode lerroa:         var state = this._controlledReadableStream._state;
Kode lerroa:         if (state !== 'readable') {
Kode lerroa:           throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be enqueued to');
Kode lerroa:         }
Kode lerroa:         if (!ArrayBuffer.isView(chunk)) {
Kode lerroa:           throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');
Kode lerroa:         }
Kode lerroa:         ReadableByteStreamControllerEnqueue(this, chunk);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'error',
Kode lerroa:       value: function error(e) {
Kode lerroa:         if (IsReadableByteStreamController(this) === false) {
Kode lerroa:           throw byteStreamControllerBrandCheckException('error');
Kode lerroa:         }
Kode lerroa:         var stream = this._controlledReadableStream;
Kode lerroa:         if (stream._state !== 'readable') {
Kode lerroa:           throw new TypeError('The stream is ' + stream._state + ' and so cannot be errored');
Kode lerroa:         }
Kode lerroa:         ReadableByteStreamControllerError(this, e);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__cancelSteps',
Kode lerroa:       value: function __cancelSteps(reason) {
Kode lerroa:         if (this._pendingPullIntos.length > 0) {
Kode lerroa:           var firstDescriptor = this._pendingPullIntos[0];
Kode lerroa:           firstDescriptor.bytesFilled = 0;
Kode lerroa:         }
Kode lerroa:         ResetQueue(this);
Kode lerroa:         return PromiseInvokeOrNoop(this._underlyingByteSource, 'cancel', [reason]);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: '__pullSteps',
Kode lerroa:       value: function __pullSteps() {
Kode lerroa:         var stream = this._controlledReadableStream;
Kode lerroa:         assert(ReadableStreamHasDefaultReader(stream) === true);
Kode lerroa:         if (this._queueTotalSize > 0) {
Kode lerroa:           assert(ReadableStreamGetNumReadRequests(stream) === 0);
Kode lerroa:           var entry = this._queue.shift();
Kode lerroa:           this._queueTotalSize -= entry.byteLength;
Kode lerroa:           ReadableByteStreamControllerHandleQueueDrain(this);
Kode lerroa:           var view = void 0;
Kode lerroa:           try {
Kode lerroa:             view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
Kode lerroa:           } catch (viewE) {
Kode lerroa:             return Promise.reject(viewE);
Kode lerroa:           }
Kode lerroa:           return Promise.resolve(CreateIterResultObject(view, false));
Kode lerroa:         }
Kode lerroa:         var autoAllocateChunkSize = this._autoAllocateChunkSize;
Kode lerroa:         if (autoAllocateChunkSize !== undefined) {
Kode lerroa:           var buffer = void 0;
Kode lerroa:           try {
Kode lerroa:             buffer = new ArrayBuffer(autoAllocateChunkSize);
Kode lerroa:           } catch (bufferE) {
Kode lerroa:             return Promise.reject(bufferE);
Kode lerroa:           }
Kode lerroa:           var pullIntoDescriptor = {
Kode lerroa:             buffer: buffer,
Kode lerroa:             byteOffset: 0,
Kode lerroa:             byteLength: autoAllocateChunkSize,
Kode lerroa:             bytesFilled: 0,
Kode lerroa:             elementSize: 1,
Kode lerroa:             ctor: Uint8Array,
Kode lerroa:             readerType: 'default'
Kode lerroa:           };
Kode lerroa:           this._pendingPullIntos.push(pullIntoDescriptor);
Kode lerroa:         }
Kode lerroa:         var promise = ReadableStreamAddReadRequest(stream);
Kode lerroa:         ReadableByteStreamControllerCallPullIfNeeded(this);
Kode lerroa:         return promise;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'byobRequest',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsReadableByteStreamController(this) === false) {
Kode lerroa:           throw byteStreamControllerBrandCheckException('byobRequest');
Kode lerroa:         }
Kode lerroa:         if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {
Kode lerroa:           var firstDescriptor = this._pendingPullIntos[0];
Kode lerroa:           var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
Kode lerroa:           this._byobRequest = new ReadableStreamBYOBRequest(this, view);
Kode lerroa:         }
Kode lerroa:         return this._byobRequest;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'desiredSize',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsReadableByteStreamController(this) === false) {
Kode lerroa:           throw byteStreamControllerBrandCheckException('desiredSize');
Kode lerroa:         }
Kode lerroa:         return ReadableByteStreamControllerGetDesiredSize(this);
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return ReadableByteStreamController;
Kode lerroa:   }();
Kode lerroa:   function IsReadableByteStreamController(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_underlyingByteSource')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function IsReadableStreamBYOBRequest(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerCallPullIfNeeded(controller) {
Kode lerroa:     var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
Kode lerroa:     if (shouldPull === false) {
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     if (controller._pulling === true) {
Kode lerroa:       controller._pullAgain = true;
Kode lerroa:       return undefined;
Kode lerroa:     }
Kode lerroa:     assert(controller._pullAgain === false);
Kode lerroa:     controller._pulling = true;
Kode lerroa:     var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, 'pull', [controller]);
Kode lerroa:     pullPromise.then(function () {
Kode lerroa:       controller._pulling = false;
Kode lerroa:       if (controller._pullAgain === true) {
Kode lerroa:         controller._pullAgain = false;
Kode lerroa:         ReadableByteStreamControllerCallPullIfNeeded(controller);
Kode lerroa:       }
Kode lerroa:     }, function (e) {
Kode lerroa:       if (controller._controlledReadableStream._state === 'readable') {
Kode lerroa:         ReadableByteStreamControllerError(controller, e);
Kode lerroa:       }
Kode lerroa:     }).catch(rethrowAssertionErrorRejection);
Kode lerroa:     return undefined;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerClearPendingPullIntos(controller) {
Kode lerroa:     ReadableByteStreamControllerInvalidateBYOBRequest(controller);
Kode lerroa:     controller._pendingPullIntos = [];
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
Kode lerroa:     assert(stream._state !== 'errored', 'state must not be errored');
Kode lerroa:     var done = false;
Kode lerroa:     if (stream._state === 'closed') {
Kode lerroa:       assert(pullIntoDescriptor.bytesFilled === 0);
Kode lerroa:       done = true;
Kode lerroa:     }
Kode lerroa:     var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
Kode lerroa:     if (pullIntoDescriptor.readerType === 'default') {
Kode lerroa:       ReadableStreamFulfillReadRequest(stream, filledView, done);
Kode lerroa:     } else {
Kode lerroa:       assert(pullIntoDescriptor.readerType === 'byob');
Kode lerroa:       ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
Kode lerroa:     var bytesFilled = pullIntoDescriptor.bytesFilled;
Kode lerroa:     var elementSize = pullIntoDescriptor.elementSize;
Kode lerroa:     assert(bytesFilled <= pullIntoDescriptor.byteLength);
Kode lerroa:     assert(bytesFilled % elementSize === 0);
Kode lerroa:     return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
Kode lerroa:     controller._queue.push({
Kode lerroa:       buffer: buffer,
Kode lerroa:       byteOffset: byteOffset,
Kode lerroa:       byteLength: byteLength
Kode lerroa:     });
Kode lerroa:     controller._queueTotalSize += byteLength;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
Kode lerroa:     var elementSize = pullIntoDescriptor.elementSize;
Kode lerroa:     var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
Kode lerroa:     var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
Kode lerroa:     var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
Kode lerroa:     var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
Kode lerroa:     var totalBytesToCopyRemaining = maxBytesToCopy;
Kode lerroa:     var ready = false;
Kode lerroa:     if (maxAlignedBytes > currentAlignedBytes) {
Kode lerroa:       totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
Kode lerroa:       ready = true;
Kode lerroa:     }
Kode lerroa:     var queue = controller._queue;
Kode lerroa:     while (totalBytesToCopyRemaining > 0) {
Kode lerroa:       var headOfQueue = queue[0];
Kode lerroa:       var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
Kode lerroa:       var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
Kode lerroa:       ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
Kode lerroa:       if (headOfQueue.byteLength === bytesToCopy) {
Kode lerroa:         queue.shift();
Kode lerroa:       } else {
Kode lerroa:         headOfQueue.byteOffset += bytesToCopy;
Kode lerroa:         headOfQueue.byteLength -= bytesToCopy;
Kode lerroa:       }
Kode lerroa:       controller._queueTotalSize -= bytesToCopy;
Kode lerroa:       ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
Kode lerroa:       totalBytesToCopyRemaining -= bytesToCopy;
Kode lerroa:     }
Kode lerroa:     if (ready === false) {
Kode lerroa:       assert(controller._queueTotalSize === 0, 'queue must be empty');
Kode lerroa:       assert(pullIntoDescriptor.bytesFilled > 0);
Kode lerroa:       assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);
Kode lerroa:     }
Kode lerroa:     return ready;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
Kode lerroa:     assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);
Kode lerroa:     ReadableByteStreamControllerInvalidateBYOBRequest(controller);
Kode lerroa:     pullIntoDescriptor.bytesFilled += size;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerHandleQueueDrain(controller) {
Kode lerroa:     assert(controller._controlledReadableStream._state === 'readable');
Kode lerroa:     if (controller._queueTotalSize === 0 && controller._closeRequested === true) {
Kode lerroa:       ReadableStreamClose(controller._controlledReadableStream);
Kode lerroa:     } else {
Kode lerroa:       ReadableByteStreamControllerCallPullIfNeeded(controller);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
Kode lerroa:     if (controller._byobRequest === undefined) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     controller._byobRequest._associatedReadableByteStreamController = undefined;
Kode lerroa:     controller._byobRequest._view = undefined;
Kode lerroa:     controller._byobRequest = undefined;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
Kode lerroa:     assert(controller._closeRequested === false);
Kode lerroa:     while (controller._pendingPullIntos.length > 0) {
Kode lerroa:       if (controller._queueTotalSize === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var pullIntoDescriptor = controller._pendingPullIntos[0];
Kode lerroa:       if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
Kode lerroa:         ReadableByteStreamControllerShiftPendingPullInto(controller);
Kode lerroa:         ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerPullInto(controller, view) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     var elementSize = 1;
Kode lerroa:     if (view.constructor !== DataView) {
Kode lerroa:       elementSize = view.constructor.BYTES_PER_ELEMENT;
Kode lerroa:     }
Kode lerroa:     var ctor = view.constructor;
Kode lerroa:     var pullIntoDescriptor = {
Kode lerroa:       buffer: view.buffer,
Kode lerroa:       byteOffset: view.byteOffset,
Kode lerroa:       byteLength: view.byteLength,
Kode lerroa:       bytesFilled: 0,
Kode lerroa:       elementSize: elementSize,
Kode lerroa:       ctor: ctor,
Kode lerroa:       readerType: 'byob'
Kode lerroa:     };
Kode lerroa:     if (controller._pendingPullIntos.length > 0) {
Kode lerroa:       pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
Kode lerroa:       controller._pendingPullIntos.push(pullIntoDescriptor);
Kode lerroa:       return ReadableStreamAddReadIntoRequest(stream);
Kode lerroa:     }
Kode lerroa:     if (stream._state === 'closed') {
Kode lerroa:       var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
Kode lerroa:       return Promise.resolve(CreateIterResultObject(emptyView, true));
Kode lerroa:     }
Kode lerroa:     if (controller._queueTotalSize > 0) {
Kode lerroa:       if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
Kode lerroa:         var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
Kode lerroa:         ReadableByteStreamControllerHandleQueueDrain(controller);
Kode lerroa:         return Promise.resolve(CreateIterResultObject(filledView, false));
Kode lerroa:       }
Kode lerroa:       if (controller._closeRequested === true) {
Kode lerroa:         var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
Kode lerroa:         ReadableByteStreamControllerError(controller, e);
Kode lerroa:         return Promise.reject(e);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
Kode lerroa:     controller._pendingPullIntos.push(pullIntoDescriptor);
Kode lerroa:     var promise = ReadableStreamAddReadIntoRequest(stream);
Kode lerroa:     ReadableByteStreamControllerCallPullIfNeeded(controller);
Kode lerroa:     return promise;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
Kode lerroa:     firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
Kode lerroa:     assert(firstDescriptor.bytesFilled === 0, 'bytesFilled must be 0');
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     if (ReadableStreamHasBYOBReader(stream) === true) {
Kode lerroa:       while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
Kode lerroa:         var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
Kode lerroa:         ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
Kode lerroa:     if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
Kode lerroa:       throw new RangeError('bytesWritten out of range');
Kode lerroa:     }
Kode lerroa:     ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
Kode lerroa:     if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     ReadableByteStreamControllerShiftPendingPullInto(controller);
Kode lerroa:     var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
Kode lerroa:     if (remainderSize > 0) {
Kode lerroa:       var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
Kode lerroa:       var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
Kode lerroa:       ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
Kode lerroa:     }
Kode lerroa:     pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
Kode lerroa:     pullIntoDescriptor.bytesFilled -= remainderSize;
Kode lerroa:     ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
Kode lerroa:     ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
Kode lerroa:     var firstDescriptor = controller._pendingPullIntos[0];
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     if (stream._state === 'closed') {
Kode lerroa:       if (bytesWritten !== 0) {
Kode lerroa:         throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
Kode lerroa:       }
Kode lerroa:       ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
Kode lerroa:     } else {
Kode lerroa:       assert(stream._state === 'readable');
Kode lerroa:       ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerShiftPendingPullInto(controller) {
Kode lerroa:     var descriptor = controller._pendingPullIntos.shift();
Kode lerroa:     ReadableByteStreamControllerInvalidateBYOBRequest(controller);
Kode lerroa:     return descriptor;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerShouldCallPull(controller) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     if (stream._state !== 'readable') {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (controller._closeRequested === true) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (controller._started === false) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerClose(controller) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     assert(controller._closeRequested === false);
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     if (controller._queueTotalSize > 0) {
Kode lerroa:       controller._closeRequested = true;
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (controller._pendingPullIntos.length > 0) {
Kode lerroa:       var firstPendingPullInto = controller._pendingPullIntos[0];
Kode lerroa:       if (firstPendingPullInto.bytesFilled > 0) {
Kode lerroa:         var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
Kode lerroa:         ReadableByteStreamControllerError(controller, e);
Kode lerroa:         throw e;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     ReadableStreamClose(stream);
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerEnqueue(controller, chunk) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     assert(controller._closeRequested === false);
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     var buffer = chunk.buffer;
Kode lerroa:     var byteOffset = chunk.byteOffset;
Kode lerroa:     var byteLength = chunk.byteLength;
Kode lerroa:     var transferredBuffer = TransferArrayBuffer(buffer);
Kode lerroa:     if (ReadableStreamHasDefaultReader(stream) === true) {
Kode lerroa:       if (ReadableStreamGetNumReadRequests(stream) === 0) {
Kode lerroa:         ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
Kode lerroa:       } else {
Kode lerroa:         assert(controller._queue.length === 0);
Kode lerroa:         var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
Kode lerroa:         ReadableStreamFulfillReadRequest(stream, transferredView, false);
Kode lerroa:       }
Kode lerroa:     } else if (ReadableStreamHasBYOBReader(stream) === true) {
Kode lerroa:       ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
Kode lerroa:       ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
Kode lerroa:     } else {
Kode lerroa:       assert(IsReadableStreamLocked(stream) === false, 'stream must not be locked');
Kode lerroa:       ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerError(controller, e) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     assert(stream._state === 'readable');
Kode lerroa:     ReadableByteStreamControllerClearPendingPullIntos(controller);
Kode lerroa:     ResetQueue(controller);
Kode lerroa:     ReadableStreamError(stream, e);
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerGetDesiredSize(controller) {
Kode lerroa:     var stream = controller._controlledReadableStream;
Kode lerroa:     var state = stream._state;
Kode lerroa:     if (state === 'errored') {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:     if (state === 'closed') {
Kode lerroa:       return 0;
Kode lerroa:     }
Kode lerroa:     return controller._strategyHWM - controller._queueTotalSize;
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerRespond(controller, bytesWritten) {
Kode lerroa:     bytesWritten = Number(bytesWritten);
Kode lerroa:     if (IsFiniteNonNegativeNumber(bytesWritten) === false) {
Kode lerroa:       throw new RangeError('bytesWritten must be a finite');
Kode lerroa:     }
Kode lerroa:     assert(controller._pendingPullIntos.length > 0);
Kode lerroa:     ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
Kode lerroa:   }
Kode lerroa:   function ReadableByteStreamControllerRespondWithNewView(controller, view) {
Kode lerroa:     assert(controller._pendingPullIntos.length > 0);
Kode lerroa:     var firstDescriptor = controller._pendingPullIntos[0];
Kode lerroa:     if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
Kode lerroa:       throw new RangeError('The region specified by view does not match byobRequest');
Kode lerroa:     }
Kode lerroa:     if (firstDescriptor.byteLength !== view.byteLength) {
Kode lerroa:       throw new RangeError('The buffer of view has different capacity than byobRequest');
Kode lerroa:     }
Kode lerroa:     firstDescriptor.buffer = view.buffer;
Kode lerroa:     ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
Kode lerroa:   }
Kode lerroa:   function streamBrandCheckException(name) {
Kode lerroa:     return new TypeError('ReadableStream.prototype.' + name + ' can only be used on a ReadableStream');
Kode lerroa:   }
Kode lerroa:   function readerLockException(name) {
Kode lerroa:     return new TypeError('Cannot ' + name + ' a stream using a released reader');
Kode lerroa:   }
Kode lerroa:   function defaultReaderBrandCheckException(name) {
Kode lerroa:     return new TypeError('ReadableStreamDefaultReader.prototype.' + name + ' can only be used on a ReadableStreamDefaultReader');
Kode lerroa:   }
Kode lerroa:   function defaultReaderClosedPromiseInitialize(reader) {
Kode lerroa:     reader._closedPromise = new Promise(function (resolve, reject) {
Kode lerroa:       reader._closedPromise_resolve = resolve;
Kode lerroa:       reader._closedPromise_reject = reject;
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
Kode lerroa:     reader._closedPromise = Promise.reject(reason);
Kode lerroa:     reader._closedPromise_resolve = undefined;
Kode lerroa:     reader._closedPromise_reject = undefined;
Kode lerroa:   }
Kode lerroa:   function defaultReaderClosedPromiseInitializeAsResolved(reader) {
Kode lerroa:     reader._closedPromise = Promise.resolve(undefined);
Kode lerroa:     reader._closedPromise_resolve = undefined;
Kode lerroa:     reader._closedPromise_reject = undefined;
Kode lerroa:   }
Kode lerroa:   function defaultReaderClosedPromiseReject(reader, reason) {
Kode lerroa:     assert(reader._closedPromise_resolve !== undefined);
Kode lerroa:     assert(reader._closedPromise_reject !== undefined);
Kode lerroa:     reader._closedPromise_reject(reason);
Kode lerroa:     reader._closedPromise_resolve = undefined;
Kode lerroa:     reader._closedPromise_reject = undefined;
Kode lerroa:   }
Kode lerroa:   function defaultReaderClosedPromiseResetToRejected(reader, reason) {
Kode lerroa:     assert(reader._closedPromise_resolve === undefined);
Kode lerroa:     assert(reader._closedPromise_reject === undefined);
Kode lerroa:     reader._closedPromise = Promise.reject(reason);
Kode lerroa:   }
Kode lerroa:   function defaultReaderClosedPromiseResolve(reader) {
Kode lerroa:     assert(reader._closedPromise_resolve !== undefined);
Kode lerroa:     assert(reader._closedPromise_reject !== undefined);
Kode lerroa:     reader._closedPromise_resolve(undefined);
Kode lerroa:     reader._closedPromise_resolve = undefined;
Kode lerroa:     reader._closedPromise_reject = undefined;
Kode lerroa:   }
Kode lerroa:   function byobReaderBrandCheckException(name) {
Kode lerroa:     return new TypeError('ReadableStreamBYOBReader.prototype.' + name + ' can only be used on a ReadableStreamBYOBReader');
Kode lerroa:   }
Kode lerroa:   function defaultControllerBrandCheckException(name) {
Kode lerroa:     return new TypeError('ReadableStreamDefaultController.prototype.' + name + ' can only be used on a ReadableStreamDefaultController');
Kode lerroa:   }
Kode lerroa:   function byobRequestBrandCheckException(name) {
Kode lerroa:     return new TypeError('ReadableStreamBYOBRequest.prototype.' + name + ' can only be used on a ReadableStreamBYOBRequest');
Kode lerroa:   }
Kode lerroa:   function byteStreamControllerBrandCheckException(name) {
Kode lerroa:     return new TypeError('ReadableByteStreamController.prototype.' + name + ' can only be used on a ReadableByteStreamController');
Kode lerroa:   }
Kode lerroa:   function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {
Kode lerroa:     try {
Kode lerroa:       Promise.prototype.then.call(promise, undefined, function () {});
Kode lerroa:     } catch (e) {}
Kode lerroa:   }
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   var transformStream = __w_pdfjs_require__(6);
Kode lerroa:   var readableStream = __w_pdfjs_require__(4);
Kode lerroa:   var writableStream = __w_pdfjs_require__(2);
Kode lerroa:   exports.TransformStream = transformStream.TransformStream;
Kode lerroa:   exports.ReadableStream = readableStream.ReadableStream;
Kode lerroa:   exports.IsReadableStreamDisturbed = readableStream.IsReadableStreamDisturbed;
Kode lerroa:   exports.ReadableStreamDefaultControllerClose = readableStream.ReadableStreamDefaultControllerClose;
Kode lerroa:   exports.ReadableStreamDefaultControllerEnqueue = readableStream.ReadableStreamDefaultControllerEnqueue;
Kode lerroa:   exports.ReadableStreamDefaultControllerError = readableStream.ReadableStreamDefaultControllerError;
Kode lerroa:   exports.ReadableStreamDefaultControllerGetDesiredSize = readableStream.ReadableStreamDefaultControllerGetDesiredSize;
Kode lerroa:   exports.AcquireWritableStreamDefaultWriter = writableStream.AcquireWritableStreamDefaultWriter;
Kode lerroa:   exports.IsWritableStream = writableStream.IsWritableStream;
Kode lerroa:   exports.IsWritableStreamLocked = writableStream.IsWritableStreamLocked;
Kode lerroa:   exports.WritableStream = writableStream.WritableStream;
Kode lerroa:   exports.WritableStreamAbort = writableStream.WritableStreamAbort;
Kode lerroa:   exports.WritableStreamDefaultControllerError = writableStream.WritableStreamDefaultControllerError;
Kode lerroa:   exports.WritableStreamDefaultWriterCloseWithErrorPropagation = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation;
Kode lerroa:   exports.WritableStreamDefaultWriterRelease = writableStream.WritableStreamDefaultWriterRelease;
Kode lerroa:   exports.WritableStreamDefaultWriterWrite = writableStream.WritableStreamDefaultWriterWrite;
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   "use strict";
Kode lerroa: 
Kode lerroa:   var _createClass = function () {
Kode lerroa:     function defineProperties(target, props) {
Kode lerroa:       for (var i = 0; i < props.length; i++) {
Kode lerroa:         var descriptor = props[i];
Kode lerroa:         descriptor.enumerable = descriptor.enumerable || false;
Kode lerroa:         descriptor.configurable = true;
Kode lerroa:         if ("value" in descriptor) descriptor.writable = true;
Kode lerroa:         Object.defineProperty(target, descriptor.key, descriptor);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return function (Constructor, protoProps, staticProps) {
Kode lerroa:       if (protoProps) defineProperties(Constructor.prototype, protoProps);
Kode lerroa:       if (staticProps) defineProperties(Constructor, staticProps);
Kode lerroa:       return Constructor;
Kode lerroa:     };
Kode lerroa:   }();
Kode lerroa:   function _classCallCheck(instance, Constructor) {
Kode lerroa:     if (!(instance instanceof Constructor)) {
Kode lerroa:       throw new TypeError("Cannot call a class as a function");
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var _require = __w_pdfjs_require__(1),
Kode lerroa:       assert = _require.assert;
Kode lerroa:   var _require2 = __w_pdfjs_require__(0),
Kode lerroa:       InvokeOrNoop = _require2.InvokeOrNoop,
Kode lerroa:       PromiseInvokeOrPerformFallback = _require2.PromiseInvokeOrPerformFallback,
Kode lerroa:       PromiseInvokeOrNoop = _require2.PromiseInvokeOrNoop,
Kode lerroa:       typeIsObject = _require2.typeIsObject;
Kode lerroa:   var _require3 = __w_pdfjs_require__(4),
Kode lerroa:       ReadableStream = _require3.ReadableStream,
Kode lerroa:       ReadableStreamDefaultControllerClose = _require3.ReadableStreamDefaultControllerClose,
Kode lerroa:       ReadableStreamDefaultControllerEnqueue = _require3.ReadableStreamDefaultControllerEnqueue,
Kode lerroa:       ReadableStreamDefaultControllerError = _require3.ReadableStreamDefaultControllerError,
Kode lerroa:       ReadableStreamDefaultControllerGetDesiredSize = _require3.ReadableStreamDefaultControllerGetDesiredSize;
Kode lerroa:   var _require4 = __w_pdfjs_require__(2),
Kode lerroa:       WritableStream = _require4.WritableStream,
Kode lerroa:       WritableStreamDefaultControllerError = _require4.WritableStreamDefaultControllerError;
Kode lerroa:   function TransformStreamCloseReadable(transformStream) {
Kode lerroa:     if (transformStream._errored === true) {
Kode lerroa:       throw new TypeError('TransformStream is already errored');
Kode lerroa:     }
Kode lerroa:     if (transformStream._readableClosed === true) {
Kode lerroa:       throw new TypeError('Readable side is already closed');
Kode lerroa:     }
Kode lerroa:     TransformStreamCloseReadableInternal(transformStream);
Kode lerroa:   }
Kode lerroa:   function TransformStreamEnqueueToReadable(transformStream, chunk) {
Kode lerroa:     if (transformStream._errored === true) {
Kode lerroa:       throw new TypeError('TransformStream is already errored');
Kode lerroa:     }
Kode lerroa:     if (transformStream._readableClosed === true) {
Kode lerroa:       throw new TypeError('Readable side is already closed');
Kode lerroa:     }
Kode lerroa:     var controller = transformStream._readableController;
Kode lerroa:     try {
Kode lerroa:       ReadableStreamDefaultControllerEnqueue(controller, chunk);
Kode lerroa:     } catch (e) {
Kode lerroa:       transformStream._readableClosed = true;
Kode lerroa:       TransformStreamErrorIfNeeded(transformStream, e);
Kode lerroa:       throw transformStream._storedError;
Kode lerroa:     }
Kode lerroa:     var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
Kode lerroa:     var maybeBackpressure = desiredSize <= 0;
Kode lerroa:     if (maybeBackpressure === true && transformStream._backpressure === false) {
Kode lerroa:       TransformStreamSetBackpressure(transformStream, true);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function TransformStreamError(transformStream, e) {
Kode lerroa:     if (transformStream._errored === true) {
Kode lerroa:       throw new TypeError('TransformStream is already errored');
Kode lerroa:     }
Kode lerroa:     TransformStreamErrorInternal(transformStream, e);
Kode lerroa:   }
Kode lerroa:   function TransformStreamCloseReadableInternal(transformStream) {
Kode lerroa:     assert(transformStream._errored === false);
Kode lerroa:     assert(transformStream._readableClosed === false);
Kode lerroa:     try {
Kode lerroa:       ReadableStreamDefaultControllerClose(transformStream._readableController);
Kode lerroa:     } catch (e) {
Kode lerroa:       assert(false);
Kode lerroa:     }
Kode lerroa:     transformStream._readableClosed = true;
Kode lerroa:   }
Kode lerroa:   function TransformStreamErrorIfNeeded(transformStream, e) {
Kode lerroa:     if (transformStream._errored === false) {
Kode lerroa:       TransformStreamErrorInternal(transformStream, e);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function TransformStreamErrorInternal(transformStream, e) {
Kode lerroa:     assert(transformStream._errored === false);
Kode lerroa:     transformStream._errored = true;
Kode lerroa:     transformStream._storedError = e;
Kode lerroa:     if (transformStream._writableDone === false) {
Kode lerroa:       WritableStreamDefaultControllerError(transformStream._writableController, e);
Kode lerroa:     }
Kode lerroa:     if (transformStream._readableClosed === false) {
Kode lerroa:       ReadableStreamDefaultControllerError(transformStream._readableController, e);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function TransformStreamReadableReadyPromise(transformStream) {
Kode lerroa:     assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');
Kode lerroa:     if (transformStream._backpressure === false) {
Kode lerroa:       return Promise.resolve();
Kode lerroa:     }
Kode lerroa:     assert(transformStream._backpressure === true, '_backpressure should have been initialized');
Kode lerroa:     return transformStream._backpressureChangePromise;
Kode lerroa:   }
Kode lerroa:   function TransformStreamSetBackpressure(transformStream, backpressure) {
Kode lerroa:     assert(transformStream._backpressure !== backpressure, 'TransformStreamSetBackpressure() should be called only when backpressure is changed');
Kode lerroa:     if (transformStream._backpressureChangePromise !== undefined) {
Kode lerroa:       transformStream._backpressureChangePromise_resolve(backpressure);
Kode lerroa:     }
Kode lerroa:     transformStream._backpressureChangePromise = new Promise(function (resolve) {
Kode lerroa:       transformStream._backpressureChangePromise_resolve = resolve;
Kode lerroa:     });
Kode lerroa:     transformStream._backpressureChangePromise.then(function (resolution) {
Kode lerroa:       assert(resolution !== backpressure, '_backpressureChangePromise should be fulfilled only when backpressure is changed');
Kode lerroa:     });
Kode lerroa:     transformStream._backpressure = backpressure;
Kode lerroa:   }
Kode lerroa:   function TransformStreamDefaultTransform(chunk, transformStreamController) {
Kode lerroa:     var transformStream = transformStreamController._controlledTransformStream;
Kode lerroa:     TransformStreamEnqueueToReadable(transformStream, chunk);
Kode lerroa:     return Promise.resolve();
Kode lerroa:   }
Kode lerroa:   function TransformStreamTransform(transformStream, chunk) {
Kode lerroa:     assert(transformStream._errored === false);
Kode lerroa:     assert(transformStream._transforming === false);
Kode lerroa:     assert(transformStream._backpressure === false);
Kode lerroa:     transformStream._transforming = true;
Kode lerroa:     var transformer = transformStream._transformer;
Kode lerroa:     var controller = transformStream._transformStreamController;
Kode lerroa:     var transformPromise = PromiseInvokeOrPerformFallback(transformer, 'transform', [chunk, controller], TransformStreamDefaultTransform, [chunk, controller]);
Kode lerroa:     return transformPromise.then(function () {
Kode lerroa:       transformStream._transforming = false;
Kode lerroa:       return TransformStreamReadableReadyPromise(transformStream);
Kode lerroa:     }, function (e) {
Kode lerroa:       TransformStreamErrorIfNeeded(transformStream, e);
Kode lerroa:       return Promise.reject(e);
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function IsTransformStreamDefaultController(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function IsTransformStream(x) {
Kode lerroa:     if (!typeIsObject(x)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   var TransformStreamSink = function () {
Kode lerroa:     function TransformStreamSink(transformStream, startPromise) {
Kode lerroa:       _classCallCheck(this, TransformStreamSink);
Kode lerroa:       this._transformStream = transformStream;
Kode lerroa:       this._startPromise = startPromise;
Kode lerroa:     }
Kode lerroa:     _createClass(TransformStreamSink, [{
Kode lerroa:       key: 'start',
Kode lerroa:       value: function start(c) {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         transformStream._writableController = c;
Kode lerroa:         return this._startPromise.then(function () {
Kode lerroa:           return TransformStreamReadableReadyPromise(transformStream);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'write',
Kode lerroa:       value: function write(chunk) {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         return TransformStreamTransform(transformStream, chunk);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'abort',
Kode lerroa:       value: function abort() {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         transformStream._writableDone = true;
Kode lerroa:         TransformStreamErrorInternal(transformStream, new TypeError('Writable side aborted'));
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'close',
Kode lerroa:       value: function close() {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         assert(transformStream._transforming === false);
Kode lerroa:         transformStream._writableDone = true;
Kode lerroa:         var flushPromise = PromiseInvokeOrNoop(transformStream._transformer, 'flush', [transformStream._transformStreamController]);
Kode lerroa:         return flushPromise.then(function () {
Kode lerroa:           if (transformStream._errored === true) {
Kode lerroa:             return Promise.reject(transformStream._storedError);
Kode lerroa:           }
Kode lerroa:           if (transformStream._readableClosed === false) {
Kode lerroa:             TransformStreamCloseReadableInternal(transformStream);
Kode lerroa:           }
Kode lerroa:           return Promise.resolve();
Kode lerroa:         }).catch(function (r) {
Kode lerroa:           TransformStreamErrorIfNeeded(transformStream, r);
Kode lerroa:           return Promise.reject(transformStream._storedError);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return TransformStreamSink;
Kode lerroa:   }();
Kode lerroa:   var TransformStreamSource = function () {
Kode lerroa:     function TransformStreamSource(transformStream, startPromise) {
Kode lerroa:       _classCallCheck(this, TransformStreamSource);
Kode lerroa:       this._transformStream = transformStream;
Kode lerroa:       this._startPromise = startPromise;
Kode lerroa:     }
Kode lerroa:     _createClass(TransformStreamSource, [{
Kode lerroa:       key: 'start',
Kode lerroa:       value: function start(c) {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         transformStream._readableController = c;
Kode lerroa:         return this._startPromise.then(function () {
Kode lerroa:           assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');
Kode lerroa:           if (transformStream._backpressure === true) {
Kode lerroa:             return Promise.resolve();
Kode lerroa:           }
Kode lerroa:           assert(transformStream._backpressure === false, '_backpressure should have been initialized');
Kode lerroa:           return transformStream._backpressureChangePromise;
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'pull',
Kode lerroa:       value: function pull() {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         assert(transformStream._backpressure === true, 'pull() should be never called while _backpressure is false');
Kode lerroa:         assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');
Kode lerroa:         TransformStreamSetBackpressure(transformStream, false);
Kode lerroa:         return transformStream._backpressureChangePromise;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'cancel',
Kode lerroa:       value: function cancel() {
Kode lerroa:         var transformStream = this._transformStream;
Kode lerroa:         transformStream._readableClosed = true;
Kode lerroa:         TransformStreamErrorInternal(transformStream, new TypeError('Readable side canceled'));
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return TransformStreamSource;
Kode lerroa:   }();
Kode lerroa:   var TransformStreamDefaultController = function () {
Kode lerroa:     function TransformStreamDefaultController(transformStream) {
Kode lerroa:       _classCallCheck(this, TransformStreamDefaultController);
Kode lerroa:       if (IsTransformStream(transformStream) === false) {
Kode lerroa:         throw new TypeError('TransformStreamDefaultController can only be ' + 'constructed with a TransformStream instance');
Kode lerroa:       }
Kode lerroa:       if (transformStream._transformStreamController !== undefined) {
Kode lerroa:         throw new TypeError('TransformStreamDefaultController instances can ' + 'only be created by the TransformStream constructor');
Kode lerroa:       }
Kode lerroa:       this._controlledTransformStream = transformStream;
Kode lerroa:     }
Kode lerroa:     _createClass(TransformStreamDefaultController, [{
Kode lerroa:       key: 'enqueue',
Kode lerroa:       value: function enqueue(chunk) {
Kode lerroa:         if (IsTransformStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('enqueue');
Kode lerroa:         }
Kode lerroa:         TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'close',
Kode lerroa:       value: function close() {
Kode lerroa:         if (IsTransformStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('close');
Kode lerroa:         }
Kode lerroa:         TransformStreamCloseReadable(this._controlledTransformStream);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'error',
Kode lerroa:       value: function error(reason) {
Kode lerroa:         if (IsTransformStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('error');
Kode lerroa:         }
Kode lerroa:         TransformStreamError(this._controlledTransformStream, reason);
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'desiredSize',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsTransformStreamDefaultController(this) === false) {
Kode lerroa:           throw defaultControllerBrandCheckException('desiredSize');
Kode lerroa:         }
Kode lerroa:         var transformStream = this._controlledTransformStream;
Kode lerroa:         var readableController = transformStream._readableController;
Kode lerroa:         return ReadableStreamDefaultControllerGetDesiredSize(readableController);
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return TransformStreamDefaultController;
Kode lerroa:   }();
Kode lerroa:   var TransformStream = function () {
Kode lerroa:     function TransformStream() {
Kode lerroa:       var transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
Kode lerroa:       _classCallCheck(this, TransformStream);
Kode lerroa:       this._transformer = transformer;
Kode lerroa:       var readableStrategy = transformer.readableStrategy,
Kode lerroa:           writableStrategy = transformer.writableStrategy;
Kode lerroa:       this._transforming = false;
Kode lerroa:       this._errored = false;
Kode lerroa:       this._storedError = undefined;
Kode lerroa:       this._writableController = undefined;
Kode lerroa:       this._readableController = undefined;
Kode lerroa:       this._transformStreamController = undefined;
Kode lerroa:       this._writableDone = false;
Kode lerroa:       this._readableClosed = false;
Kode lerroa:       this._backpressure = undefined;
Kode lerroa:       this._backpressureChangePromise = undefined;
Kode lerroa:       this._backpressureChangePromise_resolve = undefined;
Kode lerroa:       this._transformStreamController = new TransformStreamDefaultController(this);
Kode lerroa:       var startPromise_resolve = void 0;
Kode lerroa:       var startPromise = new Promise(function (resolve) {
Kode lerroa:         startPromise_resolve = resolve;
Kode lerroa:       });
Kode lerroa:       var source = new TransformStreamSource(this, startPromise);
Kode lerroa:       this._readable = new ReadableStream(source, readableStrategy);
Kode lerroa:       var sink = new TransformStreamSink(this, startPromise);
Kode lerroa:       this._writable = new WritableStream(sink, writableStrategy);
Kode lerroa:       assert(this._writableController !== undefined);
Kode lerroa:       assert(this._readableController !== undefined);
Kode lerroa:       var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);
Kode lerroa:       TransformStreamSetBackpressure(this, desiredSize <= 0);
Kode lerroa:       var transformStream = this;
Kode lerroa:       var startResult = InvokeOrNoop(transformer, 'start', [transformStream._transformStreamController]);
Kode lerroa:       startPromise_resolve(startResult);
Kode lerroa:       startPromise.catch(function (e) {
Kode lerroa:         if (transformStream._errored === false) {
Kode lerroa:           transformStream._errored = true;
Kode lerroa:           transformStream._storedError = e;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     _createClass(TransformStream, [{
Kode lerroa:       key: 'readable',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsTransformStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('readable');
Kode lerroa:         }
Kode lerroa:         return this._readable;
Kode lerroa:       }
Kode lerroa:     }, {
Kode lerroa:       key: 'writable',
Kode lerroa:       get: function get() {
Kode lerroa:         if (IsTransformStream(this) === false) {
Kode lerroa:           throw streamBrandCheckException('writable');
Kode lerroa:         }
Kode lerroa:         return this._writable;
Kode lerroa:       }
Kode lerroa:     }]);
Kode lerroa:     return TransformStream;
Kode lerroa:   }();
Kode lerroa:   module.exports = { TransformStream: TransformStream };
Kode lerroa:   function defaultControllerBrandCheckException(name) {
Kode lerroa:     return new TypeError('TransformStreamDefaultController.prototype.' + name + ' can only be used on a TransformStreamDefaultController');
Kode lerroa:   }
Kode lerroa:   function streamBrandCheckException(name) {
Kode lerroa:     return new TypeError('TransformStream.prototype.' + name + ' can only be used on a TransformStream');
Kode lerroa:   }
Kode lerroa: }, function (module, exports, __w_pdfjs_require__) {
Kode lerroa:   module.exports = __w_pdfjs_require__(5);
Kode lerroa: }]));
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 118 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFJS = exports.globalScope = undefined;
Kode lerroa: 
Kode lerroa: var _api = __w_pdfjs_require__(69);
Kode lerroa: 
Kode lerroa: var _dom_utils = __w_pdfjs_require__(15);
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _annotation_layer = __w_pdfjs_require__(72);
Kode lerroa: 
Kode lerroa: var _global_scope = __w_pdfjs_require__(20);
Kode lerroa: 
Kode lerroa: var _global_scope2 = _interopRequireDefault(_global_scope);
Kode lerroa: 
Kode lerroa: var _metadata = __w_pdfjs_require__(71);
Kode lerroa: 
Kode lerroa: var _text_layer = __w_pdfjs_require__(73);
Kode lerroa: 
Kode lerroa: var _svg = __w_pdfjs_require__(74);
Kode lerroa: 
Kode lerroa: function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
Kode lerroa: 
Kode lerroa: if (!_global_scope2.default.PDFJS) {
Kode lerroa:   _global_scope2.default.PDFJS = {};
Kode lerroa: }
Kode lerroa: var PDFJS = _global_scope2.default.PDFJS;
Kode lerroa: {
Kode lerroa:   PDFJS.version = '1.10.100';
Kode lerroa:   PDFJS.build = 'ea29ec83';
Kode lerroa: }
Kode lerroa: PDFJS.pdfBug = false;
Kode lerroa: if (PDFJS.verbosity !== undefined) {
Kode lerroa:   (0, _util.setVerbosityLevel)(PDFJS.verbosity);
Kode lerroa: }
Kode lerroa: delete PDFJS.verbosity;
Kode lerroa: Object.defineProperty(PDFJS, 'verbosity', {
Kode lerroa:   get: function get() {
Kode lerroa:     return (0, _util.getVerbosityLevel)();
Kode lerroa:   },
Kode lerroa:   set: function set(level) {
Kode lerroa:     (0, _util.setVerbosityLevel)(level);
Kode lerroa:   },
Kode lerroa: 
Kode lerroa:   enumerable: true,
Kode lerroa:   configurable: true
Kode lerroa: });
Kode lerroa: PDFJS.VERBOSITY_LEVELS = _util.VERBOSITY_LEVELS;
Kode lerroa: PDFJS.OPS = _util.OPS;
Kode lerroa: PDFJS.UNSUPPORTED_FEATURES = _util.UNSUPPORTED_FEATURES;
Kode lerroa: PDFJS.isValidUrl = _dom_utils.isValidUrl;
Kode lerroa: PDFJS.shadow = _util.shadow;
Kode lerroa: PDFJS.createBlob = _util.createBlob;
Kode lerroa: PDFJS.createObjectURL = function PDFJS_createObjectURL(data, contentType) {
Kode lerroa:   return (0, _util.createObjectURL)(data, contentType, PDFJS.disableCreateObjectURL);
Kode lerroa: };
Kode lerroa: Object.defineProperty(PDFJS, 'isLittleEndian', {
Kode lerroa:   configurable: true,
Kode lerroa:   get: function PDFJS_isLittleEndian() {
Kode lerroa:     return (0, _util.shadow)(PDFJS, 'isLittleEndian', (0, _util.isLittleEndian)());
Kode lerroa:   }
Kode lerroa: });
Kode lerroa: PDFJS.removeNullCharacters = _util.removeNullCharacters;
Kode lerroa: PDFJS.PasswordResponses = _util.PasswordResponses;
Kode lerroa: PDFJS.PasswordException = _util.PasswordException;
Kode lerroa: PDFJS.UnknownErrorException = _util.UnknownErrorException;
Kode lerroa: PDFJS.InvalidPDFException = _util.InvalidPDFException;
Kode lerroa: PDFJS.MissingPDFException = _util.MissingPDFException;
Kode lerroa: PDFJS.UnexpectedResponseException = _util.UnexpectedResponseException;
Kode lerroa: PDFJS.Util = _util.Util;
Kode lerroa: PDFJS.PageViewport = _util.PageViewport;
Kode lerroa: PDFJS.createPromiseCapability = _util.createPromiseCapability;
Kode lerroa: PDFJS.maxImageSize = PDFJS.maxImageSize === undefined ? -1 : PDFJS.maxImageSize;
Kode lerroa: PDFJS.cMapUrl = PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl;
Kode lerroa: PDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked;
Kode lerroa: PDFJS.disableFontFace = PDFJS.disableFontFace === undefined ? false : PDFJS.disableFontFace;
Kode lerroa: PDFJS.imageResourcesPath = PDFJS.imageResourcesPath === undefined ? '' : PDFJS.imageResourcesPath;
Kode lerroa: PDFJS.disableWorker = PDFJS.disableWorker === undefined ? false : PDFJS.disableWorker;
Kode lerroa: PDFJS.workerSrc = PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc;
Kode lerroa: PDFJS.workerPort = PDFJS.workerPort === undefined ? null : PDFJS.workerPort;
Kode lerroa: PDFJS.disableRange = PDFJS.disableRange === undefined ? false : PDFJS.disableRange;
Kode lerroa: PDFJS.disableStream = PDFJS.disableStream === undefined ? false : PDFJS.disableStream;
Kode lerroa: PDFJS.disableAutoFetch = PDFJS.disableAutoFetch === undefined ? false : PDFJS.disableAutoFetch;
Kode lerroa: PDFJS.pdfBug = PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug;
Kode lerroa: PDFJS.postMessageTransfers = PDFJS.postMessageTransfers === undefined ? true : PDFJS.postMessageTransfers;
Kode lerroa: PDFJS.disableCreateObjectURL = PDFJS.disableCreateObjectURL === undefined ? false : PDFJS.disableCreateObjectURL;
Kode lerroa: PDFJS.disableWebGL = PDFJS.disableWebGL === undefined ? true : PDFJS.disableWebGL;
Kode lerroa: PDFJS.externalLinkTarget = PDFJS.externalLinkTarget === undefined ? _dom_utils.LinkTarget.NONE : PDFJS.externalLinkTarget;
Kode lerroa: PDFJS.externalLinkRel = PDFJS.externalLinkRel === undefined ? _dom_utils.DEFAULT_LINK_REL : PDFJS.externalLinkRel;
Kode lerroa: PDFJS.isEvalSupported = PDFJS.isEvalSupported === undefined ? true : PDFJS.isEvalSupported;
Kode lerroa: PDFJS.pdfjsNext = PDFJS.pdfjsNext === undefined ? false : PDFJS.pdfjsNext;
Kode lerroa: {
Kode lerroa:   var savedOpenExternalLinksInNewWindow = PDFJS.openExternalLinksInNewWindow;
Kode lerroa:   delete PDFJS.openExternalLinksInNewWindow;
Kode lerroa:   Object.defineProperty(PDFJS, 'openExternalLinksInNewWindow', {
Kode lerroa:     get: function get() {
Kode lerroa:       return PDFJS.externalLinkTarget === _dom_utils.LinkTarget.BLANK;
Kode lerroa:     },
Kode lerroa:     set: function set(value) {
Kode lerroa:       if (value) {
Kode lerroa:         (0, _util.deprecated)('PDFJS.openExternalLinksInNewWindow, please use ' + '"PDFJS.externalLinkTarget = PDFJS.LinkTarget.BLANK" instead.');
Kode lerroa:       }
Kode lerroa:       if (PDFJS.externalLinkTarget !== _dom_utils.LinkTarget.NONE) {
Kode lerroa:         (0, _util.warn)('PDFJS.externalLinkTarget is already initialized');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       PDFJS.externalLinkTarget = value ? _dom_utils.LinkTarget.BLANK : _dom_utils.LinkTarget.NONE;
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     enumerable: true,
Kode lerroa:     configurable: true
Kode lerroa:   });
Kode lerroa:   if (savedOpenExternalLinksInNewWindow) {
Kode lerroa:     PDFJS.openExternalLinksInNewWindow = savedOpenExternalLinksInNewWindow;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: PDFJS.getDocument = _api.getDocument;
Kode lerroa: PDFJS.LoopbackPort = _api.LoopbackPort;
Kode lerroa: PDFJS.PDFDataRangeTransport = _api.PDFDataRangeTransport;
Kode lerroa: PDFJS.PDFWorker = _api.PDFWorker;
Kode lerroa: PDFJS.hasCanvasTypedArrays = true;
Kode lerroa: PDFJS.CustomStyle = _dom_utils.CustomStyle;
Kode lerroa: PDFJS.LinkTarget = _dom_utils.LinkTarget;
Kode lerroa: PDFJS.addLinkAttributes = _dom_utils.addLinkAttributes;
Kode lerroa: PDFJS.getFilenameFromUrl = _dom_utils.getFilenameFromUrl;
Kode lerroa: PDFJS.isExternalLinkTargetSet = _dom_utils.isExternalLinkTargetSet;
Kode lerroa: PDFJS.AnnotationLayer = _annotation_layer.AnnotationLayer;
Kode lerroa: PDFJS.renderTextLayer = _text_layer.renderTextLayer;
Kode lerroa: PDFJS.Metadata = _metadata.Metadata;
Kode lerroa: PDFJS.SVGGraphics = _svg.SVGGraphics;
Kode lerroa: PDFJS.UnsupportedManager = _api._UnsupportedManager;
Kode lerroa: exports.globalScope = _global_scope2.default;
Kode lerroa: exports.PDFJS = PDFJS;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 119 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.FontLoader = exports.FontFaceObject = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: function FontLoader(docId) {
Kode lerroa:   this.docId = docId;
Kode lerroa:   this.styleElement = null;
Kode lerroa:   this.nativeFontFaces = [];
Kode lerroa:   this.loadTestFontId = 0;
Kode lerroa:   this.loadingContext = {
Kode lerroa:     requests: [],
Kode lerroa:     nextRequestId: 0
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: FontLoader.prototype = {
Kode lerroa:   insertRule: function fontLoaderInsertRule(rule) {
Kode lerroa:     var styleElement = this.styleElement;
Kode lerroa:     if (!styleElement) {
Kode lerroa:       styleElement = this.styleElement = document.createElement('style');
Kode lerroa:       styleElement.id = 'PDFJS_FONT_STYLE_TAG_' + this.docId;
Kode lerroa:       document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
Kode lerroa:     }
Kode lerroa:     var styleSheet = styleElement.sheet;
Kode lerroa:     styleSheet.insertRule(rule, styleSheet.cssRules.length);
Kode lerroa:   },
Kode lerroa:   clear: function fontLoaderClear() {
Kode lerroa:     if (this.styleElement) {
Kode lerroa:       this.styleElement.remove();
Kode lerroa:       this.styleElement = null;
Kode lerroa:     }
Kode lerroa:     this.nativeFontFaces.forEach(function (nativeFontFace) {
Kode lerroa:       document.fonts.delete(nativeFontFace);
Kode lerroa:     });
Kode lerroa:     this.nativeFontFaces.length = 0;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: {
Kode lerroa:   var getLoadTestFont = function getLoadTestFont() {
Kode lerroa:     return atob('T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' + 'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' + 'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' + 'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' + 'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' + 'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' + 'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' + 'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' + 'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' + 'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' + 'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' + 'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' + 'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' + 'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' + 'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' + 'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' + 'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' + 'ABAAAAAAAAAAAD6AAAAAAAAA==');
Kode lerroa:   };
Kode lerroa:   Object.defineProperty(FontLoader.prototype, 'loadTestFont', {
Kode lerroa:     get: function get() {
Kode lerroa:       return (0, _util.shadow)(this, 'loadTestFont', getLoadTestFont());
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     configurable: true
Kode lerroa:   });
Kode lerroa:   FontLoader.prototype.addNativeFontFace = function fontLoader_addNativeFontFace(nativeFontFace) {
Kode lerroa:     this.nativeFontFaces.push(nativeFontFace);
Kode lerroa:     document.fonts.add(nativeFontFace);
Kode lerroa:   };
Kode lerroa:   FontLoader.prototype.bind = function fontLoaderBind(fonts, callback) {
Kode lerroa:     var rules = [];
Kode lerroa:     var fontsToLoad = [];
Kode lerroa:     var fontLoadPromises = [];
Kode lerroa:     var getNativeFontPromise = function getNativeFontPromise(nativeFontFace) {
Kode lerroa:       return nativeFontFace.loaded.catch(function (e) {
Kode lerroa:         (0, _util.warn)('Failed to load font "' + nativeFontFace.family + '": ' + e);
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     var isFontLoadingAPISupported = FontLoader.isFontLoadingAPISupported && !FontLoader.isSyncFontLoadingSupported;
Kode lerroa:     for (var i = 0, ii = fonts.length; i < ii; i++) {
Kode lerroa:       var font = fonts[i];
Kode lerroa:       if (font.attached || font.loading === false) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       font.attached = true;
Kode lerroa:       if (isFontLoadingAPISupported) {
Kode lerroa:         var nativeFontFace = font.createNativeFontFace();
Kode lerroa:         if (nativeFontFace) {
Kode lerroa:           this.addNativeFontFace(nativeFontFace);
Kode lerroa:           fontLoadPromises.push(getNativeFontPromise(nativeFontFace));
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         var rule = font.createFontFaceRule();
Kode lerroa:         if (rule) {
Kode lerroa:           this.insertRule(rule);
Kode lerroa:           rules.push(rule);
Kode lerroa:           fontsToLoad.push(font);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var request = this.queueLoadingCallback(callback);
Kode lerroa:     if (isFontLoadingAPISupported) {
Kode lerroa:       Promise.all(fontLoadPromises).then(function () {
Kode lerroa:         request.complete();
Kode lerroa:       });
Kode lerroa:     } else if (rules.length > 0 && !FontLoader.isSyncFontLoadingSupported) {
Kode lerroa:       this.prepareFontLoadEvent(rules, fontsToLoad, request);
Kode lerroa:     } else {
Kode lerroa:       request.complete();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   FontLoader.prototype.queueLoadingCallback = function FontLoader_queueLoadingCallback(callback) {
Kode lerroa:     function LoadLoader_completeRequest() {
Kode lerroa:       (0, _util.assert)(!request.end, 'completeRequest() cannot be called twice');
Kode lerroa:       request.end = Date.now();
Kode lerroa:       while (context.requests.length > 0 && context.requests[0].end) {
Kode lerroa:         var otherRequest = context.requests.shift();
Kode lerroa:         setTimeout(otherRequest.callback, 0);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var context = this.loadingContext;
Kode lerroa:     var requestId = 'pdfjs-font-loading-' + context.nextRequestId++;
Kode lerroa:     var request = {
Kode lerroa:       id: requestId,
Kode lerroa:       complete: LoadLoader_completeRequest,
Kode lerroa:       callback: callback,
Kode lerroa:       started: Date.now()
Kode lerroa:     };
Kode lerroa:     context.requests.push(request);
Kode lerroa:     return request;
Kode lerroa:   };
Kode lerroa:   FontLoader.prototype.prepareFontLoadEvent = function fontLoaderPrepareFontLoadEvent(rules, fonts, request) {
Kode lerroa:     function int32(data, offset) {
Kode lerroa:       return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
Kode lerroa:     }
Kode lerroa:     function spliceString(s, offset, remove, insert) {
Kode lerroa:       var chunk1 = s.substr(0, offset);
Kode lerroa:       var chunk2 = s.substr(offset + remove);
Kode lerroa:       return chunk1 + insert + chunk2;
Kode lerroa:     }
Kode lerroa:     var i, ii;
Kode lerroa:     var canvas = document.createElement('canvas');
Kode lerroa:     canvas.width = 1;
Kode lerroa:     canvas.height = 1;
Kode lerroa:     var ctx = canvas.getContext('2d');
Kode lerroa:     var called = 0;
Kode lerroa:     function isFontReady(name, callback) {
Kode lerroa:       called++;
Kode lerroa:       if (called > 30) {
Kode lerroa:         (0, _util.warn)('Load test font never loaded.');
Kode lerroa:         callback();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       ctx.font = '30px ' + name;
Kode lerroa:       ctx.fillText('.', 0, 20);
Kode lerroa:       var imageData = ctx.getImageData(0, 0, 1, 1);
Kode lerroa:       if (imageData.data[3] > 0) {
Kode lerroa:         callback();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       setTimeout(isFontReady.bind(null, name, callback));
Kode lerroa:     }
Kode lerroa:     var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;
Kode lerroa:     var data = this.loadTestFont;
Kode lerroa:     var COMMENT_OFFSET = 976;
Kode lerroa:     data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
Kode lerroa:     var CFF_CHECKSUM_OFFSET = 16;
Kode lerroa:     var XXXX_VALUE = 0x58585858;
Kode lerroa:     var checksum = int32(data, CFF_CHECKSUM_OFFSET);
Kode lerroa:     for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
Kode lerroa:       checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
Kode lerroa:     }
Kode lerroa:     if (i < loadTestFontId.length) {
Kode lerroa:       checksum = checksum - XXXX_VALUE + int32(loadTestFontId + 'XXX', i) | 0;
Kode lerroa:     }
Kode lerroa:     data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
Kode lerroa:     var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';
Kode lerroa:     var rule = '@font-face { font-family:"' + loadTestFontId + '";src:' + url + '}';
Kode lerroa:     this.insertRule(rule);
Kode lerroa:     var names = [];
Kode lerroa:     for (i = 0, ii = fonts.length; i < ii; i++) {
Kode lerroa:       names.push(fonts[i].loadedName);
Kode lerroa:     }
Kode lerroa:     names.push(loadTestFontId);
Kode lerroa:     var div = document.createElement('div');
Kode lerroa:     div.setAttribute('style', 'visibility: hidden;' + 'width: 10px; height: 10px;' + 'position: absolute; top: 0px; left: 0px;');
Kode lerroa:     for (i = 0, ii = names.length; i < ii; ++i) {
Kode lerroa:       var span = document.createElement('span');
Kode lerroa:       span.textContent = 'Hi';
Kode lerroa:       span.style.fontFamily = names[i];
Kode lerroa:       div.appendChild(span);
Kode lerroa:     }
Kode lerroa:     document.body.appendChild(div);
Kode lerroa:     isFontReady(loadTestFontId, function () {
Kode lerroa:       document.body.removeChild(div);
Kode lerroa:       request.complete();
Kode lerroa:     });
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: {
Kode lerroa:   FontLoader.isFontLoadingAPISupported = typeof document !== 'undefined' && !!document.fonts;
Kode lerroa: }
Kode lerroa: {
Kode lerroa:   var isSyncFontLoadingSupported = function isSyncFontLoadingSupported() {
Kode lerroa:     if (typeof navigator === 'undefined') {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     var supported = false;
Kode lerroa:     var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
Kode lerroa:     if (m && m[1] >= 14) {
Kode lerroa:       supported = true;
Kode lerroa:     }
Kode lerroa:     return supported;
Kode lerroa:   };
Kode lerroa:   Object.defineProperty(FontLoader, 'isSyncFontLoadingSupported', {
Kode lerroa:     get: function get() {
Kode lerroa:       return (0, _util.shadow)(FontLoader, 'isSyncFontLoadingSupported', isSyncFontLoadingSupported());
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     enumerable: true,
Kode lerroa:     configurable: true
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: var IsEvalSupportedCached = {
Kode lerroa:   get value() {
Kode lerroa:     return (0, _util.shadow)(this, 'value', (0, _util.isEvalSupported)());
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var FontFaceObject = function FontFaceObjectClosure() {
Kode lerroa:   function FontFaceObject(translatedData, options) {
Kode lerroa:     this.compiledGlyphs = Object.create(null);
Kode lerroa:     for (var i in translatedData) {
Kode lerroa:       this[i] = translatedData[i];
Kode lerroa:     }
Kode lerroa:     this.options = options;
Kode lerroa:   }
Kode lerroa:   FontFaceObject.prototype = {
Kode lerroa:     createNativeFontFace: function FontFaceObject_createNativeFontFace() {
Kode lerroa:       if (!this.data) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       if (this.options.disableFontFace) {
Kode lerroa:         this.disableFontFace = true;
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var nativeFontFace = new FontFace(this.loadedName, this.data, {});
Kode lerroa:       if (this.options.fontRegistry) {
Kode lerroa:         this.options.fontRegistry.registerFont(this);
Kode lerroa:       }
Kode lerroa:       return nativeFontFace;
Kode lerroa:     },
Kode lerroa:     createFontFaceRule: function FontFaceObject_createFontFaceRule() {
Kode lerroa:       if (!this.data) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       if (this.options.disableFontFace) {
Kode lerroa:         this.disableFontFace = true;
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var data = (0, _util.bytesToString)(new Uint8Array(this.data));
Kode lerroa:       var fontName = this.loadedName;
Kode lerroa:       var url = 'url(data:' + this.mimetype + ';base64,' + btoa(data) + ');';
Kode lerroa:       var rule = '@font-face { font-family:"' + fontName + '";src:' + url + '}';
Kode lerroa:       if (this.options.fontRegistry) {
Kode lerroa:         this.options.fontRegistry.registerFont(this, url);
Kode lerroa:       }
Kode lerroa:       return rule;
Kode lerroa:     },
Kode lerroa:     getPathGenerator: function FontFaceObject_getPathGenerator(objs, character) {
Kode lerroa:       if (!(character in this.compiledGlyphs)) {
Kode lerroa:         var cmds = objs.get(this.loadedName + '_path_' + character);
Kode lerroa:         var current, i, len;
Kode lerroa:         if (this.options.isEvalSupported && IsEvalSupportedCached.value) {
Kode lerroa:           var args,
Kode lerroa:               js = '';
Kode lerroa:           for (i = 0, len = cmds.length; i < len; i++) {
Kode lerroa:             current = cmds[i];
Kode lerroa:             if (current.args !== undefined) {
Kode lerroa:               args = current.args.join(',');
Kode lerroa:             } else {
Kode lerroa:               args = '';
Kode lerroa:             }
Kode lerroa:             js += 'c.' + current.cmd + '(' + args + ');\n';
Kode lerroa:           }
Kode lerroa:           this.compiledGlyphs[character] = new Function('c', 'size', js);
Kode lerroa:         } else {
Kode lerroa:           this.compiledGlyphs[character] = function (c, size) {
Kode lerroa:             for (i = 0, len = cmds.length; i < len; i++) {
Kode lerroa:               current = cmds[i];
Kode lerroa:               if (current.cmd === 'scale') {
Kode lerroa:                 current.args = [size, -size];
Kode lerroa:               }
Kode lerroa:               c[current.cmd].apply(c, current.args);
Kode lerroa:             }
Kode lerroa:           };
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return this.compiledGlyphs[character];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return FontFaceObject;
Kode lerroa: }();
Kode lerroa: exports.FontFaceObject = FontFaceObject;
Kode lerroa: exports.FontLoader = FontLoader;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 120 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.CanvasGraphics = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _pattern_helper = __w_pdfjs_require__(121);
Kode lerroa: 
Kode lerroa: var _webgl = __w_pdfjs_require__(70);
Kode lerroa: 
Kode lerroa: var MIN_FONT_SIZE = 16;
Kode lerroa: var MAX_FONT_SIZE = 100;
Kode lerroa: var MAX_GROUP_SIZE = 4096;
Kode lerroa: var MIN_WIDTH_FACTOR = 0.65;
Kode lerroa: var COMPILE_TYPE3_GLYPHS = true;
Kode lerroa: var MAX_SIZE_TO_COMPILE = 1000;
Kode lerroa: var FULL_CHUNK_HEIGHT = 16;
Kode lerroa: var IsLittleEndianCached = {
Kode lerroa:   get value() {
Kode lerroa:     return (0, _util.shadow)(IsLittleEndianCached, 'value', (0, _util.isLittleEndian)());
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function addContextCurrentTransform(ctx) {
Kode lerroa:   if (!ctx.mozCurrentTransform) {
Kode lerroa:     ctx._originalSave = ctx.save;
Kode lerroa:     ctx._originalRestore = ctx.restore;
Kode lerroa:     ctx._originalRotate = ctx.rotate;
Kode lerroa:     ctx._originalScale = ctx.scale;
Kode lerroa:     ctx._originalTranslate = ctx.translate;
Kode lerroa:     ctx._originalTransform = ctx.transform;
Kode lerroa:     ctx._originalSetTransform = ctx.setTransform;
Kode lerroa:     ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
Kode lerroa:     ctx._transformStack = [];
Kode lerroa:     Object.defineProperty(ctx, 'mozCurrentTransform', {
Kode lerroa:       get: function getCurrentTransform() {
Kode lerroa:         return this._transformMatrix;
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
Kode lerroa:       get: function getCurrentTransformInverse() {
Kode lerroa:         var m = this._transformMatrix;
Kode lerroa:         var a = m[0],
Kode lerroa:             b = m[1],
Kode lerroa:             c = m[2],
Kode lerroa:             d = m[3],
Kode lerroa:             e = m[4],
Kode lerroa:             f = m[5];
Kode lerroa:         var ad_bc = a * d - b * c;
Kode lerroa:         var bc_ad = b * c - a * d;
Kode lerroa:         return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     ctx.save = function ctxSave() {
Kode lerroa:       var old = this._transformMatrix;
Kode lerroa:       this._transformStack.push(old);
Kode lerroa:       this._transformMatrix = old.slice(0, 6);
Kode lerroa:       this._originalSave();
Kode lerroa:     };
Kode lerroa:     ctx.restore = function ctxRestore() {
Kode lerroa:       var prev = this._transformStack.pop();
Kode lerroa:       if (prev) {
Kode lerroa:         this._transformMatrix = prev;
Kode lerroa:         this._originalRestore();
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     ctx.translate = function ctxTranslate(x, y) {
Kode lerroa:       var m = this._transformMatrix;
Kode lerroa:       m[4] = m[0] * x + m[2] * y + m[4];
Kode lerroa:       m[5] = m[1] * x + m[3] * y + m[5];
Kode lerroa:       this._originalTranslate(x, y);
Kode lerroa:     };
Kode lerroa:     ctx.scale = function ctxScale(x, y) {
Kode lerroa:       var m = this._transformMatrix;
Kode lerroa:       m[0] = m[0] * x;
Kode lerroa:       m[1] = m[1] * x;
Kode lerroa:       m[2] = m[2] * y;
Kode lerroa:       m[3] = m[3] * y;
Kode lerroa:       this._originalScale(x, y);
Kode lerroa:     };
Kode lerroa:     ctx.transform = function ctxTransform(a, b, c, d, e, f) {
Kode lerroa:       var m = this._transformMatrix;
Kode lerroa:       this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
Kode lerroa:       ctx._originalTransform(a, b, c, d, e, f);
Kode lerroa:     };
Kode lerroa:     ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
Kode lerroa:       this._transformMatrix = [a, b, c, d, e, f];
Kode lerroa:       ctx._originalSetTransform(a, b, c, d, e, f);
Kode lerroa:     };
Kode lerroa:     ctx.rotate = function ctxRotate(angle) {
Kode lerroa:       var cosValue = Math.cos(angle);
Kode lerroa:       var sinValue = Math.sin(angle);
Kode lerroa:       var m = this._transformMatrix;
Kode lerroa:       this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
Kode lerroa:       this._originalRotate(angle);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var CachedCanvases = function CachedCanvasesClosure() {
Kode lerroa:   function CachedCanvases(canvasFactory) {
Kode lerroa:     this.canvasFactory = canvasFactory;
Kode lerroa:     this.cache = Object.create(null);
Kode lerroa:   }
Kode lerroa:   CachedCanvases.prototype = {
Kode lerroa:     getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
Kode lerroa:       var canvasEntry;
Kode lerroa:       if (this.cache[id] !== undefined) {
Kode lerroa:         canvasEntry = this.cache[id];
Kode lerroa:         this.canvasFactory.reset(canvasEntry, width, height);
Kode lerroa:         canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
Kode lerroa:       } else {
Kode lerroa:         canvasEntry = this.canvasFactory.create(width, height);
Kode lerroa:         this.cache[id] = canvasEntry;
Kode lerroa:       }
Kode lerroa:       if (trackTransform) {
Kode lerroa:         addContextCurrentTransform(canvasEntry.context);
Kode lerroa:       }
Kode lerroa:       return canvasEntry;
Kode lerroa:     },
Kode lerroa:     clear: function clear() {
Kode lerroa:       for (var id in this.cache) {
Kode lerroa:         var canvasEntry = this.cache[id];
Kode lerroa:         this.canvasFactory.destroy(canvasEntry);
Kode lerroa:         delete this.cache[id];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CachedCanvases;
Kode lerroa: }();
Kode lerroa: function compileType3Glyph(imgData) {
Kode lerroa:   var POINT_TO_PROCESS_LIMIT = 1000;
Kode lerroa:   var width = imgData.width,
Kode lerroa:       height = imgData.height;
Kode lerroa:   var i,
Kode lerroa:       j,
Kode lerroa:       j0,
Kode lerroa:       width1 = width + 1;
Kode lerroa:   var points = new Uint8Array(width1 * (height + 1));
Kode lerroa:   var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
Kode lerroa:   var lineSize = width + 7 & ~7,
Kode lerroa:       data0 = imgData.data;
Kode lerroa:   var data = new Uint8Array(lineSize * height),
Kode lerroa:       pos = 0,
Kode lerroa:       ii;
Kode lerroa:   for (i = 0, ii = data0.length; i < ii; i++) {
Kode lerroa:     var mask = 128,
Kode lerroa:         elem = data0[i];
Kode lerroa:     while (mask > 0) {
Kode lerroa:       data[pos++] = elem & mask ? 0 : 255;
Kode lerroa:       mask >>= 1;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var count = 0;
Kode lerroa:   pos = 0;
Kode lerroa:   if (data[pos] !== 0) {
Kode lerroa:     points[0] = 1;
Kode lerroa:     ++count;
Kode lerroa:   }
Kode lerroa:   for (j = 1; j < width; j++) {
Kode lerroa:     if (data[pos] !== data[pos + 1]) {
Kode lerroa:       points[j] = data[pos] ? 2 : 1;
Kode lerroa:       ++count;
Kode lerroa:     }
Kode lerroa:     pos++;
Kode lerroa:   }
Kode lerroa:   if (data[pos] !== 0) {
Kode lerroa:     points[j] = 2;
Kode lerroa:     ++count;
Kode lerroa:   }
Kode lerroa:   for (i = 1; i < height; i++) {
Kode lerroa:     pos = i * lineSize;
Kode lerroa:     j0 = i * width1;
Kode lerroa:     if (data[pos - lineSize] !== data[pos]) {
Kode lerroa:       points[j0] = data[pos] ? 1 : 8;
Kode lerroa:       ++count;
Kode lerroa:     }
Kode lerroa:     var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
Kode lerroa:     for (j = 1; j < width; j++) {
Kode lerroa:       sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
Kode lerroa:       if (POINT_TYPES[sum]) {
Kode lerroa:         points[j0 + j] = POINT_TYPES[sum];
Kode lerroa:         ++count;
Kode lerroa:       }
Kode lerroa:       pos++;
Kode lerroa:     }
Kode lerroa:     if (data[pos - lineSize] !== data[pos]) {
Kode lerroa:       points[j0 + j] = data[pos] ? 2 : 4;
Kode lerroa:       ++count;
Kode lerroa:     }
Kode lerroa:     if (count > POINT_TO_PROCESS_LIMIT) {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   pos = lineSize * (height - 1);
Kode lerroa:   j0 = i * width1;
Kode lerroa:   if (data[pos] !== 0) {
Kode lerroa:     points[j0] = 8;
Kode lerroa:     ++count;
Kode lerroa:   }
Kode lerroa:   for (j = 1; j < width; j++) {
Kode lerroa:     if (data[pos] !== data[pos + 1]) {
Kode lerroa:       points[j0 + j] = data[pos] ? 4 : 8;
Kode lerroa:       ++count;
Kode lerroa:     }
Kode lerroa:     pos++;
Kode lerroa:   }
Kode lerroa:   if (data[pos] !== 0) {
Kode lerroa:     points[j0 + j] = 4;
Kode lerroa:     ++count;
Kode lerroa:   }
Kode lerroa:   if (count > POINT_TO_PROCESS_LIMIT) {
Kode lerroa:     return null;
Kode lerroa:   }
Kode lerroa:   var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
Kode lerroa:   var outlines = [];
Kode lerroa:   for (i = 0; count && i <= height; i++) {
Kode lerroa:     var p = i * width1;
Kode lerroa:     var end = p + width;
Kode lerroa:     while (p < end && !points[p]) {
Kode lerroa:       p++;
Kode lerroa:     }
Kode lerroa:     if (p === end) {
Kode lerroa:       continue;
Kode lerroa:     }
Kode lerroa:     var coords = [p % width1, i];
Kode lerroa:     var type = points[p],
Kode lerroa:         p0 = p,
Kode lerroa:         pp;
Kode lerroa:     do {
Kode lerroa:       var step = steps[type];
Kode lerroa:       do {
Kode lerroa:         p += step;
Kode lerroa:       } while (!points[p]);
Kode lerroa:       pp = points[p];
Kode lerroa:       if (pp !== 5 && pp !== 10) {
Kode lerroa:         type = pp;
Kode lerroa:         points[p] = 0;
Kode lerroa:       } else {
Kode lerroa:         type = pp & 0x33 * type >> 4;
Kode lerroa:         points[p] &= type >> 2 | type << 2;
Kode lerroa:       }
Kode lerroa:       coords.push(p % width1);
Kode lerroa:       coords.push(p / width1 | 0);
Kode lerroa:       --count;
Kode lerroa:     } while (p0 !== p);
Kode lerroa:     outlines.push(coords);
Kode lerroa:     --i;
Kode lerroa:   }
Kode lerroa:   var drawOutline = function drawOutline(c) {
Kode lerroa:     c.save();
Kode lerroa:     c.scale(1 / width, -1 / height);
Kode lerroa:     c.translate(0, -height);
Kode lerroa:     c.beginPath();
Kode lerroa:     for (var i = 0, ii = outlines.length; i < ii; i++) {
Kode lerroa:       var o = outlines[i];
Kode lerroa:       c.moveTo(o[0], o[1]);
Kode lerroa:       for (var j = 2, jj = o.length; j < jj; j += 2) {
Kode lerroa:         c.lineTo(o[j], o[j + 1]);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     c.fill();
Kode lerroa:     c.beginPath();
Kode lerroa:     c.restore();
Kode lerroa:   };
Kode lerroa:   return drawOutline;
Kode lerroa: }
Kode lerroa: var CanvasExtraState = function CanvasExtraStateClosure() {
Kode lerroa:   function CanvasExtraState() {
Kode lerroa:     this.alphaIsShape = false;
Kode lerroa:     this.fontSize = 0;
Kode lerroa:     this.fontSizeScale = 1;
Kode lerroa:     this.textMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:     this.textMatrixScale = 1;
Kode lerroa:     this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
Kode lerroa:     this.leading = 0;
Kode lerroa:     this.x = 0;
Kode lerroa:     this.y = 0;
Kode lerroa:     this.lineX = 0;
Kode lerroa:     this.lineY = 0;
Kode lerroa:     this.charSpacing = 0;
Kode lerroa:     this.wordSpacing = 0;
Kode lerroa:     this.textHScale = 1;
Kode lerroa:     this.textRenderingMode = _util.TextRenderingMode.FILL;
Kode lerroa:     this.textRise = 0;
Kode lerroa:     this.fillColor = '#000000';
Kode lerroa:     this.strokeColor = '#000000';
Kode lerroa:     this.patternFill = false;
Kode lerroa:     this.fillAlpha = 1;
Kode lerroa:     this.strokeAlpha = 1;
Kode lerroa:     this.lineWidth = 1;
Kode lerroa:     this.activeSMask = null;
Kode lerroa:     this.resumeSMaskCtx = null;
Kode lerroa:   }
Kode lerroa:   CanvasExtraState.prototype = {
Kode lerroa:     clone: function CanvasExtraState_clone() {
Kode lerroa:       return Object.create(this);
Kode lerroa:     },
Kode lerroa:     setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
Kode lerroa:       this.x = x;
Kode lerroa:       this.y = y;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CanvasExtraState;
Kode lerroa: }();
Kode lerroa: var CanvasGraphics = function CanvasGraphicsClosure() {
Kode lerroa:   var EXECUTION_TIME = 15;
Kode lerroa:   var EXECUTION_STEPS = 10;
Kode lerroa:   function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, imageLayer) {
Kode lerroa:     this.ctx = canvasCtx;
Kode lerroa:     this.current = new CanvasExtraState();
Kode lerroa:     this.stateStack = [];
Kode lerroa:     this.pendingClip = null;
Kode lerroa:     this.pendingEOFill = false;
Kode lerroa:     this.res = null;
Kode lerroa:     this.xobjs = null;
Kode lerroa:     this.commonObjs = commonObjs;
Kode lerroa:     this.objs = objs;
Kode lerroa:     this.canvasFactory = canvasFactory;
Kode lerroa:     this.imageLayer = imageLayer;
Kode lerroa:     this.groupStack = [];
Kode lerroa:     this.processingType3 = null;
Kode lerroa:     this.baseTransform = null;
Kode lerroa:     this.baseTransformStack = [];
Kode lerroa:     this.groupLevel = 0;
Kode lerroa:     this.smaskStack = [];
Kode lerroa:     this.smaskCounter = 0;
Kode lerroa:     this.tempSMask = null;
Kode lerroa:     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
Kode lerroa:     if (canvasCtx) {
Kode lerroa:       addContextCurrentTransform(canvasCtx);
Kode lerroa:     }
Kode lerroa:     this.cachedGetSinglePixelWidth = null;
Kode lerroa:   }
Kode lerroa:   function putBinaryImageData(ctx, imgData) {
Kode lerroa:     if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {
Kode lerroa:       ctx.putImageData(imgData, 0, 0);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var height = imgData.height,
Kode lerroa:         width = imgData.width;
Kode lerroa:     var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
Kode lerroa:     var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
Kode lerroa:     var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
Kode lerroa:     var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
Kode lerroa:     var srcPos = 0,
Kode lerroa:         destPos;
Kode lerroa:     var src = imgData.data;
Kode lerroa:     var dest = chunkImgData.data;
Kode lerroa:     var i, j, thisChunkHeight, elemsInThisChunk;
Kode lerroa:     if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
Kode lerroa:       var srcLength = src.byteLength;
Kode lerroa:       var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
Kode lerroa:       var dest32DataLength = dest32.length;
Kode lerroa:       var fullSrcDiff = width + 7 >> 3;
Kode lerroa:       var white = 0xFFFFFFFF;
Kode lerroa:       var black = IsLittleEndianCached.value ? 0xFF000000 : 0x000000FF;
Kode lerroa:       for (i = 0; i < totalChunks; i++) {
Kode lerroa:         thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
Kode lerroa:         destPos = 0;
Kode lerroa:         for (j = 0; j < thisChunkHeight; j++) {
Kode lerroa:           var srcDiff = srcLength - srcPos;
Kode lerroa:           var k = 0;
Kode lerroa:           var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
Kode lerroa:           var kEndUnrolled = kEnd & ~7;
Kode lerroa:           var mask = 0;
Kode lerroa:           var srcByte = 0;
Kode lerroa:           for (; k < kEndUnrolled; k += 8) {
Kode lerroa:             srcByte = src[srcPos++];
Kode lerroa:             dest32[destPos++] = srcByte & 128 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 64 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 32 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 16 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 8 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 4 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 2 ? white : black;
Kode lerroa:             dest32[destPos++] = srcByte & 1 ? white : black;
Kode lerroa:           }
Kode lerroa:           for (; k < kEnd; k++) {
Kode lerroa:             if (mask === 0) {
Kode lerroa:               srcByte = src[srcPos++];
Kode lerroa:               mask = 128;
Kode lerroa:             }
Kode lerroa:             dest32[destPos++] = srcByte & mask ? white : black;
Kode lerroa:             mask >>= 1;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         while (destPos < dest32DataLength) {
Kode lerroa:           dest32[destPos++] = 0;
Kode lerroa:         }
Kode lerroa:         ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
Kode lerroa:       }
Kode lerroa:     } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
Kode lerroa:       j = 0;
Kode lerroa:       elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
Kode lerroa:       for (i = 0; i < fullChunks; i++) {
Kode lerroa:         dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
Kode lerroa:         srcPos += elemsInThisChunk;
Kode lerroa:         ctx.putImageData(chunkImgData, 0, j);
Kode lerroa:         j += FULL_CHUNK_HEIGHT;
Kode lerroa:       }
Kode lerroa:       if (i < totalChunks) {
Kode lerroa:         elemsInThisChunk = width * partialChunkHeight * 4;
Kode lerroa:         dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
Kode lerroa:         ctx.putImageData(chunkImgData, 0, j);
Kode lerroa:       }
Kode lerroa:     } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
Kode lerroa:       thisChunkHeight = FULL_CHUNK_HEIGHT;
Kode lerroa:       elemsInThisChunk = width * thisChunkHeight;
Kode lerroa:       for (i = 0; i < totalChunks; i++) {
Kode lerroa:         if (i >= fullChunks) {
Kode lerroa:           thisChunkHeight = partialChunkHeight;
Kode lerroa:           elemsInThisChunk = width * thisChunkHeight;
Kode lerroa:         }
Kode lerroa:         destPos = 0;
Kode lerroa:         for (j = elemsInThisChunk; j--;) {
Kode lerroa:           dest[destPos++] = src[srcPos++];
Kode lerroa:           dest[destPos++] = src[srcPos++];
Kode lerroa:           dest[destPos++] = src[srcPos++];
Kode lerroa:           dest[destPos++] = 255;
Kode lerroa:         }
Kode lerroa:         ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       throw new Error('bad image kind: ' + imgData.kind);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function putBinaryImageMask(ctx, imgData) {
Kode lerroa:     var height = imgData.height,
Kode lerroa:         width = imgData.width;
Kode lerroa:     var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
Kode lerroa:     var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
Kode lerroa:     var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
Kode lerroa:     var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
Kode lerroa:     var srcPos = 0;
Kode lerroa:     var src = imgData.data;
Kode lerroa:     var dest = chunkImgData.data;
Kode lerroa:     for (var i = 0; i < totalChunks; i++) {
Kode lerroa:       var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
Kode lerroa:       var destPos = 3;
Kode lerroa:       for (var j = 0; j < thisChunkHeight; j++) {
Kode lerroa:         var mask = 0;
Kode lerroa:         for (var k = 0; k < width; k++) {
Kode lerroa:           if (!mask) {
Kode lerroa:             var elem = src[srcPos++];
Kode lerroa:             mask = 128;
Kode lerroa:           }
Kode lerroa:           dest[destPos] = elem & mask ? 0 : 255;
Kode lerroa:           destPos += 4;
Kode lerroa:           mask >>= 1;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function copyCtxState(sourceCtx, destCtx) {
Kode lerroa:     var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font'];
Kode lerroa:     for (var i = 0, ii = properties.length; i < ii; i++) {
Kode lerroa:       var property = properties[i];
Kode lerroa:       if (sourceCtx[property] !== undefined) {
Kode lerroa:         destCtx[property] = sourceCtx[property];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (sourceCtx.setLineDash !== undefined) {
Kode lerroa:       destCtx.setLineDash(sourceCtx.getLineDash());
Kode lerroa:       destCtx.lineDashOffset = sourceCtx.lineDashOffset;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function resetCtxToDefault(ctx) {
Kode lerroa:     ctx.strokeStyle = '#000000';
Kode lerroa:     ctx.fillStyle = '#000000';
Kode lerroa:     ctx.fillRule = 'nonzero';
Kode lerroa:     ctx.globalAlpha = 1;
Kode lerroa:     ctx.lineWidth = 1;
Kode lerroa:     ctx.lineCap = 'butt';
Kode lerroa:     ctx.lineJoin = 'miter';
Kode lerroa:     ctx.miterLimit = 10;
Kode lerroa:     ctx.globalCompositeOperation = 'source-over';
Kode lerroa:     ctx.font = '10px sans-serif';
Kode lerroa:     if (ctx.setLineDash !== undefined) {
Kode lerroa:       ctx.setLineDash([]);
Kode lerroa:       ctx.lineDashOffset = 0;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function composeSMaskBackdrop(bytes, r0, g0, b0) {
Kode lerroa:     var length = bytes.length;
Kode lerroa:     for (var i = 3; i < length; i += 4) {
Kode lerroa:       var alpha = bytes[i];
Kode lerroa:       if (alpha === 0) {
Kode lerroa:         bytes[i - 3] = r0;
Kode lerroa:         bytes[i - 2] = g0;
Kode lerroa:         bytes[i - 1] = b0;
Kode lerroa:       } else if (alpha < 255) {
Kode lerroa:         var alpha_ = 255 - alpha;
Kode lerroa:         bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
Kode lerroa:         bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
Kode lerroa:         bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function composeSMaskAlpha(maskData, layerData, transferMap) {
Kode lerroa:     var length = maskData.length;
Kode lerroa:     var scale = 1 / 255;
Kode lerroa:     for (var i = 3; i < length; i += 4) {
Kode lerroa:       var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
Kode lerroa:       layerData[i] = layerData[i] * alpha * scale | 0;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function composeSMaskLuminosity(maskData, layerData, transferMap) {
Kode lerroa:     var length = maskData.length;
Kode lerroa:     for (var i = 3; i < length; i += 4) {
Kode lerroa:       var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
Kode lerroa:       layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
Kode lerroa:     var hasBackdrop = !!backdrop;
Kode lerroa:     var r0 = hasBackdrop ? backdrop[0] : 0;
Kode lerroa:     var g0 = hasBackdrop ? backdrop[1] : 0;
Kode lerroa:     var b0 = hasBackdrop ? backdrop[2] : 0;
Kode lerroa:     var composeFn;
Kode lerroa:     if (subtype === 'Luminosity') {
Kode lerroa:       composeFn = composeSMaskLuminosity;
Kode lerroa:     } else {
Kode lerroa:       composeFn = composeSMaskAlpha;
Kode lerroa:     }
Kode lerroa:     var PIXELS_TO_PROCESS = 1048576;
Kode lerroa:     var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
Kode lerroa:     for (var row = 0; row < height; row += chunkSize) {
Kode lerroa:       var chunkHeight = Math.min(chunkSize, height - row);
Kode lerroa:       var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
Kode lerroa:       var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
Kode lerroa:       if (hasBackdrop) {
Kode lerroa:         composeSMaskBackdrop(maskData.data, r0, g0, b0);
Kode lerroa:       }
Kode lerroa:       composeFn(maskData.data, layerData.data, transferMap);
Kode lerroa:       maskCtx.putImageData(layerData, 0, row);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function composeSMask(ctx, smask, layerCtx) {
Kode lerroa:     var mask = smask.canvas;
Kode lerroa:     var maskCtx = smask.context;
Kode lerroa:     ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
Kode lerroa:     var backdrop = smask.backdrop || null;
Kode lerroa:     if (!smask.transferMap && _webgl.WebGLUtils.isEnabled) {
Kode lerroa:       var composed = _webgl.WebGLUtils.composeSMask(layerCtx.canvas, mask, {
Kode lerroa:         subtype: smask.subtype,
Kode lerroa:         backdrop: backdrop
Kode lerroa:       });
Kode lerroa:       ctx.setTransform(1, 0, 0, 1, 0, 0);
Kode lerroa:       ctx.drawImage(composed, smask.offsetX, smask.offsetY);
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
Kode lerroa:     ctx.drawImage(mask, 0, 0);
Kode lerroa:   }
Kode lerroa:   var LINE_CAP_STYLES = ['butt', 'round', 'square'];
Kode lerroa:   var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
Kode lerroa:   var NORMAL_CLIP = {};
Kode lerroa:   var EO_CLIP = {};
Kode lerroa:   CanvasGraphics.prototype = {
Kode lerroa:     beginDrawing: function beginDrawing(_ref) {
Kode lerroa:       var transform = _ref.transform,
Kode lerroa:           viewport = _ref.viewport,
Kode lerroa:           transparency = _ref.transparency,
Kode lerroa:           _ref$background = _ref.background,
Kode lerroa:           background = _ref$background === undefined ? null : _ref$background;
Kode lerroa: 
Kode lerroa:       var width = this.ctx.canvas.width;
Kode lerroa:       var height = this.ctx.canvas.height;
Kode lerroa:       this.ctx.save();
Kode lerroa:       this.ctx.fillStyle = background || 'rgb(255, 255, 255)';
Kode lerroa:       this.ctx.fillRect(0, 0, width, height);
Kode lerroa:       this.ctx.restore();
Kode lerroa:       if (transparency) {
Kode lerroa:         var transparentCanvas = this.cachedCanvases.getCanvas('transparent', width, height, true);
Kode lerroa:         this.compositeCtx = this.ctx;
Kode lerroa:         this.transparentCanvas = transparentCanvas.canvas;
Kode lerroa:         this.ctx = transparentCanvas.context;
Kode lerroa:         this.ctx.save();
Kode lerroa:         this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
Kode lerroa:       }
Kode lerroa:       this.ctx.save();
Kode lerroa:       resetCtxToDefault(this.ctx);
Kode lerroa:       if (transform) {
Kode lerroa:         this.ctx.transform.apply(this.ctx, transform);
Kode lerroa:       }
Kode lerroa:       this.ctx.transform.apply(this.ctx, viewport.transform);
Kode lerroa:       this.baseTransform = this.ctx.mozCurrentTransform.slice();
Kode lerroa:       if (this.imageLayer) {
Kode lerroa:         this.imageLayer.beginLayout();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
Kode lerroa:       var argsArray = operatorList.argsArray;
Kode lerroa:       var fnArray = operatorList.fnArray;
Kode lerroa:       var i = executionStartIdx || 0;
Kode lerroa:       var argsArrayLen = argsArray.length;
Kode lerroa:       if (argsArrayLen === i) {
Kode lerroa:         return i;
Kode lerroa:       }
Kode lerroa:       var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === 'function';
Kode lerroa:       var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
Kode lerroa:       var steps = 0;
Kode lerroa:       var commonObjs = this.commonObjs;
Kode lerroa:       var objs = this.objs;
Kode lerroa:       var fnId;
Kode lerroa:       while (true) {
Kode lerroa:         if (stepper !== undefined && i === stepper.nextBreakPoint) {
Kode lerroa:           stepper.breakIt(i, continueCallback);
Kode lerroa:           return i;
Kode lerroa:         }
Kode lerroa:         fnId = fnArray[i];
Kode lerroa:         if (fnId !== _util.OPS.dependency) {
Kode lerroa:           this[fnId].apply(this, argsArray[i]);
Kode lerroa:         } else {
Kode lerroa:           var deps = argsArray[i];
Kode lerroa:           for (var n = 0, nn = deps.length; n < nn; n++) {
Kode lerroa:             var depObjId = deps[n];
Kode lerroa:             var common = depObjId[0] === 'g' && depObjId[1] === '_';
Kode lerroa:             var objsPool = common ? commonObjs : objs;
Kode lerroa:             if (!objsPool.isResolved(depObjId)) {
Kode lerroa:               objsPool.get(depObjId, continueCallback);
Kode lerroa:               return i;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         i++;
Kode lerroa:         if (i === argsArrayLen) {
Kode lerroa:           return i;
Kode lerroa:         }
Kode lerroa:         if (chunkOperations && ++steps > EXECUTION_STEPS) {
Kode lerroa:           if (Date.now() > endTime) {
Kode lerroa:             continueCallback();
Kode lerroa:             return i;
Kode lerroa:           }
Kode lerroa:           steps = 0;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     endDrawing: function CanvasGraphics_endDrawing() {
Kode lerroa:       if (this.current.activeSMask !== null) {
Kode lerroa:         this.endSMaskGroup();
Kode lerroa:       }
Kode lerroa:       this.ctx.restore();
Kode lerroa:       if (this.transparentCanvas) {
Kode lerroa:         this.ctx = this.compositeCtx;
Kode lerroa:         this.ctx.save();
Kode lerroa:         this.ctx.setTransform(1, 0, 0, 1, 0, 0);
Kode lerroa:         this.ctx.drawImage(this.transparentCanvas, 0, 0);
Kode lerroa:         this.ctx.restore();
Kode lerroa:         this.transparentCanvas = null;
Kode lerroa:       }
Kode lerroa:       this.cachedCanvases.clear();
Kode lerroa:       _webgl.WebGLUtils.clear();
Kode lerroa:       if (this.imageLayer) {
Kode lerroa:         this.imageLayer.endLayout();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     setLineWidth: function CanvasGraphics_setLineWidth(width) {
Kode lerroa:       this.current.lineWidth = width;
Kode lerroa:       this.ctx.lineWidth = width;
Kode lerroa:     },
Kode lerroa:     setLineCap: function CanvasGraphics_setLineCap(style) {
Kode lerroa:       this.ctx.lineCap = LINE_CAP_STYLES[style];
Kode lerroa:     },
Kode lerroa:     setLineJoin: function CanvasGraphics_setLineJoin(style) {
Kode lerroa:       this.ctx.lineJoin = LINE_JOIN_STYLES[style];
Kode lerroa:     },
Kode lerroa:     setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
Kode lerroa:       this.ctx.miterLimit = limit;
Kode lerroa:     },
Kode lerroa:     setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       if (ctx.setLineDash !== undefined) {
Kode lerroa:         ctx.setLineDash(dashArray);
Kode lerroa:         ctx.lineDashOffset = dashPhase;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {},
Kode lerroa:     setFlatness: function CanvasGraphics_setFlatness(flatness) {},
Kode lerroa:     setGState: function CanvasGraphics_setGState(states) {
Kode lerroa:       for (var i = 0, ii = states.length; i < ii; i++) {
Kode lerroa:         var state = states[i];
Kode lerroa:         var key = state[0];
Kode lerroa:         var value = state[1];
Kode lerroa:         switch (key) {
Kode lerroa:           case 'LW':
Kode lerroa:             this.setLineWidth(value);
Kode lerroa:             break;
Kode lerroa:           case 'LC':
Kode lerroa:             this.setLineCap(value);
Kode lerroa:             break;
Kode lerroa:           case 'LJ':
Kode lerroa:             this.setLineJoin(value);
Kode lerroa:             break;
Kode lerroa:           case 'ML':
Kode lerroa:             this.setMiterLimit(value);
Kode lerroa:             break;
Kode lerroa:           case 'D':
Kode lerroa:             this.setDash(value[0], value[1]);
Kode lerroa:             break;
Kode lerroa:           case 'RI':
Kode lerroa:             this.setRenderingIntent(value);
Kode lerroa:             break;
Kode lerroa:           case 'FL':
Kode lerroa:             this.setFlatness(value);
Kode lerroa:             break;
Kode lerroa:           case 'Font':
Kode lerroa:             this.setFont(value[0], value[1]);
Kode lerroa:             break;
Kode lerroa:           case 'CA':
Kode lerroa:             this.current.strokeAlpha = state[1];
Kode lerroa:             break;
Kode lerroa:           case 'ca':
Kode lerroa:             this.current.fillAlpha = state[1];
Kode lerroa:             this.ctx.globalAlpha = state[1];
Kode lerroa:             break;
Kode lerroa:           case 'BM':
Kode lerroa:             this.ctx.globalCompositeOperation = value;
Kode lerroa:             break;
Kode lerroa:           case 'SMask':
Kode lerroa:             if (this.current.activeSMask) {
Kode lerroa:               if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
Kode lerroa:                 this.suspendSMaskGroup();
Kode lerroa:               } else {
Kode lerroa:                 this.endSMaskGroup();
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             this.current.activeSMask = value ? this.tempSMask : null;
Kode lerroa:             if (this.current.activeSMask) {
Kode lerroa:               this.beginSMaskGroup();
Kode lerroa:             }
Kode lerroa:             this.tempSMask = null;
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
Kode lerroa:       var activeSMask = this.current.activeSMask;
Kode lerroa:       var drawnWidth = activeSMask.canvas.width;
Kode lerroa:       var drawnHeight = activeSMask.canvas.height;
Kode lerroa:       var cacheId = 'smaskGroupAt' + this.groupLevel;
Kode lerroa:       var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
Kode lerroa:       var currentCtx = this.ctx;
Kode lerroa:       var currentTransform = currentCtx.mozCurrentTransform;
Kode lerroa:       this.ctx.save();
Kode lerroa:       var groupCtx = scratchCanvas.context;
Kode lerroa:       groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
Kode lerroa:       groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
Kode lerroa:       groupCtx.transform.apply(groupCtx, currentTransform);
Kode lerroa:       activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
Kode lerroa:       copyCtxState(currentCtx, groupCtx);
Kode lerroa:       this.ctx = groupCtx;
Kode lerroa:       this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);
Kode lerroa:       this.groupStack.push(currentCtx);
Kode lerroa:       this.groupLevel++;
Kode lerroa:     },
Kode lerroa:     suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
Kode lerroa:       var groupCtx = this.ctx;
Kode lerroa:       this.groupLevel--;
Kode lerroa:       this.ctx = this.groupStack.pop();
Kode lerroa:       composeSMask(this.ctx, this.current.activeSMask, groupCtx);
Kode lerroa:       this.ctx.restore();
Kode lerroa:       this.ctx.save();
Kode lerroa:       copyCtxState(groupCtx, this.ctx);
Kode lerroa:       this.current.resumeSMaskCtx = groupCtx;
Kode lerroa:       var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
Kode lerroa:       this.ctx.transform.apply(this.ctx, deltaTransform);
Kode lerroa:       groupCtx.save();
Kode lerroa:       groupCtx.setTransform(1, 0, 0, 1, 0, 0);
Kode lerroa:       groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
Kode lerroa:       groupCtx.restore();
Kode lerroa:     },
Kode lerroa:     resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
Kode lerroa:       var groupCtx = this.current.resumeSMaskCtx;
Kode lerroa:       var currentCtx = this.ctx;
Kode lerroa:       this.ctx = groupCtx;
Kode lerroa:       this.groupStack.push(currentCtx);
Kode lerroa:       this.groupLevel++;
Kode lerroa:     },
Kode lerroa:     endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
Kode lerroa:       var groupCtx = this.ctx;
Kode lerroa:       this.groupLevel--;
Kode lerroa:       this.ctx = this.groupStack.pop();
Kode lerroa:       composeSMask(this.ctx, this.current.activeSMask, groupCtx);
Kode lerroa:       this.ctx.restore();
Kode lerroa:       copyCtxState(groupCtx, this.ctx);
Kode lerroa:       var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
Kode lerroa:       this.ctx.transform.apply(this.ctx, deltaTransform);
Kode lerroa:     },
Kode lerroa:     save: function CanvasGraphics_save() {
Kode lerroa:       this.ctx.save();
Kode lerroa:       var old = this.current;
Kode lerroa:       this.stateStack.push(old);
Kode lerroa:       this.current = old.clone();
Kode lerroa:       this.current.resumeSMaskCtx = null;
Kode lerroa:     },
Kode lerroa:     restore: function CanvasGraphics_restore() {
Kode lerroa:       if (this.current.resumeSMaskCtx) {
Kode lerroa:         this.resumeSMaskGroup();
Kode lerroa:       }
Kode lerroa:       if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
Kode lerroa:         this.endSMaskGroup();
Kode lerroa:       }
Kode lerroa:       if (this.stateStack.length !== 0) {
Kode lerroa:         this.current = this.stateStack.pop();
Kode lerroa:         this.ctx.restore();
Kode lerroa:         this.pendingClip = null;
Kode lerroa:         this.cachedGetSinglePixelWidth = null;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
Kode lerroa:       this.ctx.transform(a, b, c, d, e, f);
Kode lerroa:       this.cachedGetSinglePixelWidth = null;
Kode lerroa:     },
Kode lerroa:     constructPath: function CanvasGraphics_constructPath(ops, args) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var current = this.current;
Kode lerroa:       var x = current.x,
Kode lerroa:           y = current.y;
Kode lerroa:       for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
Kode lerroa:         switch (ops[i] | 0) {
Kode lerroa:           case _util.OPS.rectangle:
Kode lerroa:             x = args[j++];
Kode lerroa:             y = args[j++];
Kode lerroa:             var width = args[j++];
Kode lerroa:             var height = args[j++];
Kode lerroa:             if (width === 0) {
Kode lerroa:               width = this.getSinglePixelWidth();
Kode lerroa:             }
Kode lerroa:             if (height === 0) {
Kode lerroa:               height = this.getSinglePixelWidth();
Kode lerroa:             }
Kode lerroa:             var xw = x + width;
Kode lerroa:             var yh = y + height;
Kode lerroa:             this.ctx.moveTo(x, y);
Kode lerroa:             this.ctx.lineTo(xw, y);
Kode lerroa:             this.ctx.lineTo(xw, yh);
Kode lerroa:             this.ctx.lineTo(x, yh);
Kode lerroa:             this.ctx.lineTo(x, y);
Kode lerroa:             this.ctx.closePath();
Kode lerroa:             break;
Kode lerroa:           case _util.OPS.moveTo:
Kode lerroa:             x = args[j++];
Kode lerroa:             y = args[j++];
Kode lerroa:             ctx.moveTo(x, y);
Kode lerroa:             break;
Kode lerroa:           case _util.OPS.lineTo:
Kode lerroa:             x = args[j++];
Kode lerroa:             y = args[j++];
Kode lerroa:             ctx.lineTo(x, y);
Kode lerroa:             break;
Kode lerroa:           case _util.OPS.curveTo:
Kode lerroa:             x = args[j + 4];
Kode lerroa:             y = args[j + 5];
Kode lerroa:             ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
Kode lerroa:             j += 6;
Kode lerroa:             break;
Kode lerroa:           case _util.OPS.curveTo2:
Kode lerroa:             ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
Kode lerroa:             x = args[j + 2];
Kode lerroa:             y = args[j + 3];
Kode lerroa:             j += 4;
Kode lerroa:             break;
Kode lerroa:           case _util.OPS.curveTo3:
Kode lerroa:             x = args[j + 2];
Kode lerroa:             y = args[j + 3];
Kode lerroa:             ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
Kode lerroa:             j += 4;
Kode lerroa:             break;
Kode lerroa:           case _util.OPS.closePath:
Kode lerroa:             ctx.closePath();
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       current.setCurrentPoint(x, y);
Kode lerroa:     },
Kode lerroa:     closePath: function CanvasGraphics_closePath() {
Kode lerroa:       this.ctx.closePath();
Kode lerroa:     },
Kode lerroa:     stroke: function CanvasGraphics_stroke(consumePath) {
Kode lerroa:       consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var strokeColor = this.current.strokeColor;
Kode lerroa:       ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
Kode lerroa:       ctx.globalAlpha = this.current.strokeAlpha;
Kode lerroa:       if (strokeColor && strokeColor.hasOwnProperty('type') && strokeColor.type === 'Pattern') {
Kode lerroa:         ctx.save();
Kode lerroa:         ctx.strokeStyle = strokeColor.getPattern(ctx, this);
Kode lerroa:         ctx.stroke();
Kode lerroa:         ctx.restore();
Kode lerroa:       } else {
Kode lerroa:         ctx.stroke();
Kode lerroa:       }
Kode lerroa:       if (consumePath) {
Kode lerroa:         this.consumePath();
Kode lerroa:       }
Kode lerroa:       ctx.globalAlpha = this.current.fillAlpha;
Kode lerroa:     },
Kode lerroa:     closeStroke: function CanvasGraphics_closeStroke() {
Kode lerroa:       this.closePath();
Kode lerroa:       this.stroke();
Kode lerroa:     },
Kode lerroa:     fill: function CanvasGraphics_fill(consumePath) {
Kode lerroa:       consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var fillColor = this.current.fillColor;
Kode lerroa:       var isPatternFill = this.current.patternFill;
Kode lerroa:       var needRestore = false;
Kode lerroa:       if (isPatternFill) {
Kode lerroa:         ctx.save();
Kode lerroa:         if (this.baseTransform) {
Kode lerroa:           ctx.setTransform.apply(ctx, this.baseTransform);
Kode lerroa:         }
Kode lerroa:         ctx.fillStyle = fillColor.getPattern(ctx, this);
Kode lerroa:         needRestore = true;
Kode lerroa:       }
Kode lerroa:       if (this.pendingEOFill) {
Kode lerroa:         ctx.fill('evenodd');
Kode lerroa:         this.pendingEOFill = false;
Kode lerroa:       } else {
Kode lerroa:         ctx.fill();
Kode lerroa:       }
Kode lerroa:       if (needRestore) {
Kode lerroa:         ctx.restore();
Kode lerroa:       }
Kode lerroa:       if (consumePath) {
Kode lerroa:         this.consumePath();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     eoFill: function CanvasGraphics_eoFill() {
Kode lerroa:       this.pendingEOFill = true;
Kode lerroa:       this.fill();
Kode lerroa:     },
Kode lerroa:     fillStroke: function CanvasGraphics_fillStroke() {
Kode lerroa:       this.fill(false);
Kode lerroa:       this.stroke(false);
Kode lerroa:       this.consumePath();
Kode lerroa:     },
Kode lerroa:     eoFillStroke: function CanvasGraphics_eoFillStroke() {
Kode lerroa:       this.pendingEOFill = true;
Kode lerroa:       this.fillStroke();
Kode lerroa:     },
Kode lerroa:     closeFillStroke: function CanvasGraphics_closeFillStroke() {
Kode lerroa:       this.closePath();
Kode lerroa:       this.fillStroke();
Kode lerroa:     },
Kode lerroa:     closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
Kode lerroa:       this.pendingEOFill = true;
Kode lerroa:       this.closePath();
Kode lerroa:       this.fillStroke();
Kode lerroa:     },
Kode lerroa:     endPath: function CanvasGraphics_endPath() {
Kode lerroa:       this.consumePath();
Kode lerroa:     },
Kode lerroa:     clip: function CanvasGraphics_clip() {
Kode lerroa:       this.pendingClip = NORMAL_CLIP;
Kode lerroa:     },
Kode lerroa:     eoClip: function CanvasGraphics_eoClip() {
Kode lerroa:       this.pendingClip = EO_CLIP;
Kode lerroa:     },
Kode lerroa:     beginText: function CanvasGraphics_beginText() {
Kode lerroa:       this.current.textMatrix = _util.IDENTITY_MATRIX;
Kode lerroa:       this.current.textMatrixScale = 1;
Kode lerroa:       this.current.x = this.current.lineX = 0;
Kode lerroa:       this.current.y = this.current.lineY = 0;
Kode lerroa:     },
Kode lerroa:     endText: function CanvasGraphics_endText() {
Kode lerroa:       var paths = this.pendingTextPaths;
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       if (paths === undefined) {
Kode lerroa:         ctx.beginPath();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       ctx.save();
Kode lerroa:       ctx.beginPath();
Kode lerroa:       for (var i = 0; i < paths.length; i++) {
Kode lerroa:         var path = paths[i];
Kode lerroa:         ctx.setTransform.apply(ctx, path.transform);
Kode lerroa:         ctx.translate(path.x, path.y);
Kode lerroa:         path.addToPath(ctx, path.fontSize);
Kode lerroa:       }
Kode lerroa:       ctx.restore();
Kode lerroa:       ctx.clip();
Kode lerroa:       ctx.beginPath();
Kode lerroa:       delete this.pendingTextPaths;
Kode lerroa:     },
Kode lerroa:     setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
Kode lerroa:       this.current.charSpacing = spacing;
Kode lerroa:     },
Kode lerroa:     setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
Kode lerroa:       this.current.wordSpacing = spacing;
Kode lerroa:     },
Kode lerroa:     setHScale: function CanvasGraphics_setHScale(scale) {
Kode lerroa:       this.current.textHScale = scale / 100;
Kode lerroa:     },
Kode lerroa:     setLeading: function CanvasGraphics_setLeading(leading) {
Kode lerroa:       this.current.leading = -leading;
Kode lerroa:     },
Kode lerroa:     setFont: function CanvasGraphics_setFont(fontRefName, size) {
Kode lerroa:       var fontObj = this.commonObjs.get(fontRefName);
Kode lerroa:       var current = this.current;
Kode lerroa:       if (!fontObj) {
Kode lerroa:         throw new Error('Can\'t find font for ' + fontRefName);
Kode lerroa:       }
Kode lerroa:       current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
Kode lerroa:       if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
Kode lerroa:         (0, _util.warn)('Invalid font matrix for font ' + fontRefName);
Kode lerroa:       }
Kode lerroa:       if (size < 0) {
Kode lerroa:         size = -size;
Kode lerroa:         current.fontDirection = -1;
Kode lerroa:       } else {
Kode lerroa:         current.fontDirection = 1;
Kode lerroa:       }
Kode lerroa:       this.current.font = fontObj;
Kode lerroa:       this.current.fontSize = size;
Kode lerroa:       if (fontObj.isType3Font) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var name = fontObj.loadedName || 'sans-serif';
Kode lerroa:       var bold = fontObj.black ? '900' : fontObj.bold ? 'bold' : 'normal';
Kode lerroa:       var italic = fontObj.italic ? 'italic' : 'normal';
Kode lerroa:       var typeface = '"' + name + '", ' + fontObj.fallbackName;
Kode lerroa:       var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
Kode lerroa:       this.current.fontSizeScale = size / browserFontSize;
Kode lerroa:       var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;
Kode lerroa:       this.ctx.font = rule;
Kode lerroa:     },
Kode lerroa:     setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
Kode lerroa:       this.current.textRenderingMode = mode;
Kode lerroa:     },
Kode lerroa:     setTextRise: function CanvasGraphics_setTextRise(rise) {
Kode lerroa:       this.current.textRise = rise;
Kode lerroa:     },
Kode lerroa:     moveText: function CanvasGraphics_moveText(x, y) {
Kode lerroa:       this.current.x = this.current.lineX += x;
Kode lerroa:       this.current.y = this.current.lineY += y;
Kode lerroa:     },
Kode lerroa:     setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
Kode lerroa:       this.setLeading(-y);
Kode lerroa:       this.moveText(x, y);
Kode lerroa:     },
Kode lerroa:     setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
Kode lerroa:       this.current.textMatrix = [a, b, c, d, e, f];
Kode lerroa:       this.current.textMatrixScale = Math.sqrt(a * a + b * b);
Kode lerroa:       this.current.x = this.current.lineX = 0;
Kode lerroa:       this.current.y = this.current.lineY = 0;
Kode lerroa:     },
Kode lerroa:     nextLine: function CanvasGraphics_nextLine() {
Kode lerroa:       this.moveText(0, this.current.leading);
Kode lerroa:     },
Kode lerroa:     paintChar: function CanvasGraphics_paintChar(character, x, y) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var current = this.current;
Kode lerroa:       var font = current.font;
Kode lerroa:       var textRenderingMode = current.textRenderingMode;
Kode lerroa:       var fontSize = current.fontSize / current.fontSizeScale;
Kode lerroa:       var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
Kode lerroa:       var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
Kode lerroa:       var addToPath;
Kode lerroa:       if (font.disableFontFace || isAddToPathSet) {
Kode lerroa:         addToPath = font.getPathGenerator(this.commonObjs, character);
Kode lerroa:       }
Kode lerroa:       if (font.disableFontFace) {
Kode lerroa:         ctx.save();
Kode lerroa:         ctx.translate(x, y);
Kode lerroa:         ctx.beginPath();
Kode lerroa:         addToPath(ctx, fontSize);
Kode lerroa:         if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
Kode lerroa:           ctx.fill();
Kode lerroa:         }
Kode lerroa:         if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
Kode lerroa:           ctx.stroke();
Kode lerroa:         }
Kode lerroa:         ctx.restore();
Kode lerroa:       } else {
Kode lerroa:         if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
Kode lerroa:           ctx.fillText(character, x, y);
Kode lerroa:         }
Kode lerroa:         if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
Kode lerroa:           ctx.strokeText(character, x, y);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (isAddToPathSet) {
Kode lerroa:         var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
Kode lerroa:         paths.push({
Kode lerroa:           transform: ctx.mozCurrentTransform,
Kode lerroa:           x: x,
Kode lerroa:           y: y,
Kode lerroa:           fontSize: fontSize,
Kode lerroa:           addToPath: addToPath
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     get isFontSubpixelAAEnabled() {
Kode lerroa:       var ctx = this.canvasFactory.create(10, 10).context;
Kode lerroa:       ctx.scale(1.5, 1);
Kode lerroa:       ctx.fillText('I', 0, 10);
Kode lerroa:       var data = ctx.getImageData(0, 0, 10, 10).data;
Kode lerroa:       var enabled = false;
Kode lerroa:       for (var i = 3; i < data.length; i += 4) {
Kode lerroa:         if (data[i] > 0 && data[i] < 255) {
Kode lerroa:           enabled = true;
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'isFontSubpixelAAEnabled', enabled);
Kode lerroa:     },
Kode lerroa:     showText: function CanvasGraphics_showText(glyphs) {
Kode lerroa:       var current = this.current;
Kode lerroa:       var font = current.font;
Kode lerroa:       if (font.isType3Font) {
Kode lerroa:         return this.showType3Text(glyphs);
Kode lerroa:       }
Kode lerroa:       var fontSize = current.fontSize;
Kode lerroa:       if (fontSize === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var fontSizeScale = current.fontSizeScale;
Kode lerroa:       var charSpacing = current.charSpacing;
Kode lerroa:       var wordSpacing = current.wordSpacing;
Kode lerroa:       var fontDirection = current.fontDirection;
Kode lerroa:       var textHScale = current.textHScale * fontDirection;
Kode lerroa:       var glyphsLength = glyphs.length;
Kode lerroa:       var vertical = font.vertical;
Kode lerroa:       var spacingDir = vertical ? 1 : -1;
Kode lerroa:       var defaultVMetrics = font.defaultVMetrics;
Kode lerroa:       var widthAdvanceScale = fontSize * current.fontMatrix[0];
Kode lerroa:       var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace;
Kode lerroa:       ctx.save();
Kode lerroa:       ctx.transform.apply(ctx, current.textMatrix);
Kode lerroa:       ctx.translate(current.x, current.y + current.textRise);
Kode lerroa:       if (current.patternFill) {
Kode lerroa:         ctx.fillStyle = current.fillColor.getPattern(ctx, this);
Kode lerroa:       }
Kode lerroa:       if (fontDirection > 0) {
Kode lerroa:         ctx.scale(textHScale, -1);
Kode lerroa:       } else {
Kode lerroa:         ctx.scale(textHScale, 1);
Kode lerroa:       }
Kode lerroa:       var lineWidth = current.lineWidth;
Kode lerroa:       var scale = current.textMatrixScale;
Kode lerroa:       if (scale === 0 || lineWidth === 0) {
Kode lerroa:         var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
Kode lerroa:         if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
Kode lerroa:           this.cachedGetSinglePixelWidth = null;
Kode lerroa:           lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         lineWidth /= scale;
Kode lerroa:       }
Kode lerroa:       if (fontSizeScale !== 1.0) {
Kode lerroa:         ctx.scale(fontSizeScale, fontSizeScale);
Kode lerroa:         lineWidth /= fontSizeScale;
Kode lerroa:       }
Kode lerroa:       ctx.lineWidth = lineWidth;
Kode lerroa:       var x = 0,
Kode lerroa:           i;
Kode lerroa:       for (i = 0; i < glyphsLength; ++i) {
Kode lerroa:         var glyph = glyphs[i];
Kode lerroa:         if ((0, _util.isNum)(glyph)) {
Kode lerroa:           x += spacingDir * glyph * fontSize / 1000;
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var restoreNeeded = false;
Kode lerroa:         var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
Kode lerroa:         var character = glyph.fontChar;
Kode lerroa:         var accent = glyph.accent;
Kode lerroa:         var scaledX, scaledY, scaledAccentX, scaledAccentY;
Kode lerroa:         var width = glyph.width;
Kode lerroa:         if (vertical) {
Kode lerroa:           var vmetric, vx, vy;
Kode lerroa:           vmetric = glyph.vmetric || defaultVMetrics;
Kode lerroa:           vx = glyph.vmetric ? vmetric[1] : width * 0.5;
Kode lerroa:           vx = -vx * widthAdvanceScale;
Kode lerroa:           vy = vmetric[2] * widthAdvanceScale;
Kode lerroa:           width = vmetric ? -vmetric[0] : width;
Kode lerroa:           scaledX = vx / fontSizeScale;
Kode lerroa:           scaledY = (x + vy) / fontSizeScale;
Kode lerroa:         } else {
Kode lerroa:           scaledX = x / fontSizeScale;
Kode lerroa:           scaledY = 0;
Kode lerroa:         }
Kode lerroa:         if (font.remeasure && width > 0) {
Kode lerroa:           var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
Kode lerroa:           if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
Kode lerroa:             var characterScaleX = width / measuredWidth;
Kode lerroa:             restoreNeeded = true;
Kode lerroa:             ctx.save();
Kode lerroa:             ctx.scale(characterScaleX, 1);
Kode lerroa:             scaledX /= characterScaleX;
Kode lerroa:           } else if (width !== measuredWidth) {
Kode lerroa:             scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (glyph.isInFont || font.missingFile) {
Kode lerroa:           if (simpleFillText && !accent) {
Kode lerroa:             ctx.fillText(character, scaledX, scaledY);
Kode lerroa:           } else {
Kode lerroa:             this.paintChar(character, scaledX, scaledY);
Kode lerroa:             if (accent) {
Kode lerroa:               scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
Kode lerroa:               scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
Kode lerroa:               this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         var charWidth = width * widthAdvanceScale + spacing * fontDirection;
Kode lerroa:         x += charWidth;
Kode lerroa:         if (restoreNeeded) {
Kode lerroa:           ctx.restore();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (vertical) {
Kode lerroa:         current.y -= x * textHScale;
Kode lerroa:       } else {
Kode lerroa:         current.x += x * textHScale;
Kode lerroa:       }
Kode lerroa:       ctx.restore();
Kode lerroa:     },
Kode lerroa:     showType3Text: function CanvasGraphics_showType3Text(glyphs) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var current = this.current;
Kode lerroa:       var font = current.font;
Kode lerroa:       var fontSize = current.fontSize;
Kode lerroa:       var fontDirection = current.fontDirection;
Kode lerroa:       var spacingDir = font.vertical ? 1 : -1;
Kode lerroa:       var charSpacing = current.charSpacing;
Kode lerroa:       var wordSpacing = current.wordSpacing;
Kode lerroa:       var textHScale = current.textHScale * fontDirection;
Kode lerroa:       var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
Kode lerroa:       var glyphsLength = glyphs.length;
Kode lerroa:       var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
Kode lerroa:       var i, glyph, width, spacingLength;
Kode lerroa:       if (isTextInvisible || fontSize === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.cachedGetSinglePixelWidth = null;
Kode lerroa:       ctx.save();
Kode lerroa:       ctx.transform.apply(ctx, current.textMatrix);
Kode lerroa:       ctx.translate(current.x, current.y);
Kode lerroa:       ctx.scale(textHScale, fontDirection);
Kode lerroa:       for (i = 0; i < glyphsLength; ++i) {
Kode lerroa:         glyph = glyphs[i];
Kode lerroa:         if ((0, _util.isNum)(glyph)) {
Kode lerroa:           spacingLength = spacingDir * glyph * fontSize / 1000;
Kode lerroa:           this.ctx.translate(spacingLength, 0);
Kode lerroa:           current.x += spacingLength * textHScale;
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
Kode lerroa:         var operatorList = font.charProcOperatorList[glyph.operatorListId];
Kode lerroa:         if (!operatorList) {
Kode lerroa:           (0, _util.warn)('Type3 character "' + glyph.operatorListId + '" is not available.');
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         this.processingType3 = glyph;
Kode lerroa:         this.save();
Kode lerroa:         ctx.scale(fontSize, fontSize);
Kode lerroa:         ctx.transform.apply(ctx, fontMatrix);
Kode lerroa:         this.executeOperatorList(operatorList);
Kode lerroa:         this.restore();
Kode lerroa:         var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);
Kode lerroa:         width = transformed[0] * fontSize + spacing;
Kode lerroa:         ctx.translate(width, 0);
Kode lerroa:         current.x += width * textHScale;
Kode lerroa:       }
Kode lerroa:       ctx.restore();
Kode lerroa:       this.processingType3 = null;
Kode lerroa:     },
Kode lerroa:     setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
Kode lerroa:     setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
Kode lerroa:       this.ctx.rect(llx, lly, urx - llx, ury - lly);
Kode lerroa:       this.clip();
Kode lerroa:       this.endPath();
Kode lerroa:     },
Kode lerroa:     getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var pattern;
Kode lerroa:       if (IR[0] === 'TilingPattern') {
Kode lerroa:         var color = IR[1];
Kode lerroa:         var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
Kode lerroa:         var canvasGraphicsFactory = {
Kode lerroa:           createCanvasGraphics: function createCanvasGraphics(ctx) {
Kode lerroa:             return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory);
Kode lerroa:           }
Kode lerroa:         };
Kode lerroa:         pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
Kode lerroa:       } else {
Kode lerroa:         pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
Kode lerroa:       }
Kode lerroa:       return pattern;
Kode lerroa:     },
Kode lerroa:     setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
Kode lerroa:       this.current.strokeColor = this.getColorN_Pattern(arguments);
Kode lerroa:     },
Kode lerroa:     setFillColorN: function CanvasGraphics_setFillColorN() {
Kode lerroa:       this.current.fillColor = this.getColorN_Pattern(arguments);
Kode lerroa:       this.current.patternFill = true;
Kode lerroa:     },
Kode lerroa:     setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
Kode lerroa:       var color = _util.Util.makeCssRgb(r, g, b);
Kode lerroa:       this.ctx.strokeStyle = color;
Kode lerroa:       this.current.strokeColor = color;
Kode lerroa:     },
Kode lerroa:     setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
Kode lerroa:       var color = _util.Util.makeCssRgb(r, g, b);
Kode lerroa:       this.ctx.fillStyle = color;
Kode lerroa:       this.current.fillColor = color;
Kode lerroa:       this.current.patternFill = false;
Kode lerroa:     },
Kode lerroa:     shadingFill: function CanvasGraphics_shadingFill(patternIR) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       this.save();
Kode lerroa:       var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
Kode lerroa:       ctx.fillStyle = pattern.getPattern(ctx, this, true);
Kode lerroa:       var inv = ctx.mozCurrentTransformInverse;
Kode lerroa:       if (inv) {
Kode lerroa:         var canvas = ctx.canvas;
Kode lerroa:         var width = canvas.width;
Kode lerroa:         var height = canvas.height;
Kode lerroa:         var bl = _util.Util.applyTransform([0, 0], inv);
Kode lerroa:         var br = _util.Util.applyTransform([0, height], inv);
Kode lerroa:         var ul = _util.Util.applyTransform([width, 0], inv);
Kode lerroa:         var ur = _util.Util.applyTransform([width, height], inv);
Kode lerroa:         var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
Kode lerroa:         var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
Kode lerroa:         var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
Kode lerroa:         var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
Kode lerroa:         this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
Kode lerroa:       } else {
Kode lerroa:         this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
Kode lerroa:       }
Kode lerroa:       this.restore();
Kode lerroa:     },
Kode lerroa:     beginInlineImage: function CanvasGraphics_beginInlineImage() {
Kode lerroa:       throw new Error('Should not call beginInlineImage');
Kode lerroa:     },
Kode lerroa:     beginImageData: function CanvasGraphics_beginImageData() {
Kode lerroa:       throw new Error('Should not call beginImageData');
Kode lerroa:     },
Kode lerroa:     paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
Kode lerroa:       this.save();
Kode lerroa:       this.baseTransformStack.push(this.baseTransform);
Kode lerroa:       if (Array.isArray(matrix) && matrix.length === 6) {
Kode lerroa:         this.transform.apply(this, matrix);
Kode lerroa:       }
Kode lerroa:       this.baseTransform = this.ctx.mozCurrentTransform;
Kode lerroa:       if (Array.isArray(bbox) && bbox.length === 4) {
Kode lerroa:         var width = bbox[2] - bbox[0];
Kode lerroa:         var height = bbox[3] - bbox[1];
Kode lerroa:         this.ctx.rect(bbox[0], bbox[1], width, height);
Kode lerroa:         this.clip();
Kode lerroa:         this.endPath();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
Kode lerroa:       this.restore();
Kode lerroa:       this.baseTransform = this.baseTransformStack.pop();
Kode lerroa:     },
Kode lerroa:     beginGroup: function CanvasGraphics_beginGroup(group) {
Kode lerroa:       this.save();
Kode lerroa:       var currentCtx = this.ctx;
Kode lerroa:       if (!group.isolated) {
Kode lerroa:         (0, _util.info)('TODO: Support non-isolated groups.');
Kode lerroa:       }
Kode lerroa:       if (group.knockout) {
Kode lerroa:         (0, _util.warn)('Knockout groups not supported.');
Kode lerroa:       }
Kode lerroa:       var currentTransform = currentCtx.mozCurrentTransform;
Kode lerroa:       if (group.matrix) {
Kode lerroa:         currentCtx.transform.apply(currentCtx, group.matrix);
Kode lerroa:       }
Kode lerroa:       if (!group.bbox) {
Kode lerroa:         throw new Error('Bounding box is required.');
Kode lerroa:       }
Kode lerroa:       var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
Kode lerroa:       var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
Kode lerroa:       bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
Kode lerroa:       var offsetX = Math.floor(bounds[0]);
Kode lerroa:       var offsetY = Math.floor(bounds[1]);
Kode lerroa:       var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
Kode lerroa:       var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
Kode lerroa:       var scaleX = 1,
Kode lerroa:           scaleY = 1;
Kode lerroa:       if (drawnWidth > MAX_GROUP_SIZE) {
Kode lerroa:         scaleX = drawnWidth / MAX_GROUP_SIZE;
Kode lerroa:         drawnWidth = MAX_GROUP_SIZE;
Kode lerroa:       }
Kode lerroa:       if (drawnHeight > MAX_GROUP_SIZE) {
Kode lerroa:         scaleY = drawnHeight / MAX_GROUP_SIZE;
Kode lerroa:         drawnHeight = MAX_GROUP_SIZE;
Kode lerroa:       }
Kode lerroa:       var cacheId = 'groupAt' + this.groupLevel;
Kode lerroa:       if (group.smask) {
Kode lerroa:         cacheId += '_smask_' + this.smaskCounter++ % 2;
Kode lerroa:       }
Kode lerroa:       var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
Kode lerroa:       var groupCtx = scratchCanvas.context;
Kode lerroa:       groupCtx.scale(1 / scaleX, 1 / scaleY);
Kode lerroa:       groupCtx.translate(-offsetX, -offsetY);
Kode lerroa:       groupCtx.transform.apply(groupCtx, currentTransform);
Kode lerroa:       if (group.smask) {
Kode lerroa:         this.smaskStack.push({
Kode lerroa:           canvas: scratchCanvas.canvas,
Kode lerroa:           context: groupCtx,
Kode lerroa:           offsetX: offsetX,
Kode lerroa:           offsetY: offsetY,
Kode lerroa:           scaleX: scaleX,
Kode lerroa:           scaleY: scaleY,
Kode lerroa:           subtype: group.smask.subtype,
Kode lerroa:           backdrop: group.smask.backdrop,
Kode lerroa:           transferMap: group.smask.transferMap || null,
Kode lerroa:           startTransformInverse: null
Kode lerroa:         });
Kode lerroa:       } else {
Kode lerroa:         currentCtx.setTransform(1, 0, 0, 1, 0, 0);
Kode lerroa:         currentCtx.translate(offsetX, offsetY);
Kode lerroa:         currentCtx.scale(scaleX, scaleY);
Kode lerroa:       }
Kode lerroa:       copyCtxState(currentCtx, groupCtx);
Kode lerroa:       this.ctx = groupCtx;
Kode lerroa:       this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);
Kode lerroa:       this.groupStack.push(currentCtx);
Kode lerroa:       this.groupLevel++;
Kode lerroa:       this.current.activeSMask = null;
Kode lerroa:     },
Kode lerroa:     endGroup: function CanvasGraphics_endGroup(group) {
Kode lerroa:       this.groupLevel--;
Kode lerroa:       var groupCtx = this.ctx;
Kode lerroa:       this.ctx = this.groupStack.pop();
Kode lerroa:       if (this.ctx.imageSmoothingEnabled !== undefined) {
Kode lerroa:         this.ctx.imageSmoothingEnabled = false;
Kode lerroa:       } else {
Kode lerroa:         this.ctx.mozImageSmoothingEnabled = false;
Kode lerroa:       }
Kode lerroa:       if (group.smask) {
Kode lerroa:         this.tempSMask = this.smaskStack.pop();
Kode lerroa:       } else {
Kode lerroa:         this.ctx.drawImage(groupCtx.canvas, 0, 0);
Kode lerroa:       }
Kode lerroa:       this.restore();
Kode lerroa:     },
Kode lerroa:     beginAnnotations: function CanvasGraphics_beginAnnotations() {
Kode lerroa:       this.save();
Kode lerroa:       if (this.baseTransform) {
Kode lerroa:         this.ctx.setTransform.apply(this.ctx, this.baseTransform);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     endAnnotations: function CanvasGraphics_endAnnotations() {
Kode lerroa:       this.restore();
Kode lerroa:     },
Kode lerroa:     beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
Kode lerroa:       this.save();
Kode lerroa:       resetCtxToDefault(this.ctx);
Kode lerroa:       this.current = new CanvasExtraState();
Kode lerroa:       if (Array.isArray(rect) && rect.length === 4) {
Kode lerroa:         var width = rect[2] - rect[0];
Kode lerroa:         var height = rect[3] - rect[1];
Kode lerroa:         this.ctx.rect(rect[0], rect[1], width, height);
Kode lerroa:         this.clip();
Kode lerroa:         this.endPath();
Kode lerroa:       }
Kode lerroa:       this.transform.apply(this, transform);
Kode lerroa:       this.transform.apply(this, matrix);
Kode lerroa:     },
Kode lerroa:     endAnnotation: function CanvasGraphics_endAnnotation() {
Kode lerroa:       this.restore();
Kode lerroa:     },
Kode lerroa:     paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
Kode lerroa:       var domImage = this.objs.get(objId);
Kode lerroa:       if (!domImage) {
Kode lerroa:         (0, _util.warn)('Dependent image isn\'t ready yet');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.save();
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       ctx.scale(1 / w, -1 / h);
Kode lerroa:       ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);
Kode lerroa:       if (this.imageLayer) {
Kode lerroa:         var currentTransform = ctx.mozCurrentTransformInverse;
Kode lerroa:         var position = this.getCanvasPosition(0, 0);
Kode lerroa:         this.imageLayer.appendImage({
Kode lerroa:           objId: objId,
Kode lerroa:           left: position[0],
Kode lerroa:           top: position[1],
Kode lerroa:           width: w / currentTransform[0],
Kode lerroa:           height: h / currentTransform[3]
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       this.restore();
Kode lerroa:     },
Kode lerroa:     paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var width = img.width,
Kode lerroa:           height = img.height;
Kode lerroa:       var fillColor = this.current.fillColor;
Kode lerroa:       var isPatternFill = this.current.patternFill;
Kode lerroa:       var glyph = this.processingType3;
Kode lerroa:       if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
Kode lerroa:         if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
Kode lerroa:           glyph.compiled = compileType3Glyph({
Kode lerroa:             data: img.data,
Kode lerroa:             width: width,
Kode lerroa:             height: height
Kode lerroa:           });
Kode lerroa:         } else {
Kode lerroa:           glyph.compiled = null;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (glyph && glyph.compiled) {
Kode lerroa:         glyph.compiled(ctx);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
Kode lerroa:       var maskCtx = maskCanvas.context;
Kode lerroa:       maskCtx.save();
Kode lerroa:       putBinaryImageMask(maskCtx, img);
Kode lerroa:       maskCtx.globalCompositeOperation = 'source-in';
Kode lerroa:       maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
Kode lerroa:       maskCtx.fillRect(0, 0, width, height);
Kode lerroa:       maskCtx.restore();
Kode lerroa:       this.paintInlineImageXObject(maskCanvas.canvas);
Kode lerroa:     },
Kode lerroa:     paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
Kode lerroa:       var width = imgData.width;
Kode lerroa:       var height = imgData.height;
Kode lerroa:       var fillColor = this.current.fillColor;
Kode lerroa:       var isPatternFill = this.current.patternFill;
Kode lerroa:       var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
Kode lerroa:       var maskCtx = maskCanvas.context;
Kode lerroa:       maskCtx.save();
Kode lerroa:       putBinaryImageMask(maskCtx, imgData);
Kode lerroa:       maskCtx.globalCompositeOperation = 'source-in';
Kode lerroa:       maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
Kode lerroa:       maskCtx.fillRect(0, 0, width, height);
Kode lerroa:       maskCtx.restore();
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       for (var i = 0, ii = positions.length; i < ii; i += 2) {
Kode lerroa:         ctx.save();
Kode lerroa:         ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
Kode lerroa:         ctx.scale(1, -1);
Kode lerroa:         ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
Kode lerroa:         ctx.restore();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var fillColor = this.current.fillColor;
Kode lerroa:       var isPatternFill = this.current.patternFill;
Kode lerroa:       for (var i = 0, ii = images.length; i < ii; i++) {
Kode lerroa:         var image = images[i];
Kode lerroa:         var width = image.width,
Kode lerroa:             height = image.height;
Kode lerroa:         var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
Kode lerroa:         var maskCtx = maskCanvas.context;
Kode lerroa:         maskCtx.save();
Kode lerroa:         putBinaryImageMask(maskCtx, image);
Kode lerroa:         maskCtx.globalCompositeOperation = 'source-in';
Kode lerroa:         maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
Kode lerroa:         maskCtx.fillRect(0, 0, width, height);
Kode lerroa:         maskCtx.restore();
Kode lerroa:         ctx.save();
Kode lerroa:         ctx.transform.apply(ctx, image.transform);
Kode lerroa:         ctx.scale(1, -1);
Kode lerroa:         ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
Kode lerroa:         ctx.restore();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
Kode lerroa:       var imgData = this.objs.get(objId);
Kode lerroa:       if (!imgData) {
Kode lerroa:         (0, _util.warn)('Dependent image isn\'t ready yet');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.paintInlineImageXObject(imgData);
Kode lerroa:     },
Kode lerroa:     paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
Kode lerroa:       var imgData = this.objs.get(objId);
Kode lerroa:       if (!imgData) {
Kode lerroa:         (0, _util.warn)('Dependent image isn\'t ready yet');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var width = imgData.width;
Kode lerroa:       var height = imgData.height;
Kode lerroa:       var map = [];
Kode lerroa:       for (var i = 0, ii = positions.length; i < ii; i += 2) {
Kode lerroa:         map.push({
Kode lerroa:           transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
Kode lerroa:           x: 0,
Kode lerroa:           y: 0,
Kode lerroa:           w: width,
Kode lerroa:           h: height
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       this.paintInlineImageXObjectGroup(imgData, map);
Kode lerroa:     },
Kode lerroa:     paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
Kode lerroa:       var width = imgData.width;
Kode lerroa:       var height = imgData.height;
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       this.save();
Kode lerroa:       ctx.scale(1 / width, -1 / height);
Kode lerroa:       var currentTransform = ctx.mozCurrentTransformInverse;
Kode lerroa:       var a = currentTransform[0],
Kode lerroa:           b = currentTransform[1];
Kode lerroa:       var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
Kode lerroa:       var c = currentTransform[2],
Kode lerroa:           d = currentTransform[3];
Kode lerroa:       var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
Kode lerroa:       var imgToPaint, tmpCanvas;
Kode lerroa:       if (imgData instanceof HTMLElement || !imgData.data) {
Kode lerroa:         imgToPaint = imgData;
Kode lerroa:       } else {
Kode lerroa:         tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', width, height);
Kode lerroa:         var tmpCtx = tmpCanvas.context;
Kode lerroa:         putBinaryImageData(tmpCtx, imgData);
Kode lerroa:         imgToPaint = tmpCanvas.canvas;
Kode lerroa:       }
Kode lerroa:       var paintWidth = width,
Kode lerroa:           paintHeight = height;
Kode lerroa:       var tmpCanvasId = 'prescale1';
Kode lerroa:       while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
Kode lerroa:         var newWidth = paintWidth,
Kode lerroa:             newHeight = paintHeight;
Kode lerroa:         if (widthScale > 2 && paintWidth > 1) {
Kode lerroa:           newWidth = Math.ceil(paintWidth / 2);
Kode lerroa:           widthScale /= paintWidth / newWidth;
Kode lerroa:         }
Kode lerroa:         if (heightScale > 2 && paintHeight > 1) {
Kode lerroa:           newHeight = Math.ceil(paintHeight / 2);
Kode lerroa:           heightScale /= paintHeight / newHeight;
Kode lerroa:         }
Kode lerroa:         tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
Kode lerroa:         tmpCtx = tmpCanvas.context;
Kode lerroa:         tmpCtx.clearRect(0, 0, newWidth, newHeight);
Kode lerroa:         tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
Kode lerroa:         imgToPaint = tmpCanvas.canvas;
Kode lerroa:         paintWidth = newWidth;
Kode lerroa:         paintHeight = newHeight;
Kode lerroa:         tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';
Kode lerroa:       }
Kode lerroa:       ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
Kode lerroa:       if (this.imageLayer) {
Kode lerroa:         var position = this.getCanvasPosition(0, -height);
Kode lerroa:         this.imageLayer.appendImage({
Kode lerroa:           imgData: imgData,
Kode lerroa:           left: position[0],
Kode lerroa:           top: position[1],
Kode lerroa:           width: width / currentTransform[0],
Kode lerroa:           height: height / currentTransform[3]
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       this.restore();
Kode lerroa:     },
Kode lerroa:     paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       var w = imgData.width;
Kode lerroa:       var h = imgData.height;
Kode lerroa:       var tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', w, h);
Kode lerroa:       var tmpCtx = tmpCanvas.context;
Kode lerroa:       putBinaryImageData(tmpCtx, imgData);
Kode lerroa:       for (var i = 0, ii = map.length; i < ii; i++) {
Kode lerroa:         var entry = map[i];
Kode lerroa:         ctx.save();
Kode lerroa:         ctx.transform.apply(ctx, entry.transform);
Kode lerroa:         ctx.scale(1, -1);
Kode lerroa:         ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
Kode lerroa:         if (this.imageLayer) {
Kode lerroa:           var position = this.getCanvasPosition(entry.x, entry.y);
Kode lerroa:           this.imageLayer.appendImage({
Kode lerroa:             imgData: imgData,
Kode lerroa:             left: position[0],
Kode lerroa:             top: position[1],
Kode lerroa:             width: w,
Kode lerroa:             height: h
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         ctx.restore();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
Kode lerroa:       this.ctx.fillRect(0, 0, 1, 1);
Kode lerroa:     },
Kode lerroa:     paintXObject: function CanvasGraphics_paintXObject() {
Kode lerroa:       (0, _util.warn)('Unsupported \'paintXObject\' command.');
Kode lerroa:     },
Kode lerroa:     markPoint: function CanvasGraphics_markPoint(tag) {},
Kode lerroa:     markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
Kode lerroa:     beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {},
Kode lerroa:     beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {},
Kode lerroa:     endMarkedContent: function CanvasGraphics_endMarkedContent() {},
Kode lerroa:     beginCompat: function CanvasGraphics_beginCompat() {},
Kode lerroa:     endCompat: function CanvasGraphics_endCompat() {},
Kode lerroa:     consumePath: function CanvasGraphics_consumePath() {
Kode lerroa:       var ctx = this.ctx;
Kode lerroa:       if (this.pendingClip) {
Kode lerroa:         if (this.pendingClip === EO_CLIP) {
Kode lerroa:           ctx.clip('evenodd');
Kode lerroa:         } else {
Kode lerroa:           ctx.clip();
Kode lerroa:         }
Kode lerroa:         this.pendingClip = null;
Kode lerroa:       }
Kode lerroa:       ctx.beginPath();
Kode lerroa:     },
Kode lerroa:     getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {
Kode lerroa:       if (this.cachedGetSinglePixelWidth === null) {
Kode lerroa:         this.ctx.save();
Kode lerroa:         var inverse = this.ctx.mozCurrentTransformInverse;
Kode lerroa:         this.ctx.restore();
Kode lerroa:         this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
Kode lerroa:       }
Kode lerroa:       return this.cachedGetSinglePixelWidth;
Kode lerroa:     },
Kode lerroa:     getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
Kode lerroa:       var transform = this.ctx.mozCurrentTransform;
Kode lerroa:       return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   for (var op in _util.OPS) {
Kode lerroa:     CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
Kode lerroa:   }
Kode lerroa:   return CanvasGraphics;
Kode lerroa: }();
Kode lerroa: exports.CanvasGraphics = CanvasGraphics;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 121 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.TilingPattern = exports.getShadingPatternFromIR = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _webgl = __w_pdfjs_require__(70);
Kode lerroa: 
Kode lerroa: var ShadingIRs = {};
Kode lerroa: ShadingIRs.RadialAxial = {
Kode lerroa:   fromIR: function RadialAxial_fromIR(raw) {
Kode lerroa:     var type = raw[1];
Kode lerroa:     var colorStops = raw[2];
Kode lerroa:     var p0 = raw[3];
Kode lerroa:     var p1 = raw[4];
Kode lerroa:     var r0 = raw[5];
Kode lerroa:     var r1 = raw[6];
Kode lerroa:     return {
Kode lerroa:       type: 'Pattern',
Kode lerroa:       getPattern: function RadialAxial_getPattern(ctx) {
Kode lerroa:         var grad;
Kode lerroa:         if (type === 'axial') {
Kode lerroa:           grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
Kode lerroa:         } else if (type === 'radial') {
Kode lerroa:           grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
Kode lerroa:         }
Kode lerroa:         for (var i = 0, ii = colorStops.length; i < ii; ++i) {
Kode lerroa:           var c = colorStops[i];
Kode lerroa:           grad.addColorStop(c[0], c[1]);
Kode lerroa:         }
Kode lerroa:         return grad;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var createMeshCanvas = function createMeshCanvasClosure() {
Kode lerroa:   function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
Kode lerroa:     var coords = context.coords,
Kode lerroa:         colors = context.colors;
Kode lerroa:     var bytes = data.data,
Kode lerroa:         rowSize = data.width * 4;
Kode lerroa:     var tmp;
Kode lerroa:     if (coords[p1 + 1] > coords[p2 + 1]) {
Kode lerroa:       tmp = p1;
Kode lerroa:       p1 = p2;
Kode lerroa:       p2 = tmp;
Kode lerroa:       tmp = c1;
Kode lerroa:       c1 = c2;
Kode lerroa:       c2 = tmp;
Kode lerroa:     }
Kode lerroa:     if (coords[p2 + 1] > coords[p3 + 1]) {
Kode lerroa:       tmp = p2;
Kode lerroa:       p2 = p3;
Kode lerroa:       p3 = tmp;
Kode lerroa:       tmp = c2;
Kode lerroa:       c2 = c3;
Kode lerroa:       c3 = tmp;
Kode lerroa:     }
Kode lerroa:     if (coords[p1 + 1] > coords[p2 + 1]) {
Kode lerroa:       tmp = p1;
Kode lerroa:       p1 = p2;
Kode lerroa:       p2 = tmp;
Kode lerroa:       tmp = c1;
Kode lerroa:       c1 = c2;
Kode lerroa:       c2 = tmp;
Kode lerroa:     }
Kode lerroa:     var x1 = (coords[p1] + context.offsetX) * context.scaleX;
Kode lerroa:     var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
Kode lerroa:     var x2 = (coords[p2] + context.offsetX) * context.scaleX;
Kode lerroa:     var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
Kode lerroa:     var x3 = (coords[p3] + context.offsetX) * context.scaleX;
Kode lerroa:     var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
Kode lerroa:     if (y1 >= y3) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var c1r = colors[c1],
Kode lerroa:         c1g = colors[c1 + 1],
Kode lerroa:         c1b = colors[c1 + 2];
Kode lerroa:     var c2r = colors[c2],
Kode lerroa:         c2g = colors[c2 + 1],
Kode lerroa:         c2b = colors[c2 + 2];
Kode lerroa:     var c3r = colors[c3],
Kode lerroa:         c3g = colors[c3 + 1],
Kode lerroa:         c3b = colors[c3 + 2];
Kode lerroa:     var minY = Math.round(y1),
Kode lerroa:         maxY = Math.round(y3);
Kode lerroa:     var xa, car, cag, cab;
Kode lerroa:     var xb, cbr, cbg, cbb;
Kode lerroa:     var k;
Kode lerroa:     for (var y = minY; y <= maxY; y++) {
Kode lerroa:       if (y < y2) {
Kode lerroa:         k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);
Kode lerroa:         xa = x1 - (x1 - x2) * k;
Kode lerroa:         car = c1r - (c1r - c2r) * k;
Kode lerroa:         cag = c1g - (c1g - c2g) * k;
Kode lerroa:         cab = c1b - (c1b - c2b) * k;
Kode lerroa:       } else {
Kode lerroa:         k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);
Kode lerroa:         xa = x2 - (x2 - x3) * k;
Kode lerroa:         car = c2r - (c2r - c3r) * k;
Kode lerroa:         cag = c2g - (c2g - c3g) * k;
Kode lerroa:         cab = c2b - (c2b - c3b) * k;
Kode lerroa:       }
Kode lerroa:       k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);
Kode lerroa:       xb = x1 - (x1 - x3) * k;
Kode lerroa:       cbr = c1r - (c1r - c3r) * k;
Kode lerroa:       cbg = c1g - (c1g - c3g) * k;
Kode lerroa:       cbb = c1b - (c1b - c3b) * k;
Kode lerroa:       var x1_ = Math.round(Math.min(xa, xb));
Kode lerroa:       var x2_ = Math.round(Math.max(xa, xb));
Kode lerroa:       var j = rowSize * y + x1_ * 4;
Kode lerroa:       for (var x = x1_; x <= x2_; x++) {
Kode lerroa:         k = (xa - x) / (xa - xb);
Kode lerroa:         k = k < 0 ? 0 : k > 1 ? 1 : k;
Kode lerroa:         bytes[j++] = car - (car - cbr) * k | 0;
Kode lerroa:         bytes[j++] = cag - (cag - cbg) * k | 0;
Kode lerroa:         bytes[j++] = cab - (cab - cbb) * k | 0;
Kode lerroa:         bytes[j++] = 255;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function drawFigure(data, figure, context) {
Kode lerroa:     var ps = figure.coords;
Kode lerroa:     var cs = figure.colors;
Kode lerroa:     var i, ii;
Kode lerroa:     switch (figure.type) {
Kode lerroa:       case 'lattice':
Kode lerroa:         var verticesPerRow = figure.verticesPerRow;
Kode lerroa:         var rows = Math.floor(ps.length / verticesPerRow) - 1;
Kode lerroa:         var cols = verticesPerRow - 1;
Kode lerroa:         for (i = 0; i < rows; i++) {
Kode lerroa:           var q = i * verticesPerRow;
Kode lerroa:           for (var j = 0; j < cols; j++, q++) {
Kode lerroa:             drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
Kode lerroa:             drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 'triangles':
Kode lerroa:         for (i = 0, ii = ps.length; i < ii; i += 3) {
Kode lerroa:           drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         throw new Error('illegal figure');
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases) {
Kode lerroa:     var EXPECTED_SCALE = 1.1;
Kode lerroa:     var MAX_PATTERN_SIZE = 3000;
Kode lerroa:     var BORDER_SIZE = 2;
Kode lerroa:     var offsetX = Math.floor(bounds[0]);
Kode lerroa:     var offsetY = Math.floor(bounds[1]);
Kode lerroa:     var boundsWidth = Math.ceil(bounds[2]) - offsetX;
Kode lerroa:     var boundsHeight = Math.ceil(bounds[3]) - offsetY;
Kode lerroa:     var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
Kode lerroa:     var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
Kode lerroa:     var scaleX = boundsWidth / width;
Kode lerroa:     var scaleY = boundsHeight / height;
Kode lerroa:     var context = {
Kode lerroa:       coords: coords,
Kode lerroa:       colors: colors,
Kode lerroa:       offsetX: -offsetX,
Kode lerroa:       offsetY: -offsetY,
Kode lerroa:       scaleX: 1 / scaleX,
Kode lerroa:       scaleY: 1 / scaleY
Kode lerroa:     };
Kode lerroa:     var paddedWidth = width + BORDER_SIZE * 2;
Kode lerroa:     var paddedHeight = height + BORDER_SIZE * 2;
Kode lerroa:     var canvas, tmpCanvas, i, ii;
Kode lerroa:     if (_webgl.WebGLUtils.isEnabled) {
Kode lerroa:       canvas = _webgl.WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
Kode lerroa:       tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);
Kode lerroa:       tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
Kode lerroa:       canvas = tmpCanvas.canvas;
Kode lerroa:     } else {
Kode lerroa:       tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);
Kode lerroa:       var tmpCtx = tmpCanvas.context;
Kode lerroa:       var data = tmpCtx.createImageData(width, height);
Kode lerroa:       if (backgroundColor) {
Kode lerroa:         var bytes = data.data;
Kode lerroa:         for (i = 0, ii = bytes.length; i < ii; i += 4) {
Kode lerroa:           bytes[i] = backgroundColor[0];
Kode lerroa:           bytes[i + 1] = backgroundColor[1];
Kode lerroa:           bytes[i + 2] = backgroundColor[2];
Kode lerroa:           bytes[i + 3] = 255;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (i = 0; i < figures.length; i++) {
Kode lerroa:         drawFigure(data, figures[i], context);
Kode lerroa:       }
Kode lerroa:       tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
Kode lerroa:       canvas = tmpCanvas.canvas;
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       canvas: canvas,
Kode lerroa:       offsetX: offsetX - BORDER_SIZE * scaleX,
Kode lerroa:       offsetY: offsetY - BORDER_SIZE * scaleY,
Kode lerroa:       scaleX: scaleX,
Kode lerroa:       scaleY: scaleY
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   return createMeshCanvas;
Kode lerroa: }();
Kode lerroa: ShadingIRs.Mesh = {
Kode lerroa:   fromIR: function Mesh_fromIR(raw) {
Kode lerroa:     var coords = raw[2];
Kode lerroa:     var colors = raw[3];
Kode lerroa:     var figures = raw[4];
Kode lerroa:     var bounds = raw[5];
Kode lerroa:     var matrix = raw[6];
Kode lerroa:     var background = raw[8];
Kode lerroa:     return {
Kode lerroa:       type: 'Pattern',
Kode lerroa:       getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
Kode lerroa:         var scale;
Kode lerroa:         if (shadingFill) {
Kode lerroa:           scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
Kode lerroa:         } else {
Kode lerroa:           scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);
Kode lerroa:           if (matrix) {
Kode lerroa:             var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);
Kode lerroa:             scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases);
Kode lerroa:         if (!shadingFill) {
Kode lerroa:           ctx.setTransform.apply(ctx, owner.baseTransform);
Kode lerroa:           if (matrix) {
Kode lerroa:             ctx.transform.apply(ctx, matrix);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
Kode lerroa:         ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
Kode lerroa:         return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: ShadingIRs.Dummy = {
Kode lerroa:   fromIR: function Dummy_fromIR() {
Kode lerroa:     return {
Kode lerroa:       type: 'Pattern',
Kode lerroa:       getPattern: function Dummy_fromIR_getPattern() {
Kode lerroa:         return 'hotpink';
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function getShadingPatternFromIR(raw) {
Kode lerroa:   var shadingIR = ShadingIRs[raw[0]];
Kode lerroa:   if (!shadingIR) {
Kode lerroa:     throw new Error('Unknown IR type: ' + raw[0]);
Kode lerroa:   }
Kode lerroa:   return shadingIR.fromIR(raw);
Kode lerroa: }
Kode lerroa: var TilingPattern = function TilingPatternClosure() {
Kode lerroa:   var PaintType = {
Kode lerroa:     COLORED: 1,
Kode lerroa:     UNCOLORED: 2
Kode lerroa:   };
Kode lerroa:   var MAX_PATTERN_SIZE = 3000;
Kode lerroa:   function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
Kode lerroa:     this.operatorList = IR[2];
Kode lerroa:     this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
Kode lerroa:     this.bbox = IR[4];
Kode lerroa:     this.xstep = IR[5];
Kode lerroa:     this.ystep = IR[6];
Kode lerroa:     this.paintType = IR[7];
Kode lerroa:     this.tilingType = IR[8];
Kode lerroa:     this.color = color;
Kode lerroa:     this.canvasGraphicsFactory = canvasGraphicsFactory;
Kode lerroa:     this.baseTransform = baseTransform;
Kode lerroa:     this.type = 'Pattern';
Kode lerroa:     this.ctx = ctx;
Kode lerroa:   }
Kode lerroa:   TilingPattern.prototype = {
Kode lerroa:     createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
Kode lerroa:       var operatorList = this.operatorList;
Kode lerroa:       var bbox = this.bbox;
Kode lerroa:       var xstep = this.xstep;
Kode lerroa:       var ystep = this.ystep;
Kode lerroa:       var paintType = this.paintType;
Kode lerroa:       var tilingType = this.tilingType;
Kode lerroa:       var color = this.color;
Kode lerroa:       var canvasGraphicsFactory = this.canvasGraphicsFactory;
Kode lerroa:       (0, _util.info)('TilingType: ' + tilingType);
Kode lerroa:       var x0 = bbox[0],
Kode lerroa:           y0 = bbox[1],
Kode lerroa:           x1 = bbox[2],
Kode lerroa:           y1 = bbox[3];
Kode lerroa:       var topLeft = [x0, y0];
Kode lerroa:       var botRight = [x0 + xstep, y0 + ystep];
Kode lerroa:       var width = botRight[0] - topLeft[0];
Kode lerroa:       var height = botRight[1] - topLeft[1];
Kode lerroa:       var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
Kode lerroa:       var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);
Kode lerroa:       var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
Kode lerroa:       width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);
Kode lerroa:       height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);
Kode lerroa:       var tmpCanvas = owner.cachedCanvases.getCanvas('pattern', width, height, true);
Kode lerroa:       var tmpCtx = tmpCanvas.context;
Kode lerroa:       var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
Kode lerroa:       graphics.groupLevel = owner.groupLevel;
Kode lerroa:       this.setFillAndStrokeStyleToContext(graphics, paintType, color);
Kode lerroa:       this.setScale(width, height, xstep, ystep);
Kode lerroa:       this.transformToScale(graphics);
Kode lerroa:       var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];
Kode lerroa:       graphics.transform.apply(graphics, tmpTranslate);
Kode lerroa:       this.clipBbox(graphics, bbox, x0, y0, x1, y1);
Kode lerroa:       graphics.executeOperatorList(operatorList);
Kode lerroa:       return tmpCanvas.canvas;
Kode lerroa:     },
Kode lerroa:     setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
Kode lerroa:       this.scale = [width / xstep, height / ystep];
Kode lerroa:     },
Kode lerroa:     transformToScale: function TilingPattern_transformToScale(graphics) {
Kode lerroa:       var scale = this.scale;
Kode lerroa:       var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
Kode lerroa:       graphics.transform.apply(graphics, tmpScale);
Kode lerroa:     },
Kode lerroa:     scaleToContext: function TilingPattern_scaleToContext() {
Kode lerroa:       var scale = this.scale;
Kode lerroa:       this.ctx.scale(1 / scale[0], 1 / scale[1]);
Kode lerroa:     },
Kode lerroa:     clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
Kode lerroa:       if (Array.isArray(bbox) && bbox.length === 4) {
Kode lerroa:         var bboxWidth = x1 - x0;
Kode lerroa:         var bboxHeight = y1 - y0;
Kode lerroa:         graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
Kode lerroa:         graphics.clip();
Kode lerroa:         graphics.endPath();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
Kode lerroa:       var context = graphics.ctx,
Kode lerroa:           current = graphics.current;
Kode lerroa:       switch (paintType) {
Kode lerroa:         case PaintType.COLORED:
Kode lerroa:           var ctx = this.ctx;
Kode lerroa:           context.fillStyle = ctx.fillStyle;
Kode lerroa:           context.strokeStyle = ctx.strokeStyle;
Kode lerroa:           current.fillColor = ctx.fillStyle;
Kode lerroa:           current.strokeColor = ctx.strokeStyle;
Kode lerroa:           break;
Kode lerroa:         case PaintType.UNCOLORED:
Kode lerroa:           var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);
Kode lerroa:           context.fillStyle = cssColor;
Kode lerroa:           context.strokeStyle = cssColor;
Kode lerroa:           current.fillColor = cssColor;
Kode lerroa:           current.strokeColor = cssColor;
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           throw new _util.FormatError('Unsupported paint type: ' + paintType);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getPattern: function TilingPattern_getPattern(ctx, owner) {
Kode lerroa:       var temporaryPatternCanvas = this.createPatternCanvas(owner);
Kode lerroa:       ctx = this.ctx;
Kode lerroa:       ctx.setTransform.apply(ctx, this.baseTransform);
Kode lerroa:       ctx.transform.apply(ctx, this.matrix);
Kode lerroa:       this.scaleToContext();
Kode lerroa:       return ctx.createPattern(temporaryPatternCanvas, 'repeat');
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return TilingPattern;
Kode lerroa: }();
Kode lerroa: exports.getShadingPatternFromIR = getShadingPatternFromIR;
Kode lerroa: exports.TilingPattern = TilingPattern;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 122 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: 
Kode lerroa: var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
Kode lerroa: 
Kode lerroa: var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
Kode lerroa: 
Kode lerroa: function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var XMLParserErrorCode = {
Kode lerroa:   NoError: 0,
Kode lerroa:   EndOfDocument: -1,
Kode lerroa:   UnterminatedCdat: -2,
Kode lerroa:   UnterminatedXmlDeclaration: -3,
Kode lerroa:   UnterminatedDoctypeDeclaration: -4,
Kode lerroa:   UnterminatedComment: -5,
Kode lerroa:   MalformedElement: -6,
Kode lerroa:   OutOfMemory: -7,
Kode lerroa:   UnterminatedAttributeValue: -8,
Kode lerroa:   UnterminatedElement: -9,
Kode lerroa:   ElementNeverBegun: -10
Kode lerroa: };
Kode lerroa: function isWhitespace(s, index) {
Kode lerroa:   var ch = s[index];
Kode lerroa:   return ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t';
Kode lerroa: }
Kode lerroa: function isWhitespaceString(s) {
Kode lerroa:   for (var i = 0, ii = s.length; i < ii; i++) {
Kode lerroa:     if (!isWhitespace(s, i)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return true;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var XMLParserBase = function () {
Kode lerroa:   function XMLParserBase() {
Kode lerroa:     _classCallCheck(this, XMLParserBase);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(XMLParserBase, [{
Kode lerroa:     key: '_resolveEntities',
Kode lerroa:     value: function _resolveEntities(s) {
Kode lerroa:       return s.replace(/&([^;]+);/g, function (all, entity) {
Kode lerroa:         if (entity.substring(0, 2) === '#x') {
Kode lerroa:           return String.fromCharCode(parseInt(entity.substring(2), 16));
Kode lerroa:         } else if (entity.substring(0, 1) === '#') {
Kode lerroa:           return String.fromCharCode(parseInt(entity.substring(1), 10));
Kode lerroa:         }
Kode lerroa:         switch (entity) {
Kode lerroa:           case 'lt':
Kode lerroa:             return '<';
Kode lerroa:           case 'gt':
Kode lerroa:             return '>';
Kode lerroa:           case 'amp':
Kode lerroa:             return '&';
Kode lerroa:           case 'quot':
Kode lerroa:             return '\"';
Kode lerroa:         }
Kode lerroa:         return this.onResolveEntity(entity);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_parseContent',
Kode lerroa:     value: function _parseContent(s, start) {
Kode lerroa:       var pos = start,
Kode lerroa:           name = void 0,
Kode lerroa:           attributes = [];
Kode lerroa:       function skipWs() {
Kode lerroa:         while (pos < s.length && isWhitespace(s, pos)) {
Kode lerroa:           ++pos;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {
Kode lerroa:         ++pos;
Kode lerroa:       }
Kode lerroa:       name = s.substring(start, pos);
Kode lerroa:       skipWs();
Kode lerroa:       while (pos < s.length && s[pos] !== '>' && s[pos] !== '/' && s[pos] !== '?') {
Kode lerroa:         skipWs();
Kode lerroa:         var attrName = '',
Kode lerroa:             attrValue = '';
Kode lerroa:         while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '=') {
Kode lerroa:           attrName += s[pos];
Kode lerroa:           ++pos;
Kode lerroa:         }
Kode lerroa:         skipWs();
Kode lerroa:         if (s[pos] !== '=') {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:         ++pos;
Kode lerroa:         skipWs();
Kode lerroa:         var attrEndChar = s[pos];
Kode lerroa:         if (attrEndChar !== '\"' && attrEndChar !== '\'') {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:         var attrEndIndex = s.indexOf(attrEndChar, ++pos);
Kode lerroa:         if (attrEndIndex < 0) {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:         attrValue = s.substring(pos, attrEndIndex);
Kode lerroa:         attributes.push({
Kode lerroa:           name: attrName,
Kode lerroa:           value: this._resolveEntities(attrValue)
Kode lerroa:         });
Kode lerroa:         pos = attrEndIndex + 1;
Kode lerroa:         skipWs();
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         name: name,
Kode lerroa:         attributes: attributes,
Kode lerroa:         parsed: pos - start
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_parseProcessingInstruction',
Kode lerroa:     value: function _parseProcessingInstruction(s, start) {
Kode lerroa:       var pos = start,
Kode lerroa:           name = void 0,
Kode lerroa:           value = void 0;
Kode lerroa:       function skipWs() {
Kode lerroa:         while (pos < s.length && isWhitespace(s, pos)) {
Kode lerroa:           ++pos;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {
Kode lerroa:         ++pos;
Kode lerroa:       }
Kode lerroa:       name = s.substring(start, pos);
Kode lerroa:       skipWs();
Kode lerroa:       var attrStart = pos;
Kode lerroa:       while (pos < s.length && (s[pos] !== '?' || s[pos + 1] !== '>')) {
Kode lerroa:         ++pos;
Kode lerroa:       }
Kode lerroa:       value = s.substring(attrStart, pos);
Kode lerroa:       return {
Kode lerroa:         name: name,
Kode lerroa:         value: value,
Kode lerroa:         parsed: pos - start
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'parseXml',
Kode lerroa:     value: function parseXml(s) {
Kode lerroa:       var i = 0;
Kode lerroa:       while (i < s.length) {
Kode lerroa:         var ch = s[i];
Kode lerroa:         var j = i;
Kode lerroa:         if (ch === '<') {
Kode lerroa:           ++j;
Kode lerroa:           var ch2 = s[j];
Kode lerroa:           var q = void 0;
Kode lerroa:           switch (ch2) {
Kode lerroa:             case '/':
Kode lerroa:               ++j;
Kode lerroa:               q = s.indexOf('>', j);
Kode lerroa:               if (q < 0) {
Kode lerroa:                 this.onError(XMLParserErrorCode.UnterminatedElement);
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               this.onEndElement(s.substring(j, q));
Kode lerroa:               j = q + 1;
Kode lerroa:               break;
Kode lerroa:             case '?':
Kode lerroa:               ++j;
Kode lerroa:               var pi = this._parseProcessingInstruction(s, j);
Kode lerroa:               if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== '?>') {
Kode lerroa:                 this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               this.onPi(pi.name, pi.value);
Kode lerroa:               j += pi.parsed + 2;
Kode lerroa:               break;
Kode lerroa:             case '!':
Kode lerroa:               if (s.substring(j + 1, j + 3) === '--') {
Kode lerroa:                 q = s.indexOf('-->', j + 3);
Kode lerroa:                 if (q < 0) {
Kode lerroa:                   this.onError(XMLParserErrorCode.UnterminatedComment);
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 this.onComment(s.substring(j + 3, q));
Kode lerroa:                 j = q + 3;
Kode lerroa:               } else if (s.substring(j + 1, j + 8) === '[CDATA[') {
Kode lerroa:                 q = s.indexOf(']]>', j + 8);
Kode lerroa:                 if (q < 0) {
Kode lerroa:                   this.onError(XMLParserErrorCode.UnterminatedCdat);
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 this.onCdata(s.substring(j + 8, q));
Kode lerroa:                 j = q + 3;
Kode lerroa:               } else if (s.substring(j + 1, j + 8) === 'DOCTYPE') {
Kode lerroa:                 var q2 = s.indexOf('[', j + 8);
Kode lerroa:                 var complexDoctype = false;
Kode lerroa:                 q = s.indexOf('>', j + 8);
Kode lerroa:                 if (q < 0) {
Kode lerroa:                   this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 if (q2 > 0 && q > q2) {
Kode lerroa:                   q = s.indexOf(']>', j + 8);
Kode lerroa:                   if (q < 0) {
Kode lerroa:                     this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
Kode lerroa:                     return;
Kode lerroa:                   }
Kode lerroa:                   complexDoctype = true;
Kode lerroa:                 }
Kode lerroa:                 var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
Kode lerroa:                 this.onDoctype(doctypeContent);
Kode lerroa:                 j = q + (complexDoctype ? 2 : 1);
Kode lerroa:               } else {
Kode lerroa:                 this.onError(XMLParserErrorCode.MalformedElement);
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             default:
Kode lerroa:               var content = this._parseContent(s, j);
Kode lerroa:               if (content === null) {
Kode lerroa:                 this.onError(XMLParserErrorCode.MalformedElement);
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               var isClosed = false;
Kode lerroa:               if (s.substring(j + content.parsed, j + content.parsed + 2) === '/>') {
Kode lerroa:                 isClosed = true;
Kode lerroa:               } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== '>') {
Kode lerroa:                 this.onError(XMLParserErrorCode.UnterminatedElement);
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               this.onBeginElement(content.name, content.attributes, isClosed);
Kode lerroa:               j += content.parsed + (isClosed ? 2 : 1);
Kode lerroa:               break;
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           while (j < s.length && s[j] !== '<') {
Kode lerroa:             j++;
Kode lerroa:           }
Kode lerroa:           var text = s.substring(i, j);
Kode lerroa:           this.onText(this._resolveEntities(text));
Kode lerroa:         }
Kode lerroa:         i = j;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onResolveEntity',
Kode lerroa:     value: function onResolveEntity(name) {
Kode lerroa:       return '&' + name + ';';
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onPi',
Kode lerroa:     value: function onPi(name, value) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onComment',
Kode lerroa:     value: function onComment(text) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onCdata',
Kode lerroa:     value: function onCdata(text) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onDoctype',
Kode lerroa:     value: function onDoctype(doctypeContent) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onText',
Kode lerroa:     value: function onText(text) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onBeginElement',
Kode lerroa:     value: function onBeginElement(name, attributes, isEmpty) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onEndElement',
Kode lerroa:     value: function onEndElement(name) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onError',
Kode lerroa:     value: function onError(code) {}
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return XMLParserBase;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var SimpleDOMNode = function () {
Kode lerroa:   function SimpleDOMNode(nodeName, nodeValue) {
Kode lerroa:     _classCallCheck(this, SimpleDOMNode);
Kode lerroa: 
Kode lerroa:     this.nodeName = nodeName;
Kode lerroa:     this.nodeValue = nodeValue;
Kode lerroa:     Object.defineProperty(this, 'parentNode', {
Kode lerroa:       value: null,
Kode lerroa:       writable: true
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(SimpleDOMNode, [{
Kode lerroa:     key: 'hasChildNodes',
Kode lerroa:     value: function hasChildNodes() {
Kode lerroa:       return this.childNodes && this.childNodes.length > 0;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'firstChild',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.childNodes[0];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'nextSibling',
Kode lerroa:     get: function get() {
Kode lerroa:       var index = this.parentNode.childNodes.indexOf(this);
Kode lerroa:       return this.parentNode.childNodes[index + 1];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'textContent',
Kode lerroa:     get: function get() {
Kode lerroa:       if (!this.childNodes) {
Kode lerroa:         return this.nodeValue || '';
Kode lerroa:       }
Kode lerroa:       return this.childNodes.map(function (child) {
Kode lerroa:         return child.textContent;
Kode lerroa:       }).join('');
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return SimpleDOMNode;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var SimpleXMLParser = function (_XMLParserBase) {
Kode lerroa:   _inherits(SimpleXMLParser, _XMLParserBase);
Kode lerroa: 
Kode lerroa:   function SimpleXMLParser() {
Kode lerroa:     _classCallCheck(this, SimpleXMLParser);
Kode lerroa: 
Kode lerroa:     var _this = _possibleConstructorReturn(this, (SimpleXMLParser.__proto__ || Object.getPrototypeOf(SimpleXMLParser)).call(this));
Kode lerroa: 
Kode lerroa:     _this._currentFragment = null;
Kode lerroa:     _this._stack = null;
Kode lerroa:     _this._errorCode = XMLParserErrorCode.NoError;
Kode lerroa:     return _this;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(SimpleXMLParser, [{
Kode lerroa:     key: 'parseFromString',
Kode lerroa:     value: function parseFromString(data) {
Kode lerroa:       this._currentFragment = [];
Kode lerroa:       this._stack = [];
Kode lerroa:       this._errorCode = XMLParserErrorCode.NoError;
Kode lerroa:       this.parseXml(data);
Kode lerroa:       if (this._errorCode !== XMLParserErrorCode.NoError) {
Kode lerroa:         return undefined;
Kode lerroa:       }
Kode lerroa: 
Kode lerroa:       var _currentFragment = _slicedToArray(this._currentFragment, 1),
Kode lerroa:           documentElement = _currentFragment[0];
Kode lerroa: 
Kode lerroa:       return { documentElement: documentElement };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onResolveEntity',
Kode lerroa:     value: function onResolveEntity(name) {
Kode lerroa:       switch (name) {
Kode lerroa:         case 'apos':
Kode lerroa:           return '\'';
Kode lerroa:       }
Kode lerroa:       return _get(SimpleXMLParser.prototype.__proto__ || Object.getPrototypeOf(SimpleXMLParser.prototype), 'onResolveEntity', this).call(this, name);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onText',
Kode lerroa:     value: function onText(text) {
Kode lerroa:       if (isWhitespaceString(text)) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var node = new SimpleDOMNode('#text', text);
Kode lerroa:       this._currentFragment.push(node);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onCdata',
Kode lerroa:     value: function onCdata(text) {
Kode lerroa:       var node = new SimpleDOMNode('#text', text);
Kode lerroa:       this._currentFragment.push(node);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onBeginElement',
Kode lerroa:     value: function onBeginElement(name, attributes, isEmpty) {
Kode lerroa:       var node = new SimpleDOMNode(name);
Kode lerroa:       node.childNodes = [];
Kode lerroa:       this._currentFragment.push(node);
Kode lerroa:       if (isEmpty) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._stack.push(this._currentFragment);
Kode lerroa:       this._currentFragment = node.childNodes;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onEndElement',
Kode lerroa:     value: function onEndElement(name) {
Kode lerroa:       this._currentFragment = this._stack.pop();
Kode lerroa:       var lastElement = this._currentFragment[this._currentFragment.length - 1];
Kode lerroa:       for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
Kode lerroa:         lastElement.childNodes[i].parentNode = lastElement;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onError',
Kode lerroa:     value: function onError(code) {
Kode lerroa:       this._errorCode = code;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return SimpleXMLParser;
Kode lerroa: }(XMLParserBase);
Kode lerroa: 
Kode lerroa: exports.SimpleXMLParser = SimpleXMLParser;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 123 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFDataTransportStream = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var PDFDataTransportStream = function PDFDataTransportStreamClosure() {
Kode lerroa:   function PDFDataTransportStream(params, pdfDataRangeTransport) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     (0, _util.assert)(pdfDataRangeTransport);
Kode lerroa:     this._queuedChunks = [];
Kode lerroa:     var initialData = params.initialData;
Kode lerroa:     if (initialData && initialData.length > 0) {
Kode lerroa:       var buffer = new Uint8Array(initialData).buffer;
Kode lerroa:       this._queuedChunks.push(buffer);
Kode lerroa:     }
Kode lerroa:     this._pdfDataRangeTransport = pdfDataRangeTransport;
Kode lerroa:     this._isRangeSupported = !params.disableRange;
Kode lerroa:     this._isStreamingSupported = !params.disableStream;
Kode lerroa:     this._contentLength = params.length;
Kode lerroa:     this._fullRequestReader = null;
Kode lerroa:     this._rangeReaders = [];
Kode lerroa:     this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
Kode lerroa:       _this._onReceiveData({
Kode lerroa:         begin: begin,
Kode lerroa:         chunk: chunk
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     this._pdfDataRangeTransport.addProgressListener(function (loaded) {
Kode lerroa:       _this._onProgress({ loaded: loaded });
Kode lerroa:     });
Kode lerroa:     this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
Kode lerroa:       _this._onReceiveData({ chunk: chunk });
Kode lerroa:     });
Kode lerroa:     this._pdfDataRangeTransport.transportReady();
Kode lerroa:   }
Kode lerroa:   PDFDataTransportStream.prototype = {
Kode lerroa:     _onReceiveData: function PDFDataTransportStream_onReceiveData(args) {
Kode lerroa:       var buffer = new Uint8Array(args.chunk).buffer;
Kode lerroa:       if (args.begin === undefined) {
Kode lerroa:         if (this._fullRequestReader) {
Kode lerroa:           this._fullRequestReader._enqueue(buffer);
Kode lerroa:         } else {
Kode lerroa:           this._queuedChunks.push(buffer);
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         var found = this._rangeReaders.some(function (rangeReader) {
Kode lerroa:           if (rangeReader._begin !== args.begin) {
Kode lerroa:             return false;
Kode lerroa:           }
Kode lerroa:           rangeReader._enqueue(buffer);
Kode lerroa:           return true;
Kode lerroa:         });
Kode lerroa:         (0, _util.assert)(found);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     _onProgress: function PDFDataTransportStream_onDataProgress(evt) {
Kode lerroa:       if (this._rangeReaders.length > 0) {
Kode lerroa:         var firstReader = this._rangeReaders[0];
Kode lerroa:         if (firstReader.onProgress) {
Kode lerroa:           firstReader.onProgress({ loaded: evt.loaded });
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     _removeRangeReader: function PDFDataTransportStream_removeRangeReader(reader) {
Kode lerroa:       var i = this._rangeReaders.indexOf(reader);
Kode lerroa:       if (i >= 0) {
Kode lerroa:         this._rangeReaders.splice(i, 1);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getFullReader: function PDFDataTransportStream_getFullReader() {
Kode lerroa:       (0, _util.assert)(!this._fullRequestReader);
Kode lerroa:       var queuedChunks = this._queuedChunks;
Kode lerroa:       this._queuedChunks = null;
Kode lerroa:       return new PDFDataTransportStreamReader(this, queuedChunks);
Kode lerroa:     },
Kode lerroa:     getRangeReader: function PDFDataTransportStream_getRangeReader(begin, end) {
Kode lerroa:       var reader = new PDFDataTransportStreamRangeReader(this, begin, end);
Kode lerroa:       this._pdfDataRangeTransport.requestDataRange(begin, end);
Kode lerroa:       this._rangeReaders.push(reader);
Kode lerroa:       return reader;
Kode lerroa:     },
Kode lerroa:     cancelAllRequests: function PDFDataTransportStream_cancelAllRequests(reason) {
Kode lerroa:       if (this._fullRequestReader) {
Kode lerroa:         this._fullRequestReader.cancel(reason);
Kode lerroa:       }
Kode lerroa:       var readers = this._rangeReaders.slice(0);
Kode lerroa:       readers.forEach(function (rangeReader) {
Kode lerroa:         rangeReader.cancel(reason);
Kode lerroa:       });
Kode lerroa:       this._pdfDataRangeTransport.abort();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   function PDFDataTransportStreamReader(stream, queuedChunks) {
Kode lerroa:     this._stream = stream;
Kode lerroa:     this._done = false;
Kode lerroa:     this._queuedChunks = queuedChunks || [];
Kode lerroa:     this._requests = [];
Kode lerroa:     this._headersReady = Promise.resolve();
Kode lerroa:     stream._fullRequestReader = this;
Kode lerroa:     this.onProgress = null;
Kode lerroa:   }
Kode lerroa:   PDFDataTransportStreamReader.prototype = {
Kode lerroa:     _enqueue: function PDFDataTransportStreamReader_enqueue(chunk) {
Kode lerroa:       if (this._done) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._requests.length > 0) {
Kode lerroa:         var requestCapability = this._requests.shift();
Kode lerroa:         requestCapability.resolve({
Kode lerroa:           value: chunk,
Kode lerroa:           done: false
Kode lerroa:         });
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._queuedChunks.push(chunk);
Kode lerroa:     },
Kode lerroa:     get headersReady() {
Kode lerroa:       return this._headersReady;
Kode lerroa:     },
Kode lerroa:     get isRangeSupported() {
Kode lerroa:       return this._stream._isRangeSupported;
Kode lerroa:     },
Kode lerroa:     get isStreamingSupported() {
Kode lerroa:       return this._stream._isStreamingSupported;
Kode lerroa:     },
Kode lerroa:     get contentLength() {
Kode lerroa:       return this._stream._contentLength;
Kode lerroa:     },
Kode lerroa:     read: function PDFDataTransportStreamReader_read() {
Kode lerroa:       if (this._queuedChunks.length > 0) {
Kode lerroa:         var chunk = this._queuedChunks.shift();
Kode lerroa:         return Promise.resolve({
Kode lerroa:           value: chunk,
Kode lerroa:           done: false
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       if (this._done) {
Kode lerroa:         return Promise.resolve({
Kode lerroa:           value: undefined,
Kode lerroa:           done: true
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var requestCapability = (0, _util.createPromiseCapability)();
Kode lerroa:       this._requests.push(requestCapability);
Kode lerroa:       return requestCapability.promise;
Kode lerroa:     },
Kode lerroa:     cancel: function PDFDataTransportStreamReader_cancel(reason) {
Kode lerroa:       this._done = true;
Kode lerroa:       this._requests.forEach(function (requestCapability) {
Kode lerroa:         requestCapability.resolve({
Kode lerroa:           value: undefined,
Kode lerroa:           done: true
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       this._requests = [];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   function PDFDataTransportStreamRangeReader(stream, begin, end) {
Kode lerroa:     this._stream = stream;
Kode lerroa:     this._begin = begin;
Kode lerroa:     this._end = end;
Kode lerroa:     this._queuedChunk = null;
Kode lerroa:     this._requests = [];
Kode lerroa:     this._done = false;
Kode lerroa:     this.onProgress = null;
Kode lerroa:   }
Kode lerroa:   PDFDataTransportStreamRangeReader.prototype = {
Kode lerroa:     _enqueue: function PDFDataTransportStreamRangeReader_enqueue(chunk) {
Kode lerroa:       if (this._done) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._requests.length === 0) {
Kode lerroa:         this._queuedChunk = chunk;
Kode lerroa:       } else {
Kode lerroa:         var requestsCapability = this._requests.shift();
Kode lerroa:         requestsCapability.resolve({
Kode lerroa:           value: chunk,
Kode lerroa:           done: false
Kode lerroa:         });
Kode lerroa:         this._requests.forEach(function (requestCapability) {
Kode lerroa:           requestCapability.resolve({
Kode lerroa:             value: undefined,
Kode lerroa:             done: true
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:         this._requests = [];
Kode lerroa:       }
Kode lerroa:       this._done = true;
Kode lerroa:       this._stream._removeRangeReader(this);
Kode lerroa:     },
Kode lerroa:     get isStreamingSupported() {
Kode lerroa:       return false;
Kode lerroa:     },
Kode lerroa:     read: function PDFDataTransportStreamRangeReader_read() {
Kode lerroa:       if (this._queuedChunk) {
Kode lerroa:         var chunk = this._queuedChunk;
Kode lerroa:         this._queuedChunk = null;
Kode lerroa:         return Promise.resolve({
Kode lerroa:           value: chunk,
Kode lerroa:           done: false
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       if (this._done) {
Kode lerroa:         return Promise.resolve({
Kode lerroa:           value: undefined,
Kode lerroa:           done: true
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var requestCapability = (0, _util.createPromiseCapability)();
Kode lerroa:       this._requests.push(requestCapability);
Kode lerroa:       return requestCapability.promise;
Kode lerroa:     },
Kode lerroa:     cancel: function PDFDataTransportStreamRangeReader_cancel(reason) {
Kode lerroa:       this._done = true;
Kode lerroa:       this._requests.forEach(function (requestCapability) {
Kode lerroa:         requestCapability.resolve({
Kode lerroa:           value: undefined,
Kode lerroa:           done: true
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       this._requests = [];
Kode lerroa:       this._stream._removeRangeReader(this);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDFDataTransportStream;
Kode lerroa: }();
Kode lerroa: exports.PDFDataTransportStream = PDFDataTransportStream;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 124 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFNodeStream = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _network_utils = __w_pdfjs_require__(44);
Kode lerroa: 
Kode lerroa: function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
Kode lerroa: 
Kode lerroa: function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var fs = require('fs');
Kode lerroa: var http = require('http');
Kode lerroa: var https = require('https');
Kode lerroa: var url = require('url');
Kode lerroa: 
Kode lerroa: var PDFNodeStream = function () {
Kode lerroa:   function PDFNodeStream(options) {
Kode lerroa:     _classCallCheck(this, PDFNodeStream);
Kode lerroa: 
Kode lerroa:     this.options = options;
Kode lerroa:     this.source = options.source;
Kode lerroa:     this.url = url.parse(this.source.url);
Kode lerroa:     this.isHttp = this.url.protocol === 'http:' || this.url.protocol === 'https:';
Kode lerroa:     this.isFsUrl = this.url.protocol === 'file:' || !this.url.host;
Kode lerroa:     this.httpHeaders = this.isHttp && this.source.httpHeaders || {};
Kode lerroa:     this._fullRequest = null;
Kode lerroa:     this._rangeRequestReaders = [];
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFNodeStream, [{
Kode lerroa:     key: 'getFullReader',
Kode lerroa:     value: function getFullReader() {
Kode lerroa:       (0, _util.assert)(!this._fullRequest);
Kode lerroa:       this._fullRequest = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
Kode lerroa:       return this._fullRequest;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getRangeReader',
Kode lerroa:     value: function getRangeReader(start, end) {
Kode lerroa:       var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
Kode lerroa:       this._rangeRequestReaders.push(rangeReader);
Kode lerroa:       return rangeReader;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancelAllRequests',
Kode lerroa:     value: function cancelAllRequests(reason) {
Kode lerroa:       if (this._fullRequest) {
Kode lerroa:         this._fullRequest.cancel(reason);
Kode lerroa:       }
Kode lerroa:       var readers = this._rangeRequestReaders.slice(0);
Kode lerroa:       readers.forEach(function (reader) {
Kode lerroa:         reader.cancel(reason);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFNodeStream;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var BaseFullReader = function () {
Kode lerroa:   function BaseFullReader(stream) {
Kode lerroa:     _classCallCheck(this, BaseFullReader);
Kode lerroa: 
Kode lerroa:     this._url = stream.url;
Kode lerroa:     this._done = false;
Kode lerroa:     this._errored = false;
Kode lerroa:     this._reason = null;
Kode lerroa:     this.onProgress = null;
Kode lerroa:     this._contentLength = stream.source.length;
Kode lerroa:     this._loaded = 0;
Kode lerroa:     this._disableRange = stream.options.disableRange || false;
Kode lerroa:     this._rangeChunkSize = stream.source.rangeChunkSize;
Kode lerroa:     if (!this._rangeChunkSize && !this._disableRange) {
Kode lerroa:       this._disableRange = true;
Kode lerroa:     }
Kode lerroa:     this._isStreamingSupported = !stream.source.disableStream;
Kode lerroa:     this._isRangeSupported = !stream.options.disableRange;
Kode lerroa:     this._readableStream = null;
Kode lerroa:     this._readCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._headersCapability = (0, _util.createPromiseCapability)();
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(BaseFullReader, [{
Kode lerroa:     key: 'read',
Kode lerroa:     value: function read() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       return this._readCapability.promise.then(function () {
Kode lerroa:         if (_this._done) {
Kode lerroa:           return Promise.resolve({
Kode lerroa:             value: undefined,
Kode lerroa:             done: true
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         if (_this._errored) {
Kode lerroa:           return Promise.reject(_this._reason);
Kode lerroa:         }
Kode lerroa:         var chunk = _this._readableStream.read();
Kode lerroa:         if (chunk === null) {
Kode lerroa:           _this._readCapability = (0, _util.createPromiseCapability)();
Kode lerroa:           return _this.read();
Kode lerroa:         }
Kode lerroa:         _this._loaded += chunk.length;
Kode lerroa:         if (_this.onProgress) {
Kode lerroa:           _this.onProgress({
Kode lerroa:             loaded: _this._loaded,
Kode lerroa:             total: _this._contentLength
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         var buffer = new Uint8Array(chunk).buffer;
Kode lerroa:         return Promise.resolve({
Kode lerroa:           value: buffer,
Kode lerroa:           done: false
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancel',
Kode lerroa:     value: function cancel(reason) {
Kode lerroa:       if (!this._readableStream) {
Kode lerroa:         this._error(reason);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._readableStream.destroy(reason);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_error',
Kode lerroa:     value: function _error(reason) {
Kode lerroa:       this._errored = true;
Kode lerroa:       this._reason = reason;
Kode lerroa:       this._readCapability.resolve();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setReadableStream',
Kode lerroa:     value: function _setReadableStream(readableStream) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       this._readableStream = readableStream;
Kode lerroa:       readableStream.on('readable', function () {
Kode lerroa:         _this2._readCapability.resolve();
Kode lerroa:       });
Kode lerroa:       readableStream.on('end', function () {
Kode lerroa:         readableStream.destroy();
Kode lerroa:         _this2._done = true;
Kode lerroa:         _this2._readCapability.resolve();
Kode lerroa:       });
Kode lerroa:       readableStream.on('error', function (reason) {
Kode lerroa:         _this2._error(reason);
Kode lerroa:       });
Kode lerroa:       if (!this._isStreamingSupported && this._isRangeSupported) {
Kode lerroa:         this._error(new _util.AbortException('streaming is disabled'));
Kode lerroa:       }
Kode lerroa:       if (this._errored) {
Kode lerroa:         this._readableStream.destroy(this._reason);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'headersReady',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._headersCapability.promise;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'contentLength',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._contentLength;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isRangeSupported',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._isRangeSupported;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isStreamingSupported',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._isStreamingSupported;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return BaseFullReader;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var BaseRangeReader = function () {
Kode lerroa:   function BaseRangeReader(stream) {
Kode lerroa:     _classCallCheck(this, BaseRangeReader);
Kode lerroa: 
Kode lerroa:     this._url = stream.url;
Kode lerroa:     this._done = false;
Kode lerroa:     this._errored = false;
Kode lerroa:     this._reason = null;
Kode lerroa:     this.onProgress = null;
Kode lerroa:     this._loaded = 0;
Kode lerroa:     this._readableStream = null;
Kode lerroa:     this._readCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._isStreamingSupported = !stream.source.disableStream;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(BaseRangeReader, [{
Kode lerroa:     key: 'read',
Kode lerroa:     value: function read() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       return this._readCapability.promise.then(function () {
Kode lerroa:         if (_this3._done) {
Kode lerroa:           return Promise.resolve({
Kode lerroa:             value: undefined,
Kode lerroa:             done: true
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         if (_this3._errored) {
Kode lerroa:           return Promise.reject(_this3._reason);
Kode lerroa:         }
Kode lerroa:         var chunk = _this3._readableStream.read();
Kode lerroa:         if (chunk === null) {
Kode lerroa:           _this3._readCapability = (0, _util.createPromiseCapability)();
Kode lerroa:           return _this3.read();
Kode lerroa:         }
Kode lerroa:         _this3._loaded += chunk.length;
Kode lerroa:         if (_this3.onProgress) {
Kode lerroa:           _this3.onProgress({ loaded: _this3._loaded });
Kode lerroa:         }
Kode lerroa:         var buffer = new Uint8Array(chunk).buffer;
Kode lerroa:         return Promise.resolve({
Kode lerroa:           value: buffer,
Kode lerroa:           done: false
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancel',
Kode lerroa:     value: function cancel(reason) {
Kode lerroa:       if (!this._readableStream) {
Kode lerroa:         this._error(reason);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._readableStream.destroy(reason);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_error',
Kode lerroa:     value: function _error(reason) {
Kode lerroa:       this._errored = true;
Kode lerroa:       this._reason = reason;
Kode lerroa:       this._readCapability.resolve();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setReadableStream',
Kode lerroa:     value: function _setReadableStream(readableStream) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       this._readableStream = readableStream;
Kode lerroa:       readableStream.on('readable', function () {
Kode lerroa:         _this4._readCapability.resolve();
Kode lerroa:       });
Kode lerroa:       readableStream.on('end', function () {
Kode lerroa:         readableStream.destroy();
Kode lerroa:         _this4._done = true;
Kode lerroa:         _this4._readCapability.resolve();
Kode lerroa:       });
Kode lerroa:       readableStream.on('error', function (reason) {
Kode lerroa:         _this4._error(reason);
Kode lerroa:       });
Kode lerroa:       if (this._errored) {
Kode lerroa:         this._readableStream.destroy(this._reason);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isStreamingSupported',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._isStreamingSupported;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return BaseRangeReader;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: function createRequestOptions(url, headers) {
Kode lerroa:   return {
Kode lerroa:     protocol: url.protocol,
Kode lerroa:     auth: url.auth,
Kode lerroa:     host: url.hostname,
Kode lerroa:     port: url.port,
Kode lerroa:     path: url.path,
Kode lerroa:     method: 'GET',
Kode lerroa:     headers: headers
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var PDFNodeStreamFullReader = function (_BaseFullReader) {
Kode lerroa:   _inherits(PDFNodeStreamFullReader, _BaseFullReader);
Kode lerroa: 
Kode lerroa:   function PDFNodeStreamFullReader(stream) {
Kode lerroa:     _classCallCheck(this, PDFNodeStreamFullReader);
Kode lerroa: 
Kode lerroa:     var _this5 = _possibleConstructorReturn(this, (PDFNodeStreamFullReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamFullReader)).call(this, stream));
Kode lerroa: 
Kode lerroa:     var handleResponse = function handleResponse(response) {
Kode lerroa:       _this5._headersCapability.resolve();
Kode lerroa:       _this5._setReadableStream(response);
Kode lerroa: 
Kode lerroa:       var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
Kode lerroa:         getResponseHeader: function getResponseHeader(name) {
Kode lerroa:           return _this5._readableStream.headers[name.toLowerCase()];
Kode lerroa:         },
Kode lerroa:         isHttp: stream.isHttp,
Kode lerroa:         rangeChunkSize: _this5._rangeChunkSize,
Kode lerroa:         disableRange: _this5._disableRange
Kode lerroa:       }),
Kode lerroa:           allowRangeRequests = _validateRangeRequest.allowRangeRequests,
Kode lerroa:           suggestedLength = _validateRangeRequest.suggestedLength;
Kode lerroa: 
Kode lerroa:       if (allowRangeRequests) {
Kode lerroa:         _this5._isRangeSupported = true;
Kode lerroa:       }
Kode lerroa:       _this5._contentLength = suggestedLength;
Kode lerroa:     };
Kode lerroa:     _this5._request = null;
Kode lerroa:     if (_this5._url.protocol === 'http:') {
Kode lerroa:       _this5._request = http.request(createRequestOptions(_this5._url, stream.httpHeaders), handleResponse);
Kode lerroa:     } else {
Kode lerroa:       _this5._request = https.request(createRequestOptions(_this5._url, stream.httpHeaders), handleResponse);
Kode lerroa:     }
Kode lerroa:     _this5._request.on('error', function (reason) {
Kode lerroa:       _this5._errored = true;
Kode lerroa:       _this5._reason = reason;
Kode lerroa:       _this5._headersCapability.reject(reason);
Kode lerroa:     });
Kode lerroa:     _this5._request.end();
Kode lerroa:     return _this5;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   return PDFNodeStreamFullReader;
Kode lerroa: }(BaseFullReader);
Kode lerroa: 
Kode lerroa: var PDFNodeStreamRangeReader = function (_BaseRangeReader) {
Kode lerroa:   _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);
Kode lerroa: 
Kode lerroa:   function PDFNodeStreamRangeReader(stream, start, end) {
Kode lerroa:     _classCallCheck(this, PDFNodeStreamRangeReader);
Kode lerroa: 
Kode lerroa:     var _this6 = _possibleConstructorReturn(this, (PDFNodeStreamRangeReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamRangeReader)).call(this, stream));
Kode lerroa: 
Kode lerroa:     _this6._httpHeaders = {};
Kode lerroa:     for (var property in stream.httpHeaders) {
Kode lerroa:       var value = stream.httpHeaders[property];
Kode lerroa:       if (typeof value === 'undefined') {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       _this6._httpHeaders[property] = value;
Kode lerroa:     }
Kode lerroa:     _this6._httpHeaders['Range'] = 'bytes=' + start + '-' + (end - 1);
Kode lerroa:     _this6._request = null;
Kode lerroa:     if (_this6._url.protocol === 'http:') {
Kode lerroa:       _this6._request = http.request(createRequestOptions(_this6._url, _this6._httpHeaders), function (response) {
Kode lerroa:         _this6._setReadableStream(response);
Kode lerroa:       });
Kode lerroa:     } else {
Kode lerroa:       _this6._request = https.request(createRequestOptions(_this6._url, _this6._httpHeaders), function (response) {
Kode lerroa:         _this6._setReadableStream(response);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     _this6._request.on('error', function (reason) {
Kode lerroa:       _this6._errored = true;
Kode lerroa:       _this6._reason = reason;
Kode lerroa:     });
Kode lerroa:     _this6._request.end();
Kode lerroa:     return _this6;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   return PDFNodeStreamRangeReader;
Kode lerroa: }(BaseRangeReader);
Kode lerroa: 
Kode lerroa: var PDFNodeStreamFsFullReader = function (_BaseFullReader2) {
Kode lerroa:   _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);
Kode lerroa: 
Kode lerroa:   function PDFNodeStreamFsFullReader(stream) {
Kode lerroa:     _classCallCheck(this, PDFNodeStreamFsFullReader);
Kode lerroa: 
Kode lerroa:     var _this7 = _possibleConstructorReturn(this, (PDFNodeStreamFsFullReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamFsFullReader)).call(this, stream));
Kode lerroa: 
Kode lerroa:     var path = decodeURI(_this7._url.path);
Kode lerroa:     fs.lstat(path, function (error, stat) {
Kode lerroa:       if (error) {
Kode lerroa:         _this7._errored = true;
Kode lerroa:         _this7._reason = error;
Kode lerroa:         _this7._headersCapability.reject(error);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _this7._contentLength = stat.size;
Kode lerroa:       _this7._setReadableStream(fs.createReadStream(path));
Kode lerroa:       _this7._headersCapability.resolve();
Kode lerroa:     });
Kode lerroa:     return _this7;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   return PDFNodeStreamFsFullReader;
Kode lerroa: }(BaseFullReader);
Kode lerroa: 
Kode lerroa: var PDFNodeStreamFsRangeReader = function (_BaseRangeReader2) {
Kode lerroa:   _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);
Kode lerroa: 
Kode lerroa:   function PDFNodeStreamFsRangeReader(stream, start, end) {
Kode lerroa:     _classCallCheck(this, PDFNodeStreamFsRangeReader);
Kode lerroa: 
Kode lerroa:     var _this8 = _possibleConstructorReturn(this, (PDFNodeStreamFsRangeReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamFsRangeReader)).call(this, stream));
Kode lerroa: 
Kode lerroa:     _this8._setReadableStream(fs.createReadStream(decodeURI(_this8._url.path), {
Kode lerroa:       start: start,
Kode lerroa:       end: end - 1
Kode lerroa:     }));
Kode lerroa:     return _this8;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   return PDFNodeStreamFsRangeReader;
Kode lerroa: }(BaseRangeReader);
Kode lerroa: 
Kode lerroa: exports.PDFNodeStream = PDFNodeStream;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 125 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFFetchStream = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _network_utils = __w_pdfjs_require__(44);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: function createFetchOptions(headers, withCredentials) {
Kode lerroa:   return {
Kode lerroa:     method: 'GET',
Kode lerroa:     headers: headers,
Kode lerroa:     mode: 'cors',
Kode lerroa:     credentials: withCredentials ? 'include' : 'same-origin',
Kode lerroa:     redirect: 'follow'
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var PDFFetchStream = function () {
Kode lerroa:   function PDFFetchStream(options) {
Kode lerroa:     _classCallCheck(this, PDFFetchStream);
Kode lerroa: 
Kode lerroa:     this.options = options;
Kode lerroa:     this.source = options.source;
Kode lerroa:     this.isHttp = /^https?:/i.test(this.source.url);
Kode lerroa:     this.httpHeaders = this.isHttp && this.source.httpHeaders || {};
Kode lerroa:     this._fullRequestReader = null;
Kode lerroa:     this._rangeRequestReaders = [];
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFFetchStream, [{
Kode lerroa:     key: 'getFullReader',
Kode lerroa:     value: function getFullReader() {
Kode lerroa:       (0, _util.assert)(!this._fullRequestReader);
Kode lerroa:       this._fullRequestReader = new PDFFetchStreamReader(this);
Kode lerroa:       return this._fullRequestReader;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getRangeReader',
Kode lerroa:     value: function getRangeReader(begin, end) {
Kode lerroa:       var reader = new PDFFetchStreamRangeReader(this, begin, end);
Kode lerroa:       this._rangeRequestReaders.push(reader);
Kode lerroa:       return reader;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancelAllRequests',
Kode lerroa:     value: function cancelAllRequests(reason) {
Kode lerroa:       if (this._fullRequestReader) {
Kode lerroa:         this._fullRequestReader.cancel(reason);
Kode lerroa:       }
Kode lerroa:       var readers = this._rangeRequestReaders.slice(0);
Kode lerroa:       readers.forEach(function (reader) {
Kode lerroa:         reader.cancel(reason);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFFetchStream;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var PDFFetchStreamReader = function () {
Kode lerroa:   function PDFFetchStreamReader(stream) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFFetchStreamReader);
Kode lerroa: 
Kode lerroa:     this._stream = stream;
Kode lerroa:     this._reader = null;
Kode lerroa:     this._loaded = 0;
Kode lerroa:     this._withCredentials = stream.source.withCredentials;
Kode lerroa:     this._contentLength = this._stream.source.length;
Kode lerroa:     this._headersCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._disableRange = this._stream.options.disableRange;
Kode lerroa:     this._rangeChunkSize = this._stream.source.rangeChunkSize;
Kode lerroa:     if (!this._rangeChunkSize && !this._disableRange) {
Kode lerroa:       this._disableRange = true;
Kode lerroa:     }
Kode lerroa:     this._isRangeSupported = !this._stream.options.disableRange;
Kode lerroa:     this._isStreamingSupported = !this._stream.source.disableStream;
Kode lerroa:     this._headers = new Headers();
Kode lerroa:     for (var property in this._stream.httpHeaders) {
Kode lerroa:       var value = this._stream.httpHeaders[property];
Kode lerroa:       if (typeof value === 'undefined') {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       this._headers.append(property, value);
Kode lerroa:     }
Kode lerroa:     var url = this._stream.source.url;
Kode lerroa:     fetch(url, createFetchOptions(this._headers, this._withCredentials)).then(function (response) {
Kode lerroa:       if (!(0, _network_utils.validateResponseStatus)(response.status)) {
Kode lerroa:         throw (0, _network_utils.createResponseStatusError)(response.status, url);
Kode lerroa:       }
Kode lerroa:       _this._reader = response.body.getReader();
Kode lerroa:       _this._headersCapability.resolve();
Kode lerroa: 
Kode lerroa:       var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
Kode lerroa:         getResponseHeader: function getResponseHeader(name) {
Kode lerroa:           return response.headers.get(name);
Kode lerroa:         },
Kode lerroa:         isHttp: _this._stream.isHttp,
Kode lerroa:         rangeChunkSize: _this._rangeChunkSize,
Kode lerroa:         disableRange: _this._disableRange
Kode lerroa:       }),
Kode lerroa:           allowRangeRequests = _validateRangeRequest.allowRangeRequests,
Kode lerroa:           suggestedLength = _validateRangeRequest.suggestedLength;
Kode lerroa: 
Kode lerroa:       _this._contentLength = suggestedLength;
Kode lerroa:       _this._isRangeSupported = allowRangeRequests;
Kode lerroa:       if (!_this._isStreamingSupported && _this._isRangeSupported) {
Kode lerroa:         _this.cancel(new _util.AbortException('streaming is disabled'));
Kode lerroa:       }
Kode lerroa:     }).catch(this._headersCapability.reject);
Kode lerroa:     this.onProgress = null;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFFetchStreamReader, [{
Kode lerroa:     key: 'read',
Kode lerroa:     value: function read() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       return this._headersCapability.promise.then(function () {
Kode lerroa:         return _this2._reader.read().then(function (_ref) {
Kode lerroa:           var value = _ref.value,
Kode lerroa:               done = _ref.done;
Kode lerroa: 
Kode lerroa:           if (done) {
Kode lerroa:             return Promise.resolve({
Kode lerroa:               value: value,
Kode lerroa:               done: done
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:           _this2._loaded += value.byteLength;
Kode lerroa:           if (_this2.onProgress) {
Kode lerroa:             _this2.onProgress({
Kode lerroa:               loaded: _this2._loaded,
Kode lerroa:               total: _this2._contentLength
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:           var buffer = new Uint8Array(value).buffer;
Kode lerroa:           return Promise.resolve({
Kode lerroa:             value: buffer,
Kode lerroa:             done: false
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancel',
Kode lerroa:     value: function cancel(reason) {
Kode lerroa:       if (this._reader) {
Kode lerroa:         this._reader.cancel(reason);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'headersReady',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._headersCapability.promise;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'contentLength',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._contentLength;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isRangeSupported',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._isRangeSupported;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isStreamingSupported',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._isStreamingSupported;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFFetchStreamReader;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var PDFFetchStreamRangeReader = function () {
Kode lerroa:   function PDFFetchStreamRangeReader(stream, begin, end) {
Kode lerroa:     var _this3 = this;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFFetchStreamRangeReader);
Kode lerroa: 
Kode lerroa:     this._stream = stream;
Kode lerroa:     this._reader = null;
Kode lerroa:     this._loaded = 0;
Kode lerroa:     this._withCredentials = stream.source.withCredentials;
Kode lerroa:     this._readCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._isStreamingSupported = !stream.source.disableStream;
Kode lerroa:     this._headers = new Headers();
Kode lerroa:     for (var property in this._stream.httpHeaders) {
Kode lerroa:       var value = this._stream.httpHeaders[property];
Kode lerroa:       if (typeof value === 'undefined') {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       this._headers.append(property, value);
Kode lerroa:     }
Kode lerroa:     var rangeStr = begin + '-' + (end - 1);
Kode lerroa:     this._headers.append('Range', 'bytes=' + rangeStr);
Kode lerroa:     var url = this._stream.source.url;
Kode lerroa:     fetch(url, createFetchOptions(this._headers, this._withCredentials)).then(function (response) {
Kode lerroa:       if (!(0, _network_utils.validateResponseStatus)(response.status)) {
Kode lerroa:         throw (0, _network_utils.createResponseStatusError)(response.status, url);
Kode lerroa:       }
Kode lerroa:       _this3._readCapability.resolve();
Kode lerroa:       _this3._reader = response.body.getReader();
Kode lerroa:     });
Kode lerroa:     this.onProgress = null;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFFetchStreamRangeReader, [{
Kode lerroa:     key: 'read',
Kode lerroa:     value: function read() {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       return this._readCapability.promise.then(function () {
Kode lerroa:         return _this4._reader.read().then(function (_ref2) {
Kode lerroa:           var value = _ref2.value,
Kode lerroa:               done = _ref2.done;
Kode lerroa: 
Kode lerroa:           if (done) {
Kode lerroa:             return Promise.resolve({
Kode lerroa:               value: value,
Kode lerroa:               done: done
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:           _this4._loaded += value.byteLength;
Kode lerroa:           if (_this4.onProgress) {
Kode lerroa:             _this4.onProgress({ loaded: _this4._loaded });
Kode lerroa:           }
Kode lerroa:           var buffer = new Uint8Array(value).buffer;
Kode lerroa:           return Promise.resolve({
Kode lerroa:             value: buffer,
Kode lerroa:             done: false
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancel',
Kode lerroa:     value: function cancel(reason) {
Kode lerroa:       if (this._reader) {
Kode lerroa:         this._reader.cancel(reason);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isStreamingSupported',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._isStreamingSupported;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFFetchStreamRangeReader;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFFetchStream = PDFFetchStream;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 126 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.NetworkManager = exports.PDFNetworkStream = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _network_utils = __w_pdfjs_require__(44);
Kode lerroa: 
Kode lerroa: var _global_scope = __w_pdfjs_require__(20);
Kode lerroa: 
Kode lerroa: var _global_scope2 = _interopRequireDefault(_global_scope);
Kode lerroa: 
Kode lerroa: function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
Kode lerroa: 
Kode lerroa: ;
Kode lerroa: var OK_RESPONSE = 200;
Kode lerroa: var PARTIAL_CONTENT_RESPONSE = 206;
Kode lerroa: function NetworkManager(url, args) {
Kode lerroa:   this.url = url;
Kode lerroa:   args = args || {};
Kode lerroa:   this.isHttp = /^https?:/i.test(url);
Kode lerroa:   this.httpHeaders = this.isHttp && args.httpHeaders || {};
Kode lerroa:   this.withCredentials = args.withCredentials || false;
Kode lerroa:   this.getXhr = args.getXhr || function NetworkManager_getXhr() {
Kode lerroa:     return new XMLHttpRequest();
Kode lerroa:   };
Kode lerroa:   this.currXhrId = 0;
Kode lerroa:   this.pendingRequests = Object.create(null);
Kode lerroa:   this.loadedRequests = Object.create(null);
Kode lerroa: }
Kode lerroa: function getArrayBuffer(xhr) {
Kode lerroa:   var data = xhr.response;
Kode lerroa:   if (typeof data !== 'string') {
Kode lerroa:     return data;
Kode lerroa:   }
Kode lerroa:   var array = (0, _util.stringToBytes)(data);
Kode lerroa:   return array.buffer;
Kode lerroa: }
Kode lerroa: var supportsMozChunked = function supportsMozChunkedClosure() {
Kode lerroa:   try {
Kode lerroa:     var x = new XMLHttpRequest();
Kode lerroa:     x.open('GET', _global_scope2.default.location.href);
Kode lerroa:     x.responseType = 'moz-chunked-arraybuffer';
Kode lerroa:     return x.responseType === 'moz-chunked-arraybuffer';
Kode lerroa:   } catch (e) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa: }();
Kode lerroa: NetworkManager.prototype = {
Kode lerroa:   requestRange: function NetworkManager_requestRange(begin, end, listeners) {
Kode lerroa:     var args = {
Kode lerroa:       begin: begin,
Kode lerroa:       end: end
Kode lerroa:     };
Kode lerroa:     for (var prop in listeners) {
Kode lerroa:       args[prop] = listeners[prop];
Kode lerroa:     }
Kode lerroa:     return this.request(args);
Kode lerroa:   },
Kode lerroa:   requestFull: function NetworkManager_requestFull(listeners) {
Kode lerroa:     return this.request(listeners);
Kode lerroa:   },
Kode lerroa:   request: function NetworkManager_request(args) {
Kode lerroa:     var xhr = this.getXhr();
Kode lerroa:     var xhrId = this.currXhrId++;
Kode lerroa:     var pendingRequest = this.pendingRequests[xhrId] = { xhr: xhr };
Kode lerroa:     xhr.open('GET', this.url);
Kode lerroa:     xhr.withCredentials = this.withCredentials;
Kode lerroa:     for (var property in this.httpHeaders) {
Kode lerroa:       var value = this.httpHeaders[property];
Kode lerroa:       if (typeof value === 'undefined') {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       xhr.setRequestHeader(property, value);
Kode lerroa:     }
Kode lerroa:     if (this.isHttp && 'begin' in args && 'end' in args) {
Kode lerroa:       var rangeStr = args.begin + '-' + (args.end - 1);
Kode lerroa:       xhr.setRequestHeader('Range', 'bytes=' + rangeStr);
Kode lerroa:       pendingRequest.expectedStatus = 206;
Kode lerroa:     } else {
Kode lerroa:       pendingRequest.expectedStatus = 200;
Kode lerroa:     }
Kode lerroa:     var useMozChunkedLoading = supportsMozChunked && !!args.onProgressiveData;
Kode lerroa:     if (useMozChunkedLoading) {
Kode lerroa:       xhr.responseType = 'moz-chunked-arraybuffer';
Kode lerroa:       pendingRequest.onProgressiveData = args.onProgressiveData;
Kode lerroa:       pendingRequest.mozChunked = true;
Kode lerroa:     } else {
Kode lerroa:       xhr.responseType = 'arraybuffer';
Kode lerroa:     }
Kode lerroa:     if (args.onError) {
Kode lerroa:       xhr.onerror = function (evt) {
Kode lerroa:         args.onError(xhr.status);
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
Kode lerroa:     xhr.onprogress = this.onProgress.bind(this, xhrId);
Kode lerroa:     pendingRequest.onHeadersReceived = args.onHeadersReceived;
Kode lerroa:     pendingRequest.onDone = args.onDone;
Kode lerroa:     pendingRequest.onError = args.onError;
Kode lerroa:     pendingRequest.onProgress = args.onProgress;
Kode lerroa:     xhr.send(null);
Kode lerroa:     return xhrId;
Kode lerroa:   },
Kode lerroa:   onProgress: function NetworkManager_onProgress(xhrId, evt) {
Kode lerroa:     var pendingRequest = this.pendingRequests[xhrId];
Kode lerroa:     if (!pendingRequest) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (pendingRequest.mozChunked) {
Kode lerroa:       var chunk = getArrayBuffer(pendingRequest.xhr);
Kode lerroa:       pendingRequest.onProgressiveData(chunk);
Kode lerroa:     }
Kode lerroa:     var onProgress = pendingRequest.onProgress;
Kode lerroa:     if (onProgress) {
Kode lerroa:       onProgress(evt);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   onStateChange: function NetworkManager_onStateChange(xhrId, evt) {
Kode lerroa:     var pendingRequest = this.pendingRequests[xhrId];
Kode lerroa:     if (!pendingRequest) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var xhr = pendingRequest.xhr;
Kode lerroa:     if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
Kode lerroa:       pendingRequest.onHeadersReceived();
Kode lerroa:       delete pendingRequest.onHeadersReceived;
Kode lerroa:     }
Kode lerroa:     if (xhr.readyState !== 4) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!(xhrId in this.pendingRequests)) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     delete this.pendingRequests[xhrId];
Kode lerroa:     if (xhr.status === 0 && this.isHttp) {
Kode lerroa:       if (pendingRequest.onError) {
Kode lerroa:         pendingRequest.onError(xhr.status);
Kode lerroa:       }
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var xhrStatus = xhr.status || OK_RESPONSE;
Kode lerroa:     var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
Kode lerroa:     if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
Kode lerroa:       if (pendingRequest.onError) {
Kode lerroa:         pendingRequest.onError(xhr.status);
Kode lerroa:       }
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.loadedRequests[xhrId] = true;
Kode lerroa:     var chunk = getArrayBuffer(xhr);
Kode lerroa:     if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
Kode lerroa:       var rangeHeader = xhr.getResponseHeader('Content-Range');
Kode lerroa:       var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
Kode lerroa:       var begin = parseInt(matches[1], 10);
Kode lerroa:       pendingRequest.onDone({
Kode lerroa:         begin: begin,
Kode lerroa:         chunk: chunk
Kode lerroa:       });
Kode lerroa:     } else if (pendingRequest.onProgressiveData) {
Kode lerroa:       pendingRequest.onDone(null);
Kode lerroa:     } else if (chunk) {
Kode lerroa:       pendingRequest.onDone({
Kode lerroa:         begin: 0,
Kode lerroa:         chunk: chunk
Kode lerroa:       });
Kode lerroa:     } else if (pendingRequest.onError) {
Kode lerroa:       pendingRequest.onError(xhr.status);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   hasPendingRequests: function NetworkManager_hasPendingRequests() {
Kode lerroa:     for (var xhrId in this.pendingRequests) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     return false;
Kode lerroa:   },
Kode lerroa:   getRequestXhr: function NetworkManager_getXhr(xhrId) {
Kode lerroa:     return this.pendingRequests[xhrId].xhr;
Kode lerroa:   },
Kode lerroa:   isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {
Kode lerroa:     return !!this.pendingRequests[xhrId].onProgressiveData;
Kode lerroa:   },
Kode lerroa:   isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {
Kode lerroa:     return xhrId in this.pendingRequests;
Kode lerroa:   },
Kode lerroa:   isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {
Kode lerroa:     return xhrId in this.loadedRequests;
Kode lerroa:   },
Kode lerroa:   abortAllRequests: function NetworkManager_abortAllRequests() {
Kode lerroa:     for (var xhrId in this.pendingRequests) {
Kode lerroa:       this.abortRequest(xhrId | 0);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   abortRequest: function NetworkManager_abortRequest(xhrId) {
Kode lerroa:     var xhr = this.pendingRequests[xhrId].xhr;
Kode lerroa:     delete this.pendingRequests[xhrId];
Kode lerroa:     xhr.abort();
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function PDFNetworkStream(options) {
Kode lerroa:   this._options = options;
Kode lerroa:   var source = options.source;
Kode lerroa:   this._manager = new NetworkManager(source.url, {
Kode lerroa:     httpHeaders: source.httpHeaders,
Kode lerroa:     withCredentials: source.withCredentials
Kode lerroa:   });
Kode lerroa:   this._rangeChunkSize = source.rangeChunkSize;
Kode lerroa:   this._fullRequestReader = null;
Kode lerroa:   this._rangeRequestReaders = [];
Kode lerroa: }
Kode lerroa: PDFNetworkStream.prototype = {
Kode lerroa:   _onRangeRequestReaderClosed: function PDFNetworkStream_onRangeRequestReaderClosed(reader) {
Kode lerroa:     var i = this._rangeRequestReaders.indexOf(reader);
Kode lerroa:     if (i >= 0) {
Kode lerroa:       this._rangeRequestReaders.splice(i, 1);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   getFullReader: function PDFNetworkStream_getFullReader() {
Kode lerroa:     (0, _util.assert)(!this._fullRequestReader);
Kode lerroa:     this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._options);
Kode lerroa:     return this._fullRequestReader;
Kode lerroa:   },
Kode lerroa:   getRangeReader: function PDFNetworkStream_getRangeReader(begin, end) {
Kode lerroa:     var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
Kode lerroa:     reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
Kode lerroa:     this._rangeRequestReaders.push(reader);
Kode lerroa:     return reader;
Kode lerroa:   },
Kode lerroa:   cancelAllRequests: function PDFNetworkStream_cancelAllRequests(reason) {
Kode lerroa:     if (this._fullRequestReader) {
Kode lerroa:       this._fullRequestReader.cancel(reason);
Kode lerroa:     }
Kode lerroa:     var readers = this._rangeRequestReaders.slice(0);
Kode lerroa:     readers.forEach(function (reader) {
Kode lerroa:       reader.cancel(reason);
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function PDFNetworkStreamFullRequestReader(manager, options) {
Kode lerroa:   this._manager = manager;
Kode lerroa:   var source = options.source;
Kode lerroa:   var args = {
Kode lerroa:     onHeadersReceived: this._onHeadersReceived.bind(this),
Kode lerroa:     onProgressiveData: source.disableStream ? null : this._onProgressiveData.bind(this),
Kode lerroa:     onDone: this._onDone.bind(this),
Kode lerroa:     onError: this._onError.bind(this),
Kode lerroa:     onProgress: this._onProgress.bind(this)
Kode lerroa:   };
Kode lerroa:   this._url = source.url;
Kode lerroa:   this._fullRequestId = manager.requestFull(args);
Kode lerroa:   this._headersReceivedCapability = (0, _util.createPromiseCapability)();
Kode lerroa:   this._disableRange = options.disableRange || false;
Kode lerroa:   this._contentLength = source.length;
Kode lerroa:   this._rangeChunkSize = source.rangeChunkSize;
Kode lerroa:   if (!this._rangeChunkSize && !this._disableRange) {
Kode lerroa:     this._disableRange = true;
Kode lerroa:   }
Kode lerroa:   this._isStreamingSupported = false;
Kode lerroa:   this._isRangeSupported = false;
Kode lerroa:   this._cachedChunks = [];
Kode lerroa:   this._requests = [];
Kode lerroa:   this._done = false;
Kode lerroa:   this._storedError = undefined;
Kode lerroa:   this.onProgress = null;
Kode lerroa: }
Kode lerroa: PDFNetworkStreamFullRequestReader.prototype = {
Kode lerroa:   _onHeadersReceived: function PDFNetworkStreamFullRequestReader_onHeadersReceived() {
Kode lerroa:     var fullRequestXhrId = this._fullRequestId;
Kode lerroa:     var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
Kode lerroa: 
Kode lerroa:     var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
Kode lerroa:       getResponseHeader: function getResponseHeader(name) {
Kode lerroa:         return fullRequestXhr.getResponseHeader(name);
Kode lerroa:       },
Kode lerroa:       isHttp: this._manager.isHttp,
Kode lerroa:       rangeChunkSize: this._rangeChunkSize,
Kode lerroa:       disableRange: this._disableRange
Kode lerroa:     }),
Kode lerroa:         allowRangeRequests = _validateRangeRequest.allowRangeRequests,
Kode lerroa:         suggestedLength = _validateRangeRequest.suggestedLength;
Kode lerroa: 
Kode lerroa:     this._contentLength = suggestedLength || this._contentLength;
Kode lerroa:     if (allowRangeRequests) {
Kode lerroa:       this._isRangeSupported = true;
Kode lerroa:     }
Kode lerroa:     var networkManager = this._manager;
Kode lerroa:     if (networkManager.isStreamingRequest(fullRequestXhrId)) {
Kode lerroa:       this._isStreamingSupported = true;
Kode lerroa:     } else if (this._isRangeSupported) {
Kode lerroa:       networkManager.abortRequest(fullRequestXhrId);
Kode lerroa:     }
Kode lerroa:     this._headersReceivedCapability.resolve();
Kode lerroa:   },
Kode lerroa:   _onProgressiveData: function PDFNetworkStreamFullRequestReader_onProgressiveData(chunk) {
Kode lerroa:     if (this._requests.length > 0) {
Kode lerroa:       var requestCapability = this._requests.shift();
Kode lerroa:       requestCapability.resolve({
Kode lerroa:         value: chunk,
Kode lerroa:         done: false
Kode lerroa:       });
Kode lerroa:     } else {
Kode lerroa:       this._cachedChunks.push(chunk);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   _onDone: function PDFNetworkStreamFullRequestReader_onDone(args) {
Kode lerroa:     if (args) {
Kode lerroa:       this._onProgressiveData(args.chunk);
Kode lerroa:     }
Kode lerroa:     this._done = true;
Kode lerroa:     if (this._cachedChunks.length > 0) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this._requests.forEach(function (requestCapability) {
Kode lerroa:       requestCapability.resolve({
Kode lerroa:         value: undefined,
Kode lerroa:         done: true
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     this._requests = [];
Kode lerroa:   },
Kode lerroa:   _onError: function PDFNetworkStreamFullRequestReader_onError(status) {
Kode lerroa:     var url = this._url;
Kode lerroa:     var exception = (0, _network_utils.createResponseStatusError)(status, url);
Kode lerroa:     this._storedError = exception;
Kode lerroa:     this._headersReceivedCapability.reject(exception);
Kode lerroa:     this._requests.forEach(function (requestCapability) {
Kode lerroa:       requestCapability.reject(exception);
Kode lerroa:     });
Kode lerroa:     this._requests = [];
Kode lerroa:     this._cachedChunks = [];
Kode lerroa:   },
Kode lerroa:   _onProgress: function PDFNetworkStreamFullRequestReader_onProgress(data) {
Kode lerroa:     if (this.onProgress) {
Kode lerroa:       this.onProgress({
Kode lerroa:         loaded: data.loaded,
Kode lerroa:         total: data.lengthComputable ? data.total : this._contentLength
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   get isRangeSupported() {
Kode lerroa:     return this._isRangeSupported;
Kode lerroa:   },
Kode lerroa:   get isStreamingSupported() {
Kode lerroa:     return this._isStreamingSupported;
Kode lerroa:   },
Kode lerroa:   get contentLength() {
Kode lerroa:     return this._contentLength;
Kode lerroa:   },
Kode lerroa:   get headersReady() {
Kode lerroa:     return this._headersReceivedCapability.promise;
Kode lerroa:   },
Kode lerroa:   read: function PDFNetworkStreamFullRequestReader_read() {
Kode lerroa:     if (this._storedError) {
Kode lerroa:       return Promise.reject(this._storedError);
Kode lerroa:     }
Kode lerroa:     if (this._cachedChunks.length > 0) {
Kode lerroa:       var chunk = this._cachedChunks.shift();
Kode lerroa:       return Promise.resolve({
Kode lerroa:         value: chunk,
Kode lerroa:         done: false
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     if (this._done) {
Kode lerroa:       return Promise.resolve({
Kode lerroa:         value: undefined,
Kode lerroa:         done: true
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     var requestCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._requests.push(requestCapability);
Kode lerroa:     return requestCapability.promise;
Kode lerroa:   },
Kode lerroa:   cancel: function PDFNetworkStreamFullRequestReader_cancel(reason) {
Kode lerroa:     this._done = true;
Kode lerroa:     this._headersReceivedCapability.reject(reason);
Kode lerroa:     this._requests.forEach(function (requestCapability) {
Kode lerroa:       requestCapability.resolve({
Kode lerroa:         value: undefined,
Kode lerroa:         done: true
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     this._requests = [];
Kode lerroa:     if (this._manager.isPendingRequest(this._fullRequestId)) {
Kode lerroa:       this._manager.abortRequest(this._fullRequestId);
Kode lerroa:     }
Kode lerroa:     this._fullRequestReader = null;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
Kode lerroa:   this._manager = manager;
Kode lerroa:   var args = {
Kode lerroa:     onDone: this._onDone.bind(this),
Kode lerroa:     onProgress: this._onProgress.bind(this)
Kode lerroa:   };
Kode lerroa:   this._requestId = manager.requestRange(begin, end, args);
Kode lerroa:   this._requests = [];
Kode lerroa:   this._queuedChunk = null;
Kode lerroa:   this._done = false;
Kode lerroa:   this.onProgress = null;
Kode lerroa:   this.onClosed = null;
Kode lerroa: }
Kode lerroa: PDFNetworkStreamRangeRequestReader.prototype = {
Kode lerroa:   _close: function PDFNetworkStreamRangeRequestReader_close() {
Kode lerroa:     if (this.onClosed) {
Kode lerroa:       this.onClosed(this);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   _onDone: function PDFNetworkStreamRangeRequestReader_onDone(data) {
Kode lerroa:     var chunk = data.chunk;
Kode lerroa:     if (this._requests.length > 0) {
Kode lerroa:       var requestCapability = this._requests.shift();
Kode lerroa:       requestCapability.resolve({
Kode lerroa:         value: chunk,
Kode lerroa:         done: false
Kode lerroa:       });
Kode lerroa:     } else {
Kode lerroa:       this._queuedChunk = chunk;
Kode lerroa:     }
Kode lerroa:     this._done = true;
Kode lerroa:     this._requests.forEach(function (requestCapability) {
Kode lerroa:       requestCapability.resolve({
Kode lerroa:         value: undefined,
Kode lerroa:         done: true
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     this._requests = [];
Kode lerroa:     this._close();
Kode lerroa:   },
Kode lerroa:   _onProgress: function PDFNetworkStreamRangeRequestReader_onProgress(evt) {
Kode lerroa:     if (!this.isStreamingSupported && this.onProgress) {
Kode lerroa:       this.onProgress({ loaded: evt.loaded });
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   get isStreamingSupported() {
Kode lerroa:     return false;
Kode lerroa:   },
Kode lerroa:   read: function PDFNetworkStreamRangeRequestReader_read() {
Kode lerroa:     if (this._queuedChunk !== null) {
Kode lerroa:       var chunk = this._queuedChunk;
Kode lerroa:       this._queuedChunk = null;
Kode lerroa:       return Promise.resolve({
Kode lerroa:         value: chunk,
Kode lerroa:         done: false
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     if (this._done) {
Kode lerroa:       return Promise.resolve({
Kode lerroa:         value: undefined,
Kode lerroa:         done: true
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     var requestCapability = (0, _util.createPromiseCapability)();
Kode lerroa:     this._requests.push(requestCapability);
Kode lerroa:     return requestCapability.promise;
Kode lerroa:   },
Kode lerroa:   cancel: function PDFNetworkStreamRangeRequestReader_cancel(reason) {
Kode lerroa:     this._done = true;
Kode lerroa:     this._requests.forEach(function (requestCapability) {
Kode lerroa:       requestCapability.resolve({
Kode lerroa:         value: undefined,
Kode lerroa:         done: true
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     this._requests = [];
Kode lerroa:     if (this._manager.isPendingRequest(this._requestId)) {
Kode lerroa:       this._manager.abortRequest(this._requestId);
Kode lerroa:     }
Kode lerroa:     this._close();
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: exports.PDFNetworkStream = PDFNetworkStream;
Kode lerroa: exports.NetworkManager = NetworkManager;
Kode lerroa: 
Kode lerroa: /***/ })
Kode lerroa: /******/ ]);
Kode lerroa: });
Kode lerroa: //# sourceMappingURL=pdf.js.map
Kode lerroa: /* Copyright 2017 Mozilla Foundation
Kode lerroa:  *
Kode lerroa:  * Licensed under the Apache License, Version 2.0 (the "License");
Kode lerroa:  * you may not use this file except in compliance with the License.
Kode lerroa:  * You may obtain a copy of the License at
Kode lerroa:  *
Kode lerroa:  *     http://www.apache.org/licenses/LICENSE-2.0
Kode lerroa:  *
Kode lerroa:  * Unless required by applicable law or agreed to in writing, software
Kode lerroa:  * distributed under the License is distributed on an "AS IS" BASIS,
Kode lerroa:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
Kode lerroa:  * See the License for the specific language governing permissions and
Kode lerroa:  * limitations under the License.
Kode lerroa:  */
Kode lerroa: 
Kode lerroa: (function webpackUniversalModuleDefinition(root, factory) {
Kode lerroa: 	if(typeof exports === 'object' && typeof module === 'object')
Kode lerroa: 		module.exports = factory();
Kode lerroa: 	else if(typeof define === 'function' && define.amd)
Kode lerroa: 		define("pdfjs-dist/build/pdf.worker", [], factory);
Kode lerroa: 	else if(typeof exports === 'object')
Kode lerroa: 		exports["pdfjs-dist/build/pdf.worker"] = factory();
Kode lerroa: 	else
Kode lerroa: 		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsDistBuildPdfWorker = factory();
Kode lerroa: })(typeof self !== 'undefined' ? self : this, function() {
Kode lerroa: return /******/ (function(modules) { // webpackBootstrap
Kode lerroa: /******/ 	// The module cache
Kode lerroa: /******/ 	var installedModules = {};
Kode lerroa: /******/
Kode lerroa: /******/ 	// The require function
Kode lerroa: /******/ 	function __w_pdfjs_require__(moduleId) {
Kode lerroa: /******/
Kode lerroa: /******/ 		// Check if module is in cache
Kode lerroa: /******/ 		if(installedModules[moduleId]) {
Kode lerroa: /******/ 			return installedModules[moduleId].exports;
Kode lerroa: /******/ 		}
Kode lerroa: /******/ 		// Create a new module (and put it into the cache)
Kode lerroa: /******/ 		var module = installedModules[moduleId] = {
Kode lerroa: /******/ 			i: moduleId,
Kode lerroa: /******/ 			l: false,
Kode lerroa: /******/ 			exports: {}
Kode lerroa: /******/ 		};
Kode lerroa: /******/
Kode lerroa: /******/ 		// Execute the module function
Kode lerroa: /******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
Kode lerroa: /******/
Kode lerroa: /******/ 		// Flag the module as loaded
Kode lerroa: /******/ 		module.l = true;
Kode lerroa: /******/
Kode lerroa: /******/ 		// Return the exports of the module
Kode lerroa: /******/ 		return module.exports;
Kode lerroa: /******/ 	}
Kode lerroa: /******/
Kode lerroa: /******/
Kode lerroa: /******/ 	// expose the modules object (__webpack_modules__)
Kode lerroa: /******/ 	__w_pdfjs_require__.m = modules;
Kode lerroa: /******/
Kode lerroa: /******/ 	// expose the module cache
Kode lerroa: /******/ 	__w_pdfjs_require__.c = installedModules;
Kode lerroa: /******/
Kode lerroa: /******/ 	// define getter function for harmony exports
Kode lerroa: /******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
Kode lerroa: /******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
Kode lerroa: /******/ 			Object.defineProperty(exports, name, {
Kode lerroa: /******/ 				configurable: false,
Kode lerroa: /******/ 				enumerable: true,
Kode lerroa: /******/ 				get: getter
Kode lerroa: /******/ 			});
Kode lerroa: /******/ 		}
Kode lerroa: /******/ 	};
Kode lerroa: /******/
Kode lerroa: /******/ 	// getDefaultExport function for compatibility with non-harmony modules
Kode lerroa: /******/ 	__w_pdfjs_require__.n = function(module) {
Kode lerroa: /******/ 		var getter = module && module.__esModule ?
Kode lerroa: /******/ 			function getDefault() { return module['default']; } :
Kode lerroa: /******/ 			function getModuleExports() { return module; };
Kode lerroa: /******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
Kode lerroa: /******/ 		return getter;
Kode lerroa: /******/ 	};
Kode lerroa: /******/
Kode lerroa: /******/ 	// Object.prototype.hasOwnProperty.call
Kode lerroa: /******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
Kode lerroa: /******/
Kode lerroa: /******/ 	// __webpack_public_path__
Kode lerroa: /******/ 	__w_pdfjs_require__.p = "";
Kode lerroa: /******/
Kode lerroa: /******/ 	// Load entry module and return exports
Kode lerroa: /******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 82);
Kode lerroa: /******/ })
Kode lerroa: /************************************************************************/
Kode lerroa: /******/ ([
Kode lerroa: /* 0 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.unreachable = exports.warn = exports.utf8StringToString = exports.stringToUTF8String = exports.stringToPDFString = exports.stringToBytes = exports.string32 = exports.shadow = exports.setVerbosityLevel = exports.ReadableStream = exports.removeNullCharacters = exports.readUint32 = exports.readUint16 = exports.readInt8 = exports.log2 = exports.loadJpegStream = exports.isEvalSupported = exports.isLittleEndian = exports.createValidAbsoluteUrl = exports.isSameOrigin = exports.isNodeJS = exports.isSpace = exports.isString = exports.isNum = exports.isEmptyObj = exports.isBool = exports.isArrayBuffer = exports.info = exports.getVerbosityLevel = exports.getLookupTableFactory = exports.deprecated = exports.createObjectURL = exports.createPromiseCapability = exports.createBlob = exports.bytesToString = exports.assert = exports.arraysToBytes = exports.arrayByteLength = exports.FormatError = exports.XRefParseException = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.StatTimer = exports.PasswordResponses = exports.PasswordException = exports.PageViewport = exports.NotImplementedException = exports.NativeImageDecoding = exports.MissingPDFException = exports.MissingDataException = exports.MessageHandler = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VERBOSITY_LEVELS = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: __w_pdfjs_require__(84);
Kode lerroa: 
Kode lerroa: var _streams_polyfill = __w_pdfjs_require__(125);
Kode lerroa: 
Kode lerroa: var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
Kode lerroa: var NativeImageDecoding = {
Kode lerroa:   NONE: 'none',
Kode lerroa:   DECODE: 'decode',
Kode lerroa:   DISPLAY: 'display'
Kode lerroa: };
Kode lerroa: var TextRenderingMode = {
Kode lerroa:   FILL: 0,
Kode lerroa:   STROKE: 1,
Kode lerroa:   FILL_STROKE: 2,
Kode lerroa:   INVISIBLE: 3,
Kode lerroa:   FILL_ADD_TO_PATH: 4,
Kode lerroa:   STROKE_ADD_TO_PATH: 5,
Kode lerroa:   FILL_STROKE_ADD_TO_PATH: 6,
Kode lerroa:   ADD_TO_PATH: 7,
Kode lerroa:   FILL_STROKE_MASK: 3,
Kode lerroa:   ADD_TO_PATH_FLAG: 4
Kode lerroa: };
Kode lerroa: var ImageKind = {
Kode lerroa:   GRAYSCALE_1BPP: 1,
Kode lerroa:   RGB_24BPP: 2,
Kode lerroa:   RGBA_32BPP: 3
Kode lerroa: };
Kode lerroa: var AnnotationType = {
Kode lerroa:   TEXT: 1,
Kode lerroa:   LINK: 2,
Kode lerroa:   FREETEXT: 3,
Kode lerroa:   LINE: 4,
Kode lerroa:   SQUARE: 5,
Kode lerroa:   CIRCLE: 6,
Kode lerroa:   POLYGON: 7,
Kode lerroa:   POLYLINE: 8,
Kode lerroa:   HIGHLIGHT: 9,
Kode lerroa:   UNDERLINE: 10,
Kode lerroa:   SQUIGGLY: 11,
Kode lerroa:   STRIKEOUT: 12,
Kode lerroa:   STAMP: 13,
Kode lerroa:   CARET: 14,
Kode lerroa:   INK: 15,
Kode lerroa:   POPUP: 16,
Kode lerroa:   FILEATTACHMENT: 17,
Kode lerroa:   SOUND: 18,
Kode lerroa:   MOVIE: 19,
Kode lerroa:   WIDGET: 20,
Kode lerroa:   SCREEN: 21,
Kode lerroa:   PRINTERMARK: 22,
Kode lerroa:   TRAPNET: 23,
Kode lerroa:   WATERMARK: 24,
Kode lerroa:   THREED: 25,
Kode lerroa:   REDACT: 26
Kode lerroa: };
Kode lerroa: var AnnotationFlag = {
Kode lerroa:   INVISIBLE: 0x01,
Kode lerroa:   HIDDEN: 0x02,
Kode lerroa:   PRINT: 0x04,
Kode lerroa:   NOZOOM: 0x08,
Kode lerroa:   NOROTATE: 0x10,
Kode lerroa:   NOVIEW: 0x20,
Kode lerroa:   READONLY: 0x40,
Kode lerroa:   LOCKED: 0x80,
Kode lerroa:   TOGGLENOVIEW: 0x100,
Kode lerroa:   LOCKEDCONTENTS: 0x200
Kode lerroa: };
Kode lerroa: var AnnotationFieldFlag = {
Kode lerroa:   READONLY: 0x0000001,
Kode lerroa:   REQUIRED: 0x0000002,
Kode lerroa:   NOEXPORT: 0x0000004,
Kode lerroa:   MULTILINE: 0x0001000,
Kode lerroa:   PASSWORD: 0x0002000,
Kode lerroa:   NOTOGGLETOOFF: 0x0004000,
Kode lerroa:   RADIO: 0x0008000,
Kode lerroa:   PUSHBUTTON: 0x0010000,
Kode lerroa:   COMBO: 0x0020000,
Kode lerroa:   EDIT: 0x0040000,
Kode lerroa:   SORT: 0x0080000,
Kode lerroa:   FILESELECT: 0x0100000,
Kode lerroa:   MULTISELECT: 0x0200000,
Kode lerroa:   DONOTSPELLCHECK: 0x0400000,
Kode lerroa:   DONOTSCROLL: 0x0800000,
Kode lerroa:   COMB: 0x1000000,
Kode lerroa:   RICHTEXT: 0x2000000,
Kode lerroa:   RADIOSINUNISON: 0x2000000,
Kode lerroa:   COMMITONSELCHANGE: 0x4000000
Kode lerroa: };
Kode lerroa: var AnnotationBorderStyleType = {
Kode lerroa:   SOLID: 1,
Kode lerroa:   DASHED: 2,
Kode lerroa:   BEVELED: 3,
Kode lerroa:   INSET: 4,
Kode lerroa:   UNDERLINE: 5
Kode lerroa: };
Kode lerroa: var StreamType = {
Kode lerroa:   UNKNOWN: 0,
Kode lerroa:   FLATE: 1,
Kode lerroa:   LZW: 2,
Kode lerroa:   DCT: 3,
Kode lerroa:   JPX: 4,
Kode lerroa:   JBIG: 5,
Kode lerroa:   A85: 6,
Kode lerroa:   AHX: 7,
Kode lerroa:   CCF: 8,
Kode lerroa:   RL: 9
Kode lerroa: };
Kode lerroa: var FontType = {
Kode lerroa:   UNKNOWN: 0,
Kode lerroa:   TYPE1: 1,
Kode lerroa:   TYPE1C: 2,
Kode lerroa:   CIDFONTTYPE0: 3,
Kode lerroa:   CIDFONTTYPE0C: 4,
Kode lerroa:   TRUETYPE: 5,
Kode lerroa:   CIDFONTTYPE2: 6,
Kode lerroa:   TYPE3: 7,
Kode lerroa:   OPENTYPE: 8,
Kode lerroa:   TYPE0: 9,
Kode lerroa:   MMTYPE1: 10
Kode lerroa: };
Kode lerroa: var VERBOSITY_LEVELS = {
Kode lerroa:   errors: 0,
Kode lerroa:   warnings: 1,
Kode lerroa:   infos: 5
Kode lerroa: };
Kode lerroa: var CMapCompressionType = {
Kode lerroa:   NONE: 0,
Kode lerroa:   BINARY: 1,
Kode lerroa:   STREAM: 2
Kode lerroa: };
Kode lerroa: var OPS = {
Kode lerroa:   dependency: 1,
Kode lerroa:   setLineWidth: 2,
Kode lerroa:   setLineCap: 3,
Kode lerroa:   setLineJoin: 4,
Kode lerroa:   setMiterLimit: 5,
Kode lerroa:   setDash: 6,
Kode lerroa:   setRenderingIntent: 7,
Kode lerroa:   setFlatness: 8,
Kode lerroa:   setGState: 9,
Kode lerroa:   save: 10,
Kode lerroa:   restore: 11,
Kode lerroa:   transform: 12,
Kode lerroa:   moveTo: 13,
Kode lerroa:   lineTo: 14,
Kode lerroa:   curveTo: 15,
Kode lerroa:   curveTo2: 16,
Kode lerroa:   curveTo3: 17,
Kode lerroa:   closePath: 18,
Kode lerroa:   rectangle: 19,
Kode lerroa:   stroke: 20,
Kode lerroa:   closeStroke: 21,
Kode lerroa:   fill: 22,
Kode lerroa:   eoFill: 23,
Kode lerroa:   fillStroke: 24,
Kode lerroa:   eoFillStroke: 25,
Kode lerroa:   closeFillStroke: 26,
Kode lerroa:   closeEOFillStroke: 27,
Kode lerroa:   endPath: 28,
Kode lerroa:   clip: 29,
Kode lerroa:   eoClip: 30,
Kode lerroa:   beginText: 31,
Kode lerroa:   endText: 32,
Kode lerroa:   setCharSpacing: 33,
Kode lerroa:   setWordSpacing: 34,
Kode lerroa:   setHScale: 35,
Kode lerroa:   setLeading: 36,
Kode lerroa:   setFont: 37,
Kode lerroa:   setTextRenderingMode: 38,
Kode lerroa:   setTextRise: 39,
Kode lerroa:   moveText: 40,
Kode lerroa:   setLeadingMoveText: 41,
Kode lerroa:   setTextMatrix: 42,
Kode lerroa:   nextLine: 43,
Kode lerroa:   showText: 44,
Kode lerroa:   showSpacedText: 45,
Kode lerroa:   nextLineShowText: 46,
Kode lerroa:   nextLineSetSpacingShowText: 47,
Kode lerroa:   setCharWidth: 48,
Kode lerroa:   setCharWidthAndBounds: 49,
Kode lerroa:   setStrokeColorSpace: 50,
Kode lerroa:   setFillColorSpace: 51,
Kode lerroa:   setStrokeColor: 52,
Kode lerroa:   setStrokeColorN: 53,
Kode lerroa:   setFillColor: 54,
Kode lerroa:   setFillColorN: 55,
Kode lerroa:   setStrokeGray: 56,
Kode lerroa:   setFillGray: 57,
Kode lerroa:   setStrokeRGBColor: 58,
Kode lerroa:   setFillRGBColor: 59,
Kode lerroa:   setStrokeCMYKColor: 60,
Kode lerroa:   setFillCMYKColor: 61,
Kode lerroa:   shadingFill: 62,
Kode lerroa:   beginInlineImage: 63,
Kode lerroa:   beginImageData: 64,
Kode lerroa:   endInlineImage: 65,
Kode lerroa:   paintXObject: 66,
Kode lerroa:   markPoint: 67,
Kode lerroa:   markPointProps: 68,
Kode lerroa:   beginMarkedContent: 69,
Kode lerroa:   beginMarkedContentProps: 70,
Kode lerroa:   endMarkedContent: 71,
Kode lerroa:   beginCompat: 72,
Kode lerroa:   endCompat: 73,
Kode lerroa:   paintFormXObjectBegin: 74,
Kode lerroa:   paintFormXObjectEnd: 75,
Kode lerroa:   beginGroup: 76,
Kode lerroa:   endGroup: 77,
Kode lerroa:   beginAnnotations: 78,
Kode lerroa:   endAnnotations: 79,
Kode lerroa:   beginAnnotation: 80,
Kode lerroa:   endAnnotation: 81,
Kode lerroa:   paintJpegXObject: 82,
Kode lerroa:   paintImageMaskXObject: 83,
Kode lerroa:   paintImageMaskXObjectGroup: 84,
Kode lerroa:   paintImageXObject: 85,
Kode lerroa:   paintInlineImageXObject: 86,
Kode lerroa:   paintInlineImageXObjectGroup: 87,
Kode lerroa:   paintImageXObjectRepeat: 88,
Kode lerroa:   paintImageMaskXObjectRepeat: 89,
Kode lerroa:   paintSolidColorImageMask: 90,
Kode lerroa:   constructPath: 91
Kode lerroa: };
Kode lerroa: var verbosity = VERBOSITY_LEVELS.warnings;
Kode lerroa: function setVerbosityLevel(level) {
Kode lerroa:   verbosity = level;
Kode lerroa: }
Kode lerroa: function getVerbosityLevel() {
Kode lerroa:   return verbosity;
Kode lerroa: }
Kode lerroa: function info(msg) {
Kode lerroa:   if (verbosity >= VERBOSITY_LEVELS.infos) {
Kode lerroa:     console.log('Info: ' + msg);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function warn(msg) {
Kode lerroa:   if (verbosity >= VERBOSITY_LEVELS.warnings) {
Kode lerroa:     console.log('Warning: ' + msg);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function deprecated(details) {
Kode lerroa:   console.log('Deprecated API usage: ' + details);
Kode lerroa: }
Kode lerroa: function unreachable(msg) {
Kode lerroa:   throw new Error(msg);
Kode lerroa: }
Kode lerroa: function assert(cond, msg) {
Kode lerroa:   if (!cond) {
Kode lerroa:     unreachable(msg);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var UNSUPPORTED_FEATURES = {
Kode lerroa:   unknown: 'unknown',
Kode lerroa:   forms: 'forms',
Kode lerroa:   javaScript: 'javaScript',
Kode lerroa:   smask: 'smask',
Kode lerroa:   shadingPattern: 'shadingPattern',
Kode lerroa:   font: 'font'
Kode lerroa: };
Kode lerroa: function isSameOrigin(baseUrl, otherUrl) {
Kode lerroa:   try {
Kode lerroa:     var base = new URL(baseUrl);
Kode lerroa:     if (!base.origin || base.origin === 'null') {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   } catch (e) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   var other = new URL(otherUrl, base);
Kode lerroa:   return base.origin === other.origin;
Kode lerroa: }
Kode lerroa: function isValidProtocol(url) {
Kode lerroa:   if (!url) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   switch (url.protocol) {
Kode lerroa:     case 'http:':
Kode lerroa:     case 'https:':
Kode lerroa:     case 'ftp:':
Kode lerroa:     case 'mailto:':
Kode lerroa:     case 'tel:':
Kode lerroa:       return true;
Kode lerroa:     default:
Kode lerroa:       return false;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function createValidAbsoluteUrl(url, baseUrl) {
Kode lerroa:   if (!url) {
Kode lerroa:     return null;
Kode lerroa:   }
Kode lerroa:   try {
Kode lerroa:     var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
Kode lerroa:     if (isValidProtocol(absoluteUrl)) {
Kode lerroa:       return absoluteUrl;
Kode lerroa:     }
Kode lerroa:   } catch (ex) {}
Kode lerroa:   return null;
Kode lerroa: }
Kode lerroa: function shadow(obj, prop, value) {
Kode lerroa:   Object.defineProperty(obj, prop, {
Kode lerroa:     value: value,
Kode lerroa:     enumerable: true,
Kode lerroa:     configurable: true,
Kode lerroa:     writable: false
Kode lerroa:   });
Kode lerroa:   return value;
Kode lerroa: }
Kode lerroa: function getLookupTableFactory(initializer) {
Kode lerroa:   var lookup;
Kode lerroa:   return function () {
Kode lerroa:     if (initializer) {
Kode lerroa:       lookup = Object.create(null);
Kode lerroa:       initializer(lookup);
Kode lerroa:       initializer = null;
Kode lerroa:     }
Kode lerroa:     return lookup;
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: var PasswordResponses = {
Kode lerroa:   NEED_PASSWORD: 1,
Kode lerroa:   INCORRECT_PASSWORD: 2
Kode lerroa: };
Kode lerroa: var PasswordException = function PasswordExceptionClosure() {
Kode lerroa:   function PasswordException(msg, code) {
Kode lerroa:     this.name = 'PasswordException';
Kode lerroa:     this.message = msg;
Kode lerroa:     this.code = code;
Kode lerroa:   }
Kode lerroa:   PasswordException.prototype = new Error();
Kode lerroa:   PasswordException.constructor = PasswordException;
Kode lerroa:   return PasswordException;
Kode lerroa: }();
Kode lerroa: var UnknownErrorException = function UnknownErrorExceptionClosure() {
Kode lerroa:   function UnknownErrorException(msg, details) {
Kode lerroa:     this.name = 'UnknownErrorException';
Kode lerroa:     this.message = msg;
Kode lerroa:     this.details = details;
Kode lerroa:   }
Kode lerroa:   UnknownErrorException.prototype = new Error();
Kode lerroa:   UnknownErrorException.constructor = UnknownErrorException;
Kode lerroa:   return UnknownErrorException;
Kode lerroa: }();
Kode lerroa: var InvalidPDFException = function InvalidPDFExceptionClosure() {
Kode lerroa:   function InvalidPDFException(msg) {
Kode lerroa:     this.name = 'InvalidPDFException';
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   InvalidPDFException.prototype = new Error();
Kode lerroa:   InvalidPDFException.constructor = InvalidPDFException;
Kode lerroa:   return InvalidPDFException;
Kode lerroa: }();
Kode lerroa: var MissingPDFException = function MissingPDFExceptionClosure() {
Kode lerroa:   function MissingPDFException(msg) {
Kode lerroa:     this.name = 'MissingPDFException';
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   MissingPDFException.prototype = new Error();
Kode lerroa:   MissingPDFException.constructor = MissingPDFException;
Kode lerroa:   return MissingPDFException;
Kode lerroa: }();
Kode lerroa: var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
Kode lerroa:   function UnexpectedResponseException(msg, status) {
Kode lerroa:     this.name = 'UnexpectedResponseException';
Kode lerroa:     this.message = msg;
Kode lerroa:     this.status = status;
Kode lerroa:   }
Kode lerroa:   UnexpectedResponseException.prototype = new Error();
Kode lerroa:   UnexpectedResponseException.constructor = UnexpectedResponseException;
Kode lerroa:   return UnexpectedResponseException;
Kode lerroa: }();
Kode lerroa: var NotImplementedException = function NotImplementedExceptionClosure() {
Kode lerroa:   function NotImplementedException(msg) {
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   NotImplementedException.prototype = new Error();
Kode lerroa:   NotImplementedException.prototype.name = 'NotImplementedException';
Kode lerroa:   NotImplementedException.constructor = NotImplementedException;
Kode lerroa:   return NotImplementedException;
Kode lerroa: }();
Kode lerroa: var MissingDataException = function MissingDataExceptionClosure() {
Kode lerroa:   function MissingDataException(begin, end) {
Kode lerroa:     this.begin = begin;
Kode lerroa:     this.end = end;
Kode lerroa:     this.message = 'Missing data [' + begin + ', ' + end + ')';
Kode lerroa:   }
Kode lerroa:   MissingDataException.prototype = new Error();
Kode lerroa:   MissingDataException.prototype.name = 'MissingDataException';
Kode lerroa:   MissingDataException.constructor = MissingDataException;
Kode lerroa:   return MissingDataException;
Kode lerroa: }();
Kode lerroa: var XRefParseException = function XRefParseExceptionClosure() {
Kode lerroa:   function XRefParseException(msg) {
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   XRefParseException.prototype = new Error();
Kode lerroa:   XRefParseException.prototype.name = 'XRefParseException';
Kode lerroa:   XRefParseException.constructor = XRefParseException;
Kode lerroa:   return XRefParseException;
Kode lerroa: }();
Kode lerroa: var FormatError = function FormatErrorClosure() {
Kode lerroa:   function FormatError(msg) {
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   FormatError.prototype = new Error();
Kode lerroa:   FormatError.prototype.name = 'FormatError';
Kode lerroa:   FormatError.constructor = FormatError;
Kode lerroa:   return FormatError;
Kode lerroa: }();
Kode lerroa: var AbortException = function AbortExceptionClosure() {
Kode lerroa:   function AbortException(msg) {
Kode lerroa:     this.name = 'AbortException';
Kode lerroa:     this.message = msg;
Kode lerroa:   }
Kode lerroa:   AbortException.prototype = new Error();
Kode lerroa:   AbortException.constructor = AbortException;
Kode lerroa:   return AbortException;
Kode lerroa: }();
Kode lerroa: var NullCharactersRegExp = /\x00/g;
Kode lerroa: function removeNullCharacters(str) {
Kode lerroa:   if (typeof str !== 'string') {
Kode lerroa:     warn('The argument for removeNullCharacters must be a string.');
Kode lerroa:     return str;
Kode lerroa:   }
Kode lerroa:   return str.replace(NullCharactersRegExp, '');
Kode lerroa: }
Kode lerroa: function bytesToString(bytes) {
Kode lerroa:   assert(bytes !== null && (typeof bytes === 'undefined' ? 'undefined' : _typeof(bytes)) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
Kode lerroa:   var length = bytes.length;
Kode lerroa:   var MAX_ARGUMENT_COUNT = 8192;
Kode lerroa:   if (length < MAX_ARGUMENT_COUNT) {
Kode lerroa:     return String.fromCharCode.apply(null, bytes);
Kode lerroa:   }
Kode lerroa:   var strBuf = [];
Kode lerroa:   for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
Kode lerroa:     var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
Kode lerroa:     var chunk = bytes.subarray(i, chunkEnd);
Kode lerroa:     strBuf.push(String.fromCharCode.apply(null, chunk));
Kode lerroa:   }
Kode lerroa:   return strBuf.join('');
Kode lerroa: }
Kode lerroa: function stringToBytes(str) {
Kode lerroa:   assert(typeof str === 'string', 'Invalid argument for stringToBytes');
Kode lerroa:   var length = str.length;
Kode lerroa:   var bytes = new Uint8Array(length);
Kode lerroa:   for (var i = 0; i < length; ++i) {
Kode lerroa:     bytes[i] = str.charCodeAt(i) & 0xFF;
Kode lerroa:   }
Kode lerroa:   return bytes;
Kode lerroa: }
Kode lerroa: function arrayByteLength(arr) {
Kode lerroa:   if (arr.length !== undefined) {
Kode lerroa:     return arr.length;
Kode lerroa:   }
Kode lerroa:   assert(arr.byteLength !== undefined);
Kode lerroa:   return arr.byteLength;
Kode lerroa: }
Kode lerroa: function arraysToBytes(arr) {
Kode lerroa:   if (arr.length === 1 && arr[0] instanceof Uint8Array) {
Kode lerroa:     return arr[0];
Kode lerroa:   }
Kode lerroa:   var resultLength = 0;
Kode lerroa:   var i,
Kode lerroa:       ii = arr.length;
Kode lerroa:   var item, itemLength;
Kode lerroa:   for (i = 0; i < ii; i++) {
Kode lerroa:     item = arr[i];
Kode lerroa:     itemLength = arrayByteLength(item);
Kode lerroa:     resultLength += itemLength;
Kode lerroa:   }
Kode lerroa:   var pos = 0;
Kode lerroa:   var data = new Uint8Array(resultLength);
Kode lerroa:   for (i = 0; i < ii; i++) {
Kode lerroa:     item = arr[i];
Kode lerroa:     if (!(item instanceof Uint8Array)) {
Kode lerroa:       if (typeof item === 'string') {
Kode lerroa:         item = stringToBytes(item);
Kode lerroa:       } else {
Kode lerroa:         item = new Uint8Array(item);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     itemLength = item.byteLength;
Kode lerroa:     data.set(item, pos);
Kode lerroa:     pos += itemLength;
Kode lerroa:   }
Kode lerroa:   return data;
Kode lerroa: }
Kode lerroa: function string32(value) {
Kode lerroa:   return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
Kode lerroa: }
Kode lerroa: function log2(x) {
Kode lerroa:   var n = 1,
Kode lerroa:       i = 0;
Kode lerroa:   while (x > n) {
Kode lerroa:     n <<= 1;
Kode lerroa:     i++;
Kode lerroa:   }
Kode lerroa:   return i;
Kode lerroa: }
Kode lerroa: function readInt8(data, start) {
Kode lerroa:   return data[start] << 24 >> 24;
Kode lerroa: }
Kode lerroa: function readUint16(data, offset) {
Kode lerroa:   return data[offset] << 8 | data[offset + 1];
Kode lerroa: }
Kode lerroa: function readUint32(data, offset) {
Kode lerroa:   return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
Kode lerroa: }
Kode lerroa: function isLittleEndian() {
Kode lerroa:   var buffer8 = new Uint8Array(4);
Kode lerroa:   buffer8[0] = 1;
Kode lerroa:   var view32 = new Uint32Array(buffer8.buffer, 0, 1);
Kode lerroa:   return view32[0] === 1;
Kode lerroa: }
Kode lerroa: function isEvalSupported() {
Kode lerroa:   try {
Kode lerroa:     new Function('');
Kode lerroa:     return true;
Kode lerroa:   } catch (e) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
Kode lerroa: var Util = function UtilClosure() {
Kode lerroa:   function Util() {}
Kode lerroa:   var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
Kode lerroa:   Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
Kode lerroa:     rgbBuf[1] = r;
Kode lerroa:     rgbBuf[3] = g;
Kode lerroa:     rgbBuf[5] = b;
Kode lerroa:     return rgbBuf.join('');
Kode lerroa:   };
Kode lerroa:   Util.transform = function Util_transform(m1, m2) {
Kode lerroa:     return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
Kode lerroa:   };
Kode lerroa:   Util.applyTransform = function Util_applyTransform(p, m) {
Kode lerroa:     var xt = p[0] * m[0] + p[1] * m[2] + m[4];
Kode lerroa:     var yt = p[0] * m[1] + p[1] * m[3] + m[5];
Kode lerroa:     return [xt, yt];
Kode lerroa:   };
Kode lerroa:   Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
Kode lerroa:     var d = m[0] * m[3] - m[1] * m[2];
Kode lerroa:     var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
Kode lerroa:     var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
Kode lerroa:     return [xt, yt];
Kode lerroa:   };
Kode lerroa:   Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
Kode lerroa:     var p1 = Util.applyTransform(r, m);
Kode lerroa:     var p2 = Util.applyTransform(r.slice(2, 4), m);
Kode lerroa:     var p3 = Util.applyTransform([r[0], r[3]], m);
Kode lerroa:     var p4 = Util.applyTransform([r[2], r[1]], m);
Kode lerroa:     return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
Kode lerroa:   };
Kode lerroa:   Util.inverseTransform = function Util_inverseTransform(m) {
Kode lerroa:     var d = m[0] * m[3] - m[1] * m[2];
Kode lerroa:     return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
Kode lerroa:   };
Kode lerroa:   Util.apply3dTransform = function Util_apply3dTransform(m, v) {
Kode lerroa:     return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
Kode lerroa:   };
Kode lerroa:   Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
Kode lerroa:     var transpose = [m[0], m[2], m[1], m[3]];
Kode lerroa:     var a = m[0] * transpose[0] + m[1] * transpose[2];
Kode lerroa:     var b = m[0] * transpose[1] + m[1] * transpose[3];
Kode lerroa:     var c = m[2] * transpose[0] + m[3] * transpose[2];
Kode lerroa:     var d = m[2] * transpose[1] + m[3] * transpose[3];
Kode lerroa:     var first = (a + d) / 2;
Kode lerroa:     var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
Kode lerroa:     var sx = first + second || 1;
Kode lerroa:     var sy = first - second || 1;
Kode lerroa:     return [Math.sqrt(sx), Math.sqrt(sy)];
Kode lerroa:   };
Kode lerroa:   Util.normalizeRect = function Util_normalizeRect(rect) {
Kode lerroa:     var r = rect.slice(0);
Kode lerroa:     if (rect[0] > rect[2]) {
Kode lerroa:       r[0] = rect[2];
Kode lerroa:       r[2] = rect[0];
Kode lerroa:     }
Kode lerroa:     if (rect[1] > rect[3]) {
Kode lerroa:       r[1] = rect[3];
Kode lerroa:       r[3] = rect[1];
Kode lerroa:     }
Kode lerroa:     return r;
Kode lerroa:   };
Kode lerroa:   Util.intersect = function Util_intersect(rect1, rect2) {
Kode lerroa:     function compare(a, b) {
Kode lerroa:       return a - b;
Kode lerroa:     }
Kode lerroa:     var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
Kode lerroa:         orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
Kode lerroa:         result = [];
Kode lerroa:     rect1 = Util.normalizeRect(rect1);
Kode lerroa:     rect2 = Util.normalizeRect(rect2);
Kode lerroa:     if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
Kode lerroa:       result[0] = orderedX[1];
Kode lerroa:       result[2] = orderedX[2];
Kode lerroa:     } else {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
Kode lerroa:       result[1] = orderedY[1];
Kode lerroa:       result[3] = orderedY[2];
Kode lerroa:     } else {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   };
Kode lerroa:   var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
Kode lerroa:   Util.toRoman = function Util_toRoman(number, lowerCase) {
Kode lerroa:     assert(Number.isInteger(number) && number > 0, 'The number should be a positive integer.');
Kode lerroa:     var pos,
Kode lerroa:         romanBuf = [];
Kode lerroa:     while (number >= 1000) {
Kode lerroa:       number -= 1000;
Kode lerroa:       romanBuf.push('M');
Kode lerroa:     }
Kode lerroa:     pos = number / 100 | 0;
Kode lerroa:     number %= 100;
Kode lerroa:     romanBuf.push(ROMAN_NUMBER_MAP[pos]);
Kode lerroa:     pos = number / 10 | 0;
Kode lerroa:     number %= 10;
Kode lerroa:     romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
Kode lerroa:     romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
Kode lerroa:     var romanStr = romanBuf.join('');
Kode lerroa:     return lowerCase ? romanStr.toLowerCase() : romanStr;
Kode lerroa:   };
Kode lerroa:   Util.appendToArray = function Util_appendToArray(arr1, arr2) {
Kode lerroa:     Array.prototype.push.apply(arr1, arr2);
Kode lerroa:   };
Kode lerroa:   Util.prependToArray = function Util_prependToArray(arr1, arr2) {
Kode lerroa:     Array.prototype.unshift.apply(arr1, arr2);
Kode lerroa:   };
Kode lerroa:   Util.extendObj = function extendObj(obj1, obj2) {
Kode lerroa:     for (var key in obj2) {
Kode lerroa:       obj1[key] = obj2[key];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Util.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
Kode lerroa:     while (dict && !dict.has(name)) {
Kode lerroa:       dict = dict.get('Parent');
Kode lerroa:     }
Kode lerroa:     if (!dict) {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:     return getArray ? dict.getArray(name) : dict.get(name);
Kode lerroa:   };
Kode lerroa:   Util.inherit = function Util_inherit(sub, base, prototype) {
Kode lerroa:     sub.prototype = Object.create(base.prototype);
Kode lerroa:     sub.prototype.constructor = sub;
Kode lerroa:     for (var prop in prototype) {
Kode lerroa:       sub.prototype[prop] = prototype[prop];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Util.loadScript = function Util_loadScript(src, callback) {
Kode lerroa:     var script = document.createElement('script');
Kode lerroa:     var loaded = false;
Kode lerroa:     script.setAttribute('src', src);
Kode lerroa:     if (callback) {
Kode lerroa:       script.onload = function () {
Kode lerroa:         if (!loaded) {
Kode lerroa:           callback();
Kode lerroa:         }
Kode lerroa:         loaded = true;
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     document.getElementsByTagName('head')[0].appendChild(script);
Kode lerroa:   };
Kode lerroa:   return Util;
Kode lerroa: }();
Kode lerroa: var PageViewport = function PageViewportClosure() {
Kode lerroa:   function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
Kode lerroa:     this.viewBox = viewBox;
Kode lerroa:     this.scale = scale;
Kode lerroa:     this.rotation = rotation;
Kode lerroa:     this.offsetX = offsetX;
Kode lerroa:     this.offsetY = offsetY;
Kode lerroa:     var centerX = (viewBox[2] + viewBox[0]) / 2;
Kode lerroa:     var centerY = (viewBox[3] + viewBox[1]) / 2;
Kode lerroa:     var rotateA, rotateB, rotateC, rotateD;
Kode lerroa:     rotation = rotation % 360;
Kode lerroa:     rotation = rotation < 0 ? rotation + 360 : rotation;
Kode lerroa:     switch (rotation) {
Kode lerroa:       case 180:
Kode lerroa:         rotateA = -1;
Kode lerroa:         rotateB = 0;
Kode lerroa:         rotateC = 0;
Kode lerroa:         rotateD = 1;
Kode lerroa:         break;
Kode lerroa:       case 90:
Kode lerroa:         rotateA = 0;
Kode lerroa:         rotateB = 1;
Kode lerroa:         rotateC = 1;
Kode lerroa:         rotateD = 0;
Kode lerroa:         break;
Kode lerroa:       case 270:
Kode lerroa:         rotateA = 0;
Kode lerroa:         rotateB = -1;
Kode lerroa:         rotateC = -1;
Kode lerroa:         rotateD = 0;
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         rotateA = 1;
Kode lerroa:         rotateB = 0;
Kode lerroa:         rotateC = 0;
Kode lerroa:         rotateD = -1;
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:     if (dontFlip) {
Kode lerroa:       rotateC = -rotateC;
Kode lerroa:       rotateD = -rotateD;
Kode lerroa:     }
Kode lerroa:     var offsetCanvasX, offsetCanvasY;
Kode lerroa:     var width, height;
Kode lerroa:     if (rotateA === 0) {
Kode lerroa:       offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
Kode lerroa:       offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
Kode lerroa:       width = Math.abs(viewBox[3] - viewBox[1]) * scale;
Kode lerroa:       height = Math.abs(viewBox[2] - viewBox[0]) * scale;
Kode lerroa:     } else {
Kode lerroa:       offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
Kode lerroa:       offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
Kode lerroa:       width = Math.abs(viewBox[2] - viewBox[0]) * scale;
Kode lerroa:       height = Math.abs(viewBox[3] - viewBox[1]) * scale;
Kode lerroa:     }
Kode lerroa:     this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
Kode lerroa:     this.width = width;
Kode lerroa:     this.height = height;
Kode lerroa:     this.fontScale = scale;
Kode lerroa:   }
Kode lerroa:   PageViewport.prototype = {
Kode lerroa:     clone: function PageViewPort_clone(args) {
Kode lerroa:       args = args || {};
Kode lerroa:       var scale = 'scale' in args ? args.scale : this.scale;
Kode lerroa:       var rotation = 'rotation' in args ? args.rotation : this.rotation;
Kode lerroa:       return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
Kode lerroa:     },
Kode lerroa:     convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
Kode lerroa:       return Util.applyTransform([x, y], this.transform);
Kode lerroa:     },
Kode lerroa:     convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
Kode lerroa:       var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
Kode lerroa:       var br = Util.applyTransform([rect[2], rect[3]], this.transform);
Kode lerroa:       return [tl[0], tl[1], br[0], br[1]];
Kode lerroa:     },
Kode lerroa:     convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
Kode lerroa:       return Util.applyInverseTransform([x, y], this.transform);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PageViewport;
Kode lerroa: }();
Kode lerroa: var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
Kode lerroa: function stringToPDFString(str) {
Kode lerroa:   var i,
Kode lerroa:       n = str.length,
Kode lerroa:       strBuf = [];
Kode lerroa:   if (str[0] === '\xFE' && str[1] === '\xFF') {
Kode lerroa:     for (i = 2; i < n; i += 2) {
Kode lerroa:       strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
Kode lerroa:     }
Kode lerroa:   } else {
Kode lerroa:     for (i = 0; i < n; ++i) {
Kode lerroa:       var code = PDFStringTranslateTable[str.charCodeAt(i)];
Kode lerroa:       strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return strBuf.join('');
Kode lerroa: }
Kode lerroa: function stringToUTF8String(str) {
Kode lerroa:   return decodeURIComponent(escape(str));
Kode lerroa: }
Kode lerroa: function utf8StringToString(str) {
Kode lerroa:   return unescape(encodeURIComponent(str));
Kode lerroa: }
Kode lerroa: function isEmptyObj(obj) {
Kode lerroa:   for (var key in obj) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   return true;
Kode lerroa: }
Kode lerroa: function isBool(v) {
Kode lerroa:   return typeof v === 'boolean';
Kode lerroa: }
Kode lerroa: function isNum(v) {
Kode lerroa:   return typeof v === 'number';
Kode lerroa: }
Kode lerroa: function isString(v) {
Kode lerroa:   return typeof v === 'string';
Kode lerroa: }
Kode lerroa: function isArrayBuffer(v) {
Kode lerroa:   return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.byteLength !== undefined;
Kode lerroa: }
Kode lerroa: function isSpace(ch) {
Kode lerroa:   return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
Kode lerroa: }
Kode lerroa: function isNodeJS() {
Kode lerroa:   return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process + '' === '[object process]';
Kode lerroa: }
Kode lerroa: function createPromiseCapability() {
Kode lerroa:   var capability = {};
Kode lerroa:   capability.promise = new Promise(function (resolve, reject) {
Kode lerroa:     capability.resolve = resolve;
Kode lerroa:     capability.reject = reject;
Kode lerroa:   });
Kode lerroa:   return capability;
Kode lerroa: }
Kode lerroa: var StatTimer = function StatTimerClosure() {
Kode lerroa:   function rpad(str, pad, length) {
Kode lerroa:     while (str.length < length) {
Kode lerroa:       str += pad;
Kode lerroa:     }
Kode lerroa:     return str;
Kode lerroa:   }
Kode lerroa:   function StatTimer() {
Kode lerroa:     this.started = Object.create(null);
Kode lerroa:     this.times = [];
Kode lerroa:     this.enabled = true;
Kode lerroa:   }
Kode lerroa:   StatTimer.prototype = {
Kode lerroa:     time: function StatTimer_time(name) {
Kode lerroa:       if (!this.enabled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (name in this.started) {
Kode lerroa:         warn('Timer is already running for ' + name);
Kode lerroa:       }
Kode lerroa:       this.started[name] = Date.now();
Kode lerroa:     },
Kode lerroa:     timeEnd: function StatTimer_timeEnd(name) {
Kode lerroa:       if (!this.enabled) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!(name in this.started)) {
Kode lerroa:         warn('Timer has not been started for ' + name);
Kode lerroa:       }
Kode lerroa:       this.times.push({
Kode lerroa:         'name': name,
Kode lerroa:         'start': this.started[name],
Kode lerroa:         'end': Date.now()
Kode lerroa:       });
Kode lerroa:       delete this.started[name];
Kode lerroa:     },
Kode lerroa:     toString: function StatTimer_toString() {
Kode lerroa:       var i, ii;
Kode lerroa:       var times = this.times;
Kode lerroa:       var out = '';
Kode lerroa:       var longest = 0;
Kode lerroa:       for (i = 0, ii = times.length; i < ii; ++i) {
Kode lerroa:         var name = times[i]['name'];
Kode lerroa:         if (name.length > longest) {
Kode lerroa:           longest = name.length;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (i = 0, ii = times.length; i < ii; ++i) {
Kode lerroa:         var span = times[i];
Kode lerroa:         var duration = span.end - span.start;
Kode lerroa:         out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
Kode lerroa:       }
Kode lerroa:       return out;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return StatTimer;
Kode lerroa: }();
Kode lerroa: var createBlob = function createBlob(data, contentType) {
Kode lerroa:   if (typeof Blob !== 'undefined') {
Kode lerroa:     return new Blob([data], { type: contentType });
Kode lerroa:   }
Kode lerroa:   throw new Error('The "Blob" constructor is not supported.');
Kode lerroa: };
Kode lerroa: var createObjectURL = function createObjectURLClosure() {
Kode lerroa:   var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
Kode lerroa:   return function createObjectURL(data, contentType) {
Kode lerroa:     var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:     if (!forceDataSchema && URL.createObjectURL) {
Kode lerroa:       var blob = createBlob(data, contentType);
Kode lerroa:       return URL.createObjectURL(blob);
Kode lerroa:     }
Kode lerroa:     var buffer = 'data:' + contentType + ';base64,';
Kode lerroa:     for (var i = 0, ii = data.length; i < ii; i += 3) {
Kode lerroa:       var b1 = data[i] & 0xFF;
Kode lerroa:       var b2 = data[i + 1] & 0xFF;
Kode lerroa:       var b3 = data[i + 2] & 0xFF;
Kode lerroa:       var d1 = b1 >> 2,
Kode lerroa:           d2 = (b1 & 3) << 4 | b2 >> 4;
Kode lerroa:       var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
Kode lerroa:       var d4 = i + 2 < ii ? b3 & 0x3F : 64;
Kode lerroa:       buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
Kode lerroa:     }
Kode lerroa:     return buffer;
Kode lerroa:   };
Kode lerroa: }();
Kode lerroa: function resolveCall(fn, args) {
Kode lerroa:   var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
Kode lerroa: 
Kode lerroa:   if (!fn) {
Kode lerroa:     return Promise.resolve(undefined);
Kode lerroa:   }
Kode lerroa:   return new Promise(function (resolve, reject) {
Kode lerroa:     resolve(fn.apply(thisArg, args));
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function wrapReason(reason) {
Kode lerroa:   if ((typeof reason === 'undefined' ? 'undefined' : _typeof(reason)) !== 'object') {
Kode lerroa:     return reason;
Kode lerroa:   }
Kode lerroa:   switch (reason.name) {
Kode lerroa:     case 'AbortException':
Kode lerroa:       return new AbortException(reason.message);
Kode lerroa:     case 'MissingPDFException':
Kode lerroa:       return new MissingPDFException(reason.message);
Kode lerroa:     case 'UnexpectedResponseException':
Kode lerroa:       return new UnexpectedResponseException(reason.message, reason.status);
Kode lerroa:     default:
Kode lerroa:       return new UnknownErrorException(reason.message, reason.details);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function makeReasonSerializable(reason) {
Kode lerroa:   if (!(reason instanceof Error) || reason instanceof AbortException || reason instanceof MissingPDFException || reason instanceof UnexpectedResponseException || reason instanceof UnknownErrorException) {
Kode lerroa:     return reason;
Kode lerroa:   }
Kode lerroa:   return new UnknownErrorException(reason.message, reason.toString());
Kode lerroa: }
Kode lerroa: function resolveOrReject(capability, success, reason) {
Kode lerroa:   if (success) {
Kode lerroa:     capability.resolve();
Kode lerroa:   } else {
Kode lerroa:     capability.reject(reason);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function finalize(promise) {
Kode lerroa:   return Promise.resolve(promise).catch(function () {});
Kode lerroa: }
Kode lerroa: function MessageHandler(sourceName, targetName, comObj) {
Kode lerroa:   var _this = this;
Kode lerroa: 
Kode lerroa:   this.sourceName = sourceName;
Kode lerroa:   this.targetName = targetName;
Kode lerroa:   this.comObj = comObj;
Kode lerroa:   this.callbackId = 1;
Kode lerroa:   this.streamId = 1;
Kode lerroa:   this.postMessageTransfers = true;
Kode lerroa:   this.streamSinks = Object.create(null);
Kode lerroa:   this.streamControllers = Object.create(null);
Kode lerroa:   var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);
Kode lerroa:   var ah = this.actionHandler = Object.create(null);
Kode lerroa:   this._onComObjOnMessage = function (event) {
Kode lerroa:     var data = event.data;
Kode lerroa:     if (data.targetName !== _this.sourceName) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (data.stream) {
Kode lerroa:       _this._processStreamMessage(data);
Kode lerroa:     } else if (data.isReply) {
Kode lerroa:       var callbackId = data.callbackId;
Kode lerroa:       if (data.callbackId in callbacksCapabilities) {
Kode lerroa:         var callback = callbacksCapabilities[callbackId];
Kode lerroa:         delete callbacksCapabilities[callbackId];
Kode lerroa:         if ('error' in data) {
Kode lerroa:           callback.reject(wrapReason(data.error));
Kode lerroa:         } else {
Kode lerroa:           callback.resolve(data.data);
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         throw new Error('Cannot resolve callback ' + callbackId);
Kode lerroa:       }
Kode lerroa:     } else if (data.action in ah) {
Kode lerroa:       var action = ah[data.action];
Kode lerroa:       if (data.callbackId) {
Kode lerroa:         var _sourceName = _this.sourceName;
Kode lerroa:         var _targetName = data.sourceName;
Kode lerroa:         Promise.resolve().then(function () {
Kode lerroa:           return action[0].call(action[1], data.data);
Kode lerroa:         }).then(function (result) {
Kode lerroa:           comObj.postMessage({
Kode lerroa:             sourceName: _sourceName,
Kode lerroa:             targetName: _targetName,
Kode lerroa:             isReply: true,
Kode lerroa:             callbackId: data.callbackId,
Kode lerroa:             data: result
Kode lerroa:           });
Kode lerroa:         }, function (reason) {
Kode lerroa:           comObj.postMessage({
Kode lerroa:             sourceName: _sourceName,
Kode lerroa:             targetName: _targetName,
Kode lerroa:             isReply: true,
Kode lerroa:             callbackId: data.callbackId,
Kode lerroa:             error: makeReasonSerializable(reason)
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       } else if (data.streamId) {
Kode lerroa:         _this._createStreamSink(data);
Kode lerroa:       } else {
Kode lerroa:         action[0].call(action[1], data.data);
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Unknown action from worker: ' + data.action);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   comObj.addEventListener('message', this._onComObjOnMessage);
Kode lerroa: }
Kode lerroa: MessageHandler.prototype = {
Kode lerroa:   on: function on(actionName, handler, scope) {
Kode lerroa:     var ah = this.actionHandler;
Kode lerroa:     if (ah[actionName]) {
Kode lerroa:       throw new Error('There is already an actionName called "' + actionName + '"');
Kode lerroa:     }
Kode lerroa:     ah[actionName] = [handler, scope];
Kode lerroa:   },
Kode lerroa:   send: function send(actionName, data, transfers) {
Kode lerroa:     var message = {
Kode lerroa:       sourceName: this.sourceName,
Kode lerroa:       targetName: this.targetName,
Kode lerroa:       action: actionName,
Kode lerroa:       data: data
Kode lerroa:     };
Kode lerroa:     this.postMessage(message, transfers);
Kode lerroa:   },
Kode lerroa:   sendWithPromise: function sendWithPromise(actionName, data, transfers) {
Kode lerroa:     var callbackId = this.callbackId++;
Kode lerroa:     var message = {
Kode lerroa:       sourceName: this.sourceName,
Kode lerroa:       targetName: this.targetName,
Kode lerroa:       action: actionName,
Kode lerroa:       data: data,
Kode lerroa:       callbackId: callbackId
Kode lerroa:     };
Kode lerroa:     var capability = createPromiseCapability();
Kode lerroa:     this.callbacksCapabilities[callbackId] = capability;
Kode lerroa:     try {
Kode lerroa:       this.postMessage(message, transfers);
Kode lerroa:     } catch (e) {
Kode lerroa:       capability.reject(e);
Kode lerroa:     }
Kode lerroa:     return capability.promise;
Kode lerroa:   },
Kode lerroa:   sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
Kode lerroa:     var _this2 = this;
Kode lerroa: 
Kode lerroa:     var streamId = this.streamId++;
Kode lerroa:     var sourceName = this.sourceName;
Kode lerroa:     var targetName = this.targetName;
Kode lerroa:     return new _streams_polyfill.ReadableStream({
Kode lerroa:       start: function start(controller) {
Kode lerroa:         var startCapability = createPromiseCapability();
Kode lerroa:         _this2.streamControllers[streamId] = {
Kode lerroa:           controller: controller,
Kode lerroa:           startCall: startCapability,
Kode lerroa:           isClosed: false
Kode lerroa:         };
Kode lerroa:         _this2.postMessage({
Kode lerroa:           sourceName: sourceName,
Kode lerroa:           targetName: targetName,
Kode lerroa:           action: actionName,
Kode lerroa:           streamId: streamId,
Kode lerroa:           data: data,
Kode lerroa:           desiredSize: controller.desiredSize
Kode lerroa:         });
Kode lerroa:         return startCapability.promise;
Kode lerroa:       },
Kode lerroa:       pull: function pull(controller) {
Kode lerroa:         var pullCapability = createPromiseCapability();
Kode lerroa:         _this2.streamControllers[streamId].pullCall = pullCapability;
Kode lerroa:         _this2.postMessage({
Kode lerroa:           sourceName: sourceName,
Kode lerroa:           targetName: targetName,
Kode lerroa:           stream: 'pull',
Kode lerroa:           streamId: streamId,
Kode lerroa:           desiredSize: controller.desiredSize
Kode lerroa:         });
Kode lerroa:         return pullCapability.promise;
Kode lerroa:       },
Kode lerroa:       cancel: function cancel(reason) {
Kode lerroa:         var cancelCapability = createPromiseCapability();
Kode lerroa:         _this2.streamControllers[streamId].cancelCall = cancelCapability;
Kode lerroa:         _this2.streamControllers[streamId].isClosed = true;
Kode lerroa:         _this2.postMessage({
Kode lerroa:           sourceName: sourceName,
Kode lerroa:           targetName: targetName,
Kode lerroa:           stream: 'cancel',
Kode lerroa:           reason: reason,
Kode lerroa:           streamId: streamId
Kode lerroa:         });
Kode lerroa:         return cancelCapability.promise;
Kode lerroa:       }
Kode lerroa:     }, queueingStrategy);
Kode lerroa:   },
Kode lerroa:   _createStreamSink: function _createStreamSink(data) {
Kode lerroa:     var _this3 = this;
Kode lerroa: 
Kode lerroa:     var self = this;
Kode lerroa:     var action = this.actionHandler[data.action];
Kode lerroa:     var streamId = data.streamId;
Kode lerroa:     var desiredSize = data.desiredSize;
Kode lerroa:     var sourceName = this.sourceName;
Kode lerroa:     var targetName = data.sourceName;
Kode lerroa:     var capability = createPromiseCapability();
Kode lerroa:     var sendStreamRequest = function sendStreamRequest(_ref) {
Kode lerroa:       var stream = _ref.stream,
Kode lerroa:           chunk = _ref.chunk,
Kode lerroa:           transfers = _ref.transfers,
Kode lerroa:           success = _ref.success,
Kode lerroa:           reason = _ref.reason;
Kode lerroa: 
Kode lerroa:       _this3.postMessage({
Kode lerroa:         sourceName: sourceName,
Kode lerroa:         targetName: targetName,
Kode lerroa:         stream: stream,
Kode lerroa:         streamId: streamId,
Kode lerroa:         chunk: chunk,
Kode lerroa:         success: success,
Kode lerroa:         reason: reason
Kode lerroa:       }, transfers);
Kode lerroa:     };
Kode lerroa:     var streamSink = {
Kode lerroa:       enqueue: function enqueue(chunk) {
Kode lerroa:         var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
Kode lerroa:         var transfers = arguments[2];
Kode lerroa: 
Kode lerroa:         if (this.isCancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var lastDesiredSize = this.desiredSize;
Kode lerroa:         this.desiredSize -= size;
Kode lerroa:         if (lastDesiredSize > 0 && this.desiredSize <= 0) {
Kode lerroa:           this.sinkCapability = createPromiseCapability();
Kode lerroa:           this.ready = this.sinkCapability.promise;
Kode lerroa:         }
Kode lerroa:         sendStreamRequest({
Kode lerroa:           stream: 'enqueue',
Kode lerroa:           chunk: chunk,
Kode lerroa:           transfers: transfers
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa:       close: function close() {
Kode lerroa:         if (this.isCancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this.isCancelled = true;
Kode lerroa:         sendStreamRequest({ stream: 'close' });
Kode lerroa:         delete self.streamSinks[streamId];
Kode lerroa:       },
Kode lerroa:       error: function error(reason) {
Kode lerroa:         if (this.isCancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this.isCancelled = true;
Kode lerroa:         sendStreamRequest({
Kode lerroa:           stream: 'error',
Kode lerroa:           reason: reason
Kode lerroa:         });
Kode lerroa:       },
Kode lerroa: 
Kode lerroa:       sinkCapability: capability,
Kode lerroa:       onPull: null,
Kode lerroa:       onCancel: null,
Kode lerroa:       isCancelled: false,
Kode lerroa:       desiredSize: desiredSize,
Kode lerroa:       ready: null
Kode lerroa:     };
Kode lerroa:     streamSink.sinkCapability.resolve();
Kode lerroa:     streamSink.ready = streamSink.sinkCapability.promise;
Kode lerroa:     this.streamSinks[streamId] = streamSink;
Kode lerroa:     resolveCall(action[0], [data.data, streamSink], action[1]).then(function () {
Kode lerroa:       sendStreamRequest({
Kode lerroa:         stream: 'start_complete',
Kode lerroa:         success: true
Kode lerroa:       });
Kode lerroa:     }, function (reason) {
Kode lerroa:       sendStreamRequest({
Kode lerroa:         stream: 'start_complete',
Kode lerroa:         success: false,
Kode lerroa:         reason: reason
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   _processStreamMessage: function _processStreamMessage(data) {
Kode lerroa:     var _this4 = this;
Kode lerroa: 
Kode lerroa:     var sourceName = this.sourceName;
Kode lerroa:     var targetName = data.sourceName;
Kode lerroa:     var streamId = data.streamId;
Kode lerroa:     var sendStreamResponse = function sendStreamResponse(_ref2) {
Kode lerroa:       var stream = _ref2.stream,
Kode lerroa:           success = _ref2.success,
Kode lerroa:           reason = _ref2.reason;
Kode lerroa: 
Kode lerroa:       _this4.comObj.postMessage({
Kode lerroa:         sourceName: sourceName,
Kode lerroa:         targetName: targetName,
Kode lerroa:         stream: stream,
Kode lerroa:         success: success,
Kode lerroa:         streamId: streamId,
Kode lerroa:         reason: reason
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     var deleteStreamController = function deleteStreamController() {
Kode lerroa:       Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function (capability) {
Kode lerroa:         return capability && finalize(capability.promise);
Kode lerroa:       })).then(function () {
Kode lerroa:         delete _this4.streamControllers[data.streamId];
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:     switch (data.stream) {
Kode lerroa:       case 'start_complete':
Kode lerroa:         resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
Kode lerroa:         break;
Kode lerroa:       case 'pull_complete':
Kode lerroa:         resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
Kode lerroa:         break;
Kode lerroa:       case 'pull':
Kode lerroa:         if (!this.streamSinks[data.streamId]) {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'pull_complete',
Kode lerroa:             success: true
Kode lerroa:           });
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
Kode lerroa:           this.streamSinks[data.streamId].sinkCapability.resolve();
Kode lerroa:         }
Kode lerroa:         this.streamSinks[data.streamId].desiredSize = data.desiredSize;
Kode lerroa:         resolveCall(this.streamSinks[data.streamId].onPull).then(function () {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'pull_complete',
Kode lerroa:             success: true
Kode lerroa:           });
Kode lerroa:         }, function (reason) {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'pull_complete',
Kode lerroa:             success: false,
Kode lerroa:             reason: reason
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:         break;
Kode lerroa:       case 'enqueue':
Kode lerroa:         assert(this.streamControllers[data.streamId], 'enqueue should have stream controller');
Kode lerroa:         if (!this.streamControllers[data.streamId].isClosed) {
Kode lerroa:           this.streamControllers[data.streamId].controller.enqueue(data.chunk);
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 'close':
Kode lerroa:         assert(this.streamControllers[data.streamId], 'close should have stream controller');
Kode lerroa:         if (this.streamControllers[data.streamId].isClosed) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         this.streamControllers[data.streamId].isClosed = true;
Kode lerroa:         this.streamControllers[data.streamId].controller.close();
Kode lerroa:         deleteStreamController();
Kode lerroa:         break;
Kode lerroa:       case 'error':
Kode lerroa:         assert(this.streamControllers[data.streamId], 'error should have stream controller');
Kode lerroa:         this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
Kode lerroa:         deleteStreamController();
Kode lerroa:         break;
Kode lerroa:       case 'cancel_complete':
Kode lerroa:         resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
Kode lerroa:         deleteStreamController();
Kode lerroa:         break;
Kode lerroa:       case 'cancel':
Kode lerroa:         if (!this.streamSinks[data.streamId]) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function () {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'cancel_complete',
Kode lerroa:             success: true
Kode lerroa:           });
Kode lerroa:         }, function (reason) {
Kode lerroa:           sendStreamResponse({
Kode lerroa:             stream: 'cancel_complete',
Kode lerroa:             success: false,
Kode lerroa:             reason: reason
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:         this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
Kode lerroa:         this.streamSinks[data.streamId].isCancelled = true;
Kode lerroa:         delete this.streamSinks[data.streamId];
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         throw new Error('Unexpected stream case');
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   postMessage: function postMessage(message, transfers) {
Kode lerroa:     if (transfers && this.postMessageTransfers) {
Kode lerroa:       this.comObj.postMessage(message, transfers);
Kode lerroa:     } else {
Kode lerroa:       this.comObj.postMessage(message);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   destroy: function destroy() {
Kode lerroa:     this.comObj.removeEventListener('message', this._onComObjOnMessage);
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function loadJpegStream(id, imageUrl, objs) {
Kode lerroa:   var img = new Image();
Kode lerroa:   img.onload = function loadJpegStream_onloadClosure() {
Kode lerroa:     objs.resolve(id, img);
Kode lerroa:   };
Kode lerroa:   img.onerror = function loadJpegStream_onerrorClosure() {
Kode lerroa:     objs.resolve(id, null);
Kode lerroa:     warn('Error during JPEG image loading');
Kode lerroa:   };
Kode lerroa:   img.src = imageUrl;
Kode lerroa: }
Kode lerroa: exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
Kode lerroa: exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
Kode lerroa: exports.OPS = OPS;
Kode lerroa: exports.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
Kode lerroa: exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
Kode lerroa: exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
Kode lerroa: exports.AnnotationFieldFlag = AnnotationFieldFlag;
Kode lerroa: exports.AnnotationFlag = AnnotationFlag;
Kode lerroa: exports.AnnotationType = AnnotationType;
Kode lerroa: exports.FontType = FontType;
Kode lerroa: exports.ImageKind = ImageKind;
Kode lerroa: exports.CMapCompressionType = CMapCompressionType;
Kode lerroa: exports.AbortException = AbortException;
Kode lerroa: exports.InvalidPDFException = InvalidPDFException;
Kode lerroa: exports.MessageHandler = MessageHandler;
Kode lerroa: exports.MissingDataException = MissingDataException;
Kode lerroa: exports.MissingPDFException = MissingPDFException;
Kode lerroa: exports.NativeImageDecoding = NativeImageDecoding;
Kode lerroa: exports.NotImplementedException = NotImplementedException;
Kode lerroa: exports.PageViewport = PageViewport;
Kode lerroa: exports.PasswordException = PasswordException;
Kode lerroa: exports.PasswordResponses = PasswordResponses;
Kode lerroa: exports.StatTimer = StatTimer;
Kode lerroa: exports.StreamType = StreamType;
Kode lerroa: exports.TextRenderingMode = TextRenderingMode;
Kode lerroa: exports.UnexpectedResponseException = UnexpectedResponseException;
Kode lerroa: exports.UnknownErrorException = UnknownErrorException;
Kode lerroa: exports.Util = Util;
Kode lerroa: exports.XRefParseException = XRefParseException;
Kode lerroa: exports.FormatError = FormatError;
Kode lerroa: exports.arrayByteLength = arrayByteLength;
Kode lerroa: exports.arraysToBytes = arraysToBytes;
Kode lerroa: exports.assert = assert;
Kode lerroa: exports.bytesToString = bytesToString;
Kode lerroa: exports.createBlob = createBlob;
Kode lerroa: exports.createPromiseCapability = createPromiseCapability;
Kode lerroa: exports.createObjectURL = createObjectURL;
Kode lerroa: exports.deprecated = deprecated;
Kode lerroa: exports.getLookupTableFactory = getLookupTableFactory;
Kode lerroa: exports.getVerbosityLevel = getVerbosityLevel;
Kode lerroa: exports.info = info;
Kode lerroa: exports.isArrayBuffer = isArrayBuffer;
Kode lerroa: exports.isBool = isBool;
Kode lerroa: exports.isEmptyObj = isEmptyObj;
Kode lerroa: exports.isNum = isNum;
Kode lerroa: exports.isString = isString;
Kode lerroa: exports.isSpace = isSpace;
Kode lerroa: exports.isNodeJS = isNodeJS;
Kode lerroa: exports.isSameOrigin = isSameOrigin;
Kode lerroa: exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
Kode lerroa: exports.isLittleEndian = isLittleEndian;
Kode lerroa: exports.isEvalSupported = isEvalSupported;
Kode lerroa: exports.loadJpegStream = loadJpegStream;
Kode lerroa: exports.log2 = log2;
Kode lerroa: exports.readInt8 = readInt8;
Kode lerroa: exports.readUint16 = readUint16;
Kode lerroa: exports.readUint32 = readUint32;
Kode lerroa: exports.removeNullCharacters = removeNullCharacters;
Kode lerroa: exports.ReadableStream = _streams_polyfill.ReadableStream;
Kode lerroa: exports.setVerbosityLevel = setVerbosityLevel;
Kode lerroa: exports.shadow = shadow;
Kode lerroa: exports.string32 = string32;
Kode lerroa: exports.stringToBytes = stringToBytes;
Kode lerroa: exports.stringToPDFString = stringToPDFString;
Kode lerroa: exports.stringToUTF8String = stringToUTF8String;
Kode lerroa: exports.utf8StringToString = utf8StringToString;
Kode lerroa: exports.warn = warn;
Kode lerroa: exports.unreachable = unreachable;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 1 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
Kode lerroa: if (typeof __g == 'number') __g = global;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 2 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var EOF = {};
Kode lerroa: var Name = function NameClosure() {
Kode lerroa:   function Name(name) {
Kode lerroa:     this.name = name;
Kode lerroa:   }
Kode lerroa:   Name.prototype = {};
Kode lerroa:   var nameCache = Object.create(null);
Kode lerroa:   Name.get = function Name_get(name) {
Kode lerroa:     var nameValue = nameCache[name];
Kode lerroa:     return nameValue ? nameValue : nameCache[name] = new Name(name);
Kode lerroa:   };
Kode lerroa:   return Name;
Kode lerroa: }();
Kode lerroa: var Cmd = function CmdClosure() {
Kode lerroa:   function Cmd(cmd) {
Kode lerroa:     this.cmd = cmd;
Kode lerroa:   }
Kode lerroa:   Cmd.prototype = {};
Kode lerroa:   var cmdCache = Object.create(null);
Kode lerroa:   Cmd.get = function Cmd_get(cmd) {
Kode lerroa:     var cmdValue = cmdCache[cmd];
Kode lerroa:     return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd(cmd);
Kode lerroa:   };
Kode lerroa:   return Cmd;
Kode lerroa: }();
Kode lerroa: var Dict = function DictClosure() {
Kode lerroa:   var nonSerializable = function nonSerializableClosure() {
Kode lerroa:     return nonSerializable;
Kode lerroa:   };
Kode lerroa:   function Dict(xref) {
Kode lerroa:     this._map = Object.create(null);
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.objId = null;
Kode lerroa:     this.suppressEncryption = false;
Kode lerroa:     this.__nonSerializable__ = nonSerializable;
Kode lerroa:   }
Kode lerroa:   Dict.prototype = {
Kode lerroa:     assignXref: function Dict_assignXref(newXref) {
Kode lerroa:       this.xref = newXref;
Kode lerroa:     },
Kode lerroa:     get: function Dict_get(key1, key2, key3) {
Kode lerroa:       var value;
Kode lerroa:       var xref = this.xref,
Kode lerroa:           suppressEncryption = this.suppressEncryption;
Kode lerroa:       if (typeof (value = this._map[key1]) !== 'undefined' || key1 in this._map || typeof key2 === 'undefined') {
Kode lerroa:         return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
Kode lerroa:       }
Kode lerroa:       if (typeof (value = this._map[key2]) !== 'undefined' || key2 in this._map || typeof key3 === 'undefined') {
Kode lerroa:         return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
Kode lerroa:       }
Kode lerroa:       value = this._map[key3] || null;
Kode lerroa:       return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
Kode lerroa:     },
Kode lerroa:     getAsync: function Dict_getAsync(key1, key2, key3) {
Kode lerroa:       var value;
Kode lerroa:       var xref = this.xref,
Kode lerroa:           suppressEncryption = this.suppressEncryption;
Kode lerroa:       if (typeof (value = this._map[key1]) !== 'undefined' || key1 in this._map || typeof key2 === 'undefined') {
Kode lerroa:         if (xref) {
Kode lerroa:           return xref.fetchIfRefAsync(value, suppressEncryption);
Kode lerroa:         }
Kode lerroa:         return Promise.resolve(value);
Kode lerroa:       }
Kode lerroa:       if (typeof (value = this._map[key2]) !== 'undefined' || key2 in this._map || typeof key3 === 'undefined') {
Kode lerroa:         if (xref) {
Kode lerroa:           return xref.fetchIfRefAsync(value, suppressEncryption);
Kode lerroa:         }
Kode lerroa:         return Promise.resolve(value);
Kode lerroa:       }
Kode lerroa:       value = this._map[key3] || null;
Kode lerroa:       if (xref) {
Kode lerroa:         return xref.fetchIfRefAsync(value, suppressEncryption);
Kode lerroa:       }
Kode lerroa:       return Promise.resolve(value);
Kode lerroa:     },
Kode lerroa:     getArray: function Dict_getArray(key1, key2, key3) {
Kode lerroa:       var value = this.get(key1, key2, key3);
Kode lerroa:       var xref = this.xref,
Kode lerroa:           suppressEncryption = this.suppressEncryption;
Kode lerroa:       if (!Array.isArray(value) || !xref) {
Kode lerroa:         return value;
Kode lerroa:       }
Kode lerroa:       value = value.slice();
Kode lerroa:       for (var i = 0, ii = value.length; i < ii; i++) {
Kode lerroa:         if (!isRef(value[i])) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         value[i] = xref.fetch(value[i], suppressEncryption);
Kode lerroa:       }
Kode lerroa:       return value;
Kode lerroa:     },
Kode lerroa:     getRaw: function Dict_getRaw(key) {
Kode lerroa:       return this._map[key];
Kode lerroa:     },
Kode lerroa:     getKeys: function Dict_getKeys() {
Kode lerroa:       return Object.keys(this._map);
Kode lerroa:     },
Kode lerroa:     set: function Dict_set(key, value) {
Kode lerroa:       this._map[key] = value;
Kode lerroa:     },
Kode lerroa:     has: function Dict_has(key) {
Kode lerroa:       return key in this._map;
Kode lerroa:     },
Kode lerroa:     forEach: function Dict_forEach(callback) {
Kode lerroa:       for (var key in this._map) {
Kode lerroa:         callback(key, this.get(key));
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Dict.empty = new Dict(null);
Kode lerroa:   Dict.merge = function (xref, dictArray) {
Kode lerroa:     var mergedDict = new Dict(xref);
Kode lerroa:     for (var i = 0, ii = dictArray.length; i < ii; i++) {
Kode lerroa:       var dict = dictArray[i];
Kode lerroa:       if (!isDict(dict)) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       for (var keyName in dict._map) {
Kode lerroa:         if (mergedDict._map[keyName] !== undefined) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         mergedDict._map[keyName] = dict._map[keyName];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return mergedDict;
Kode lerroa:   };
Kode lerroa:   return Dict;
Kode lerroa: }();
Kode lerroa: var Ref = function RefClosure() {
Kode lerroa:   function Ref(num, gen) {
Kode lerroa:     this.num = num;
Kode lerroa:     this.gen = gen;
Kode lerroa:   }
Kode lerroa:   Ref.prototype = {
Kode lerroa:     toString: function Ref_toString() {
Kode lerroa:       var str = this.num + 'R';
Kode lerroa:       if (this.gen !== 0) {
Kode lerroa:         str += this.gen;
Kode lerroa:       }
Kode lerroa:       return str;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Ref;
Kode lerroa: }();
Kode lerroa: var RefSet = function RefSetClosure() {
Kode lerroa:   function RefSet() {
Kode lerroa:     this.dict = Object.create(null);
Kode lerroa:   }
Kode lerroa:   RefSet.prototype = {
Kode lerroa:     has: function RefSet_has(ref) {
Kode lerroa:       return ref.toString() in this.dict;
Kode lerroa:     },
Kode lerroa:     put: function RefSet_put(ref) {
Kode lerroa:       this.dict[ref.toString()] = true;
Kode lerroa:     },
Kode lerroa:     remove: function RefSet_remove(ref) {
Kode lerroa:       delete this.dict[ref.toString()];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return RefSet;
Kode lerroa: }();
Kode lerroa: var RefSetCache = function RefSetCacheClosure() {
Kode lerroa:   function RefSetCache() {
Kode lerroa:     this.dict = Object.create(null);
Kode lerroa:   }
Kode lerroa:   RefSetCache.prototype = {
Kode lerroa:     get: function RefSetCache_get(ref) {
Kode lerroa:       return this.dict[ref.toString()];
Kode lerroa:     },
Kode lerroa:     has: function RefSetCache_has(ref) {
Kode lerroa:       return ref.toString() in this.dict;
Kode lerroa:     },
Kode lerroa:     put: function RefSetCache_put(ref, obj) {
Kode lerroa:       this.dict[ref.toString()] = obj;
Kode lerroa:     },
Kode lerroa:     putAlias: function RefSetCache_putAlias(ref, aliasRef) {
Kode lerroa:       this.dict[ref.toString()] = this.get(aliasRef);
Kode lerroa:     },
Kode lerroa:     forEach: function RefSetCache_forEach(fn, thisArg) {
Kode lerroa:       for (var i in this.dict) {
Kode lerroa:         fn.call(thisArg, this.dict[i]);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     clear: function RefSetCache_clear() {
Kode lerroa:       this.dict = Object.create(null);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return RefSetCache;
Kode lerroa: }();
Kode lerroa: function isEOF(v) {
Kode lerroa:   return v === EOF;
Kode lerroa: }
Kode lerroa: function isName(v, name) {
Kode lerroa:   return v instanceof Name && (name === undefined || v.name === name);
Kode lerroa: }
Kode lerroa: function isCmd(v, cmd) {
Kode lerroa:   return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
Kode lerroa: }
Kode lerroa: function isDict(v, type) {
Kode lerroa:   return v instanceof Dict && (type === undefined || isName(v.get('Type'), type));
Kode lerroa: }
Kode lerroa: function isRef(v) {
Kode lerroa:   return v instanceof Ref;
Kode lerroa: }
Kode lerroa: function isRefsEqual(v1, v2) {
Kode lerroa:   return v1.num === v2.num && v1.gen === v2.gen;
Kode lerroa: }
Kode lerroa: function isStream(v) {
Kode lerroa:   return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.getBytes !== undefined;
Kode lerroa: }
Kode lerroa: exports.EOF = EOF;
Kode lerroa: exports.Cmd = Cmd;
Kode lerroa: exports.Dict = Dict;
Kode lerroa: exports.Name = Name;
Kode lerroa: exports.Ref = Ref;
Kode lerroa: exports.RefSet = RefSet;
Kode lerroa: exports.RefSetCache = RefSetCache;
Kode lerroa: exports.isEOF = isEOF;
Kode lerroa: exports.isCmd = isCmd;
Kode lerroa: exports.isDict = isDict;
Kode lerroa: exports.isName = isName;
Kode lerroa: exports.isRef = isRef;
Kode lerroa: exports.isRefsEqual = isRefsEqual;
Kode lerroa: exports.isStream = isStream;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 3 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 4 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var store = __w_pdfjs_require__(54)('wks');
Kode lerroa: var uid = __w_pdfjs_require__(17);
Kode lerroa: var _Symbol = __w_pdfjs_require__(1).Symbol;
Kode lerroa: var USE_SYMBOL = typeof _Symbol == 'function';
Kode lerroa: var $exports = module.exports = function (name) {
Kode lerroa:   return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
Kode lerroa: };
Kode lerroa: $exports.store = store;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 5 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.LZWStream = exports.StringStream = exports.StreamsSequenceStream = exports.Stream = exports.RunLengthStream = exports.PredictorStream = exports.NullStream = exports.JpxStream = exports.JpegStream = exports.FlateStream = exports.DecodeStream = exports.DecryptStream = exports.AsciiHexStream = exports.Ascii85Stream = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var _jpg = __w_pdfjs_require__(129);
Kode lerroa: 
Kode lerroa: var _jpx = __w_pdfjs_require__(74);
Kode lerroa: 
Kode lerroa: var Stream = function StreamClosure() {
Kode lerroa:   function Stream(arrayBuffer, start, length, dict) {
Kode lerroa:     this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
Kode lerroa:     this.start = start || 0;
Kode lerroa:     this.pos = this.start;
Kode lerroa:     this.end = start + length || this.bytes.length;
Kode lerroa:     this.dict = dict;
Kode lerroa:   }
Kode lerroa:   Stream.prototype = {
Kode lerroa:     get length() {
Kode lerroa:       return this.end - this.start;
Kode lerroa:     },
Kode lerroa:     get isEmpty() {
Kode lerroa:       return this.length === 0;
Kode lerroa:     },
Kode lerroa:     getByte: function Stream_getByte() {
Kode lerroa:       if (this.pos >= this.end) {
Kode lerroa:         return -1;
Kode lerroa:       }
Kode lerroa:       return this.bytes[this.pos++];
Kode lerroa:     },
Kode lerroa:     getUint16: function Stream_getUint16() {
Kode lerroa:       var b0 = this.getByte();
Kode lerroa:       var b1 = this.getByte();
Kode lerroa:       if (b0 === -1 || b1 === -1) {
Kode lerroa:         return -1;
Kode lerroa:       }
Kode lerroa:       return (b0 << 8) + b1;
Kode lerroa:     },
Kode lerroa:     getInt32: function Stream_getInt32() {
Kode lerroa:       var b0 = this.getByte();
Kode lerroa:       var b1 = this.getByte();
Kode lerroa:       var b2 = this.getByte();
Kode lerroa:       var b3 = this.getByte();
Kode lerroa:       return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
Kode lerroa:     },
Kode lerroa:     getBytes: function Stream_getBytes(length) {
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var pos = this.pos;
Kode lerroa:       var strEnd = this.end;
Kode lerroa:       if (!length) {
Kode lerroa:         return bytes.subarray(pos, strEnd);
Kode lerroa:       }
Kode lerroa:       var end = pos + length;
Kode lerroa:       if (end > strEnd) {
Kode lerroa:         end = strEnd;
Kode lerroa:       }
Kode lerroa:       this.pos = end;
Kode lerroa:       return bytes.subarray(pos, end);
Kode lerroa:     },
Kode lerroa:     peekByte: function Stream_peekByte() {
Kode lerroa:       var peekedByte = this.getByte();
Kode lerroa:       this.pos--;
Kode lerroa:       return peekedByte;
Kode lerroa:     },
Kode lerroa:     peekBytes: function Stream_peekBytes(length) {
Kode lerroa:       var bytes = this.getBytes(length);
Kode lerroa:       this.pos -= bytes.length;
Kode lerroa:       return bytes;
Kode lerroa:     },
Kode lerroa:     skip: function Stream_skip(n) {
Kode lerroa:       if (!n) {
Kode lerroa:         n = 1;
Kode lerroa:       }
Kode lerroa:       this.pos += n;
Kode lerroa:     },
Kode lerroa:     reset: function Stream_reset() {
Kode lerroa:       this.pos = this.start;
Kode lerroa:     },
Kode lerroa:     moveStart: function Stream_moveStart() {
Kode lerroa:       this.start = this.pos;
Kode lerroa:     },
Kode lerroa:     makeSubStream: function Stream_makeSubStream(start, length, dict) {
Kode lerroa:       return new Stream(this.bytes.buffer, start, length, dict);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Stream;
Kode lerroa: }();
Kode lerroa: var StringStream = function StringStreamClosure() {
Kode lerroa:   function StringStream(str) {
Kode lerroa:     var bytes = (0, _util.stringToBytes)(str);
Kode lerroa:     Stream.call(this, bytes);
Kode lerroa:   }
Kode lerroa:   StringStream.prototype = Stream.prototype;
Kode lerroa:   return StringStream;
Kode lerroa: }();
Kode lerroa: var DecodeStream = function DecodeStreamClosure() {
Kode lerroa:   var emptyBuffer = new Uint8Array(0);
Kode lerroa:   function DecodeStream(maybeMinBufferLength) {
Kode lerroa:     this.pos = 0;
Kode lerroa:     this.bufferLength = 0;
Kode lerroa:     this.eof = false;
Kode lerroa:     this.buffer = emptyBuffer;
Kode lerroa:     this.minBufferLength = 512;
Kode lerroa:     if (maybeMinBufferLength) {
Kode lerroa:       while (this.minBufferLength < maybeMinBufferLength) {
Kode lerroa:         this.minBufferLength *= 2;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   DecodeStream.prototype = {
Kode lerroa:     get isEmpty() {
Kode lerroa:       while (!this.eof && this.bufferLength === 0) {
Kode lerroa:         this.readBlock();
Kode lerroa:       }
Kode lerroa:       return this.bufferLength === 0;
Kode lerroa:     },
Kode lerroa:     ensureBuffer: function DecodeStream_ensureBuffer(requested) {
Kode lerroa:       var buffer = this.buffer;
Kode lerroa:       if (requested <= buffer.byteLength) {
Kode lerroa:         return buffer;
Kode lerroa:       }
Kode lerroa:       var size = this.minBufferLength;
Kode lerroa:       while (size < requested) {
Kode lerroa:         size *= 2;
Kode lerroa:       }
Kode lerroa:       var buffer2 = new Uint8Array(size);
Kode lerroa:       buffer2.set(buffer);
Kode lerroa:       return this.buffer = buffer2;
Kode lerroa:     },
Kode lerroa:     getByte: function DecodeStream_getByte() {
Kode lerroa:       var pos = this.pos;
Kode lerroa:       while (this.bufferLength <= pos) {
Kode lerroa:         if (this.eof) {
Kode lerroa:           return -1;
Kode lerroa:         }
Kode lerroa:         this.readBlock();
Kode lerroa:       }
Kode lerroa:       return this.buffer[this.pos++];
Kode lerroa:     },
Kode lerroa:     getUint16: function DecodeStream_getUint16() {
Kode lerroa:       var b0 = this.getByte();
Kode lerroa:       var b1 = this.getByte();
Kode lerroa:       if (b0 === -1 || b1 === -1) {
Kode lerroa:         return -1;
Kode lerroa:       }
Kode lerroa:       return (b0 << 8) + b1;
Kode lerroa:     },
Kode lerroa:     getInt32: function DecodeStream_getInt32() {
Kode lerroa:       var b0 = this.getByte();
Kode lerroa:       var b1 = this.getByte();
Kode lerroa:       var b2 = this.getByte();
Kode lerroa:       var b3 = this.getByte();
Kode lerroa:       return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
Kode lerroa:     },
Kode lerroa:     getBytes: function DecodeStream_getBytes(length) {
Kode lerroa:       var end,
Kode lerroa:           pos = this.pos;
Kode lerroa:       if (length) {
Kode lerroa:         this.ensureBuffer(pos + length);
Kode lerroa:         end = pos + length;
Kode lerroa:         while (!this.eof && this.bufferLength < end) {
Kode lerroa:           this.readBlock();
Kode lerroa:         }
Kode lerroa:         var bufEnd = this.bufferLength;
Kode lerroa:         if (end > bufEnd) {
Kode lerroa:           end = bufEnd;
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         while (!this.eof) {
Kode lerroa:           this.readBlock();
Kode lerroa:         }
Kode lerroa:         end = this.bufferLength;
Kode lerroa:       }
Kode lerroa:       this.pos = end;
Kode lerroa:       return this.buffer.subarray(pos, end);
Kode lerroa:     },
Kode lerroa:     peekByte: function DecodeStream_peekByte() {
Kode lerroa:       var peekedByte = this.getByte();
Kode lerroa:       this.pos--;
Kode lerroa:       return peekedByte;
Kode lerroa:     },
Kode lerroa:     peekBytes: function DecodeStream_peekBytes(length) {
Kode lerroa:       var bytes = this.getBytes(length);
Kode lerroa:       this.pos -= bytes.length;
Kode lerroa:       return bytes;
Kode lerroa:     },
Kode lerroa:     makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
Kode lerroa:       var end = start + length;
Kode lerroa:       while (this.bufferLength <= end && !this.eof) {
Kode lerroa:         this.readBlock();
Kode lerroa:       }
Kode lerroa:       return new Stream(this.buffer, start, length, dict);
Kode lerroa:     },
Kode lerroa:     skip: function DecodeStream_skip(n) {
Kode lerroa:       if (!n) {
Kode lerroa:         n = 1;
Kode lerroa:       }
Kode lerroa:       this.pos += n;
Kode lerroa:     },
Kode lerroa:     reset: function DecodeStream_reset() {
Kode lerroa:       this.pos = 0;
Kode lerroa:     },
Kode lerroa:     getBaseStreams: function DecodeStream_getBaseStreams() {
Kode lerroa:       if (this.str && this.str.getBaseStreams) {
Kode lerroa:         return this.str.getBaseStreams();
Kode lerroa:       }
Kode lerroa:       return [];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return DecodeStream;
Kode lerroa: }();
Kode lerroa: var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
Kode lerroa:   function StreamsSequenceStream(streams) {
Kode lerroa:     this.streams = streams;
Kode lerroa:     DecodeStream.call(this, null);
Kode lerroa:   }
Kode lerroa:   StreamsSequenceStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   StreamsSequenceStream.prototype.readBlock = function streamSequenceStreamReadBlock() {
Kode lerroa:     var streams = this.streams;
Kode lerroa:     if (streams.length === 0) {
Kode lerroa:       this.eof = true;
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var stream = streams.shift();
Kode lerroa:     var chunk = stream.getBytes();
Kode lerroa:     var bufferLength = this.bufferLength;
Kode lerroa:     var newLength = bufferLength + chunk.length;
Kode lerroa:     var buffer = this.ensureBuffer(newLength);
Kode lerroa:     buffer.set(chunk, bufferLength);
Kode lerroa:     this.bufferLength = newLength;
Kode lerroa:   };
Kode lerroa:   StreamsSequenceStream.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
Kode lerroa:     var baseStreams = [];
Kode lerroa:     for (var i = 0, ii = this.streams.length; i < ii; i++) {
Kode lerroa:       var stream = this.streams[i];
Kode lerroa:       if (stream.getBaseStreams) {
Kode lerroa:         _util.Util.appendToArray(baseStreams, stream.getBaseStreams());
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return baseStreams;
Kode lerroa:   };
Kode lerroa:   return StreamsSequenceStream;
Kode lerroa: }();
Kode lerroa: var FlateStream = function FlateStreamClosure() {
Kode lerroa:   var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
Kode lerroa:   var lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
Kode lerroa:   var distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
Kode lerroa:   var fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
Kode lerroa:   var fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];
Kode lerroa:   function FlateStream(str, maybeLength) {
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     var cmf = str.getByte();
Kode lerroa:     var flg = str.getByte();
Kode lerroa:     if (cmf === -1 || flg === -1) {
Kode lerroa:       throw new _util.FormatError('Invalid header in flate stream: ' + cmf + ', ' + flg);
Kode lerroa:     }
Kode lerroa:     if ((cmf & 0x0f) !== 0x08) {
Kode lerroa:       throw new _util.FormatError('Unknown compression method in flate stream: ' + cmf + ', ' + flg);
Kode lerroa:     }
Kode lerroa:     if (((cmf << 8) + flg) % 31 !== 0) {
Kode lerroa:       throw new _util.FormatError('Bad FCHECK in flate stream: ' + cmf + ', ' + flg);
Kode lerroa:     }
Kode lerroa:     if (flg & 0x20) {
Kode lerroa:       throw new _util.FormatError('FDICT bit set in flate stream: ' + cmf + ', ' + flg);
Kode lerroa:     }
Kode lerroa:     this.codeSize = 0;
Kode lerroa:     this.codeBuf = 0;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   FlateStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   FlateStream.prototype.getBits = function FlateStream_getBits(bits) {
Kode lerroa:     var str = this.str;
Kode lerroa:     var codeSize = this.codeSize;
Kode lerroa:     var codeBuf = this.codeBuf;
Kode lerroa:     var b;
Kode lerroa:     while (codeSize < bits) {
Kode lerroa:       if ((b = str.getByte()) === -1) {
Kode lerroa:         throw new _util.FormatError('Bad encoding in flate stream');
Kode lerroa:       }
Kode lerroa:       codeBuf |= b << codeSize;
Kode lerroa:       codeSize += 8;
Kode lerroa:     }
Kode lerroa:     b = codeBuf & (1 << bits) - 1;
Kode lerroa:     this.codeBuf = codeBuf >> bits;
Kode lerroa:     this.codeSize = codeSize -= bits;
Kode lerroa:     return b;
Kode lerroa:   };
Kode lerroa:   FlateStream.prototype.getCode = function FlateStream_getCode(table) {
Kode lerroa:     var str = this.str;
Kode lerroa:     var codes = table[0];
Kode lerroa:     var maxLen = table[1];
Kode lerroa:     var codeSize = this.codeSize;
Kode lerroa:     var codeBuf = this.codeBuf;
Kode lerroa:     var b;
Kode lerroa:     while (codeSize < maxLen) {
Kode lerroa:       if ((b = str.getByte()) === -1) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       codeBuf |= b << codeSize;
Kode lerroa:       codeSize += 8;
Kode lerroa:     }
Kode lerroa:     var code = codes[codeBuf & (1 << maxLen) - 1];
Kode lerroa:     var codeLen = code >> 16;
Kode lerroa:     var codeVal = code & 0xffff;
Kode lerroa:     if (codeLen < 1 || codeSize < codeLen) {
Kode lerroa:       throw new _util.FormatError('Bad encoding in flate stream');
Kode lerroa:     }
Kode lerroa:     this.codeBuf = codeBuf >> codeLen;
Kode lerroa:     this.codeSize = codeSize - codeLen;
Kode lerroa:     return codeVal;
Kode lerroa:   };
Kode lerroa:   FlateStream.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
Kode lerroa:     var n = lengths.length;
Kode lerroa:     var maxLen = 0;
Kode lerroa:     var i;
Kode lerroa:     for (i = 0; i < n; ++i) {
Kode lerroa:       if (lengths[i] > maxLen) {
Kode lerroa:         maxLen = lengths[i];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var size = 1 << maxLen;
Kode lerroa:     var codes = new Int32Array(size);
Kode lerroa:     for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
Kode lerroa:       for (var val = 0; val < n; ++val) {
Kode lerroa:         if (lengths[val] === len) {
Kode lerroa:           var code2 = 0;
Kode lerroa:           var t = code;
Kode lerroa:           for (i = 0; i < len; ++i) {
Kode lerroa:             code2 = code2 << 1 | t & 1;
Kode lerroa:             t >>= 1;
Kode lerroa:           }
Kode lerroa:           for (i = code2; i < size; i += skip) {
Kode lerroa:             codes[i] = len << 16 | val;
Kode lerroa:           }
Kode lerroa:           ++code;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return [codes, maxLen];
Kode lerroa:   };
Kode lerroa:   FlateStream.prototype.readBlock = function FlateStream_readBlock() {
Kode lerroa:     var buffer, len;
Kode lerroa:     var str = this.str;
Kode lerroa:     var hdr = this.getBits(3);
Kode lerroa:     if (hdr & 1) {
Kode lerroa:       this.eof = true;
Kode lerroa:     }
Kode lerroa:     hdr >>= 1;
Kode lerroa:     if (hdr === 0) {
Kode lerroa:       var b;
Kode lerroa:       if ((b = str.getByte()) === -1) {
Kode lerroa:         throw new _util.FormatError('Bad block header in flate stream');
Kode lerroa:       }
Kode lerroa:       var blockLen = b;
Kode lerroa:       if ((b = str.getByte()) === -1) {
Kode lerroa:         throw new _util.FormatError('Bad block header in flate stream');
Kode lerroa:       }
Kode lerroa:       blockLen |= b << 8;
Kode lerroa:       if ((b = str.getByte()) === -1) {
Kode lerroa:         throw new _util.FormatError('Bad block header in flate stream');
Kode lerroa:       }
Kode lerroa:       var check = b;
Kode lerroa:       if ((b = str.getByte()) === -1) {
Kode lerroa:         throw new _util.FormatError('Bad block header in flate stream');
Kode lerroa:       }
Kode lerroa:       check |= b << 8;
Kode lerroa:       if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
Kode lerroa:         throw new _util.FormatError('Bad uncompressed block length in flate stream');
Kode lerroa:       }
Kode lerroa:       this.codeBuf = 0;
Kode lerroa:       this.codeSize = 0;
Kode lerroa:       var bufferLength = this.bufferLength;
Kode lerroa:       buffer = this.ensureBuffer(bufferLength + blockLen);
Kode lerroa:       var end = bufferLength + blockLen;
Kode lerroa:       this.bufferLength = end;
Kode lerroa:       if (blockLen === 0) {
Kode lerroa:         if (str.peekByte() === -1) {
Kode lerroa:           this.eof = true;
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         for (var n = bufferLength; n < end; ++n) {
Kode lerroa:           if ((b = str.getByte()) === -1) {
Kode lerroa:             this.eof = true;
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           buffer[n] = b;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var litCodeTable;
Kode lerroa:     var distCodeTable;
Kode lerroa:     if (hdr === 1) {
Kode lerroa:       litCodeTable = fixedLitCodeTab;
Kode lerroa:       distCodeTable = fixedDistCodeTab;
Kode lerroa:     } else if (hdr === 2) {
Kode lerroa:       var numLitCodes = this.getBits(5) + 257;
Kode lerroa:       var numDistCodes = this.getBits(5) + 1;
Kode lerroa:       var numCodeLenCodes = this.getBits(4) + 4;
Kode lerroa:       var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
Kode lerroa:       var i;
Kode lerroa:       for (i = 0; i < numCodeLenCodes; ++i) {
Kode lerroa:         codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
Kode lerroa:       }
Kode lerroa:       var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
Kode lerroa:       len = 0;
Kode lerroa:       i = 0;
Kode lerroa:       var codes = numLitCodes + numDistCodes;
Kode lerroa:       var codeLengths = new Uint8Array(codes);
Kode lerroa:       var bitsLength, bitsOffset, what;
Kode lerroa:       while (i < codes) {
Kode lerroa:         var code = this.getCode(codeLenCodeTab);
Kode lerroa:         if (code === 16) {
Kode lerroa:           bitsLength = 2;
Kode lerroa:           bitsOffset = 3;
Kode lerroa:           what = len;
Kode lerroa:         } else if (code === 17) {
Kode lerroa:           bitsLength = 3;
Kode lerroa:           bitsOffset = 3;
Kode lerroa:           what = len = 0;
Kode lerroa:         } else if (code === 18) {
Kode lerroa:           bitsLength = 7;
Kode lerroa:           bitsOffset = 11;
Kode lerroa:           what = len = 0;
Kode lerroa:         } else {
Kode lerroa:           codeLengths[i++] = len = code;
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var repeatLength = this.getBits(bitsLength) + bitsOffset;
Kode lerroa:         while (repeatLength-- > 0) {
Kode lerroa:           codeLengths[i++] = what;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
Kode lerroa:       distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
Kode lerroa:     } else {
Kode lerroa:       throw new _util.FormatError('Unknown block type in flate stream');
Kode lerroa:     }
Kode lerroa:     buffer = this.buffer;
Kode lerroa:     var limit = buffer ? buffer.length : 0;
Kode lerroa:     var pos = this.bufferLength;
Kode lerroa:     while (true) {
Kode lerroa:       var code1 = this.getCode(litCodeTable);
Kode lerroa:       if (code1 < 256) {
Kode lerroa:         if (pos + 1 >= limit) {
Kode lerroa:           buffer = this.ensureBuffer(pos + 1);
Kode lerroa:           limit = buffer.length;
Kode lerroa:         }
Kode lerroa:         buffer[pos++] = code1;
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       if (code1 === 256) {
Kode lerroa:         this.bufferLength = pos;
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       code1 -= 257;
Kode lerroa:       code1 = lengthDecode[code1];
Kode lerroa:       var code2 = code1 >> 16;
Kode lerroa:       if (code2 > 0) {
Kode lerroa:         code2 = this.getBits(code2);
Kode lerroa:       }
Kode lerroa:       len = (code1 & 0xffff) + code2;
Kode lerroa:       code1 = this.getCode(distCodeTable);
Kode lerroa:       code1 = distDecode[code1];
Kode lerroa:       code2 = code1 >> 16;
Kode lerroa:       if (code2 > 0) {
Kode lerroa:         code2 = this.getBits(code2);
Kode lerroa:       }
Kode lerroa:       var dist = (code1 & 0xffff) + code2;
Kode lerroa:       if (pos + len >= limit) {
Kode lerroa:         buffer = this.ensureBuffer(pos + len);
Kode lerroa:         limit = buffer.length;
Kode lerroa:       }
Kode lerroa:       for (var k = 0; k < len; ++k, ++pos) {
Kode lerroa:         buffer[pos] = buffer[pos - dist];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return FlateStream;
Kode lerroa: }();
Kode lerroa: var PredictorStream = function PredictorStreamClosure() {
Kode lerroa:   function PredictorStream(str, maybeLength, params) {
Kode lerroa:     if (!(0, _primitives.isDict)(params)) {
Kode lerroa:       return str;
Kode lerroa:     }
Kode lerroa:     var predictor = this.predictor = params.get('Predictor') || 1;
Kode lerroa:     if (predictor <= 1) {
Kode lerroa:       return str;
Kode lerroa:     }
Kode lerroa:     if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
Kode lerroa:       throw new _util.FormatError('Unsupported predictor: ' + predictor);
Kode lerroa:     }
Kode lerroa:     if (predictor === 2) {
Kode lerroa:       this.readBlock = this.readBlockTiff;
Kode lerroa:     } else {
Kode lerroa:       this.readBlock = this.readBlockPng;
Kode lerroa:     }
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     var colors = this.colors = params.get('Colors') || 1;
Kode lerroa:     var bits = this.bits = params.get('BitsPerComponent') || 8;
Kode lerroa:     var columns = this.columns = params.get('Columns') || 1;
Kode lerroa:     this.pixBytes = colors * bits + 7 >> 3;
Kode lerroa:     this.rowBytes = columns * colors * bits + 7 >> 3;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:     return this;
Kode lerroa:   }
Kode lerroa:   PredictorStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   PredictorStream.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
Kode lerroa:     var rowBytes = this.rowBytes;
Kode lerroa:     var bufferLength = this.bufferLength;
Kode lerroa:     var buffer = this.ensureBuffer(bufferLength + rowBytes);
Kode lerroa:     var bits = this.bits;
Kode lerroa:     var colors = this.colors;
Kode lerroa:     var rawBytes = this.str.getBytes(rowBytes);
Kode lerroa:     this.eof = !rawBytes.length;
Kode lerroa:     if (this.eof) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var inbuf = 0,
Kode lerroa:         outbuf = 0;
Kode lerroa:     var inbits = 0,
Kode lerroa:         outbits = 0;
Kode lerroa:     var pos = bufferLength;
Kode lerroa:     var i;
Kode lerroa:     if (bits === 1 && colors === 1) {
Kode lerroa:       for (i = 0; i < rowBytes; ++i) {
Kode lerroa:         var c = rawBytes[i] ^ inbuf;
Kode lerroa:         c ^= c >> 1;
Kode lerroa:         c ^= c >> 2;
Kode lerroa:         c ^= c >> 4;
Kode lerroa:         inbuf = (c & 1) << 7;
Kode lerroa:         buffer[pos++] = c;
Kode lerroa:       }
Kode lerroa:     } else if (bits === 8) {
Kode lerroa:       for (i = 0; i < colors; ++i) {
Kode lerroa:         buffer[pos++] = rawBytes[i];
Kode lerroa:       }
Kode lerroa:       for (; i < rowBytes; ++i) {
Kode lerroa:         buffer[pos] = buffer[pos - colors] + rawBytes[i];
Kode lerroa:         pos++;
Kode lerroa:       }
Kode lerroa:     } else if (bits === 16) {
Kode lerroa:       var bytesPerPixel = colors * 2;
Kode lerroa:       for (i = 0; i < bytesPerPixel; ++i) {
Kode lerroa:         buffer[pos++] = rawBytes[i];
Kode lerroa:       }
Kode lerroa:       for (; i < rowBytes; i += 2) {
Kode lerroa:         var sum = ((rawBytes[i] & 0xFF) << 8) + (rawBytes[i + 1] & 0xFF) + ((buffer[pos - bytesPerPixel] & 0xFF) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xFF);
Kode lerroa:         buffer[pos++] = sum >> 8 & 0xFF;
Kode lerroa:         buffer[pos++] = sum & 0xFF;
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       var compArray = new Uint8Array(colors + 1);
Kode lerroa:       var bitMask = (1 << bits) - 1;
Kode lerroa:       var j = 0,
Kode lerroa:           k = bufferLength;
Kode lerroa:       var columns = this.columns;
Kode lerroa:       for (i = 0; i < columns; ++i) {
Kode lerroa:         for (var kk = 0; kk < colors; ++kk) {
Kode lerroa:           if (inbits < bits) {
Kode lerroa:             inbuf = inbuf << 8 | rawBytes[j++] & 0xFF;
Kode lerroa:             inbits += 8;
Kode lerroa:           }
Kode lerroa:           compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
Kode lerroa:           inbits -= bits;
Kode lerroa:           outbuf = outbuf << bits | compArray[kk];
Kode lerroa:           outbits += bits;
Kode lerroa:           if (outbits >= 8) {
Kode lerroa:             buffer[k++] = outbuf >> outbits - 8 & 0xFF;
Kode lerroa:             outbits -= 8;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (outbits > 0) {
Kode lerroa:         buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     this.bufferLength += rowBytes;
Kode lerroa:   };
Kode lerroa:   PredictorStream.prototype.readBlockPng = function predictorStreamReadBlockPng() {
Kode lerroa:     var rowBytes = this.rowBytes;
Kode lerroa:     var pixBytes = this.pixBytes;
Kode lerroa:     var predictor = this.str.getByte();
Kode lerroa:     var rawBytes = this.str.getBytes(rowBytes);
Kode lerroa:     this.eof = !rawBytes.length;
Kode lerroa:     if (this.eof) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var bufferLength = this.bufferLength;
Kode lerroa:     var buffer = this.ensureBuffer(bufferLength + rowBytes);
Kode lerroa:     var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
Kode lerroa:     if (prevRow.length === 0) {
Kode lerroa:       prevRow = new Uint8Array(rowBytes);
Kode lerroa:     }
Kode lerroa:     var i,
Kode lerroa:         j = bufferLength,
Kode lerroa:         up,
Kode lerroa:         c;
Kode lerroa:     switch (predictor) {
Kode lerroa:       case 0:
Kode lerroa:         for (i = 0; i < rowBytes; ++i) {
Kode lerroa:           buffer[j++] = rawBytes[i];
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 1:
Kode lerroa:         for (i = 0; i < pixBytes; ++i) {
Kode lerroa:           buffer[j++] = rawBytes[i];
Kode lerroa:         }
Kode lerroa:         for (; i < rowBytes; ++i) {
Kode lerroa:           buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xFF;
Kode lerroa:           j++;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 2:
Kode lerroa:         for (i = 0; i < rowBytes; ++i) {
Kode lerroa:           buffer[j++] = prevRow[i] + rawBytes[i] & 0xFF;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 3:
Kode lerroa:         for (i = 0; i < pixBytes; ++i) {
Kode lerroa:           buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
Kode lerroa:         }
Kode lerroa:         for (; i < rowBytes; ++i) {
Kode lerroa:           buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xFF;
Kode lerroa:           j++;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 4:
Kode lerroa:         for (i = 0; i < pixBytes; ++i) {
Kode lerroa:           up = prevRow[i];
Kode lerroa:           c = rawBytes[i];
Kode lerroa:           buffer[j++] = up + c;
Kode lerroa:         }
Kode lerroa:         for (; i < rowBytes; ++i) {
Kode lerroa:           up = prevRow[i];
Kode lerroa:           var upLeft = prevRow[i - pixBytes];
Kode lerroa:           var left = buffer[j - pixBytes];
Kode lerroa:           var p = left + up - upLeft;
Kode lerroa:           var pa = p - left;
Kode lerroa:           if (pa < 0) {
Kode lerroa:             pa = -pa;
Kode lerroa:           }
Kode lerroa:           var pb = p - up;
Kode lerroa:           if (pb < 0) {
Kode lerroa:             pb = -pb;
Kode lerroa:           }
Kode lerroa:           var pc = p - upLeft;
Kode lerroa:           if (pc < 0) {
Kode lerroa:             pc = -pc;
Kode lerroa:           }
Kode lerroa:           c = rawBytes[i];
Kode lerroa:           if (pa <= pb && pa <= pc) {
Kode lerroa:             buffer[j++] = left + c;
Kode lerroa:           } else if (pb <= pc) {
Kode lerroa:             buffer[j++] = up + c;
Kode lerroa:           } else {
Kode lerroa:             buffer[j++] = upLeft + c;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         throw new _util.FormatError('Unsupported predictor: ' + predictor);
Kode lerroa:     }
Kode lerroa:     this.bufferLength += rowBytes;
Kode lerroa:   };
Kode lerroa:   return PredictorStream;
Kode lerroa: }();
Kode lerroa: var JpegStream = function JpegStreamClosure() {
Kode lerroa:   function JpegStream(stream, maybeLength, dict, params) {
Kode lerroa:     var ch;
Kode lerroa:     while ((ch = stream.getByte()) !== -1) {
Kode lerroa:       if (ch === 0xFF) {
Kode lerroa:         stream.skip(-1);
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     this.stream = stream;
Kode lerroa:     this.maybeLength = maybeLength;
Kode lerroa:     this.dict = dict;
Kode lerroa:     this.params = params;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   JpegStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   Object.defineProperty(JpegStream.prototype, 'bytes', {
Kode lerroa:     get: function JpegStream_bytes() {
Kode lerroa:       return (0, _util.shadow)(this, 'bytes', this.stream.getBytes(this.maybeLength));
Kode lerroa:     },
Kode lerroa:     configurable: true
Kode lerroa:   });
Kode lerroa:   JpegStream.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
Kode lerroa:     if (this.bufferLength) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var jpegImage = new _jpg.JpegImage();
Kode lerroa:     var decodeArr = this.dict.getArray('Decode', 'D');
Kode lerroa:     if (this.forceRGB && Array.isArray(decodeArr)) {
Kode lerroa:       var bitsPerComponent = this.dict.get('BitsPerComponent') || 8;
Kode lerroa:       var decodeArrLength = decodeArr.length;
Kode lerroa:       var transform = new Int32Array(decodeArrLength);
Kode lerroa:       var transformNeeded = false;
Kode lerroa:       var maxValue = (1 << bitsPerComponent) - 1;
Kode lerroa:       for (var i = 0; i < decodeArrLength; i += 2) {
Kode lerroa:         transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
Kode lerroa:         transform[i + 1] = decodeArr[i] * maxValue | 0;
Kode lerroa:         if (transform[i] !== 256 || transform[i + 1] !== 0) {
Kode lerroa:           transformNeeded = true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (transformNeeded) {
Kode lerroa:         jpegImage.decodeTransform = transform;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if ((0, _primitives.isDict)(this.params)) {
Kode lerroa:       var colorTransform = this.params.get('ColorTransform');
Kode lerroa:       if (Number.isInteger(colorTransform)) {
Kode lerroa:         jpegImage.colorTransform = colorTransform;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     jpegImage.parse(this.bytes);
Kode lerroa:     var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
Kode lerroa:     this.buffer = data;
Kode lerroa:     this.bufferLength = data.length;
Kode lerroa:     this.eof = true;
Kode lerroa:   };
Kode lerroa:   JpegStream.prototype.getBytes = function JpegStream_getBytes(length) {
Kode lerroa:     this.ensureBuffer();
Kode lerroa:     return this.buffer;
Kode lerroa:   };
Kode lerroa:   JpegStream.prototype.getIR = function JpegStream_getIR(forceDataSchema) {
Kode lerroa:     return (0, _util.createObjectURL)(this.bytes, 'image/jpeg', forceDataSchema);
Kode lerroa:   };
Kode lerroa:   return JpegStream;
Kode lerroa: }();
Kode lerroa: var JpxStream = function JpxStreamClosure() {
Kode lerroa:   function JpxStream(stream, maybeLength, dict, params) {
Kode lerroa:     this.stream = stream;
Kode lerroa:     this.maybeLength = maybeLength;
Kode lerroa:     this.dict = dict;
Kode lerroa:     this.params = params;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   JpxStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   Object.defineProperty(JpxStream.prototype, 'bytes', {
Kode lerroa:     get: function JpxStream_bytes() {
Kode lerroa:       return (0, _util.shadow)(this, 'bytes', this.stream.getBytes(this.maybeLength));
Kode lerroa:     },
Kode lerroa:     configurable: true
Kode lerroa:   });
Kode lerroa:   JpxStream.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
Kode lerroa:     if (this.bufferLength) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var jpxImage = new _jpx.JpxImage();
Kode lerroa:     jpxImage.parse(this.bytes);
Kode lerroa:     var width = jpxImage.width;
Kode lerroa:     var height = jpxImage.height;
Kode lerroa:     var componentsCount = jpxImage.componentsCount;
Kode lerroa:     var tileCount = jpxImage.tiles.length;
Kode lerroa:     if (tileCount === 1) {
Kode lerroa:       this.buffer = jpxImage.tiles[0].items;
Kode lerroa:     } else {
Kode lerroa:       var data = new Uint8ClampedArray(width * height * componentsCount);
Kode lerroa:       for (var k = 0; k < tileCount; k++) {
Kode lerroa:         var tileComponents = jpxImage.tiles[k];
Kode lerroa:         var tileWidth = tileComponents.width;
Kode lerroa:         var tileHeight = tileComponents.height;
Kode lerroa:         var tileLeft = tileComponents.left;
Kode lerroa:         var tileTop = tileComponents.top;
Kode lerroa:         var src = tileComponents.items;
Kode lerroa:         var srcPosition = 0;
Kode lerroa:         var dataPosition = (width * tileTop + tileLeft) * componentsCount;
Kode lerroa:         var imgRowSize = width * componentsCount;
Kode lerroa:         var tileRowSize = tileWidth * componentsCount;
Kode lerroa:         for (var j = 0; j < tileHeight; j++) {
Kode lerroa:           var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
Kode lerroa:           data.set(rowBytes, dataPosition);
Kode lerroa:           srcPosition += tileRowSize;
Kode lerroa:           dataPosition += imgRowSize;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.buffer = data;
Kode lerroa:     }
Kode lerroa:     this.bufferLength = this.buffer.length;
Kode lerroa:     this.eof = true;
Kode lerroa:   };
Kode lerroa:   return JpxStream;
Kode lerroa: }();
Kode lerroa: var DecryptStream = function DecryptStreamClosure() {
Kode lerroa:   function DecryptStream(str, maybeLength, decrypt) {
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     this.decrypt = decrypt;
Kode lerroa:     this.nextChunk = null;
Kode lerroa:     this.initialized = false;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   var chunkSize = 512;
Kode lerroa:   DecryptStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   DecryptStream.prototype.readBlock = function DecryptStream_readBlock() {
Kode lerroa:     var chunk;
Kode lerroa:     if (this.initialized) {
Kode lerroa:       chunk = this.nextChunk;
Kode lerroa:     } else {
Kode lerroa:       chunk = this.str.getBytes(chunkSize);
Kode lerroa:       this.initialized = true;
Kode lerroa:     }
Kode lerroa:     if (!chunk || chunk.length === 0) {
Kode lerroa:       this.eof = true;
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.nextChunk = this.str.getBytes(chunkSize);
Kode lerroa:     var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
Kode lerroa:     var decrypt = this.decrypt;
Kode lerroa:     chunk = decrypt(chunk, !hasMoreData);
Kode lerroa:     var bufferLength = this.bufferLength;
Kode lerroa:     var i,
Kode lerroa:         n = chunk.length;
Kode lerroa:     var buffer = this.ensureBuffer(bufferLength + n);
Kode lerroa:     for (i = 0; i < n; i++) {
Kode lerroa:       buffer[bufferLength++] = chunk[i];
Kode lerroa:     }
Kode lerroa:     this.bufferLength = bufferLength;
Kode lerroa:   };
Kode lerroa:   return DecryptStream;
Kode lerroa: }();
Kode lerroa: var Ascii85Stream = function Ascii85StreamClosure() {
Kode lerroa:   function Ascii85Stream(str, maybeLength) {
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     this.input = new Uint8Array(5);
Kode lerroa:     if (maybeLength) {
Kode lerroa:       maybeLength = 0.8 * maybeLength;
Kode lerroa:     }
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   Ascii85Stream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   Ascii85Stream.prototype.readBlock = function Ascii85Stream_readBlock() {
Kode lerroa:     var TILDA_CHAR = 0x7E;
Kode lerroa:     var Z_LOWER_CHAR = 0x7A;
Kode lerroa:     var EOF = -1;
Kode lerroa:     var str = this.str;
Kode lerroa:     var c = str.getByte();
Kode lerroa:     while ((0, _util.isSpace)(c)) {
Kode lerroa:       c = str.getByte();
Kode lerroa:     }
Kode lerroa:     if (c === EOF || c === TILDA_CHAR) {
Kode lerroa:       this.eof = true;
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var bufferLength = this.bufferLength,
Kode lerroa:         buffer;
Kode lerroa:     var i;
Kode lerroa:     if (c === Z_LOWER_CHAR) {
Kode lerroa:       buffer = this.ensureBuffer(bufferLength + 4);
Kode lerroa:       for (i = 0; i < 4; ++i) {
Kode lerroa:         buffer[bufferLength + i] = 0;
Kode lerroa:       }
Kode lerroa:       this.bufferLength += 4;
Kode lerroa:     } else {
Kode lerroa:       var input = this.input;
Kode lerroa:       input[0] = c;
Kode lerroa:       for (i = 1; i < 5; ++i) {
Kode lerroa:         c = str.getByte();
Kode lerroa:         while ((0, _util.isSpace)(c)) {
Kode lerroa:           c = str.getByte();
Kode lerroa:         }
Kode lerroa:         input[i] = c;
Kode lerroa:         if (c === EOF || c === TILDA_CHAR) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       buffer = this.ensureBuffer(bufferLength + i - 1);
Kode lerroa:       this.bufferLength += i - 1;
Kode lerroa:       if (i < 5) {
Kode lerroa:         for (; i < 5; ++i) {
Kode lerroa:           input[i] = 0x21 + 84;
Kode lerroa:         }
Kode lerroa:         this.eof = true;
Kode lerroa:       }
Kode lerroa:       var t = 0;
Kode lerroa:       for (i = 0; i < 5; ++i) {
Kode lerroa:         t = t * 85 + (input[i] - 0x21);
Kode lerroa:       }
Kode lerroa:       for (i = 3; i >= 0; --i) {
Kode lerroa:         buffer[bufferLength + i] = t & 0xFF;
Kode lerroa:         t >>= 8;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Ascii85Stream;
Kode lerroa: }();
Kode lerroa: var AsciiHexStream = function AsciiHexStreamClosure() {
Kode lerroa:   function AsciiHexStream(str, maybeLength) {
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     this.firstDigit = -1;
Kode lerroa:     if (maybeLength) {
Kode lerroa:       maybeLength = 0.5 * maybeLength;
Kode lerroa:     }
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   AsciiHexStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   AsciiHexStream.prototype.readBlock = function AsciiHexStream_readBlock() {
Kode lerroa:     var UPSTREAM_BLOCK_SIZE = 8000;
Kode lerroa:     var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
Kode lerroa:     if (!bytes.length) {
Kode lerroa:       this.eof = true;
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var maxDecodeLength = bytes.length + 1 >> 1;
Kode lerroa:     var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
Kode lerroa:     var bufferLength = this.bufferLength;
Kode lerroa:     var firstDigit = this.firstDigit;
Kode lerroa:     for (var i = 0, ii = bytes.length; i < ii; i++) {
Kode lerroa:       var ch = bytes[i],
Kode lerroa:           digit;
Kode lerroa:       if (ch >= 0x30 && ch <= 0x39) {
Kode lerroa:         digit = ch & 0x0F;
Kode lerroa:       } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
Kode lerroa:         digit = (ch & 0x0F) + 9;
Kode lerroa:       } else if (ch === 0x3E) {
Kode lerroa:         this.eof = true;
Kode lerroa:         break;
Kode lerroa:       } else {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       if (firstDigit < 0) {
Kode lerroa:         firstDigit = digit;
Kode lerroa:       } else {
Kode lerroa:         buffer[bufferLength++] = firstDigit << 4 | digit;
Kode lerroa:         firstDigit = -1;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (firstDigit >= 0 && this.eof) {
Kode lerroa:       buffer[bufferLength++] = firstDigit << 4;
Kode lerroa:       firstDigit = -1;
Kode lerroa:     }
Kode lerroa:     this.firstDigit = firstDigit;
Kode lerroa:     this.bufferLength = bufferLength;
Kode lerroa:   };
Kode lerroa:   return AsciiHexStream;
Kode lerroa: }();
Kode lerroa: var RunLengthStream = function RunLengthStreamClosure() {
Kode lerroa:   function RunLengthStream(str, maybeLength) {
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   RunLengthStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   RunLengthStream.prototype.readBlock = function RunLengthStream_readBlock() {
Kode lerroa:     var repeatHeader = this.str.getBytes(2);
Kode lerroa:     if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
Kode lerroa:       this.eof = true;
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var buffer;
Kode lerroa:     var bufferLength = this.bufferLength;
Kode lerroa:     var n = repeatHeader[0];
Kode lerroa:     if (n < 128) {
Kode lerroa:       buffer = this.ensureBuffer(bufferLength + n + 1);
Kode lerroa:       buffer[bufferLength++] = repeatHeader[1];
Kode lerroa:       if (n > 0) {
Kode lerroa:         var source = this.str.getBytes(n);
Kode lerroa:         buffer.set(source, bufferLength);
Kode lerroa:         bufferLength += n;
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       n = 257 - n;
Kode lerroa:       var b = repeatHeader[1];
Kode lerroa:       buffer = this.ensureBuffer(bufferLength + n + 1);
Kode lerroa:       for (var i = 0; i < n; i++) {
Kode lerroa:         buffer[bufferLength++] = b;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     this.bufferLength = bufferLength;
Kode lerroa:   };
Kode lerroa:   return RunLengthStream;
Kode lerroa: }();
Kode lerroa: var LZWStream = function LZWStreamClosure() {
Kode lerroa:   function LZWStream(str, maybeLength, earlyChange) {
Kode lerroa:     this.str = str;
Kode lerroa:     this.dict = str.dict;
Kode lerroa:     this.cachedData = 0;
Kode lerroa:     this.bitsCached = 0;
Kode lerroa:     var maxLzwDictionarySize = 4096;
Kode lerroa:     var lzwState = {
Kode lerroa:       earlyChange: earlyChange,
Kode lerroa:       codeLength: 9,
Kode lerroa:       nextCode: 258,
Kode lerroa:       dictionaryValues: new Uint8Array(maxLzwDictionarySize),
Kode lerroa:       dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
Kode lerroa:       dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
Kode lerroa:       currentSequence: new Uint8Array(maxLzwDictionarySize),
Kode lerroa:       currentSequenceLength: 0
Kode lerroa:     };
Kode lerroa:     for (var i = 0; i < 256; ++i) {
Kode lerroa:       lzwState.dictionaryValues[i] = i;
Kode lerroa:       lzwState.dictionaryLengths[i] = 1;
Kode lerroa:     }
Kode lerroa:     this.lzwState = lzwState;
Kode lerroa:     DecodeStream.call(this, maybeLength);
Kode lerroa:   }
Kode lerroa:   LZWStream.prototype = Object.create(DecodeStream.prototype);
Kode lerroa:   LZWStream.prototype.readBits = function LZWStream_readBits(n) {
Kode lerroa:     var bitsCached = this.bitsCached;
Kode lerroa:     var cachedData = this.cachedData;
Kode lerroa:     while (bitsCached < n) {
Kode lerroa:       var c = this.str.getByte();
Kode lerroa:       if (c === -1) {
Kode lerroa:         this.eof = true;
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       cachedData = cachedData << 8 | c;
Kode lerroa:       bitsCached += 8;
Kode lerroa:     }
Kode lerroa:     this.bitsCached = bitsCached -= n;
Kode lerroa:     this.cachedData = cachedData;
Kode lerroa:     this.lastCode = null;
Kode lerroa:     return cachedData >>> bitsCached & (1 << n) - 1;
Kode lerroa:   };
Kode lerroa:   LZWStream.prototype.readBlock = function LZWStream_readBlock() {
Kode lerroa:     var blockSize = 512;
Kode lerroa:     var estimatedDecodedSize = blockSize * 2,
Kode lerroa:         decodedSizeDelta = blockSize;
Kode lerroa:     var i, j, q;
Kode lerroa:     var lzwState = this.lzwState;
Kode lerroa:     if (!lzwState) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var earlyChange = lzwState.earlyChange;
Kode lerroa:     var nextCode = lzwState.nextCode;
Kode lerroa:     var dictionaryValues = lzwState.dictionaryValues;
Kode lerroa:     var dictionaryLengths = lzwState.dictionaryLengths;
Kode lerroa:     var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
Kode lerroa:     var codeLength = lzwState.codeLength;
Kode lerroa:     var prevCode = lzwState.prevCode;
Kode lerroa:     var currentSequence = lzwState.currentSequence;
Kode lerroa:     var currentSequenceLength = lzwState.currentSequenceLength;
Kode lerroa:     var decodedLength = 0;
Kode lerroa:     var currentBufferLength = this.bufferLength;
Kode lerroa:     var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
Kode lerroa:     for (i = 0; i < blockSize; i++) {
Kode lerroa:       var code = this.readBits(codeLength);
Kode lerroa:       var hasPrev = currentSequenceLength > 0;
Kode lerroa:       if (code < 256) {
Kode lerroa:         currentSequence[0] = code;
Kode lerroa:         currentSequenceLength = 1;
Kode lerroa:       } else if (code >= 258) {
Kode lerroa:         if (code < nextCode) {
Kode lerroa:           currentSequenceLength = dictionaryLengths[code];
Kode lerroa:           for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
Kode lerroa:             currentSequence[j] = dictionaryValues[q];
Kode lerroa:             q = dictionaryPrevCodes[q];
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           currentSequence[currentSequenceLength++] = currentSequence[0];
Kode lerroa:         }
Kode lerroa:       } else if (code === 256) {
Kode lerroa:         codeLength = 9;
Kode lerroa:         nextCode = 258;
Kode lerroa:         currentSequenceLength = 0;
Kode lerroa:         continue;
Kode lerroa:       } else {
Kode lerroa:         this.eof = true;
Kode lerroa:         delete this.lzwState;
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       if (hasPrev) {
Kode lerroa:         dictionaryPrevCodes[nextCode] = prevCode;
Kode lerroa:         dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
Kode lerroa:         dictionaryValues[nextCode] = currentSequence[0];
Kode lerroa:         nextCode++;
Kode lerroa:         codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
Kode lerroa:       }
Kode lerroa:       prevCode = code;
Kode lerroa:       decodedLength += currentSequenceLength;
Kode lerroa:       if (estimatedDecodedSize < decodedLength) {
Kode lerroa:         do {
Kode lerroa:           estimatedDecodedSize += decodedSizeDelta;
Kode lerroa:         } while (estimatedDecodedSize < decodedLength);
Kode lerroa:         buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
Kode lerroa:       }
Kode lerroa:       for (j = 0; j < currentSequenceLength; j++) {
Kode lerroa:         buffer[currentBufferLength++] = currentSequence[j];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     lzwState.nextCode = nextCode;
Kode lerroa:     lzwState.codeLength = codeLength;
Kode lerroa:     lzwState.prevCode = prevCode;
Kode lerroa:     lzwState.currentSequenceLength = currentSequenceLength;
Kode lerroa:     this.bufferLength = currentBufferLength;
Kode lerroa:   };
Kode lerroa:   return LZWStream;
Kode lerroa: }();
Kode lerroa: var NullStream = function NullStreamClosure() {
Kode lerroa:   function NullStream() {
Kode lerroa:     Stream.call(this, new Uint8Array(0));
Kode lerroa:   }
Kode lerroa:   NullStream.prototype = Stream.prototype;
Kode lerroa:   return NullStream;
Kode lerroa: }();
Kode lerroa: exports.Ascii85Stream = Ascii85Stream;
Kode lerroa: exports.AsciiHexStream = AsciiHexStream;
Kode lerroa: exports.DecryptStream = DecryptStream;
Kode lerroa: exports.DecodeStream = DecodeStream;
Kode lerroa: exports.FlateStream = FlateStream;
Kode lerroa: exports.JpegStream = JpegStream;
Kode lerroa: exports.JpxStream = JpxStream;
Kode lerroa: exports.NullStream = NullStream;
Kode lerroa: exports.PredictorStream = PredictorStream;
Kode lerroa: exports.RunLengthStream = RunLengthStream;
Kode lerroa: exports.Stream = Stream;
Kode lerroa: exports.StreamsSequenceStream = StreamsSequenceStream;
Kode lerroa: exports.StringStream = StringStream;
Kode lerroa: exports.LZWStream = LZWStream;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 6 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var core = module.exports = { version: '2.5.7' };
Kode lerroa: if (typeof __e == 'number') __e = core;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 7 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var core = __w_pdfjs_require__(6);
Kode lerroa: var hide = __w_pdfjs_require__(8);
Kode lerroa: var redefine = __w_pdfjs_require__(16);
Kode lerroa: var ctx = __w_pdfjs_require__(13);
Kode lerroa: var PROTOTYPE = 'prototype';
Kode lerroa: var $export = function $export(type, name, source) {
Kode lerroa:   var IS_FORCED = type & $export.F;
Kode lerroa:   var IS_GLOBAL = type & $export.G;
Kode lerroa:   var IS_STATIC = type & $export.S;
Kode lerroa:   var IS_PROTO = type & $export.P;
Kode lerroa:   var IS_BIND = type & $export.B;
Kode lerroa:   var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
Kode lerroa:   var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
Kode lerroa:   var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
Kode lerroa:   var key, own, out, exp;
Kode lerroa:   if (IS_GLOBAL) source = name;
Kode lerroa:   for (key in source) {
Kode lerroa:     own = !IS_FORCED && target && target[key] !== undefined;
Kode lerroa:     out = (own ? target : source)[key];
Kode lerroa:     exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
Kode lerroa:     if (target) redefine(target, key, out, type & $export.U);
Kode lerroa:     if (exports[key] != out) hide(exports, key, exp);
Kode lerroa:     if (IS_PROTO && expProto[key] != out) expProto[key] = out;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: global.core = core;
Kode lerroa: $export.F = 1;
Kode lerroa: $export.G = 2;
Kode lerroa: $export.S = 4;
Kode lerroa: $export.P = 8;
Kode lerroa: $export.B = 16;
Kode lerroa: $export.W = 32;
Kode lerroa: $export.U = 64;
Kode lerroa: $export.R = 128;
Kode lerroa: module.exports = $export;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 8 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var dP = __w_pdfjs_require__(15);
Kode lerroa: var createDesc = __w_pdfjs_require__(29);
Kode lerroa: module.exports = __w_pdfjs_require__(10) ? function (object, key, value) {
Kode lerroa:   return dP.f(object, key, createDesc(1, value));
Kode lerroa: } : function (object, key, value) {
Kode lerroa:   object[key] = value;
Kode lerroa:   return object;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 9 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(3);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (!isObject(it)) throw TypeError(it + ' is not an object!');
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 10 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = !__w_pdfjs_require__(11)(function () {
Kode lerroa:   return Object.defineProperty({}, 'a', {
Kode lerroa:     get: function get() {
Kode lerroa:       return 7;
Kode lerroa:     }
Kode lerroa:   }).a != 7;
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 11 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (exec) {
Kode lerroa:   try {
Kode lerroa:     return !!exec();
Kode lerroa:   } catch (e) {
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 12 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var hasOwnProperty = {}.hasOwnProperty;
Kode lerroa: module.exports = function (it, key) {
Kode lerroa:   return hasOwnProperty.call(it, key);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 13 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: module.exports = function (fn, that, length) {
Kode lerroa:   aFunction(fn);
Kode lerroa:   if (that === undefined) return fn;
Kode lerroa:   switch (length) {
Kode lerroa:     case 1:
Kode lerroa:       return function (a) {
Kode lerroa:         return fn.call(that, a);
Kode lerroa:       };
Kode lerroa:     case 2:
Kode lerroa:       return function (a, b) {
Kode lerroa:         return fn.call(that, a, b);
Kode lerroa:       };
Kode lerroa:     case 3:
Kode lerroa:       return function (a, b, c) {
Kode lerroa:         return fn.call(that, a, b, c);
Kode lerroa:       };
Kode lerroa:   }
Kode lerroa:   return function () {
Kode lerroa:     return fn.apply(that, arguments);
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 14 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(18);
Kode lerroa: var min = Math.min;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 15 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(9);
Kode lerroa: var IE8_DOM_DEFINE = __w_pdfjs_require__(48);
Kode lerroa: var toPrimitive = __w_pdfjs_require__(36);
Kode lerroa: var dP = Object.defineProperty;
Kode lerroa: exports.f = __w_pdfjs_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
Kode lerroa:   anObject(O);
Kode lerroa:   P = toPrimitive(P, true);
Kode lerroa:   anObject(Attributes);
Kode lerroa:   if (IE8_DOM_DEFINE) try {
Kode lerroa:     return dP(O, P, Attributes);
Kode lerroa:   } catch (e) {}
Kode lerroa:   if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
Kode lerroa:   if ('value' in Attributes) O[P] = Attributes.value;
Kode lerroa:   return O;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 16 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var hide = __w_pdfjs_require__(8);
Kode lerroa: var has = __w_pdfjs_require__(12);
Kode lerroa: var SRC = __w_pdfjs_require__(17)('src');
Kode lerroa: var TO_STRING = 'toString';
Kode lerroa: var $toString = Function[TO_STRING];
Kode lerroa: var TPL = ('' + $toString).split(TO_STRING);
Kode lerroa: __w_pdfjs_require__(6).inspectSource = function (it) {
Kode lerroa:   return $toString.call(it);
Kode lerroa: };
Kode lerroa: (module.exports = function (O, key, val, safe) {
Kode lerroa:   var isFunction = typeof val == 'function';
Kode lerroa:   if (isFunction) has(val, 'name') || hide(val, 'name', key);
Kode lerroa:   if (O[key] === val) return;
Kode lerroa:   if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
Kode lerroa:   if (O === global) {
Kode lerroa:     O[key] = val;
Kode lerroa:   } else if (!safe) {
Kode lerroa:     delete O[key];
Kode lerroa:     hide(O, key, val);
Kode lerroa:   } else if (O[key]) {
Kode lerroa:     O[key] = val;
Kode lerroa:   } else {
Kode lerroa:     hide(O, key, val);
Kode lerroa:   }
Kode lerroa: })(Function.prototype, TO_STRING, function toString() {
Kode lerroa:   return typeof this == 'function' && this[SRC] || $toString.call(this);
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 17 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var id = 0;
Kode lerroa: var px = Math.random();
Kode lerroa: module.exports = function (key) {
Kode lerroa:   return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 18 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ceil = Math.ceil;
Kode lerroa: var floor = Math.floor;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 19 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var defined = __w_pdfjs_require__(38);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return Object(defined(it));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 20 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = {};
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 21 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = false;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 22 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (typeof it != 'function') throw TypeError(it + ' is not a function!');
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 23 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var redefine = __w_pdfjs_require__(16);
Kode lerroa: module.exports = function (target, src, safe) {
Kode lerroa:   for (var key in src) {
Kode lerroa:     redefine(target, key, src[key], safe);
Kode lerroa:   }return target;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 24 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (it, Constructor, name, forbiddenField) {
Kode lerroa:   if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
Kode lerroa:     throw TypeError(name + ': incorrect invocation!');
Kode lerroa:   }
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 25 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toString = {}.toString;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return toString.call(it).slice(8, -1);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 26 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var def = __w_pdfjs_require__(15).f;
Kode lerroa: var has = __w_pdfjs_require__(12);
Kode lerroa: var TAG = __w_pdfjs_require__(4)('toStringTag');
Kode lerroa: module.exports = function (it, tag, stat) {
Kode lerroa:   if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
Kode lerroa:     configurable: true,
Kode lerroa:     value: tag
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 27 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.ColorSpace = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var ColorSpace = function ColorSpaceClosure() {
Kode lerroa:   function resizeRgbImage(src, bpc, w1, h1, w2, h2, alpha01, dest) {
Kode lerroa:     var COMPONENTS = 3;
Kode lerroa:     alpha01 = alpha01 !== 1 ? 0 : alpha01;
Kode lerroa:     var xRatio = w1 / w2;
Kode lerroa:     var yRatio = h1 / h2;
Kode lerroa:     var i,
Kode lerroa:         j,
Kode lerroa:         py,
Kode lerroa:         newIndex = 0,
Kode lerroa:         oldIndex;
Kode lerroa:     var xScaled = new Uint16Array(w2);
Kode lerroa:     var w1Scanline = w1 * COMPONENTS;
Kode lerroa:     for (i = 0; i < w2; i++) {
Kode lerroa:       xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
Kode lerroa:     }
Kode lerroa:     for (i = 0; i < h2; i++) {
Kode lerroa:       py = Math.floor(i * yRatio) * w1Scanline;
Kode lerroa:       for (j = 0; j < w2; j++) {
Kode lerroa:         oldIndex = py + xScaled[j];
Kode lerroa:         dest[newIndex++] = src[oldIndex++];
Kode lerroa:         dest[newIndex++] = src[oldIndex++];
Kode lerroa:         dest[newIndex++] = src[oldIndex++];
Kode lerroa:         newIndex += alpha01;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ColorSpace() {
Kode lerroa:     throw new Error('should not call ColorSpace constructor');
Kode lerroa:   }
Kode lerroa:   ColorSpace.prototype = {
Kode lerroa:     getRgb: function ColorSpace_getRgb(src, srcOffset) {
Kode lerroa:       var rgb = new Uint8Array(3);
Kode lerroa:       this.getRgbItem(src, srcOffset, rgb, 0);
Kode lerroa:       return rgb;
Kode lerroa:     },
Kode lerroa:     getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       throw new Error('Should not call ColorSpace.getRgbItem');
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       throw new Error('Should not call ColorSpace.getRgbBuffer');
Kode lerroa:     },
Kode lerroa:     getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
Kode lerroa:       throw new Error('Should not call ColorSpace.getOutputLength');
Kode lerroa:     },
Kode lerroa:     isPassthrough: function ColorSpace_isPassthrough(bits) {
Kode lerroa:       return false;
Kode lerroa:     },
Kode lerroa:     fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
Kode lerroa:       var count = originalWidth * originalHeight;
Kode lerroa:       var rgbBuf = null;
Kode lerroa:       var numComponentColors = 1 << bpc;
Kode lerroa:       var needsResizing = originalHeight !== height || originalWidth !== width;
Kode lerroa:       var i, ii;
Kode lerroa:       if (this.isPassthrough(bpc)) {
Kode lerroa:         rgbBuf = comps;
Kode lerroa:       } else if (this.numComps === 1 && count > numComponentColors && this.name !== 'DeviceGray' && this.name !== 'DeviceRGB') {
Kode lerroa:         var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
Kode lerroa:         var key;
Kode lerroa:         for (i = 0; i < numComponentColors; i++) {
Kode lerroa:           allColors[i] = i;
Kode lerroa:         }
Kode lerroa:         var colorMap = new Uint8Array(numComponentColors * 3);
Kode lerroa:         this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
Kode lerroa:         var destPos, rgbPos;
Kode lerroa:         if (!needsResizing) {
Kode lerroa:           destPos = 0;
Kode lerroa:           for (i = 0; i < count; ++i) {
Kode lerroa:             key = comps[i] * 3;
Kode lerroa:             dest[destPos++] = colorMap[key];
Kode lerroa:             dest[destPos++] = colorMap[key + 1];
Kode lerroa:             dest[destPos++] = colorMap[key + 2];
Kode lerroa:             destPos += alpha01;
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           rgbBuf = new Uint8Array(count * 3);
Kode lerroa:           rgbPos = 0;
Kode lerroa:           for (i = 0; i < count; ++i) {
Kode lerroa:             key = comps[i] * 3;
Kode lerroa:             rgbBuf[rgbPos++] = colorMap[key];
Kode lerroa:             rgbBuf[rgbPos++] = colorMap[key + 1];
Kode lerroa:             rgbBuf[rgbPos++] = colorMap[key + 2];
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (!needsResizing) {
Kode lerroa:           this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
Kode lerroa:         } else {
Kode lerroa:           rgbBuf = new Uint8Array(count * 3);
Kode lerroa:           this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (rgbBuf) {
Kode lerroa:         if (needsResizing) {
Kode lerroa:           resizeRgbImage(rgbBuf, bpc, originalWidth, originalHeight, width, height, alpha01, dest);
Kode lerroa:         } else {
Kode lerroa:           rgbPos = 0;
Kode lerroa:           destPos = 0;
Kode lerroa:           for (i = 0, ii = width * actualHeight; i < ii; i++) {
Kode lerroa:             dest[destPos++] = rgbBuf[rgbPos++];
Kode lerroa:             dest[destPos++] = rgbBuf[rgbPos++];
Kode lerroa:             dest[destPos++] = rgbBuf[rgbPos++];
Kode lerroa:             destPos += alpha01;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   ColorSpace.parse = function (cs, xref, res, pdfFunctionFactory) {
Kode lerroa:     var IR = ColorSpace.parseToIR(cs, xref, res, pdfFunctionFactory);
Kode lerroa:     return ColorSpace.fromIR(IR);
Kode lerroa:   };
Kode lerroa:   ColorSpace.fromIR = function (IR) {
Kode lerroa:     var name = Array.isArray(IR) ? IR[0] : IR;
Kode lerroa:     var whitePoint, blackPoint, gamma;
Kode lerroa:     switch (name) {
Kode lerroa:       case 'DeviceGrayCS':
Kode lerroa:         return this.singletons.gray;
Kode lerroa:       case 'DeviceRgbCS':
Kode lerroa:         return this.singletons.rgb;
Kode lerroa:       case 'DeviceCmykCS':
Kode lerroa:         return this.singletons.cmyk;
Kode lerroa:       case 'CalGrayCS':
Kode lerroa:         whitePoint = IR[1];
Kode lerroa:         blackPoint = IR[2];
Kode lerroa:         gamma = IR[3];
Kode lerroa:         return new CalGrayCS(whitePoint, blackPoint, gamma);
Kode lerroa:       case 'CalRGBCS':
Kode lerroa:         whitePoint = IR[1];
Kode lerroa:         blackPoint = IR[2];
Kode lerroa:         gamma = IR[3];
Kode lerroa:         var matrix = IR[4];
Kode lerroa:         return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
Kode lerroa:       case 'PatternCS':
Kode lerroa:         var basePatternCS = IR[1];
Kode lerroa:         if (basePatternCS) {
Kode lerroa:           basePatternCS = ColorSpace.fromIR(basePatternCS);
Kode lerroa:         }
Kode lerroa:         return new PatternCS(basePatternCS);
Kode lerroa:       case 'IndexedCS':
Kode lerroa:         var baseIndexedCS = IR[1];
Kode lerroa:         var hiVal = IR[2];
Kode lerroa:         var lookup = IR[3];
Kode lerroa:         return new IndexedCS(ColorSpace.fromIR(baseIndexedCS), hiVal, lookup);
Kode lerroa:       case 'AlternateCS':
Kode lerroa:         var numComps = IR[1];
Kode lerroa:         var alt = IR[2];
Kode lerroa:         var tintFn = IR[3];
Kode lerroa:         return new AlternateCS(numComps, ColorSpace.fromIR(alt), tintFn);
Kode lerroa:       case 'LabCS':
Kode lerroa:         whitePoint = IR[1];
Kode lerroa:         blackPoint = IR[2];
Kode lerroa:         var range = IR[3];
Kode lerroa:         return new LabCS(whitePoint, blackPoint, range);
Kode lerroa:       default:
Kode lerroa:         throw new _util.FormatError('Unknown colorspace name: ' + name);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   ColorSpace.parseToIR = function (cs, xref, res, pdfFunctionFactory) {
Kode lerroa:     if ((0, _primitives.isName)(cs)) {
Kode lerroa:       var colorSpaces = res.get('ColorSpace');
Kode lerroa:       if ((0, _primitives.isDict)(colorSpaces)) {
Kode lerroa:         var refcs = colorSpaces.get(cs.name);
Kode lerroa:         if (refcs) {
Kode lerroa:           cs = refcs;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     cs = xref.fetchIfRef(cs);
Kode lerroa:     if ((0, _primitives.isName)(cs)) {
Kode lerroa:       switch (cs.name) {
Kode lerroa:         case 'DeviceGray':
Kode lerroa:         case 'G':
Kode lerroa:           return 'DeviceGrayCS';
Kode lerroa:         case 'DeviceRGB':
Kode lerroa:         case 'RGB':
Kode lerroa:           return 'DeviceRgbCS';
Kode lerroa:         case 'DeviceCMYK':
Kode lerroa:         case 'CMYK':
Kode lerroa:           return 'DeviceCmykCS';
Kode lerroa:         case 'Pattern':
Kode lerroa:           return ['PatternCS', null];
Kode lerroa:         default:
Kode lerroa:           throw new _util.FormatError('unrecognized colorspace ' + cs.name);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (Array.isArray(cs)) {
Kode lerroa:       var mode = xref.fetchIfRef(cs[0]).name;
Kode lerroa:       var numComps, params, alt, whitePoint, blackPoint, gamma;
Kode lerroa:       switch (mode) {
Kode lerroa:         case 'DeviceGray':
Kode lerroa:         case 'G':
Kode lerroa:           return 'DeviceGrayCS';
Kode lerroa:         case 'DeviceRGB':
Kode lerroa:         case 'RGB':
Kode lerroa:           return 'DeviceRgbCS';
Kode lerroa:         case 'DeviceCMYK':
Kode lerroa:         case 'CMYK':
Kode lerroa:           return 'DeviceCmykCS';
Kode lerroa:         case 'CalGray':
Kode lerroa:           params = xref.fetchIfRef(cs[1]);
Kode lerroa:           whitePoint = params.getArray('WhitePoint');
Kode lerroa:           blackPoint = params.getArray('BlackPoint');
Kode lerroa:           gamma = params.get('Gamma');
Kode lerroa:           return ['CalGrayCS', whitePoint, blackPoint, gamma];
Kode lerroa:         case 'CalRGB':
Kode lerroa:           params = xref.fetchIfRef(cs[1]);
Kode lerroa:           whitePoint = params.getArray('WhitePoint');
Kode lerroa:           blackPoint = params.getArray('BlackPoint');
Kode lerroa:           gamma = params.getArray('Gamma');
Kode lerroa:           var matrix = params.getArray('Matrix');
Kode lerroa:           return ['CalRGBCS', whitePoint, blackPoint, gamma, matrix];
Kode lerroa:         case 'ICCBased':
Kode lerroa:           var stream = xref.fetchIfRef(cs[1]);
Kode lerroa:           var dict = stream.dict;
Kode lerroa:           numComps = dict.get('N');
Kode lerroa:           alt = dict.get('Alternate');
Kode lerroa:           if (alt) {
Kode lerroa:             var altIR = ColorSpace.parseToIR(alt, xref, res, pdfFunctionFactory);
Kode lerroa:             var altCS = ColorSpace.fromIR(altIR, pdfFunctionFactory);
Kode lerroa:             if (altCS.numComps === numComps) {
Kode lerroa:               return altIR;
Kode lerroa:             }
Kode lerroa:             (0, _util.warn)('ICCBased color space: Ignoring incorrect /Alternate entry.');
Kode lerroa:           }
Kode lerroa:           if (numComps === 1) {
Kode lerroa:             return 'DeviceGrayCS';
Kode lerroa:           } else if (numComps === 3) {
Kode lerroa:             return 'DeviceRgbCS';
Kode lerroa:           } else if (numComps === 4) {
Kode lerroa:             return 'DeviceCmykCS';
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'Pattern':
Kode lerroa:           var basePatternCS = cs[1] || null;
Kode lerroa:           if (basePatternCS) {
Kode lerroa:             basePatternCS = ColorSpace.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
Kode lerroa:           }
Kode lerroa:           return ['PatternCS', basePatternCS];
Kode lerroa:         case 'Indexed':
Kode lerroa:         case 'I':
Kode lerroa:           var baseIndexedCS = ColorSpace.parseToIR(cs[1], xref, res, pdfFunctionFactory);
Kode lerroa:           var hiVal = xref.fetchIfRef(cs[2]) + 1;
Kode lerroa:           var lookup = xref.fetchIfRef(cs[3]);
Kode lerroa:           if ((0, _primitives.isStream)(lookup)) {
Kode lerroa:             lookup = lookup.getBytes();
Kode lerroa:           }
Kode lerroa:           return ['IndexedCS', baseIndexedCS, hiVal, lookup];
Kode lerroa:         case 'Separation':
Kode lerroa:         case 'DeviceN':
Kode lerroa:           var name = xref.fetchIfRef(cs[1]);
Kode lerroa:           numComps = Array.isArray(name) ? name.length : 1;
Kode lerroa:           alt = ColorSpace.parseToIR(cs[2], xref, res, pdfFunctionFactory);
Kode lerroa:           var tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
Kode lerroa:           return ['AlternateCS', numComps, alt, tintFn];
Kode lerroa:         case 'Lab':
Kode lerroa:           params = xref.fetchIfRef(cs[1]);
Kode lerroa:           whitePoint = params.getArray('WhitePoint');
Kode lerroa:           blackPoint = params.getArray('BlackPoint');
Kode lerroa:           var range = params.getArray('Range');
Kode lerroa:           return ['LabCS', whitePoint, blackPoint, range];
Kode lerroa:         default:
Kode lerroa:           throw new _util.FormatError('unimplemented color space object "' + mode + '"');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     throw new _util.FormatError('unrecognized color space object: "' + cs + '"');
Kode lerroa:   };
Kode lerroa:   ColorSpace.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
Kode lerroa:     if (!Array.isArray(decode)) {
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     if (n * 2 !== decode.length) {
Kode lerroa:       (0, _util.warn)('The decode map is not the correct length');
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     for (var i = 0, ii = decode.length; i < ii; i += 2) {
Kode lerroa:       if (decode[i] !== 0 || decode[i + 1] !== 1) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   };
Kode lerroa:   ColorSpace.singletons = {
Kode lerroa:     get gray() {
Kode lerroa:       return (0, _util.shadow)(this, 'gray', new DeviceGrayCS());
Kode lerroa:     },
Kode lerroa:     get rgb() {
Kode lerroa:       return (0, _util.shadow)(this, 'rgb', new DeviceRgbCS());
Kode lerroa:     },
Kode lerroa:     get cmyk() {
Kode lerroa:       return (0, _util.shadow)(this, 'cmyk', new DeviceCmykCS());
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return ColorSpace;
Kode lerroa: }();
Kode lerroa: var AlternateCS = function AlternateCSClosure() {
Kode lerroa:   function AlternateCS(numComps, base, tintFn) {
Kode lerroa:     this.name = 'Alternate';
Kode lerroa:     this.numComps = numComps;
Kode lerroa:     this.defaultColor = new Float32Array(numComps);
Kode lerroa:     for (var i = 0; i < numComps; ++i) {
Kode lerroa:       this.defaultColor[i] = 1;
Kode lerroa:     }
Kode lerroa:     this.base = base;
Kode lerroa:     this.tintFn = tintFn;
Kode lerroa:     this.tmpBuf = new Float32Array(base.numComps);
Kode lerroa:   }
Kode lerroa:   AlternateCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       var tmpBuf = this.tmpBuf;
Kode lerroa:       this.tintFn(src, srcOffset, tmpBuf, 0);
Kode lerroa:       this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var tintFn = this.tintFn;
Kode lerroa:       var base = this.base;
Kode lerroa:       var scale = 1 / ((1 << bits) - 1);
Kode lerroa:       var baseNumComps = base.numComps;
Kode lerroa:       var usesZeroToOneRange = base.usesZeroToOneRange;
Kode lerroa:       var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
Kode lerroa:       var pos = isPassthrough ? destOffset : 0;
Kode lerroa:       var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
Kode lerroa:       var numComps = this.numComps;
Kode lerroa:       var scaled = new Float32Array(numComps);
Kode lerroa:       var tinted = new Float32Array(baseNumComps);
Kode lerroa:       var i, j;
Kode lerroa:       for (i = 0; i < count; i++) {
Kode lerroa:         for (j = 0; j < numComps; j++) {
Kode lerroa:           scaled[j] = src[srcOffset++] * scale;
Kode lerroa:         }
Kode lerroa:         tintFn(scaled, 0, tinted, 0);
Kode lerroa:         if (usesZeroToOneRange) {
Kode lerroa:           for (j = 0; j < baseNumComps; j++) {
Kode lerroa:             baseBuf[pos++] = tinted[j] * 255;
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           base.getRgbItem(tinted, 0, baseBuf, pos);
Kode lerroa:           pos += baseNumComps;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (!isPassthrough) {
Kode lerroa:         base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return AlternateCS;
Kode lerroa: }();
Kode lerroa: var PatternCS = function PatternCSClosure() {
Kode lerroa:   function PatternCS(baseCS) {
Kode lerroa:     this.name = 'Pattern';
Kode lerroa:     this.base = baseCS;
Kode lerroa:   }
Kode lerroa:   PatternCS.prototype = {};
Kode lerroa:   return PatternCS;
Kode lerroa: }();
Kode lerroa: var IndexedCS = function IndexedCSClosure() {
Kode lerroa:   function IndexedCS(base, highVal, lookup) {
Kode lerroa:     this.name = 'Indexed';
Kode lerroa:     this.numComps = 1;
Kode lerroa:     this.defaultColor = new Uint8Array(this.numComps);
Kode lerroa:     this.base = base;
Kode lerroa:     this.highVal = highVal;
Kode lerroa:     var baseNumComps = base.numComps;
Kode lerroa:     var length = baseNumComps * highVal;
Kode lerroa:     if ((0, _primitives.isStream)(lookup)) {
Kode lerroa:       this.lookup = new Uint8Array(length);
Kode lerroa:       var bytes = lookup.getBytes(length);
Kode lerroa:       this.lookup.set(bytes);
Kode lerroa:     } else if ((0, _util.isString)(lookup)) {
Kode lerroa:       this.lookup = new Uint8Array(length);
Kode lerroa:       for (var i = 0; i < length; ++i) {
Kode lerroa:         this.lookup[i] = lookup.charCodeAt(i);
Kode lerroa:       }
Kode lerroa:     } else if (lookup instanceof Uint8Array || lookup instanceof Array) {
Kode lerroa:       this.lookup = lookup;
Kode lerroa:     } else {
Kode lerroa:       throw new _util.FormatError('Unrecognized lookup table: ' + lookup);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   IndexedCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       var numComps = this.base.numComps;
Kode lerroa:       var start = src[srcOffset] * numComps;
Kode lerroa:       this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var base = this.base;
Kode lerroa:       var numComps = base.numComps;
Kode lerroa:       var outputDelta = base.getOutputLength(numComps, alpha01);
Kode lerroa:       var lookup = this.lookup;
Kode lerroa:       for (var i = 0; i < count; ++i) {
Kode lerroa:         var lookupPos = src[srcOffset++] * numComps;
Kode lerroa:         base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
Kode lerroa:         destOffset += outputDelta;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return true;
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return IndexedCS;
Kode lerroa: }();
Kode lerroa: var DeviceGrayCS = function DeviceGrayCSClosure() {
Kode lerroa:   function DeviceGrayCS() {
Kode lerroa:     this.name = 'DeviceGray';
Kode lerroa:     this.numComps = 1;
Kode lerroa:     this.defaultColor = new Float32Array(this.numComps);
Kode lerroa:   }
Kode lerroa:   DeviceGrayCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       var c = src[srcOffset] * 255 | 0;
Kode lerroa:       c = c < 0 ? 0 : c > 255 ? 255 : c;
Kode lerroa:       dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var scale = 255 / ((1 << bits) - 1);
Kode lerroa:       var j = srcOffset,
Kode lerroa:           q = destOffset;
Kode lerroa:       for (var i = 0; i < count; ++i) {
Kode lerroa:         var c = scale * src[j++] | 0;
Kode lerroa:         dest[q++] = c;
Kode lerroa:         dest[q++] = c;
Kode lerroa:         dest[q++] = c;
Kode lerroa:         q += alpha01;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return inputLength * (3 + alpha01);
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return DeviceGrayCS;
Kode lerroa: }();
Kode lerroa: var DeviceRgbCS = function DeviceRgbCSClosure() {
Kode lerroa:   function DeviceRgbCS() {
Kode lerroa:     this.name = 'DeviceRGB';
Kode lerroa:     this.numComps = 3;
Kode lerroa:     this.defaultColor = new Float32Array(this.numComps);
Kode lerroa:   }
Kode lerroa:   DeviceRgbCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       var r = src[srcOffset] * 255 | 0;
Kode lerroa:       var g = src[srcOffset + 1] * 255 | 0;
Kode lerroa:       var b = src[srcOffset + 2] * 255 | 0;
Kode lerroa:       dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
Kode lerroa:       dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
Kode lerroa:       dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       if (bits === 8 && alpha01 === 0) {
Kode lerroa:         dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var scale = 255 / ((1 << bits) - 1);
Kode lerroa:       var j = srcOffset,
Kode lerroa:           q = destOffset;
Kode lerroa:       for (var i = 0; i < count; ++i) {
Kode lerroa:         dest[q++] = scale * src[j++] | 0;
Kode lerroa:         dest[q++] = scale * src[j++] | 0;
Kode lerroa:         dest[q++] = scale * src[j++] | 0;
Kode lerroa:         q += alpha01;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return inputLength * (3 + alpha01) / 3 | 0;
Kode lerroa:     },
Kode lerroa:     isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
Kode lerroa:       return bits === 8;
Kode lerroa:     },
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return DeviceRgbCS;
Kode lerroa: }();
Kode lerroa: var DeviceCmykCS = function DeviceCmykCSClosure() {
Kode lerroa:   function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
Kode lerroa:     var c = src[srcOffset + 0] * srcScale;
Kode lerroa:     var m = src[srcOffset + 1] * srcScale;
Kode lerroa:     var y = src[srcOffset + 2] * srcScale;
Kode lerroa:     var k = src[srcOffset + 3] * srcScale;
Kode lerroa:     var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747) + 255 | 0;
Kode lerroa:     var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578) + 255 | 0;
Kode lerroa:     var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367) + 255 | 0;
Kode lerroa:     dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
Kode lerroa:     dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
Kode lerroa:     dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
Kode lerroa:   }
Kode lerroa:   function DeviceCmykCS() {
Kode lerroa:     this.name = 'DeviceCMYK';
Kode lerroa:     this.numComps = 4;
Kode lerroa:     this.defaultColor = new Float32Array(this.numComps);
Kode lerroa:     this.defaultColor[3] = 1;
Kode lerroa:   }
Kode lerroa:   DeviceCmykCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       convertToRgb(src, srcOffset, 1, dest, destOffset);
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var scale = 1 / ((1 << bits) - 1);
Kode lerroa:       for (var i = 0; i < count; i++) {
Kode lerroa:         convertToRgb(src, srcOffset, scale, dest, destOffset);
Kode lerroa:         srcOffset += 4;
Kode lerroa:         destOffset += 3 + alpha01;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return inputLength / 4 * (3 + alpha01) | 0;
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return DeviceCmykCS;
Kode lerroa: }();
Kode lerroa: var CalGrayCS = function CalGrayCSClosure() {
Kode lerroa:   function CalGrayCS(whitePoint, blackPoint, gamma) {
Kode lerroa:     this.name = 'CalGray';
Kode lerroa:     this.numComps = 1;
Kode lerroa:     this.defaultColor = new Float32Array(this.numComps);
Kode lerroa:     if (!whitePoint) {
Kode lerroa:       throw new _util.FormatError('WhitePoint missing - required for color space CalGray');
Kode lerroa:     }
Kode lerroa:     blackPoint = blackPoint || [0, 0, 0];
Kode lerroa:     gamma = gamma || 1;
Kode lerroa:     this.XW = whitePoint[0];
Kode lerroa:     this.YW = whitePoint[1];
Kode lerroa:     this.ZW = whitePoint[2];
Kode lerroa:     this.XB = blackPoint[0];
Kode lerroa:     this.YB = blackPoint[1];
Kode lerroa:     this.ZB = blackPoint[2];
Kode lerroa:     this.G = gamma;
Kode lerroa:     if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
Kode lerroa:       throw new _util.FormatError('Invalid WhitePoint components for ' + this.name + ', no fallback available');
Kode lerroa:     }
Kode lerroa:     if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
Kode lerroa:       (0, _util.info)('Invalid BlackPoint for ' + this.name + ', falling back to default');
Kode lerroa:       this.XB = this.YB = this.ZB = 0;
Kode lerroa:     }
Kode lerroa:     if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
Kode lerroa:       (0, _util.warn)(this.name + ', BlackPoint: XB: ' + this.XB + ', YB: ' + this.YB + ', ZB: ' + this.ZB + ', only default values are supported.');
Kode lerroa:     }
Kode lerroa:     if (this.G < 1) {
Kode lerroa:       (0, _util.info)('Invalid Gamma: ' + this.G + ' for ' + this.name + ', falling back to default');
Kode lerroa:       this.G = 1;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
Kode lerroa:     var A = src[srcOffset] * scale;
Kode lerroa:     var AG = Math.pow(A, cs.G);
Kode lerroa:     var L = cs.YW * AG;
Kode lerroa:     var val = Math.max(295.8 * Math.pow(L, 0.333333333333333333) - 40.8, 0) | 0;
Kode lerroa:     dest[destOffset] = val;
Kode lerroa:     dest[destOffset + 1] = val;
Kode lerroa:     dest[destOffset + 2] = val;
Kode lerroa:   }
Kode lerroa:   CalGrayCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       convertToRgb(this, src, srcOffset, dest, destOffset, 1);
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var scale = 1 / ((1 << bits) - 1);
Kode lerroa:       for (var i = 0; i < count; ++i) {
Kode lerroa:         convertToRgb(this, src, srcOffset, dest, destOffset, scale);
Kode lerroa:         srcOffset += 1;
Kode lerroa:         destOffset += 3 + alpha01;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return inputLength * (3 + alpha01);
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return CalGrayCS;
Kode lerroa: }();
Kode lerroa: var CalRGBCS = function CalRGBCSClosure() {
Kode lerroa:   var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
Kode lerroa:   var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
Kode lerroa:   var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
Kode lerroa:   var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
Kode lerroa:   var tempNormalizeMatrix = new Float32Array(3);
Kode lerroa:   var tempConvertMatrix1 = new Float32Array(3);
Kode lerroa:   var tempConvertMatrix2 = new Float32Array(3);
Kode lerroa:   var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8.0;
Kode lerroa:   function CalRGBCS(whitePoint, blackPoint, gamma, matrix) {
Kode lerroa:     this.name = 'CalRGB';
Kode lerroa:     this.numComps = 3;
Kode lerroa:     this.defaultColor = new Float32Array(this.numComps);
Kode lerroa:     if (!whitePoint) {
Kode lerroa:       throw new _util.FormatError('WhitePoint missing - required for color space CalRGB');
Kode lerroa:     }
Kode lerroa:     blackPoint = blackPoint || new Float32Array(3);
Kode lerroa:     gamma = gamma || new Float32Array([1, 1, 1]);
Kode lerroa:     matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
Kode lerroa:     var XW = whitePoint[0];
Kode lerroa:     var YW = whitePoint[1];
Kode lerroa:     var ZW = whitePoint[2];
Kode lerroa:     this.whitePoint = whitePoint;
Kode lerroa:     var XB = blackPoint[0];
Kode lerroa:     var YB = blackPoint[1];
Kode lerroa:     var ZB = blackPoint[2];
Kode lerroa:     this.blackPoint = blackPoint;
Kode lerroa:     this.GR = gamma[0];
Kode lerroa:     this.GG = gamma[1];
Kode lerroa:     this.GB = gamma[2];
Kode lerroa:     this.MXA = matrix[0];
Kode lerroa:     this.MYA = matrix[1];
Kode lerroa:     this.MZA = matrix[2];
Kode lerroa:     this.MXB = matrix[3];
Kode lerroa:     this.MYB = matrix[4];
Kode lerroa:     this.MZB = matrix[5];
Kode lerroa:     this.MXC = matrix[6];
Kode lerroa:     this.MYC = matrix[7];
Kode lerroa:     this.MZC = matrix[8];
Kode lerroa:     if (XW < 0 || ZW < 0 || YW !== 1) {
Kode lerroa:       throw new _util.FormatError('Invalid WhitePoint components for ' + this.name + ', no fallback available');
Kode lerroa:     }
Kode lerroa:     if (XB < 0 || YB < 0 || ZB < 0) {
Kode lerroa:       (0, _util.info)('Invalid BlackPoint for ' + this.name + ' [' + XB + ', ' + YB + ', ' + ZB + '], falling back to default');
Kode lerroa:       this.blackPoint = new Float32Array(3);
Kode lerroa:     }
Kode lerroa:     if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
Kode lerroa:       (0, _util.info)('Invalid Gamma [' + this.GR + ', ' + this.GG + ', ' + this.GB + '] for ' + this.name + ', falling back to default');
Kode lerroa:       this.GR = this.GG = this.GB = 1;
Kode lerroa:     }
Kode lerroa:     if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
Kode lerroa:       (0, _util.info)('Invalid Matrix for ' + this.name + ' [' + this.MXA + ', ' + this.MYA + ', ' + this.MZA + this.MXB + ', ' + this.MYB + ', ' + this.MZB + this.MXC + ', ' + this.MYC + ', ' + this.MZC + '], falling back to default');
Kode lerroa:       this.MXA = this.MYB = this.MZC = 1;
Kode lerroa:       this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function matrixProduct(a, b, result) {
Kode lerroa:     result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
Kode lerroa:     result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
Kode lerroa:     result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
Kode lerroa:   }
Kode lerroa:   function convertToFlat(sourceWhitePoint, LMS, result) {
Kode lerroa:     result[0] = LMS[0] * 1 / sourceWhitePoint[0];
Kode lerroa:     result[1] = LMS[1] * 1 / sourceWhitePoint[1];
Kode lerroa:     result[2] = LMS[2] * 1 / sourceWhitePoint[2];
Kode lerroa:   }
Kode lerroa:   function convertToD65(sourceWhitePoint, LMS, result) {
Kode lerroa:     var D65X = 0.95047;
Kode lerroa:     var D65Y = 1;
Kode lerroa:     var D65Z = 1.08883;
Kode lerroa:     result[0] = LMS[0] * D65X / sourceWhitePoint[0];
Kode lerroa:     result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
Kode lerroa:     result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
Kode lerroa:   }
Kode lerroa:   function sRGBTransferFunction(color) {
Kode lerroa:     if (color <= 0.0031308) {
Kode lerroa:       return adjustToRange(0, 1, 12.92 * color);
Kode lerroa:     }
Kode lerroa:     return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
Kode lerroa:   }
Kode lerroa:   function adjustToRange(min, max, value) {
Kode lerroa:     return Math.max(min, Math.min(max, value));
Kode lerroa:   }
Kode lerroa:   function decodeL(L) {
Kode lerroa:     if (L < 0) {
Kode lerroa:       return -decodeL(-L);
Kode lerroa:     }
Kode lerroa:     if (L > 8.0) {
Kode lerroa:       return Math.pow((L + 16) / 116, 3);
Kode lerroa:     }
Kode lerroa:     return L * DECODE_L_CONSTANT;
Kode lerroa:   }
Kode lerroa:   function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
Kode lerroa:     if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
Kode lerroa:       result[0] = XYZ_Flat[0];
Kode lerroa:       result[1] = XYZ_Flat[1];
Kode lerroa:       result[2] = XYZ_Flat[2];
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var zeroDecodeL = decodeL(0);
Kode lerroa:     var X_DST = zeroDecodeL;
Kode lerroa:     var X_SRC = decodeL(sourceBlackPoint[0]);
Kode lerroa:     var Y_DST = zeroDecodeL;
Kode lerroa:     var Y_SRC = decodeL(sourceBlackPoint[1]);
Kode lerroa:     var Z_DST = zeroDecodeL;
Kode lerroa:     var Z_SRC = decodeL(sourceBlackPoint[2]);
Kode lerroa:     var X_Scale = (1 - X_DST) / (1 - X_SRC);
Kode lerroa:     var X_Offset = 1 - X_Scale;
Kode lerroa:     var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
Kode lerroa:     var Y_Offset = 1 - Y_Scale;
Kode lerroa:     var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
Kode lerroa:     var Z_Offset = 1 - Z_Scale;
Kode lerroa:     result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
Kode lerroa:     result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
Kode lerroa:     result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
Kode lerroa:   }
Kode lerroa:   function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
Kode lerroa:     if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
Kode lerroa:       result[0] = XYZ_In[0];
Kode lerroa:       result[1] = XYZ_In[1];
Kode lerroa:       result[2] = XYZ_In[2];
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var LMS = result;
Kode lerroa:     matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
Kode lerroa:     var LMS_Flat = tempNormalizeMatrix;
Kode lerroa:     convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
Kode lerroa:     matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
Kode lerroa:   }
Kode lerroa:   function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
Kode lerroa:     var LMS = result;
Kode lerroa:     matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
Kode lerroa:     var LMS_D65 = tempNormalizeMatrix;
Kode lerroa:     convertToD65(sourceWhitePoint, LMS, LMS_D65);
Kode lerroa:     matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
Kode lerroa:   }
Kode lerroa:   function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
Kode lerroa:     var A = adjustToRange(0, 1, src[srcOffset] * scale);
Kode lerroa:     var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
Kode lerroa:     var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
Kode lerroa:     var AGR = Math.pow(A, cs.GR);
Kode lerroa:     var BGG = Math.pow(B, cs.GG);
Kode lerroa:     var CGB = Math.pow(C, cs.GB);
Kode lerroa:     var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
Kode lerroa:     var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
Kode lerroa:     var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
Kode lerroa:     var XYZ = tempConvertMatrix1;
Kode lerroa:     XYZ[0] = X;
Kode lerroa:     XYZ[1] = Y;
Kode lerroa:     XYZ[2] = Z;
Kode lerroa:     var XYZ_Flat = tempConvertMatrix2;
Kode lerroa:     normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
Kode lerroa:     var XYZ_Black = tempConvertMatrix1;
Kode lerroa:     compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
Kode lerroa:     var XYZ_D65 = tempConvertMatrix2;
Kode lerroa:     normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
Kode lerroa:     var SRGB = tempConvertMatrix1;
Kode lerroa:     matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
Kode lerroa:     var sR = sRGBTransferFunction(SRGB[0]);
Kode lerroa:     var sG = sRGBTransferFunction(SRGB[1]);
Kode lerroa:     var sB = sRGBTransferFunction(SRGB[2]);
Kode lerroa:     dest[destOffset] = Math.round(sR * 255);
Kode lerroa:     dest[destOffset + 1] = Math.round(sG * 255);
Kode lerroa:     dest[destOffset + 2] = Math.round(sB * 255);
Kode lerroa:   }
Kode lerroa:   CalRGBCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       convertToRgb(this, src, srcOffset, dest, destOffset, 1);
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var scale = 1 / ((1 << bits) - 1);
Kode lerroa:       for (var i = 0; i < count; ++i) {
Kode lerroa:         convertToRgb(this, src, srcOffset, dest, destOffset, scale);
Kode lerroa:         srcOffset += 3;
Kode lerroa:         destOffset += 3 + alpha01;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return inputLength * (3 + alpha01) / 3 | 0;
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: true
Kode lerroa:   };
Kode lerroa:   return CalRGBCS;
Kode lerroa: }();
Kode lerroa: var LabCS = function LabCSClosure() {
Kode lerroa:   function LabCS(whitePoint, blackPoint, range) {
Kode lerroa:     this.name = 'Lab';
Kode lerroa:     this.numComps = 3;
Kode lerroa:     this.defaultColor = new Float32Array(this.numComps);
Kode lerroa:     if (!whitePoint) {
Kode lerroa:       throw new _util.FormatError('WhitePoint missing - required for color space Lab');
Kode lerroa:     }
Kode lerroa:     blackPoint = blackPoint || [0, 0, 0];
Kode lerroa:     range = range || [-100, 100, -100, 100];
Kode lerroa:     this.XW = whitePoint[0];
Kode lerroa:     this.YW = whitePoint[1];
Kode lerroa:     this.ZW = whitePoint[2];
Kode lerroa:     this.amin = range[0];
Kode lerroa:     this.amax = range[1];
Kode lerroa:     this.bmin = range[2];
Kode lerroa:     this.bmax = range[3];
Kode lerroa:     this.XB = blackPoint[0];
Kode lerroa:     this.YB = blackPoint[1];
Kode lerroa:     this.ZB = blackPoint[2];
Kode lerroa:     if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
Kode lerroa:       throw new _util.FormatError('Invalid WhitePoint components, no fallback available');
Kode lerroa:     }
Kode lerroa:     if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
Kode lerroa:       (0, _util.info)('Invalid BlackPoint, falling back to default');
Kode lerroa:       this.XB = this.YB = this.ZB = 0;
Kode lerroa:     }
Kode lerroa:     if (this.amin > this.amax || this.bmin > this.bmax) {
Kode lerroa:       (0, _util.info)('Invalid Range, falling back to defaults');
Kode lerroa:       this.amin = -100;
Kode lerroa:       this.amax = 100;
Kode lerroa:       this.bmin = -100;
Kode lerroa:       this.bmax = 100;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function fn_g(x) {
Kode lerroa:     var result;
Kode lerroa:     if (x >= 6 / 29) {
Kode lerroa:       result = x * x * x;
Kode lerroa:     } else {
Kode lerroa:       result = 108 / 841 * (x - 4 / 29);
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   }
Kode lerroa:   function decode(value, high1, low2, high2) {
Kode lerroa:     return low2 + value * (high2 - low2) / high1;
Kode lerroa:   }
Kode lerroa:   function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
Kode lerroa:     var Ls = src[srcOffset];
Kode lerroa:     var as = src[srcOffset + 1];
Kode lerroa:     var bs = src[srcOffset + 2];
Kode lerroa:     if (maxVal !== false) {
Kode lerroa:       Ls = decode(Ls, maxVal, 0, 100);
Kode lerroa:       as = decode(as, maxVal, cs.amin, cs.amax);
Kode lerroa:       bs = decode(bs, maxVal, cs.bmin, cs.bmax);
Kode lerroa:     }
Kode lerroa:     as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
Kode lerroa:     bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
Kode lerroa:     var M = (Ls + 16) / 116;
Kode lerroa:     var L = M + as / 500;
Kode lerroa:     var N = M - bs / 200;
Kode lerroa:     var X = cs.XW * fn_g(L);
Kode lerroa:     var Y = cs.YW * fn_g(M);
Kode lerroa:     var Z = cs.ZW * fn_g(N);
Kode lerroa:     var r, g, b;
Kode lerroa:     if (cs.ZW < 1) {
Kode lerroa:       r = X * 3.1339 + Y * -1.6170 + Z * -0.4906;
Kode lerroa:       g = X * -0.9785 + Y * 1.9160 + Z * 0.0333;
Kode lerroa:       b = X * 0.0720 + Y * -0.2290 + Z * 1.4057;
Kode lerroa:     } else {
Kode lerroa:       r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
Kode lerroa:       g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
Kode lerroa:       b = X * 0.0557 + Y * -0.2040 + Z * 1.0570;
Kode lerroa:     }
Kode lerroa:     dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
Kode lerroa:     dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
Kode lerroa:     dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
Kode lerroa:   }
Kode lerroa:   LabCS.prototype = {
Kode lerroa:     getRgb: ColorSpace.prototype.getRgb,
Kode lerroa:     getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
Kode lerroa:       convertToRgb(this, src, srcOffset, false, dest, destOffset);
Kode lerroa:     },
Kode lerroa:     getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
Kode lerroa:       var maxVal = (1 << bits) - 1;
Kode lerroa:       for (var i = 0; i < count; i++) {
Kode lerroa:         convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
Kode lerroa:         srcOffset += 3;
Kode lerroa:         destOffset += 3 + alpha01;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
Kode lerroa:       return inputLength * (3 + alpha01) / 3 | 0;
Kode lerroa:     },
Kode lerroa:     isPassthrough: ColorSpace.prototype.isPassthrough,
Kode lerroa:     fillRgb: ColorSpace.prototype.fillRgb,
Kode lerroa:     isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
Kode lerroa:       return true;
Kode lerroa:     },
Kode lerroa:     usesZeroToOneRange: false
Kode lerroa:   };
Kode lerroa:   return LabCS;
Kode lerroa: }();
Kode lerroa: exports.ColorSpace = ColorSpace;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 28 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: var ExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
Kode lerroa: var MacExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', 'centoldstyle', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', '', 'threequartersemdash', '', 'questionsmall', '', '', '', '', 'Ethsmall', '', '', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', '', '', '', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hypheninferior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', 'asuperior', 'centsuperior', '', '', '', '', 'Aacutesmall', 'Agravesmall', 'Acircumflexsmall', 'Adieresissmall', 'Atildesmall', 'Aringsmall', 'Ccedillasmall', 'Eacutesmall', 'Egravesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Iacutesmall', 'Igravesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ntildesmall', 'Oacutesmall', 'Ogravesmall', 'Ocircumflexsmall', 'Odieresissmall', 'Otildesmall', 'Uacutesmall', 'Ugravesmall', 'Ucircumflexsmall', 'Udieresissmall', '', 'eightsuperior', 'fourinferior', 'threeinferior', 'sixinferior', 'eightinferior', 'seveninferior', 'Scaronsmall', '', 'centinferior', 'twoinferior', '', 'Dieresissmall', '', 'Caronsmall', 'osuperior', 'fiveinferior', '', 'commainferior', 'periodinferior', 'Yacutesmall', '', 'dollarinferior', '', 'Thornsmall', '', 'nineinferior', 'zeroinferior', 'Zcaronsmall', 'AEsmall', 'Oslashsmall', 'questiondownsmall', 'oneinferior', 'Lslashsmall', '', '', '', '', '', '', 'Cedillasmall', '', '', '', '', '', 'OEsmall', 'figuredash', 'hyphensuperior', '', '', '', '', 'exclamdownsmall', '', 'Ydieresissmall', '', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'ninesuperior', 'zerosuperior', '', 'esuperior', 'rsuperior', 'tsuperior', '', '', 'isuperior', 'ssuperior', 'dsuperior', '', '', '', '', '', 'lsuperior', 'Ogoneksmall', 'Brevesmall', 'Macronsmall', 'bsuperior', 'nsuperior', 'msuperior', 'commasuperior', 'periodsuperior', 'Dotaccentsmall', 'Ringsmall'];
Kode lerroa: var MacRomanEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'space', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron'];
Kode lerroa: var StandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];
Kode lerroa: var WinAnsiEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'bullet', 'Euro', 'bullet', 'quotesinglbase', 'florin', 'quotedblbase', 'ellipsis', 'dagger', 'daggerdbl', 'circumflex', 'perthousand', 'Scaron', 'guilsinglleft', 'OE', 'bullet', 'Zcaron', 'bullet', 'bullet', 'quoteleft', 'quoteright', 'quotedblleft', 'quotedblright', 'bullet', 'endash', 'emdash', 'tilde', 'trademark', 'scaron', 'guilsinglright', 'oe', 'bullet', 'zcaron', 'Ydieresis', 'space', 'exclamdown', 'cent', 'sterling', 'currency', 'yen', 'brokenbar', 'section', 'dieresis', 'copyright', 'ordfeminine', 'guillemotleft', 'logicalnot', 'hyphen', 'registered', 'macron', 'degree', 'plusminus', 'twosuperior', 'threesuperior', 'acute', 'mu', 'paragraph', 'periodcentered', 'cedilla', 'onesuperior', 'ordmasculine', 'guillemotright', 'onequarter', 'onehalf', 'threequarters', 'questiondown', 'Agrave', 'Aacute', 'Acircumflex', 'Atilde', 'Adieresis', 'Aring', 'AE', 'Ccedilla', 'Egrave', 'Eacute', 'Ecircumflex', 'Edieresis', 'Igrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Eth', 'Ntilde', 'Ograve', 'Oacute', 'Ocircumflex', 'Otilde', 'Odieresis', 'multiply', 'Oslash', 'Ugrave', 'Uacute', 'Ucircumflex', 'Udieresis', 'Yacute', 'Thorn', 'germandbls', 'agrave', 'aacute', 'acircumflex', 'atilde', 'adieresis', 'aring', 'ae', 'ccedilla', 'egrave', 'eacute', 'ecircumflex', 'edieresis', 'igrave', 'iacute', 'icircumflex', 'idieresis', 'eth', 'ntilde', 'ograve', 'oacute', 'ocircumflex', 'otilde', 'odieresis', 'divide', 'oslash', 'ugrave', 'uacute', 'ucircumflex', 'udieresis', 'yacute', 'thorn', 'ydieresis'];
Kode lerroa: var SymbolSetEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'universal', 'numbersign', 'existential', 'percent', 'ampersand', 'suchthat', 'parenleft', 'parenright', 'asteriskmath', 'plus', 'comma', 'minus', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'congruent', 'Alpha', 'Beta', 'Chi', 'Delta', 'Epsilon', 'Phi', 'Gamma', 'Eta', 'Iota', 'theta1', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Omicron', 'Pi', 'Theta', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'sigma1', 'Omega', 'Xi', 'Psi', 'Zeta', 'bracketleft', 'therefore', 'bracketright', 'perpendicular', 'underscore', 'radicalex', 'alpha', 'beta', 'chi', 'delta', 'epsilon', 'phi', 'gamma', 'eta', 'iota', 'phi1', 'kappa', 'lambda', 'mu', 'nu', 'omicron', 'pi', 'theta', 'rho', 'sigma', 'tau', 'upsilon', 'omega1', 'omega', 'xi', 'psi', 'zeta', 'braceleft', 'bar', 'braceright', 'similar', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'Euro', 'Upsilon1', 'minute', 'lessequal', 'fraction', 'infinity', 'florin', 'club', 'diamond', 'heart', 'spade', 'arrowboth', 'arrowleft', 'arrowup', 'arrowright', 'arrowdown', 'degree', 'plusminus', 'second', 'greaterequal', 'multiply', 'proportional', 'partialdiff', 'bullet', 'divide', 'notequal', 'equivalence', 'approxequal', 'ellipsis', 'arrowvertex', 'arrowhorizex', 'carriagereturn', 'aleph', 'Ifraktur', 'Rfraktur', 'weierstrass', 'circlemultiply', 'circleplus', 'emptyset', 'intersection', 'union', 'propersuperset', 'reflexsuperset', 'notsubset', 'propersubset', 'reflexsubset', 'element', 'notelement', 'angle', 'gradient', 'registerserif', 'copyrightserif', 'trademarkserif', 'product', 'radical', 'dotmath', 'logicalnot', 'logicaland', 'logicalor', 'arrowdblboth', 'arrowdblleft', 'arrowdblup', 'arrowdblright', 'arrowdbldown', 'lozenge', 'angleleft', 'registersans', 'copyrightsans', 'trademarksans', 'summation', 'parenlefttp', 'parenleftex', 'parenleftbt', 'bracketlefttp', 'bracketleftex', 'bracketleftbt', 'bracelefttp', 'braceleftmid', 'braceleftbt', 'braceex', '', 'angleright', 'integral', 'integraltp', 'integralex', 'integralbt', 'parenrighttp', 'parenrightex', 'parenrightbt', 'bracketrighttp', 'bracketrightex', 'bracketrightbt', 'bracerighttp', 'bracerightmid', 'bracerightbt'];
Kode lerroa: var ZapfDingbatsEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'a1', 'a2', 'a202', 'a3', 'a4', 'a5', 'a119', 'a118', 'a117', 'a11', 'a12', 'a13', 'a14', 'a15', 'a16', 'a105', 'a17', 'a18', 'a19', 'a20', 'a21', 'a22', 'a23', 'a24', 'a25', 'a26', 'a27', 'a28', 'a6', 'a7', 'a8', 'a9', 'a10', 'a29', 'a30', 'a31', 'a32', 'a33', 'a34', 'a35', 'a36', 'a37', 'a38', 'a39', 'a40', 'a41', 'a42', 'a43', 'a44', 'a45', 'a46', 'a47', 'a48', 'a49', 'a50', 'a51', 'a52', 'a53', 'a54', 'a55', 'a56', 'a57', 'a58', 'a59', 'a60', 'a61', 'a62', 'a63', 'a64', 'a65', 'a66', 'a67', 'a68', 'a69', 'a70', 'a71', 'a72', 'a73', 'a74', 'a203', 'a75', 'a204', 'a76', 'a77', 'a78', 'a79', 'a81', 'a82', 'a83', 'a84', 'a97', 'a98', 'a99', 'a100', '', 'a89', 'a90', 'a93', 'a94', 'a91', 'a92', 'a205', 'a85', 'a206', 'a86', 'a87', 'a88', 'a95', 'a96', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'a101', 'a102', 'a103', 'a104', 'a106', 'a107', 'a108', 'a112', 'a111', 'a110', 'a109', 'a120', 'a121', 'a122', 'a123', 'a124', 'a125', 'a126', 'a127', 'a128', 'a129', 'a130', 'a131', 'a132', 'a133', 'a134', 'a135', 'a136', 'a137', 'a138', 'a139', 'a140', 'a141', 'a142', 'a143', 'a144', 'a145', 'a146', 'a147', 'a148', 'a149', 'a150', 'a151', 'a152', 'a153', 'a154', 'a155', 'a156', 'a157', 'a158', 'a159', 'a160', 'a161', 'a163', 'a164', 'a196', 'a165', 'a192', 'a166', 'a167', 'a168', 'a169', 'a170', 'a171', 'a172', 'a173', 'a162', 'a174', 'a175', 'a176', 'a177', 'a178', 'a179', 'a193', 'a180', 'a199', 'a181', 'a200', 'a182', '', 'a201', 'a183', 'a184', 'a197', 'a185', 'a194', 'a198', 'a186', 'a195', 'a187', 'a188', 'a189', 'a190', 'a191'];
Kode lerroa: function getEncoding(encodingName) {
Kode lerroa:   switch (encodingName) {
Kode lerroa:     case 'WinAnsiEncoding':
Kode lerroa:       return WinAnsiEncoding;
Kode lerroa:     case 'StandardEncoding':
Kode lerroa:       return StandardEncoding;
Kode lerroa:     case 'MacRomanEncoding':
Kode lerroa:       return MacRomanEncoding;
Kode lerroa:     case 'SymbolSetEncoding':
Kode lerroa:       return SymbolSetEncoding;
Kode lerroa:     case 'ZapfDingbatsEncoding':
Kode lerroa:       return ZapfDingbatsEncoding;
Kode lerroa:     case 'ExpertEncoding':
Kode lerroa:       return ExpertEncoding;
Kode lerroa:     case 'MacExpertEncoding':
Kode lerroa:       return MacExpertEncoding;
Kode lerroa:     default:
Kode lerroa:       return null;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: exports.WinAnsiEncoding = WinAnsiEncoding;
Kode lerroa: exports.StandardEncoding = StandardEncoding;
Kode lerroa: exports.MacRomanEncoding = MacRomanEncoding;
Kode lerroa: exports.SymbolSetEncoding = SymbolSetEncoding;
Kode lerroa: exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
Kode lerroa: exports.ExpertEncoding = ExpertEncoding;
Kode lerroa: exports.getEncoding = getEncoding;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 29 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (bitmap, value) {
Kode lerroa:   return {
Kode lerroa:     enumerable: !(bitmap & 1),
Kode lerroa:     configurable: !(bitmap & 2),
Kode lerroa:     writable: !(bitmap & 4),
Kode lerroa:     value: value
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 30 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var IObject = __w_pdfjs_require__(37);
Kode lerroa: var defined = __w_pdfjs_require__(38);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return IObject(defined(it));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 31 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(18);
Kode lerroa: var max = Math.max;
Kode lerroa: var min = Math.min;
Kode lerroa: module.exports = function (index, length) {
Kode lerroa:   index = toInteger(index);
Kode lerroa:   return index < 0 ? max(index + length, 0) : min(index, length);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 32 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var cof = __w_pdfjs_require__(25);
Kode lerroa: var TAG = __w_pdfjs_require__(4)('toStringTag');
Kode lerroa: var ARG = cof(function () {
Kode lerroa:   return arguments;
Kode lerroa: }()) == 'Arguments';
Kode lerroa: var tryGet = function tryGet(it, key) {
Kode lerroa:   try {
Kode lerroa:     return it[key];
Kode lerroa:   } catch (e) {}
Kode lerroa: };
Kode lerroa: module.exports = function (it) {
Kode lerroa:   var O, T, B;
Kode lerroa:   return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 33 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ctx = __w_pdfjs_require__(13);
Kode lerroa: var call = __w_pdfjs_require__(107);
Kode lerroa: var isArrayIter = __w_pdfjs_require__(56);
Kode lerroa: var anObject = __w_pdfjs_require__(9);
Kode lerroa: var toLength = __w_pdfjs_require__(14);
Kode lerroa: var getIterFn = __w_pdfjs_require__(60);
Kode lerroa: var BREAK = {};
Kode lerroa: var RETURN = {};
Kode lerroa: var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
Kode lerroa:   var iterFn = ITERATOR ? function () {
Kode lerroa:     return iterable;
Kode lerroa:   } : getIterFn(iterable);
Kode lerroa:   var f = ctx(fn, that, entries ? 2 : 1);
Kode lerroa:   var index = 0;
Kode lerroa:   var length, step, iterator, result;
Kode lerroa:   if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
Kode lerroa:   if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
Kode lerroa:     result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
Kode lerroa:     if (result === BREAK || result === RETURN) return result;
Kode lerroa:   } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
Kode lerroa:     result = call(iterator, f, step.value, entries);
Kode lerroa:     if (result === BREAK || result === RETURN) return result;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: _exports.BREAK = BREAK;
Kode lerroa: _exports.RETURN = RETURN;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 34 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.Parser = exports.Linearization = exports.Lexer = undefined;
Kode lerroa: 
Kode lerroa: var _stream = __w_pdfjs_require__(5);
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var _ccitt_stream = __w_pdfjs_require__(130);
Kode lerroa: 
Kode lerroa: var _jbig2_stream = __w_pdfjs_require__(132);
Kode lerroa: 
Kode lerroa: var MAX_LENGTH_TO_CACHE = 1000;
Kode lerroa: var Parser = function ParserClosure() {
Kode lerroa:   function Parser(lexer, allowStreams, xref, recoveryMode) {
Kode lerroa:     this.lexer = lexer;
Kode lerroa:     this.allowStreams = allowStreams;
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.recoveryMode = recoveryMode || false;
Kode lerroa:     this.imageCache = Object.create(null);
Kode lerroa:     this.refill();
Kode lerroa:   }
Kode lerroa:   Parser.prototype = {
Kode lerroa:     refill: function Parser_refill() {
Kode lerroa:       this.buf1 = this.lexer.getObj();
Kode lerroa:       this.buf2 = this.lexer.getObj();
Kode lerroa:     },
Kode lerroa:     shift: function Parser_shift() {
Kode lerroa:       if ((0, _primitives.isCmd)(this.buf2, 'ID')) {
Kode lerroa:         this.buf1 = this.buf2;
Kode lerroa:         this.buf2 = null;
Kode lerroa:       } else {
Kode lerroa:         this.buf1 = this.buf2;
Kode lerroa:         this.buf2 = this.lexer.getObj();
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     tryShift: function Parser_tryShift() {
Kode lerroa:       try {
Kode lerroa:         this.shift();
Kode lerroa:         return true;
Kode lerroa:       } catch (e) {
Kode lerroa:         if (e instanceof _util.MissingDataException) {
Kode lerroa:           throw e;
Kode lerroa:         }
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getObj: function Parser_getObj(cipherTransform) {
Kode lerroa:       var buf1 = this.buf1;
Kode lerroa:       this.shift();
Kode lerroa:       if (buf1 instanceof _primitives.Cmd) {
Kode lerroa:         switch (buf1.cmd) {
Kode lerroa:           case 'BI':
Kode lerroa:             return this.makeInlineImage(cipherTransform);
Kode lerroa:           case '[':
Kode lerroa:             var array = [];
Kode lerroa:             while (!(0, _primitives.isCmd)(this.buf1, ']') && !(0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:               array.push(this.getObj(cipherTransform));
Kode lerroa:             }
Kode lerroa:             if ((0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:               if (!this.recoveryMode) {
Kode lerroa:                 throw new _util.FormatError('End of file inside array');
Kode lerroa:               }
Kode lerroa:               return array;
Kode lerroa:             }
Kode lerroa:             this.shift();
Kode lerroa:             return array;
Kode lerroa:           case '<<':
Kode lerroa:             var dict = new _primitives.Dict(this.xref);
Kode lerroa:             while (!(0, _primitives.isCmd)(this.buf1, '>>') && !(0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:               if (!(0, _primitives.isName)(this.buf1)) {
Kode lerroa:                 (0, _util.info)('Malformed dictionary: key must be a name object');
Kode lerroa:                 this.shift();
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               var key = this.buf1.name;
Kode lerroa:               this.shift();
Kode lerroa:               if ((0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               dict.set(key, this.getObj(cipherTransform));
Kode lerroa:             }
Kode lerroa:             if ((0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:               if (!this.recoveryMode) {
Kode lerroa:                 throw new _util.FormatError('End of file inside dictionary');
Kode lerroa:               }
Kode lerroa:               return dict;
Kode lerroa:             }
Kode lerroa:             if ((0, _primitives.isCmd)(this.buf2, 'stream')) {
Kode lerroa:               return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
Kode lerroa:             }
Kode lerroa:             this.shift();
Kode lerroa:             return dict;
Kode lerroa:           default:
Kode lerroa:             return buf1;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (Number.isInteger(buf1)) {
Kode lerroa:         var num = buf1;
Kode lerroa:         if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, 'R')) {
Kode lerroa:           var ref = new _primitives.Ref(num, this.buf1);
Kode lerroa:           this.shift();
Kode lerroa:           this.shift();
Kode lerroa:           return ref;
Kode lerroa:         }
Kode lerroa:         return num;
Kode lerroa:       }
Kode lerroa:       if ((0, _util.isString)(buf1)) {
Kode lerroa:         var str = buf1;
Kode lerroa:         if (cipherTransform) {
Kode lerroa:           str = cipherTransform.decryptString(str);
Kode lerroa:         }
Kode lerroa:         return str;
Kode lerroa:       }
Kode lerroa:       return buf1;
Kode lerroa:     },
Kode lerroa:     findDefaultInlineStreamEnd: function findDefaultInlineStreamEnd(stream) {
Kode lerroa:       var E = 0x45,
Kode lerroa:           I = 0x49,
Kode lerroa:           SPACE = 0x20,
Kode lerroa:           LF = 0xA,
Kode lerroa:           CR = 0xD;
Kode lerroa:       var n = 10,
Kode lerroa:           NUL = 0x0;
Kode lerroa:       var startPos = stream.pos,
Kode lerroa:           state = 0,
Kode lerroa:           ch = void 0,
Kode lerroa:           maybeEIPos = void 0;
Kode lerroa:       while ((ch = stream.getByte()) !== -1) {
Kode lerroa:         if (state === 0) {
Kode lerroa:           state = ch === E ? 1 : 0;
Kode lerroa:         } else if (state === 1) {
Kode lerroa:           state = ch === I ? 2 : 0;
Kode lerroa:         } else {
Kode lerroa:           (0, _util.assert)(state === 2);
Kode lerroa:           if (ch === SPACE || ch === LF || ch === CR) {
Kode lerroa:             maybeEIPos = stream.pos;
Kode lerroa:             var followingBytes = stream.peekBytes(n);
Kode lerroa:             for (var i = 0, ii = followingBytes.length; i < ii; i++) {
Kode lerroa:               ch = followingBytes[i];
Kode lerroa:               if (ch === NUL && followingBytes[i + 1] !== NUL) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7F)) {
Kode lerroa:                 state = 0;
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             if (state === 2) {
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:           } else {
Kode lerroa:             state = 0;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (ch === -1) {
Kode lerroa:         (0, _util.warn)('findDefaultInlineStreamEnd: ' + 'Reached the end of the stream without finding a valid EI marker');
Kode lerroa:         if (maybeEIPos) {
Kode lerroa:           (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
Kode lerroa:           stream.skip(-(stream.pos - maybeEIPos));
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return stream.pos - 4 - startPos;
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream) {
Kode lerroa:       var startPos = stream.pos,
Kode lerroa:           foundEOI = false,
Kode lerroa:           b,
Kode lerroa:           markerLength,
Kode lerroa:           length;
Kode lerroa:       while ((b = stream.getByte()) !== -1) {
Kode lerroa:         if (b !== 0xFF) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         switch (stream.getByte()) {
Kode lerroa:           case 0x00:
Kode lerroa:             break;
Kode lerroa:           case 0xFF:
Kode lerroa:             stream.skip(-1);
Kode lerroa:             break;
Kode lerroa:           case 0xD9:
Kode lerroa:             foundEOI = true;
Kode lerroa:             break;
Kode lerroa:           case 0xC0:
Kode lerroa:           case 0xC1:
Kode lerroa:           case 0xC2:
Kode lerroa:           case 0xC3:
Kode lerroa:           case 0xC5:
Kode lerroa:           case 0xC6:
Kode lerroa:           case 0xC7:
Kode lerroa:           case 0xC9:
Kode lerroa:           case 0xCA:
Kode lerroa:           case 0xCB:
Kode lerroa:           case 0xCD:
Kode lerroa:           case 0xCE:
Kode lerroa:           case 0xCF:
Kode lerroa:           case 0xC4:
Kode lerroa:           case 0xCC:
Kode lerroa:           case 0xDA:
Kode lerroa:           case 0xDB:
Kode lerroa:           case 0xDC:
Kode lerroa:           case 0xDD:
Kode lerroa:           case 0xDE:
Kode lerroa:           case 0xDF:
Kode lerroa:           case 0xE0:
Kode lerroa:           case 0xE1:
Kode lerroa:           case 0xE2:
Kode lerroa:           case 0xE3:
Kode lerroa:           case 0xE4:
Kode lerroa:           case 0xE5:
Kode lerroa:           case 0xE6:
Kode lerroa:           case 0xE7:
Kode lerroa:           case 0xE8:
Kode lerroa:           case 0xE9:
Kode lerroa:           case 0xEA:
Kode lerroa:           case 0xEB:
Kode lerroa:           case 0xEC:
Kode lerroa:           case 0xED:
Kode lerroa:           case 0xEE:
Kode lerroa:           case 0xEF:
Kode lerroa:           case 0xFE:
Kode lerroa:             markerLength = stream.getUint16();
Kode lerroa:             if (markerLength > 2) {
Kode lerroa:               stream.skip(markerLength - 2);
Kode lerroa:             } else {
Kode lerroa:               stream.skip(-2);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         if (foundEOI) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       length = stream.pos - startPos;
Kode lerroa:       if (b === -1) {
Kode lerroa:         (0, _util.warn)('Inline DCTDecode image stream: ' + 'EOI marker not found, searching for /EI/ instead.');
Kode lerroa:         stream.skip(-length);
Kode lerroa:         return this.findDefaultInlineStreamEnd(stream);
Kode lerroa:       }
Kode lerroa:       this.inlineStreamSkipEI(stream);
Kode lerroa:       return length;
Kode lerroa:     },
Kode lerroa:     findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream) {
Kode lerroa:       var TILDE = 0x7E,
Kode lerroa:           GT = 0x3E;
Kode lerroa:       var startPos = stream.pos,
Kode lerroa:           ch,
Kode lerroa:           length;
Kode lerroa:       while ((ch = stream.getByte()) !== -1) {
Kode lerroa:         if (ch === TILDE && stream.peekByte() === GT) {
Kode lerroa:           stream.skip();
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       length = stream.pos - startPos;
Kode lerroa:       if (ch === -1) {
Kode lerroa:         (0, _util.warn)('Inline ASCII85Decode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
Kode lerroa:         stream.skip(-length);
Kode lerroa:         return this.findDefaultInlineStreamEnd(stream);
Kode lerroa:       }
Kode lerroa:       this.inlineStreamSkipEI(stream);
Kode lerroa:       return length;
Kode lerroa:     },
Kode lerroa:     findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream) {
Kode lerroa:       var GT = 0x3E;
Kode lerroa:       var startPos = stream.pos,
Kode lerroa:           ch,
Kode lerroa:           length;
Kode lerroa:       while ((ch = stream.getByte()) !== -1) {
Kode lerroa:         if (ch === GT) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       length = stream.pos - startPos;
Kode lerroa:       if (ch === -1) {
Kode lerroa:         (0, _util.warn)('Inline ASCIIHexDecode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
Kode lerroa:         stream.skip(-length);
Kode lerroa:         return this.findDefaultInlineStreamEnd(stream);
Kode lerroa:       }
Kode lerroa:       this.inlineStreamSkipEI(stream);
Kode lerroa:       return length;
Kode lerroa:     },
Kode lerroa:     inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
Kode lerroa:       var E = 0x45,
Kode lerroa:           I = 0x49;
Kode lerroa:       var state = 0,
Kode lerroa:           ch;
Kode lerroa:       while ((ch = stream.getByte()) !== -1) {
Kode lerroa:         if (state === 0) {
Kode lerroa:           state = ch === E ? 1 : 0;
Kode lerroa:         } else if (state === 1) {
Kode lerroa:           state = ch === I ? 2 : 0;
Kode lerroa:         } else if (state === 2) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
Kode lerroa:       var lexer = this.lexer;
Kode lerroa:       var stream = lexer.stream;
Kode lerroa:       var dict = new _primitives.Dict(this.xref);
Kode lerroa:       while (!(0, _primitives.isCmd)(this.buf1, 'ID') && !(0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:         if (!(0, _primitives.isName)(this.buf1)) {
Kode lerroa:           throw new _util.FormatError('Dictionary key must be a name object');
Kode lerroa:         }
Kode lerroa:         var key = this.buf1.name;
Kode lerroa:         this.shift();
Kode lerroa:         if ((0, _primitives.isEOF)(this.buf1)) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         dict.set(key, this.getObj(cipherTransform));
Kode lerroa:       }
Kode lerroa:       var filter = dict.get('Filter', 'F'),
Kode lerroa:           filterName;
Kode lerroa:       if ((0, _primitives.isName)(filter)) {
Kode lerroa:         filterName = filter.name;
Kode lerroa:       } else if (Array.isArray(filter)) {
Kode lerroa:         var filterZero = this.xref.fetchIfRef(filter[0]);
Kode lerroa:         if ((0, _primitives.isName)(filterZero)) {
Kode lerroa:           filterName = filterZero.name;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var startPos = stream.pos,
Kode lerroa:           length,
Kode lerroa:           i,
Kode lerroa:           ii;
Kode lerroa:       if (filterName === 'DCTDecode' || filterName === 'DCT') {
Kode lerroa:         length = this.findDCTDecodeInlineStreamEnd(stream);
Kode lerroa:       } else if (filterName === 'ASCII85Decode' || filterName === 'A85') {
Kode lerroa:         length = this.findASCII85DecodeInlineStreamEnd(stream);
Kode lerroa:       } else if (filterName === 'ASCIIHexDecode' || filterName === 'AHx') {
Kode lerroa:         length = this.findASCIIHexDecodeInlineStreamEnd(stream);
Kode lerroa:       } else {
Kode lerroa:         length = this.findDefaultInlineStreamEnd(stream);
Kode lerroa:       }
Kode lerroa:       var imageStream = stream.makeSubStream(startPos, length, dict);
Kode lerroa:       var adler32;
Kode lerroa:       if (length < MAX_LENGTH_TO_CACHE) {
Kode lerroa:         var imageBytes = imageStream.getBytes();
Kode lerroa:         imageStream.reset();
Kode lerroa:         var a = 1;
Kode lerroa:         var b = 0;
Kode lerroa:         for (i = 0, ii = imageBytes.length; i < ii; ++i) {
Kode lerroa:           a += imageBytes[i] & 0xff;
Kode lerroa:           b += a;
Kode lerroa:         }
Kode lerroa:         adler32 = b % 65521 << 16 | a % 65521;
Kode lerroa:         var cacheEntry = this.imageCache[adler32];
Kode lerroa:         if (cacheEntry !== undefined) {
Kode lerroa:           this.buf2 = _primitives.Cmd.get('EI');
Kode lerroa:           this.shift();
Kode lerroa:           cacheEntry.reset();
Kode lerroa:           return cacheEntry;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (cipherTransform) {
Kode lerroa:         imageStream = cipherTransform.createStream(imageStream, length);
Kode lerroa:       }
Kode lerroa:       imageStream = this.filter(imageStream, dict, length);
Kode lerroa:       imageStream.dict = dict;
Kode lerroa:       if (adler32 !== undefined) {
Kode lerroa:         imageStream.cacheKey = 'inline_' + length + '_' + adler32;
Kode lerroa:         this.imageCache[adler32] = imageStream;
Kode lerroa:       }
Kode lerroa:       this.buf2 = _primitives.Cmd.get('EI');
Kode lerroa:       this.shift();
Kode lerroa:       return imageStream;
Kode lerroa:     },
Kode lerroa:     makeStream: function Parser_makeStream(dict, cipherTransform) {
Kode lerroa:       var lexer = this.lexer;
Kode lerroa:       var stream = lexer.stream;
Kode lerroa:       lexer.skipToNextLine();
Kode lerroa:       var pos = stream.pos - 1;
Kode lerroa:       var length = dict.get('Length');
Kode lerroa:       if (!Number.isInteger(length)) {
Kode lerroa:         (0, _util.info)('Bad ' + length + ' attribute in stream');
Kode lerroa:         length = 0;
Kode lerroa:       }
Kode lerroa:       stream.pos = pos + length;
Kode lerroa:       lexer.nextChar();
Kode lerroa:       if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, 'endstream')) {
Kode lerroa:         this.shift();
Kode lerroa:       } else {
Kode lerroa:         stream.pos = pos;
Kode lerroa:         var SCAN_BLOCK_SIZE = 2048;
Kode lerroa:         var ENDSTREAM_SIGNATURE_LENGTH = 9;
Kode lerroa:         var ENDSTREAM_SIGNATURE = [0x65, 0x6E, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D];
Kode lerroa:         var skipped = 0,
Kode lerroa:             found = false,
Kode lerroa:             i,
Kode lerroa:             j;
Kode lerroa:         while (stream.pos < stream.end) {
Kode lerroa:           var scanBytes = stream.peekBytes(SCAN_BLOCK_SIZE);
Kode lerroa:           var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
Kode lerroa:           if (scanLength <= 0) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           found = false;
Kode lerroa:           i = 0;
Kode lerroa:           while (i < scanLength) {
Kode lerroa:             j = 0;
Kode lerroa:             while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
Kode lerroa:               j++;
Kode lerroa:             }
Kode lerroa:             if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
Kode lerroa:               found = true;
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:             i++;
Kode lerroa:           }
Kode lerroa:           if (found) {
Kode lerroa:             skipped += i;
Kode lerroa:             stream.pos += i;
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           skipped += scanLength;
Kode lerroa:           stream.pos += scanLength;
Kode lerroa:         }
Kode lerroa:         if (!found) {
Kode lerroa:           throw new _util.FormatError('Missing endstream');
Kode lerroa:         }
Kode lerroa:         length = skipped;
Kode lerroa:         lexer.nextChar();
Kode lerroa:         this.shift();
Kode lerroa:         this.shift();
Kode lerroa:       }
Kode lerroa:       this.shift();
Kode lerroa:       stream = stream.makeSubStream(pos, length, dict);
Kode lerroa:       if (cipherTransform) {
Kode lerroa:         stream = cipherTransform.createStream(stream, length);
Kode lerroa:       }
Kode lerroa:       stream = this.filter(stream, dict, length);
Kode lerroa:       stream.dict = dict;
Kode lerroa:       return stream;
Kode lerroa:     },
Kode lerroa:     filter: function Parser_filter(stream, dict, length) {
Kode lerroa:       var filter = dict.get('Filter', 'F');
Kode lerroa:       var params = dict.get('DecodeParms', 'DP');
Kode lerroa:       if ((0, _primitives.isName)(filter)) {
Kode lerroa:         if (Array.isArray(params)) {
Kode lerroa:           (0, _util.warn)('/DecodeParms should not contain an Array, ' + 'when /Filter contains a Name.');
Kode lerroa:         }
Kode lerroa:         return this.makeFilter(stream, filter.name, length, params);
Kode lerroa:       }
Kode lerroa:       var maybeLength = length;
Kode lerroa:       if (Array.isArray(filter)) {
Kode lerroa:         var filterArray = filter;
Kode lerroa:         var paramsArray = params;
Kode lerroa:         for (var i = 0, ii = filterArray.length; i < ii; ++i) {
Kode lerroa:           filter = this.xref.fetchIfRef(filterArray[i]);
Kode lerroa:           if (!(0, _primitives.isName)(filter)) {
Kode lerroa:             throw new _util.FormatError('Bad filter name: ' + filter);
Kode lerroa:           }
Kode lerroa:           params = null;
Kode lerroa:           if (Array.isArray(paramsArray) && i in paramsArray) {
Kode lerroa:             params = this.xref.fetchIfRef(paramsArray[i]);
Kode lerroa:           }
Kode lerroa:           stream = this.makeFilter(stream, filter.name, maybeLength, params);
Kode lerroa:           maybeLength = null;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return stream;
Kode lerroa:     },
Kode lerroa:     makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
Kode lerroa:       if (maybeLength === 0) {
Kode lerroa:         (0, _util.warn)('Empty "' + name + '" stream.');
Kode lerroa:         return new _stream.NullStream(stream);
Kode lerroa:       }
Kode lerroa:       try {
Kode lerroa:         var xrefStreamStats = this.xref.stats.streamTypes;
Kode lerroa:         if (name === 'FlateDecode' || name === 'Fl') {
Kode lerroa:           xrefStreamStats[_util.StreamType.FLATE] = true;
Kode lerroa:           if (params) {
Kode lerroa:             return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
Kode lerroa:           }
Kode lerroa:           return new _stream.FlateStream(stream, maybeLength);
Kode lerroa:         }
Kode lerroa:         if (name === 'LZWDecode' || name === 'LZW') {
Kode lerroa:           xrefStreamStats[_util.StreamType.LZW] = true;
Kode lerroa:           var earlyChange = 1;
Kode lerroa:           if (params) {
Kode lerroa:             if (params.has('EarlyChange')) {
Kode lerroa:               earlyChange = params.get('EarlyChange');
Kode lerroa:             }
Kode lerroa:             return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
Kode lerroa:           }
Kode lerroa:           return new _stream.LZWStream(stream, maybeLength, earlyChange);
Kode lerroa:         }
Kode lerroa:         if (name === 'DCTDecode' || name === 'DCT') {
Kode lerroa:           xrefStreamStats[_util.StreamType.DCT] = true;
Kode lerroa:           return new _stream.JpegStream(stream, maybeLength, stream.dict, params);
Kode lerroa:         }
Kode lerroa:         if (name === 'JPXDecode' || name === 'JPX') {
Kode lerroa:           xrefStreamStats[_util.StreamType.JPX] = true;
Kode lerroa:           return new _stream.JpxStream(stream, maybeLength, stream.dict, params);
Kode lerroa:         }
Kode lerroa:         if (name === 'ASCII85Decode' || name === 'A85') {
Kode lerroa:           xrefStreamStats[_util.StreamType.A85] = true;
Kode lerroa:           return new _stream.Ascii85Stream(stream, maybeLength);
Kode lerroa:         }
Kode lerroa:         if (name === 'ASCIIHexDecode' || name === 'AHx') {
Kode lerroa:           xrefStreamStats[_util.StreamType.AHX] = true;
Kode lerroa:           return new _stream.AsciiHexStream(stream, maybeLength);
Kode lerroa:         }
Kode lerroa:         if (name === 'CCITTFaxDecode' || name === 'CCF') {
Kode lerroa:           xrefStreamStats[_util.StreamType.CCF] = true;
Kode lerroa:           return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
Kode lerroa:         }
Kode lerroa:         if (name === 'RunLengthDecode' || name === 'RL') {
Kode lerroa:           xrefStreamStats[_util.StreamType.RL] = true;
Kode lerroa:           return new _stream.RunLengthStream(stream, maybeLength);
Kode lerroa:         }
Kode lerroa:         if (name === 'JBIG2Decode') {
Kode lerroa:           xrefStreamStats[_util.StreamType.JBIG] = true;
Kode lerroa:           return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
Kode lerroa:         }
Kode lerroa:         (0, _util.warn)('filter "' + name + '" not supported yet');
Kode lerroa:         return stream;
Kode lerroa:       } catch (ex) {
Kode lerroa:         if (ex instanceof _util.MissingDataException) {
Kode lerroa:           throw ex;
Kode lerroa:         }
Kode lerroa:         (0, _util.warn)('Invalid stream: \"' + ex + '\"');
Kode lerroa:         return new _stream.NullStream(stream);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Parser;
Kode lerroa: }();
Kode lerroa: var Lexer = function LexerClosure() {
Kode lerroa:   function Lexer(stream, knownCommands) {
Kode lerroa:     this.stream = stream;
Kode lerroa:     this.nextChar();
Kode lerroa:     this.strBuf = [];
Kode lerroa:     this.knownCommands = knownCommands;
Kode lerroa:   }
Kode lerroa:   var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
Kode lerroa:   function toHexDigit(ch) {
Kode lerroa:     if (ch >= 0x30 && ch <= 0x39) {
Kode lerroa:       return ch & 0x0F;
Kode lerroa:     }
Kode lerroa:     if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
Kode lerroa:       return (ch & 0x0F) + 9;
Kode lerroa:     }
Kode lerroa:     return -1;
Kode lerroa:   }
Kode lerroa:   Lexer.prototype = {
Kode lerroa:     nextChar: function Lexer_nextChar() {
Kode lerroa:       return this.currentChar = this.stream.getByte();
Kode lerroa:     },
Kode lerroa:     peekChar: function Lexer_peekChar() {
Kode lerroa:       return this.stream.peekByte();
Kode lerroa:     },
Kode lerroa:     getNumber: function Lexer_getNumber() {
Kode lerroa:       var ch = this.currentChar;
Kode lerroa:       var eNotation = false;
Kode lerroa:       var divideBy = 0;
Kode lerroa:       var sign = 1;
Kode lerroa:       if (ch === 0x2D) {
Kode lerroa:         sign = -1;
Kode lerroa:         ch = this.nextChar();
Kode lerroa:         if (ch === 0x2D) {
Kode lerroa:           ch = this.nextChar();
Kode lerroa:         }
Kode lerroa:       } else if (ch === 0x2B) {
Kode lerroa:         ch = this.nextChar();
Kode lerroa:       }
Kode lerroa:       if (ch === 0x2E) {
Kode lerroa:         divideBy = 10;
Kode lerroa:         ch = this.nextChar();
Kode lerroa:       }
Kode lerroa:       if (ch === 0x0A || ch === 0x0D) {
Kode lerroa:         do {
Kode lerroa:           ch = this.nextChar();
Kode lerroa:         } while (ch === 0x0A || ch === 0x0D);
Kode lerroa:       }
Kode lerroa:       if (ch < 0x30 || ch > 0x39) {
Kode lerroa:         throw new _util.FormatError('Invalid number: ' + String.fromCharCode(ch) + ' (charCode ' + ch + ')');
Kode lerroa:       }
Kode lerroa:       var baseValue = ch - 0x30;
Kode lerroa:       var powerValue = 0;
Kode lerroa:       var powerValueSign = 1;
Kode lerroa:       while ((ch = this.nextChar()) >= 0) {
Kode lerroa:         if (0x30 <= ch && ch <= 0x39) {
Kode lerroa:           var currentDigit = ch - 0x30;
Kode lerroa:           if (eNotation) {
Kode lerroa:             powerValue = powerValue * 10 + currentDigit;
Kode lerroa:           } else {
Kode lerroa:             if (divideBy !== 0) {
Kode lerroa:               divideBy *= 10;
Kode lerroa:             }
Kode lerroa:             baseValue = baseValue * 10 + currentDigit;
Kode lerroa:           }
Kode lerroa:         } else if (ch === 0x2E) {
Kode lerroa:           if (divideBy === 0) {
Kode lerroa:             divideBy = 1;
Kode lerroa:           } else {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         } else if (ch === 0x2D) {
Kode lerroa:           (0, _util.warn)('Badly formatted number');
Kode lerroa:         } else if (ch === 0x45 || ch === 0x65) {
Kode lerroa:           ch = this.peekChar();
Kode lerroa:           if (ch === 0x2B || ch === 0x2D) {
Kode lerroa:             powerValueSign = ch === 0x2D ? -1 : 1;
Kode lerroa:             this.nextChar();
Kode lerroa:           } else if (ch < 0x30 || ch > 0x39) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           eNotation = true;
Kode lerroa:         } else {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (divideBy !== 0) {
Kode lerroa:         baseValue /= divideBy;
Kode lerroa:       }
Kode lerroa:       if (eNotation) {
Kode lerroa:         baseValue *= Math.pow(10, powerValueSign * powerValue);
Kode lerroa:       }
Kode lerroa:       return sign * baseValue;
Kode lerroa:     },
Kode lerroa:     getString: function Lexer_getString() {
Kode lerroa:       var numParen = 1;
Kode lerroa:       var done = false;
Kode lerroa:       var strBuf = this.strBuf;
Kode lerroa:       strBuf.length = 0;
Kode lerroa:       var ch = this.nextChar();
Kode lerroa:       while (true) {
Kode lerroa:         var charBuffered = false;
Kode lerroa:         switch (ch | 0) {
Kode lerroa:           case -1:
Kode lerroa:             (0, _util.warn)('Unterminated string');
Kode lerroa:             done = true;
Kode lerroa:             break;
Kode lerroa:           case 0x28:
Kode lerroa:             ++numParen;
Kode lerroa:             strBuf.push('(');
Kode lerroa:             break;
Kode lerroa:           case 0x29:
Kode lerroa:             if (--numParen === 0) {
Kode lerroa:               this.nextChar();
Kode lerroa:               done = true;
Kode lerroa:             } else {
Kode lerroa:               strBuf.push(')');
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 0x5C:
Kode lerroa:             ch = this.nextChar();
Kode lerroa:             switch (ch) {
Kode lerroa:               case -1:
Kode lerroa:                 (0, _util.warn)('Unterminated string');
Kode lerroa:                 done = true;
Kode lerroa:                 break;
Kode lerroa:               case 0x6E:
Kode lerroa:                 strBuf.push('\n');
Kode lerroa:                 break;
Kode lerroa:               case 0x72:
Kode lerroa:                 strBuf.push('\r');
Kode lerroa:                 break;
Kode lerroa:               case 0x74:
Kode lerroa:                 strBuf.push('\t');
Kode lerroa:                 break;
Kode lerroa:               case 0x62:
Kode lerroa:                 strBuf.push('\b');
Kode lerroa:                 break;
Kode lerroa:               case 0x66:
Kode lerroa:                 strBuf.push('\f');
Kode lerroa:                 break;
Kode lerroa:               case 0x5C:
Kode lerroa:               case 0x28:
Kode lerroa:               case 0x29:
Kode lerroa:                 strBuf.push(String.fromCharCode(ch));
Kode lerroa:                 break;
Kode lerroa:               case 0x30:
Kode lerroa:               case 0x31:
Kode lerroa:               case 0x32:
Kode lerroa:               case 0x33:
Kode lerroa:               case 0x34:
Kode lerroa:               case 0x35:
Kode lerroa:               case 0x36:
Kode lerroa:               case 0x37:
Kode lerroa:                 var x = ch & 0x0F;
Kode lerroa:                 ch = this.nextChar();
Kode lerroa:                 charBuffered = true;
Kode lerroa:                 if (ch >= 0x30 && ch <= 0x37) {
Kode lerroa:                   x = (x << 3) + (ch & 0x0F);
Kode lerroa:                   ch = this.nextChar();
Kode lerroa:                   if (ch >= 0x30 && ch <= 0x37) {
Kode lerroa:                     charBuffered = false;
Kode lerroa:                     x = (x << 3) + (ch & 0x0F);
Kode lerroa:                   }
Kode lerroa:                 }
Kode lerroa:                 strBuf.push(String.fromCharCode(x));
Kode lerroa:                 break;
Kode lerroa:               case 0x0D:
Kode lerroa:                 if (this.peekChar() === 0x0A) {
Kode lerroa:                   this.nextChar();
Kode lerroa:                 }
Kode lerroa:                 break;
Kode lerroa:               case 0x0A:
Kode lerroa:                 break;
Kode lerroa:               default:
Kode lerroa:                 strBuf.push(String.fromCharCode(ch));
Kode lerroa:                 break;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             strBuf.push(String.fromCharCode(ch));
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         if (done) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         if (!charBuffered) {
Kode lerroa:           ch = this.nextChar();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return strBuf.join('');
Kode lerroa:     },
Kode lerroa:     getName: function Lexer_getName() {
Kode lerroa:       var ch, previousCh;
Kode lerroa:       var strBuf = this.strBuf;
Kode lerroa:       strBuf.length = 0;
Kode lerroa:       while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
Kode lerroa:         if (ch === 0x23) {
Kode lerroa:           ch = this.nextChar();
Kode lerroa:           if (specialChars[ch]) {
Kode lerroa:             (0, _util.warn)('Lexer_getName: ' + 'NUMBER SIGN (#) should be followed by a hexadecimal number.');
Kode lerroa:             strBuf.push('#');
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           var x = toHexDigit(ch);
Kode lerroa:           if (x !== -1) {
Kode lerroa:             previousCh = ch;
Kode lerroa:             ch = this.nextChar();
Kode lerroa:             var x2 = toHexDigit(ch);
Kode lerroa:             if (x2 === -1) {
Kode lerroa:               (0, _util.warn)('Lexer_getName: Illegal digit (' + String.fromCharCode(ch) + ') in hexadecimal number.');
Kode lerroa:               strBuf.push('#', String.fromCharCode(previousCh));
Kode lerroa:               if (specialChars[ch]) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               strBuf.push(String.fromCharCode(ch));
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             strBuf.push(String.fromCharCode(x << 4 | x2));
Kode lerroa:           } else {
Kode lerroa:             strBuf.push('#', String.fromCharCode(ch));
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           strBuf.push(String.fromCharCode(ch));
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (strBuf.length > 127) {
Kode lerroa:         (0, _util.warn)('name token is longer than allowed by the spec: ' + strBuf.length);
Kode lerroa:       }
Kode lerroa:       return _primitives.Name.get(strBuf.join(''));
Kode lerroa:     },
Kode lerroa:     getHexString: function Lexer_getHexString() {
Kode lerroa:       var strBuf = this.strBuf;
Kode lerroa:       strBuf.length = 0;
Kode lerroa:       var ch = this.currentChar;
Kode lerroa:       var isFirstHex = true;
Kode lerroa:       var firstDigit;
Kode lerroa:       var secondDigit;
Kode lerroa:       while (true) {
Kode lerroa:         if (ch < 0) {
Kode lerroa:           (0, _util.warn)('Unterminated hex string');
Kode lerroa:           break;
Kode lerroa:         } else if (ch === 0x3E) {
Kode lerroa:           this.nextChar();
Kode lerroa:           break;
Kode lerroa:         } else if (specialChars[ch] === 1) {
Kode lerroa:           ch = this.nextChar();
Kode lerroa:           continue;
Kode lerroa:         } else {
Kode lerroa:           if (isFirstHex) {
Kode lerroa:             firstDigit = toHexDigit(ch);
Kode lerroa:             if (firstDigit === -1) {
Kode lerroa:               (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
Kode lerroa:               ch = this.nextChar();
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:           } else {
Kode lerroa:             secondDigit = toHexDigit(ch);
Kode lerroa:             if (secondDigit === -1) {
Kode lerroa:               (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
Kode lerroa:               ch = this.nextChar();
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
Kode lerroa:           }
Kode lerroa:           isFirstHex = !isFirstHex;
Kode lerroa:           ch = this.nextChar();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return strBuf.join('');
Kode lerroa:     },
Kode lerroa:     getObj: function Lexer_getObj() {
Kode lerroa:       var comment = false;
Kode lerroa:       var ch = this.currentChar;
Kode lerroa:       while (true) {
Kode lerroa:         if (ch < 0) {
Kode lerroa:           return _primitives.EOF;
Kode lerroa:         }
Kode lerroa:         if (comment) {
Kode lerroa:           if (ch === 0x0A || ch === 0x0D) {
Kode lerroa:             comment = false;
Kode lerroa:           }
Kode lerroa:         } else if (ch === 0x25) {
Kode lerroa:           comment = true;
Kode lerroa:         } else if (specialChars[ch] !== 1) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         ch = this.nextChar();
Kode lerroa:       }
Kode lerroa:       switch (ch | 0) {
Kode lerroa:         case 0x30:
Kode lerroa:         case 0x31:
Kode lerroa:         case 0x32:
Kode lerroa:         case 0x33:
Kode lerroa:         case 0x34:
Kode lerroa:         case 0x35:
Kode lerroa:         case 0x36:
Kode lerroa:         case 0x37:
Kode lerroa:         case 0x38:
Kode lerroa:         case 0x39:
Kode lerroa:         case 0x2B:
Kode lerroa:         case 0x2D:
Kode lerroa:         case 0x2E:
Kode lerroa:           return this.getNumber();
Kode lerroa:         case 0x28:
Kode lerroa:           return this.getString();
Kode lerroa:         case 0x2F:
Kode lerroa:           return this.getName();
Kode lerroa:         case 0x5B:
Kode lerroa:           this.nextChar();
Kode lerroa:           return _primitives.Cmd.get('[');
Kode lerroa:         case 0x5D:
Kode lerroa:           this.nextChar();
Kode lerroa:           return _primitives.Cmd.get(']');
Kode lerroa:         case 0x3C:
Kode lerroa:           ch = this.nextChar();
Kode lerroa:           if (ch === 0x3C) {
Kode lerroa:             this.nextChar();
Kode lerroa:             return _primitives.Cmd.get('<<');
Kode lerroa:           }
Kode lerroa:           return this.getHexString();
Kode lerroa:         case 0x3E:
Kode lerroa:           ch = this.nextChar();
Kode lerroa:           if (ch === 0x3E) {
Kode lerroa:             this.nextChar();
Kode lerroa:             return _primitives.Cmd.get('>>');
Kode lerroa:           }
Kode lerroa:           return _primitives.Cmd.get('>');
Kode lerroa:         case 0x7B:
Kode lerroa:           this.nextChar();
Kode lerroa:           return _primitives.Cmd.get('{');
Kode lerroa:         case 0x7D:
Kode lerroa:           this.nextChar();
Kode lerroa:           return _primitives.Cmd.get('}');
Kode lerroa:         case 0x29:
Kode lerroa:           this.nextChar();
Kode lerroa:           throw new _util.FormatError('Illegal character: ' + ch);
Kode lerroa:       }
Kode lerroa:       var str = String.fromCharCode(ch);
Kode lerroa:       var knownCommands = this.knownCommands;
Kode lerroa:       var knownCommandFound = knownCommands && knownCommands[str] !== undefined;
Kode lerroa:       while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
Kode lerroa:         var possibleCommand = str + String.fromCharCode(ch);
Kode lerroa:         if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         if (str.length === 128) {
Kode lerroa:           throw new _util.FormatError('Command token too long: ' + str.length);
Kode lerroa:         }
Kode lerroa:         str = possibleCommand;
Kode lerroa:         knownCommandFound = knownCommands && knownCommands[str] !== undefined;
Kode lerroa:       }
Kode lerroa:       if (str === 'true') {
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:       if (str === 'false') {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       if (str === 'null') {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       return _primitives.Cmd.get(str);
Kode lerroa:     },
Kode lerroa:     skipToNextLine: function Lexer_skipToNextLine() {
Kode lerroa:       var ch = this.currentChar;
Kode lerroa:       while (ch >= 0) {
Kode lerroa:         if (ch === 0x0D) {
Kode lerroa:           ch = this.nextChar();
Kode lerroa:           if (ch === 0x0A) {
Kode lerroa:             this.nextChar();
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         } else if (ch === 0x0A) {
Kode lerroa:           this.nextChar();
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         ch = this.nextChar();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Lexer;
Kode lerroa: }();
Kode lerroa: var Linearization = {
Kode lerroa:   create: function LinearizationCreate(stream) {
Kode lerroa:     function getInt(name, allowZeroValue) {
Kode lerroa:       var obj = linDict.get(name);
Kode lerroa:       if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
Kode lerroa:         return obj;
Kode lerroa:       }
Kode lerroa:       throw new Error('The "' + name + '" parameter in the linearization ' + 'dictionary is invalid.');
Kode lerroa:     }
Kode lerroa:     function getHints() {
Kode lerroa:       var hints = linDict.get('H'),
Kode lerroa:           hintsLength,
Kode lerroa:           item;
Kode lerroa:       if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
Kode lerroa:         for (var index = 0; index < hintsLength; index++) {
Kode lerroa:           if (!(Number.isInteger(item = hints[index]) && item > 0)) {
Kode lerroa:             throw new Error('Hint (' + index + ') in the linearization dictionary is invalid.');
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return hints;
Kode lerroa:       }
Kode lerroa:       throw new Error('Hint array in the linearization dictionary is invalid.');
Kode lerroa:     }
Kode lerroa:     var parser = new Parser(new Lexer(stream), false, null);
Kode lerroa:     var obj1 = parser.getObj();
Kode lerroa:     var obj2 = parser.getObj();
Kode lerroa:     var obj3 = parser.getObj();
Kode lerroa:     var linDict = parser.getObj();
Kode lerroa:     var obj, length;
Kode lerroa:     if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, 'obj') && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get('Linearized')) && obj > 0)) {
Kode lerroa:       return null;
Kode lerroa:     } else if ((length = getInt('L')) !== stream.length) {
Kode lerroa:       throw new Error('The "L" parameter in the linearization dictionary ' + 'does not equal the stream length.');
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       length: length,
Kode lerroa:       hints: getHints(),
Kode lerroa:       objectNumberFirst: getInt('O'),
Kode lerroa:       endFirst: getInt('E'),
Kode lerroa:       numPages: getInt('N'),
Kode lerroa:       mainXRefEntriesOffset: getInt('T'),
Kode lerroa:       pageFirst: linDict.has('P') ? getInt('P', true) : 0
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: exports.Lexer = Lexer;
Kode lerroa: exports.Linearization = Linearization;
Kode lerroa: exports.Parser = Parser;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 35 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(3);
Kode lerroa: var document = __w_pdfjs_require__(1).document;
Kode lerroa: var is = isObject(document) && isObject(document.createElement);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return is ? document.createElement(it) : {};
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 36 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(3);
Kode lerroa: module.exports = function (it, S) {
Kode lerroa:   if (!isObject(it)) return it;
Kode lerroa:   var fn, val;
Kode lerroa:   if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
Kode lerroa:   if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
Kode lerroa:   if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
Kode lerroa:   throw TypeError("Can't convert object to primitive value");
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 37 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var cof = __w_pdfjs_require__(25);
Kode lerroa: module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
Kode lerroa:   return cof(it) == 'String' ? it.split('') : Object(it);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 38 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (it == undefined) throw TypeError("Can't call method on  " + it);
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 39 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var shared = __w_pdfjs_require__(54)('keys');
Kode lerroa: var uid = __w_pdfjs_require__(17);
Kode lerroa: module.exports = function (key) {
Kode lerroa:   return shared[key] || (shared[key] = uid(key));
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 40 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 41 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $keys = __w_pdfjs_require__(52);
Kode lerroa: var enumBugKeys = __w_pdfjs_require__(40);
Kode lerroa: module.exports = Object.keys || function keys(O) {
Kode lerroa:   return $keys(O, enumBugKeys);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 42 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ctx = __w_pdfjs_require__(13);
Kode lerroa: var IObject = __w_pdfjs_require__(37);
Kode lerroa: var toObject = __w_pdfjs_require__(19);
Kode lerroa: var toLength = __w_pdfjs_require__(14);
Kode lerroa: var asc = __w_pdfjs_require__(91);
Kode lerroa: module.exports = function (TYPE, $create) {
Kode lerroa:   var IS_MAP = TYPE == 1;
Kode lerroa:   var IS_FILTER = TYPE == 2;
Kode lerroa:   var IS_SOME = TYPE == 3;
Kode lerroa:   var IS_EVERY = TYPE == 4;
Kode lerroa:   var IS_FIND_INDEX = TYPE == 6;
Kode lerroa:   var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
Kode lerroa:   var create = $create || asc;
Kode lerroa:   return function ($this, callbackfn, that) {
Kode lerroa:     var O = toObject($this);
Kode lerroa:     var self = IObject(O);
Kode lerroa:     var f = ctx(callbackfn, that, 3);
Kode lerroa:     var length = toLength(self.length);
Kode lerroa:     var index = 0;
Kode lerroa:     var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
Kode lerroa:     var val, res;
Kode lerroa:     for (; length > index; index++) {
Kode lerroa:       if (NO_HOLES || index in self) {
Kode lerroa:         val = self[index];
Kode lerroa:         res = f(val, index, O);
Kode lerroa:         if (TYPE) {
Kode lerroa:           if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {
Kode lerroa:             case 3:
Kode lerroa:               return true;
Kode lerroa:             case 5:
Kode lerroa:               return val;
Kode lerroa:             case 6:
Kode lerroa:               return index;
Kode lerroa:             case 2:
Kode lerroa:               result.push(val);
Kode lerroa:           } else if (IS_EVERY) return false;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 43 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(9);
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: var SPECIES = __w_pdfjs_require__(4)('species');
Kode lerroa: module.exports = function (O, D) {
Kode lerroa:   var C = anObject(O).constructor;
Kode lerroa:   var S;
Kode lerroa:   return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 44 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ITERATOR = __w_pdfjs_require__(4)('iterator');
Kode lerroa: var SAFE_CLOSING = false;
Kode lerroa: try {
Kode lerroa:   var riter = [7][ITERATOR]();
Kode lerroa:   riter['return'] = function () {
Kode lerroa:     SAFE_CLOSING = true;
Kode lerroa:   };
Kode lerroa:   Array.from(riter, function () {
Kode lerroa:     throw 2;
Kode lerroa:   });
Kode lerroa: } catch (e) {}
Kode lerroa: module.exports = function (exec, skipClosing) {
Kode lerroa:   if (!skipClosing && !SAFE_CLOSING) return false;
Kode lerroa:   var safe = false;
Kode lerroa:   try {
Kode lerroa:     var arr = [7];
Kode lerroa:     var iter = arr[ITERATOR]();
Kode lerroa:     iter.next = function () {
Kode lerroa:       return { done: safe = true };
Kode lerroa:     };
Kode lerroa:     arr[ITERATOR] = function () {
Kode lerroa:       return iter;
Kode lerroa:     };
Kode lerroa:     exec(arr);
Kode lerroa:   } catch (e) {}
Kode lerroa:   return safe;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 45 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var aFunction = __w_pdfjs_require__(22);
Kode lerroa: function PromiseCapability(C) {
Kode lerroa:   var resolve, reject;
Kode lerroa:   this.promise = new C(function ($$resolve, $$reject) {
Kode lerroa:     if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
Kode lerroa:     resolve = $$resolve;
Kode lerroa:     reject = $$reject;
Kode lerroa:   });
Kode lerroa:   this.resolve = aFunction(resolve);
Kode lerroa:   this.reject = aFunction(reject);
Kode lerroa: }
Kode lerroa: module.exports.f = function (C) {
Kode lerroa:   return new PromiseCapability(C);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 46 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var META = __w_pdfjs_require__(17)('meta');
Kode lerroa: var isObject = __w_pdfjs_require__(3);
Kode lerroa: var has = __w_pdfjs_require__(12);
Kode lerroa: var setDesc = __w_pdfjs_require__(15).f;
Kode lerroa: var id = 0;
Kode lerroa: var isExtensible = Object.isExtensible || function () {
Kode lerroa:   return true;
Kode lerroa: };
Kode lerroa: var FREEZE = !__w_pdfjs_require__(11)(function () {
Kode lerroa:   return isExtensible(Object.preventExtensions({}));
Kode lerroa: });
Kode lerroa: var setMeta = function setMeta(it) {
Kode lerroa:   setDesc(it, META, {
Kode lerroa:     value: {
Kode lerroa:       i: 'O' + ++id,
Kode lerroa:       w: {}
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: var fastKey = function fastKey(it, create) {
Kode lerroa:   if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
Kode lerroa:   if (!has(it, META)) {
Kode lerroa:     if (!isExtensible(it)) return 'F';
Kode lerroa:     if (!create) return 'E';
Kode lerroa:     setMeta(it);
Kode lerroa:   }
Kode lerroa:   return it[META].i;
Kode lerroa: };
Kode lerroa: var getWeak = function getWeak(it, create) {
Kode lerroa:   if (!has(it, META)) {
Kode lerroa:     if (!isExtensible(it)) return true;
Kode lerroa:     if (!create) return false;
Kode lerroa:     setMeta(it);
Kode lerroa:   }
Kode lerroa:   return it[META].w;
Kode lerroa: };
Kode lerroa: var onFreeze = function onFreeze(it) {
Kode lerroa:   if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: var meta = module.exports = {
Kode lerroa:   KEY: META,
Kode lerroa:   NEED: false,
Kode lerroa:   fastKey: fastKey,
Kode lerroa:   getWeak: getWeak,
Kode lerroa:   onFreeze: onFreeze
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 47 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: var getLookupTableFactory = __w_pdfjs_require__(0).getLookupTableFactory;
Kode lerroa: var getGlyphsUnicode = getLookupTableFactory(function (t) {
Kode lerroa:  t['A'] = 0x0041;
Kode lerroa:  t['AE'] = 0x00C6;
Kode lerroa:  t['AEacute'] = 0x01FC;
Kode lerroa:  t['AEmacron'] = 0x01E2;
Kode lerroa:  t['AEsmall'] = 0xF7E6;
Kode lerroa:  t['Aacute'] = 0x00C1;
Kode lerroa:  t['Aacutesmall'] = 0xF7E1;
Kode lerroa:  t['Abreve'] = 0x0102;
Kode lerroa:  t['Abreveacute'] = 0x1EAE;
Kode lerroa:  t['Abrevecyrillic'] = 0x04D0;
Kode lerroa:  t['Abrevedotbelow'] = 0x1EB6;
Kode lerroa:  t['Abrevegrave'] = 0x1EB0;
Kode lerroa:  t['Abrevehookabove'] = 0x1EB2;
Kode lerroa:  t['Abrevetilde'] = 0x1EB4;
Kode lerroa:  t['Acaron'] = 0x01CD;
Kode lerroa:  t['Acircle'] = 0x24B6;
Kode lerroa:  t['Acircumflex'] = 0x00C2;
Kode lerroa:  t['Acircumflexacute'] = 0x1EA4;
Kode lerroa:  t['Acircumflexdotbelow'] = 0x1EAC;
Kode lerroa:  t['Acircumflexgrave'] = 0x1EA6;
Kode lerroa:  t['Acircumflexhookabove'] = 0x1EA8;
Kode lerroa:  t['Acircumflexsmall'] = 0xF7E2;
Kode lerroa:  t['Acircumflextilde'] = 0x1EAA;
Kode lerroa:  t['Acute'] = 0xF6C9;
Kode lerroa:  t['Acutesmall'] = 0xF7B4;
Kode lerroa:  t['Acyrillic'] = 0x0410;
Kode lerroa:  t['Adblgrave'] = 0x0200;
Kode lerroa:  t['Adieresis'] = 0x00C4;
Kode lerroa:  t['Adieresiscyrillic'] = 0x04D2;
Kode lerroa:  t['Adieresismacron'] = 0x01DE;
Kode lerroa:  t['Adieresissmall'] = 0xF7E4;
Kode lerroa:  t['Adotbelow'] = 0x1EA0;
Kode lerroa:  t['Adotmacron'] = 0x01E0;
Kode lerroa:  t['Agrave'] = 0x00C0;
Kode lerroa:  t['Agravesmall'] = 0xF7E0;
Kode lerroa:  t['Ahookabove'] = 0x1EA2;
Kode lerroa:  t['Aiecyrillic'] = 0x04D4;
Kode lerroa:  t['Ainvertedbreve'] = 0x0202;
Kode lerroa:  t['Alpha'] = 0x0391;
Kode lerroa:  t['Alphatonos'] = 0x0386;
Kode lerroa:  t['Amacron'] = 0x0100;
Kode lerroa:  t['Amonospace'] = 0xFF21;
Kode lerroa:  t['Aogonek'] = 0x0104;
Kode lerroa:  t['Aring'] = 0x00C5;
Kode lerroa:  t['Aringacute'] = 0x01FA;
Kode lerroa:  t['Aringbelow'] = 0x1E00;
Kode lerroa:  t['Aringsmall'] = 0xF7E5;
Kode lerroa:  t['Asmall'] = 0xF761;
Kode lerroa:  t['Atilde'] = 0x00C3;
Kode lerroa:  t['Atildesmall'] = 0xF7E3;
Kode lerroa:  t['Aybarmenian'] = 0x0531;
Kode lerroa:  t['B'] = 0x0042;
Kode lerroa:  t['Bcircle'] = 0x24B7;
Kode lerroa:  t['Bdotaccent'] = 0x1E02;
Kode lerroa:  t['Bdotbelow'] = 0x1E04;
Kode lerroa:  t['Becyrillic'] = 0x0411;
Kode lerroa:  t['Benarmenian'] = 0x0532;
Kode lerroa:  t['Beta'] = 0x0392;
Kode lerroa:  t['Bhook'] = 0x0181;
Kode lerroa:  t['Blinebelow'] = 0x1E06;
Kode lerroa:  t['Bmonospace'] = 0xFF22;
Kode lerroa:  t['Brevesmall'] = 0xF6F4;
Kode lerroa:  t['Bsmall'] = 0xF762;
Kode lerroa:  t['Btopbar'] = 0x0182;
Kode lerroa:  t['C'] = 0x0043;
Kode lerroa:  t['Caarmenian'] = 0x053E;
Kode lerroa:  t['Cacute'] = 0x0106;
Kode lerroa:  t['Caron'] = 0xF6CA;
Kode lerroa:  t['Caronsmall'] = 0xF6F5;
Kode lerroa:  t['Ccaron'] = 0x010C;
Kode lerroa:  t['Ccedilla'] = 0x00C7;
Kode lerroa:  t['Ccedillaacute'] = 0x1E08;
Kode lerroa:  t['Ccedillasmall'] = 0xF7E7;
Kode lerroa:  t['Ccircle'] = 0x24B8;
Kode lerroa:  t['Ccircumflex'] = 0x0108;
Kode lerroa:  t['Cdot'] = 0x010A;
Kode lerroa:  t['Cdotaccent'] = 0x010A;
Kode lerroa:  t['Cedillasmall'] = 0xF7B8;
Kode lerroa:  t['Chaarmenian'] = 0x0549;
Kode lerroa:  t['Cheabkhasiancyrillic'] = 0x04BC;
Kode lerroa:  t['Checyrillic'] = 0x0427;
Kode lerroa:  t['Chedescenderabkhasiancyrillic'] = 0x04BE;
Kode lerroa:  t['Chedescendercyrillic'] = 0x04B6;
Kode lerroa:  t['Chedieresiscyrillic'] = 0x04F4;
Kode lerroa:  t['Cheharmenian'] = 0x0543;
Kode lerroa:  t['Chekhakassiancyrillic'] = 0x04CB;
Kode lerroa:  t['Cheverticalstrokecyrillic'] = 0x04B8;
Kode lerroa:  t['Chi'] = 0x03A7;
Kode lerroa:  t['Chook'] = 0x0187;
Kode lerroa:  t['Circumflexsmall'] = 0xF6F6;
Kode lerroa:  t['Cmonospace'] = 0xFF23;
Kode lerroa:  t['Coarmenian'] = 0x0551;
Kode lerroa:  t['Csmall'] = 0xF763;
Kode lerroa:  t['D'] = 0x0044;
Kode lerroa:  t['DZ'] = 0x01F1;
Kode lerroa:  t['DZcaron'] = 0x01C4;
Kode lerroa:  t['Daarmenian'] = 0x0534;
Kode lerroa:  t['Dafrican'] = 0x0189;
Kode lerroa:  t['Dcaron'] = 0x010E;
Kode lerroa:  t['Dcedilla'] = 0x1E10;
Kode lerroa:  t['Dcircle'] = 0x24B9;
Kode lerroa:  t['Dcircumflexbelow'] = 0x1E12;
Kode lerroa:  t['Dcroat'] = 0x0110;
Kode lerroa:  t['Ddotaccent'] = 0x1E0A;
Kode lerroa:  t['Ddotbelow'] = 0x1E0C;
Kode lerroa:  t['Decyrillic'] = 0x0414;
Kode lerroa:  t['Deicoptic'] = 0x03EE;
Kode lerroa:  t['Delta'] = 0x2206;
Kode lerroa:  t['Deltagreek'] = 0x0394;
Kode lerroa:  t['Dhook'] = 0x018A;
Kode lerroa:  t['Dieresis'] = 0xF6CB;
Kode lerroa:  t['DieresisAcute'] = 0xF6CC;
Kode lerroa:  t['DieresisGrave'] = 0xF6CD;
Kode lerroa:  t['Dieresissmall'] = 0xF7A8;
Kode lerroa:  t['Digammagreek'] = 0x03DC;
Kode lerroa:  t['Djecyrillic'] = 0x0402;
Kode lerroa:  t['Dlinebelow'] = 0x1E0E;
Kode lerroa:  t['Dmonospace'] = 0xFF24;
Kode lerroa:  t['Dotaccentsmall'] = 0xF6F7;
Kode lerroa:  t['Dslash'] = 0x0110;
Kode lerroa:  t['Dsmall'] = 0xF764;
Kode lerroa:  t['Dtopbar'] = 0x018B;
Kode lerroa:  t['Dz'] = 0x01F2;
Kode lerroa:  t['Dzcaron'] = 0x01C5;
Kode lerroa:  t['Dzeabkhasiancyrillic'] = 0x04E0;
Kode lerroa:  t['Dzecyrillic'] = 0x0405;
Kode lerroa:  t['Dzhecyrillic'] = 0x040F;
Kode lerroa:  t['E'] = 0x0045;
Kode lerroa:  t['Eacute'] = 0x00C9;
Kode lerroa:  t['Eacutesmall'] = 0xF7E9;
Kode lerroa:  t['Ebreve'] = 0x0114;
Kode lerroa:  t['Ecaron'] = 0x011A;
Kode lerroa:  t['Ecedillabreve'] = 0x1E1C;
Kode lerroa:  t['Echarmenian'] = 0x0535;
Kode lerroa:  t['Ecircle'] = 0x24BA;
Kode lerroa:  t['Ecircumflex'] = 0x00CA;
Kode lerroa:  t['Ecircumflexacute'] = 0x1EBE;
Kode lerroa:  t['Ecircumflexbelow'] = 0x1E18;
Kode lerroa:  t['Ecircumflexdotbelow'] = 0x1EC6;
Kode lerroa:  t['Ecircumflexgrave'] = 0x1EC0;
Kode lerroa:  t['Ecircumflexhookabove'] = 0x1EC2;
Kode lerroa:  t['Ecircumflexsmall'] = 0xF7EA;
Kode lerroa:  t['Ecircumflextilde'] = 0x1EC4;
Kode lerroa:  t['Ecyrillic'] = 0x0404;
Kode lerroa:  t['Edblgrave'] = 0x0204;
Kode lerroa:  t['Edieresis'] = 0x00CB;
Kode lerroa:  t['Edieresissmall'] = 0xF7EB;
Kode lerroa:  t['Edot'] = 0x0116;
Kode lerroa:  t['Edotaccent'] = 0x0116;
Kode lerroa:  t['Edotbelow'] = 0x1EB8;
Kode lerroa:  t['Efcyrillic'] = 0x0424;
Kode lerroa:  t['Egrave'] = 0x00C8;
Kode lerroa:  t['Egravesmall'] = 0xF7E8;
Kode lerroa:  t['Eharmenian'] = 0x0537;
Kode lerroa:  t['Ehookabove'] = 0x1EBA;
Kode lerroa:  t['Eightroman'] = 0x2167;
Kode lerroa:  t['Einvertedbreve'] = 0x0206;
Kode lerroa:  t['Eiotifiedcyrillic'] = 0x0464;
Kode lerroa:  t['Elcyrillic'] = 0x041B;
Kode lerroa:  t['Elevenroman'] = 0x216A;
Kode lerroa:  t['Emacron'] = 0x0112;
Kode lerroa:  t['Emacronacute'] = 0x1E16;
Kode lerroa:  t['Emacrongrave'] = 0x1E14;
Kode lerroa:  t['Emcyrillic'] = 0x041C;
Kode lerroa:  t['Emonospace'] = 0xFF25;
Kode lerroa:  t['Encyrillic'] = 0x041D;
Kode lerroa:  t['Endescendercyrillic'] = 0x04A2;
Kode lerroa:  t['Eng'] = 0x014A;
Kode lerroa:  t['Enghecyrillic'] = 0x04A4;
Kode lerroa:  t['Enhookcyrillic'] = 0x04C7;
Kode lerroa:  t['Eogonek'] = 0x0118;
Kode lerroa:  t['Eopen'] = 0x0190;
Kode lerroa:  t['Epsilon'] = 0x0395;
Kode lerroa:  t['Epsilontonos'] = 0x0388;
Kode lerroa:  t['Ercyrillic'] = 0x0420;
Kode lerroa:  t['Ereversed'] = 0x018E;
Kode lerroa:  t['Ereversedcyrillic'] = 0x042D;
Kode lerroa:  t['Escyrillic'] = 0x0421;
Kode lerroa:  t['Esdescendercyrillic'] = 0x04AA;
Kode lerroa:  t['Esh'] = 0x01A9;
Kode lerroa:  t['Esmall'] = 0xF765;
Kode lerroa:  t['Eta'] = 0x0397;
Kode lerroa:  t['Etarmenian'] = 0x0538;
Kode lerroa:  t['Etatonos'] = 0x0389;
Kode lerroa:  t['Eth'] = 0x00D0;
Kode lerroa:  t['Ethsmall'] = 0xF7F0;
Kode lerroa:  t['Etilde'] = 0x1EBC;
Kode lerroa:  t['Etildebelow'] = 0x1E1A;
Kode lerroa:  t['Euro'] = 0x20AC;
Kode lerroa:  t['Ezh'] = 0x01B7;
Kode lerroa:  t['Ezhcaron'] = 0x01EE;
Kode lerroa:  t['Ezhreversed'] = 0x01B8;
Kode lerroa:  t['F'] = 0x0046;
Kode lerroa:  t['Fcircle'] = 0x24BB;
Kode lerroa:  t['Fdotaccent'] = 0x1E1E;
Kode lerroa:  t['Feharmenian'] = 0x0556;
Kode lerroa:  t['Feicoptic'] = 0x03E4;
Kode lerroa:  t['Fhook'] = 0x0191;
Kode lerroa:  t['Fitacyrillic'] = 0x0472;
Kode lerroa:  t['Fiveroman'] = 0x2164;
Kode lerroa:  t['Fmonospace'] = 0xFF26;
Kode lerroa:  t['Fourroman'] = 0x2163;
Kode lerroa:  t['Fsmall'] = 0xF766;
Kode lerroa:  t['G'] = 0x0047;
Kode lerroa:  t['GBsquare'] = 0x3387;
Kode lerroa:  t['Gacute'] = 0x01F4;
Kode lerroa:  t['Gamma'] = 0x0393;
Kode lerroa:  t['Gammaafrican'] = 0x0194;
Kode lerroa:  t['Gangiacoptic'] = 0x03EA;
Kode lerroa:  t['Gbreve'] = 0x011E;
Kode lerroa:  t['Gcaron'] = 0x01E6;
Kode lerroa:  t['Gcedilla'] = 0x0122;
Kode lerroa:  t['Gcircle'] = 0x24BC;
Kode lerroa:  t['Gcircumflex'] = 0x011C;
Kode lerroa:  t['Gcommaaccent'] = 0x0122;
Kode lerroa:  t['Gdot'] = 0x0120;
Kode lerroa:  t['Gdotaccent'] = 0x0120;
Kode lerroa:  t['Gecyrillic'] = 0x0413;
Kode lerroa:  t['Ghadarmenian'] = 0x0542;
Kode lerroa:  t['Ghemiddlehookcyrillic'] = 0x0494;
Kode lerroa:  t['Ghestrokecyrillic'] = 0x0492;
Kode lerroa:  t['Gheupturncyrillic'] = 0x0490;
Kode lerroa:  t['Ghook'] = 0x0193;
Kode lerroa:  t['Gimarmenian'] = 0x0533;
Kode lerroa:  t['Gjecyrillic'] = 0x0403;
Kode lerroa:  t['Gmacron'] = 0x1E20;
Kode lerroa:  t['Gmonospace'] = 0xFF27;
Kode lerroa:  t['Grave'] = 0xF6CE;
Kode lerroa:  t['Gravesmall'] = 0xF760;
Kode lerroa:  t['Gsmall'] = 0xF767;
Kode lerroa:  t['Gsmallhook'] = 0x029B;
Kode lerroa:  t['Gstroke'] = 0x01E4;
Kode lerroa:  t['H'] = 0x0048;
Kode lerroa:  t['H18533'] = 0x25CF;
Kode lerroa:  t['H18543'] = 0x25AA;
Kode lerroa:  t['H18551'] = 0x25AB;
Kode lerroa:  t['H22073'] = 0x25A1;
Kode lerroa:  t['HPsquare'] = 0x33CB;
Kode lerroa:  t['Haabkhasiancyrillic'] = 0x04A8;
Kode lerroa:  t['Hadescendercyrillic'] = 0x04B2;
Kode lerroa:  t['Hardsigncyrillic'] = 0x042A;
Kode lerroa:  t['Hbar'] = 0x0126;
Kode lerroa:  t['Hbrevebelow'] = 0x1E2A;
Kode lerroa:  t['Hcedilla'] = 0x1E28;
Kode lerroa:  t['Hcircle'] = 0x24BD;
Kode lerroa:  t['Hcircumflex'] = 0x0124;
Kode lerroa:  t['Hdieresis'] = 0x1E26;
Kode lerroa:  t['Hdotaccent'] = 0x1E22;
Kode lerroa:  t['Hdotbelow'] = 0x1E24;
Kode lerroa:  t['Hmonospace'] = 0xFF28;
Kode lerroa:  t['Hoarmenian'] = 0x0540;
Kode lerroa:  t['Horicoptic'] = 0x03E8;
Kode lerroa:  t['Hsmall'] = 0xF768;
Kode lerroa:  t['Hungarumlaut'] = 0xF6CF;
Kode lerroa:  t['Hungarumlautsmall'] = 0xF6F8;
Kode lerroa:  t['Hzsquare'] = 0x3390;
Kode lerroa:  t['I'] = 0x0049;
Kode lerroa:  t['IAcyrillic'] = 0x042F;
Kode lerroa:  t['IJ'] = 0x0132;
Kode lerroa:  t['IUcyrillic'] = 0x042E;
Kode lerroa:  t['Iacute'] = 0x00CD;
Kode lerroa:  t['Iacutesmall'] = 0xF7ED;
Kode lerroa:  t['Ibreve'] = 0x012C;
Kode lerroa:  t['Icaron'] = 0x01CF;
Kode lerroa:  t['Icircle'] = 0x24BE;
Kode lerroa:  t['Icircumflex'] = 0x00CE;
Kode lerroa:  t['Icircumflexsmall'] = 0xF7EE;
Kode lerroa:  t['Icyrillic'] = 0x0406;
Kode lerroa:  t['Idblgrave'] = 0x0208;
Kode lerroa:  t['Idieresis'] = 0x00CF;
Kode lerroa:  t['Idieresisacute'] = 0x1E2E;
Kode lerroa:  t['Idieresiscyrillic'] = 0x04E4;
Kode lerroa:  t['Idieresissmall'] = 0xF7EF;
Kode lerroa:  t['Idot'] = 0x0130;
Kode lerroa:  t['Idotaccent'] = 0x0130;
Kode lerroa:  t['Idotbelow'] = 0x1ECA;
Kode lerroa:  t['Iebrevecyrillic'] = 0x04D6;
Kode lerroa:  t['Iecyrillic'] = 0x0415;
Kode lerroa:  t['Ifraktur'] = 0x2111;
Kode lerroa:  t['Igrave'] = 0x00CC;
Kode lerroa:  t['Igravesmall'] = 0xF7EC;
Kode lerroa:  t['Ihookabove'] = 0x1EC8;
Kode lerroa:  t['Iicyrillic'] = 0x0418;
Kode lerroa:  t['Iinvertedbreve'] = 0x020A;
Kode lerroa:  t['Iishortcyrillic'] = 0x0419;
Kode lerroa:  t['Imacron'] = 0x012A;
Kode lerroa:  t['Imacroncyrillic'] = 0x04E2;
Kode lerroa:  t['Imonospace'] = 0xFF29;
Kode lerroa:  t['Iniarmenian'] = 0x053B;
Kode lerroa:  t['Iocyrillic'] = 0x0401;
Kode lerroa:  t['Iogonek'] = 0x012E;
Kode lerroa:  t['Iota'] = 0x0399;
Kode lerroa:  t['Iotaafrican'] = 0x0196;
Kode lerroa:  t['Iotadieresis'] = 0x03AA;
Kode lerroa:  t['Iotatonos'] = 0x038A;
Kode lerroa:  t['Ismall'] = 0xF769;
Kode lerroa:  t['Istroke'] = 0x0197;
Kode lerroa:  t['Itilde'] = 0x0128;
Kode lerroa:  t['Itildebelow'] = 0x1E2C;
Kode lerroa:  t['Izhitsacyrillic'] = 0x0474;
Kode lerroa:  t['Izhitsadblgravecyrillic'] = 0x0476;
Kode lerroa:  t['J'] = 0x004A;
Kode lerroa:  t['Jaarmenian'] = 0x0541;
Kode lerroa:  t['Jcircle'] = 0x24BF;
Kode lerroa:  t['Jcircumflex'] = 0x0134;
Kode lerroa:  t['Jecyrillic'] = 0x0408;
Kode lerroa:  t['Jheharmenian'] = 0x054B;
Kode lerroa:  t['Jmonospace'] = 0xFF2A;
Kode lerroa:  t['Jsmall'] = 0xF76A;
Kode lerroa:  t['K'] = 0x004B;
Kode lerroa:  t['KBsquare'] = 0x3385;
Kode lerroa:  t['KKsquare'] = 0x33CD;
Kode lerroa:  t['Kabashkircyrillic'] = 0x04A0;
Kode lerroa:  t['Kacute'] = 0x1E30;
Kode lerroa:  t['Kacyrillic'] = 0x041A;
Kode lerroa:  t['Kadescendercyrillic'] = 0x049A;
Kode lerroa:  t['Kahookcyrillic'] = 0x04C3;
Kode lerroa:  t['Kappa'] = 0x039A;
Kode lerroa:  t['Kastrokecyrillic'] = 0x049E;
Kode lerroa:  t['Kaverticalstrokecyrillic'] = 0x049C;
Kode lerroa:  t['Kcaron'] = 0x01E8;
Kode lerroa:  t['Kcedilla'] = 0x0136;
Kode lerroa:  t['Kcircle'] = 0x24C0;
Kode lerroa:  t['Kcommaaccent'] = 0x0136;
Kode lerroa:  t['Kdotbelow'] = 0x1E32;
Kode lerroa:  t['Keharmenian'] = 0x0554;
Kode lerroa:  t['Kenarmenian'] = 0x053F;
Kode lerroa:  t['Khacyrillic'] = 0x0425;
Kode lerroa:  t['Kheicoptic'] = 0x03E6;
Kode lerroa:  t['Khook'] = 0x0198;
Kode lerroa:  t['Kjecyrillic'] = 0x040C;
Kode lerroa:  t['Klinebelow'] = 0x1E34;
Kode lerroa:  t['Kmonospace'] = 0xFF2B;
Kode lerroa:  t['Koppacyrillic'] = 0x0480;
Kode lerroa:  t['Koppagreek'] = 0x03DE;
Kode lerroa:  t['Ksicyrillic'] = 0x046E;
Kode lerroa:  t['Ksmall'] = 0xF76B;
Kode lerroa:  t['L'] = 0x004C;
Kode lerroa:  t['LJ'] = 0x01C7;
Kode lerroa:  t['LL'] = 0xF6BF;
Kode lerroa:  t['Lacute'] = 0x0139;
Kode lerroa:  t['Lambda'] = 0x039B;
Kode lerroa:  t['Lcaron'] = 0x013D;
Kode lerroa:  t['Lcedilla'] = 0x013B;
Kode lerroa:  t['Lcircle'] = 0x24C1;
Kode lerroa:  t['Lcircumflexbelow'] = 0x1E3C;
Kode lerroa:  t['Lcommaaccent'] = 0x013B;
Kode lerroa:  t['Ldot'] = 0x013F;
Kode lerroa:  t['Ldotaccent'] = 0x013F;
Kode lerroa:  t['Ldotbelow'] = 0x1E36;
Kode lerroa:  t['Ldotbelowmacron'] = 0x1E38;
Kode lerroa:  t['Liwnarmenian'] = 0x053C;
Kode lerroa:  t['Lj'] = 0x01C8;
Kode lerroa:  t['Ljecyrillic'] = 0x0409;
Kode lerroa:  t['Llinebelow'] = 0x1E3A;
Kode lerroa:  t['Lmonospace'] = 0xFF2C;
Kode lerroa:  t['Lslash'] = 0x0141;
Kode lerroa:  t['Lslashsmall'] = 0xF6F9;
Kode lerroa:  t['Lsmall'] = 0xF76C;
Kode lerroa:  t['M'] = 0x004D;
Kode lerroa:  t['MBsquare'] = 0x3386;
Kode lerroa:  t['Macron'] = 0xF6D0;
Kode lerroa:  t['Macronsmall'] = 0xF7AF;
Kode lerroa:  t['Macute'] = 0x1E3E;
Kode lerroa:  t['Mcircle'] = 0x24C2;
Kode lerroa:  t['Mdotaccent'] = 0x1E40;
Kode lerroa:  t['Mdotbelow'] = 0x1E42;
Kode lerroa:  t['Menarmenian'] = 0x0544;
Kode lerroa:  t['Mmonospace'] = 0xFF2D;
Kode lerroa:  t['Msmall'] = 0xF76D;
Kode lerroa:  t['Mturned'] = 0x019C;
Kode lerroa:  t['Mu'] = 0x039C;
Kode lerroa:  t['N'] = 0x004E;
Kode lerroa:  t['NJ'] = 0x01CA;
Kode lerroa:  t['Nacute'] = 0x0143;
Kode lerroa:  t['Ncaron'] = 0x0147;
Kode lerroa:  t['Ncedilla'] = 0x0145;
Kode lerroa:  t['Ncircle'] = 0x24C3;
Kode lerroa:  t['Ncircumflexbelow'] = 0x1E4A;
Kode lerroa:  t['Ncommaaccent'] = 0x0145;
Kode lerroa:  t['Ndotaccent'] = 0x1E44;
Kode lerroa:  t['Ndotbelow'] = 0x1E46;
Kode lerroa:  t['Nhookleft'] = 0x019D;
Kode lerroa:  t['Nineroman'] = 0x2168;
Kode lerroa:  t['Nj'] = 0x01CB;
Kode lerroa:  t['Njecyrillic'] = 0x040A;
Kode lerroa:  t['Nlinebelow'] = 0x1E48;
Kode lerroa:  t['Nmonospace'] = 0xFF2E;
Kode lerroa:  t['Nowarmenian'] = 0x0546;
Kode lerroa:  t['Nsmall'] = 0xF76E;
Kode lerroa:  t['Ntilde'] = 0x00D1;
Kode lerroa:  t['Ntildesmall'] = 0xF7F1;
Kode lerroa:  t['Nu'] = 0x039D;
Kode lerroa:  t['O'] = 0x004F;
Kode lerroa:  t['OE'] = 0x0152;
Kode lerroa:  t['OEsmall'] = 0xF6FA;
Kode lerroa:  t['Oacute'] = 0x00D3;
Kode lerroa:  t['Oacutesmall'] = 0xF7F3;
Kode lerroa:  t['Obarredcyrillic'] = 0x04E8;
Kode lerroa:  t['Obarreddieresiscyrillic'] = 0x04EA;
Kode lerroa:  t['Obreve'] = 0x014E;
Kode lerroa:  t['Ocaron'] = 0x01D1;
Kode lerroa:  t['Ocenteredtilde'] = 0x019F;
Kode lerroa:  t['Ocircle'] = 0x24C4;
Kode lerroa:  t['Ocircumflex'] = 0x00D4;
Kode lerroa:  t['Ocircumflexacute'] = 0x1ED0;
Kode lerroa:  t['Ocircumflexdotbelow'] = 0x1ED8;
Kode lerroa:  t['Ocircumflexgrave'] = 0x1ED2;
Kode lerroa:  t['Ocircumflexhookabove'] = 0x1ED4;
Kode lerroa:  t['Ocircumflexsmall'] = 0xF7F4;
Kode lerroa:  t['Ocircumflextilde'] = 0x1ED6;
Kode lerroa:  t['Ocyrillic'] = 0x041E;
Kode lerroa:  t['Odblacute'] = 0x0150;
Kode lerroa:  t['Odblgrave'] = 0x020C;
Kode lerroa:  t['Odieresis'] = 0x00D6;
Kode lerroa:  t['Odieresiscyrillic'] = 0x04E6;
Kode lerroa:  t['Odieresissmall'] = 0xF7F6;
Kode lerroa:  t['Odotbelow'] = 0x1ECC;
Kode lerroa:  t['Ogoneksmall'] = 0xF6FB;
Kode lerroa:  t['Ograve'] = 0x00D2;
Kode lerroa:  t['Ogravesmall'] = 0xF7F2;
Kode lerroa:  t['Oharmenian'] = 0x0555;
Kode lerroa:  t['Ohm'] = 0x2126;
Kode lerroa:  t['Ohookabove'] = 0x1ECE;
Kode lerroa:  t['Ohorn'] = 0x01A0;
Kode lerroa:  t['Ohornacute'] = 0x1EDA;
Kode lerroa:  t['Ohorndotbelow'] = 0x1EE2;
Kode lerroa:  t['Ohorngrave'] = 0x1EDC;
Kode lerroa:  t['Ohornhookabove'] = 0x1EDE;
Kode lerroa:  t['Ohorntilde'] = 0x1EE0;
Kode lerroa:  t['Ohungarumlaut'] = 0x0150;
Kode lerroa:  t['Oi'] = 0x01A2;
Kode lerroa:  t['Oinvertedbreve'] = 0x020E;
Kode lerroa:  t['Omacron'] = 0x014C;
Kode lerroa:  t['Omacronacute'] = 0x1E52;
Kode lerroa:  t['Omacrongrave'] = 0x1E50;
Kode lerroa:  t['Omega'] = 0x2126;
Kode lerroa:  t['Omegacyrillic'] = 0x0460;
Kode lerroa:  t['Omegagreek'] = 0x03A9;
Kode lerroa:  t['Omegaroundcyrillic'] = 0x047A;
Kode lerroa:  t['Omegatitlocyrillic'] = 0x047C;
Kode lerroa:  t['Omegatonos'] = 0x038F;
Kode lerroa:  t['Omicron'] = 0x039F;
Kode lerroa:  t['Omicrontonos'] = 0x038C;
Kode lerroa:  t['Omonospace'] = 0xFF2F;
Kode lerroa:  t['Oneroman'] = 0x2160;
Kode lerroa:  t['Oogonek'] = 0x01EA;
Kode lerroa:  t['Oogonekmacron'] = 0x01EC;
Kode lerroa:  t['Oopen'] = 0x0186;
Kode lerroa:  t['Oslash'] = 0x00D8;
Kode lerroa:  t['Oslashacute'] = 0x01FE;
Kode lerroa:  t['Oslashsmall'] = 0xF7F8;
Kode lerroa:  t['Osmall'] = 0xF76F;
Kode lerroa:  t['Ostrokeacute'] = 0x01FE;
Kode lerroa:  t['Otcyrillic'] = 0x047E;
Kode lerroa:  t['Otilde'] = 0x00D5;
Kode lerroa:  t['Otildeacute'] = 0x1E4C;
Kode lerroa:  t['Otildedieresis'] = 0x1E4E;
Kode lerroa:  t['Otildesmall'] = 0xF7F5;
Kode lerroa:  t['P'] = 0x0050;
Kode lerroa:  t['Pacute'] = 0x1E54;
Kode lerroa:  t['Pcircle'] = 0x24C5;
Kode lerroa:  t['Pdotaccent'] = 0x1E56;
Kode lerroa:  t['Pecyrillic'] = 0x041F;
Kode lerroa:  t['Peharmenian'] = 0x054A;
Kode lerroa:  t['Pemiddlehookcyrillic'] = 0x04A6;
Kode lerroa:  t['Phi'] = 0x03A6;
Kode lerroa:  t['Phook'] = 0x01A4;
Kode lerroa:  t['Pi'] = 0x03A0;
Kode lerroa:  t['Piwrarmenian'] = 0x0553;
Kode lerroa:  t['Pmonospace'] = 0xFF30;
Kode lerroa:  t['Psi'] = 0x03A8;
Kode lerroa:  t['Psicyrillic'] = 0x0470;
Kode lerroa:  t['Psmall'] = 0xF770;
Kode lerroa:  t['Q'] = 0x0051;
Kode lerroa:  t['Qcircle'] = 0x24C6;
Kode lerroa:  t['Qmonospace'] = 0xFF31;
Kode lerroa:  t['Qsmall'] = 0xF771;
Kode lerroa:  t['R'] = 0x0052;
Kode lerroa:  t['Raarmenian'] = 0x054C;
Kode lerroa:  t['Racute'] = 0x0154;
Kode lerroa:  t['Rcaron'] = 0x0158;
Kode lerroa:  t['Rcedilla'] = 0x0156;
Kode lerroa:  t['Rcircle'] = 0x24C7;
Kode lerroa:  t['Rcommaaccent'] = 0x0156;
Kode lerroa:  t['Rdblgrave'] = 0x0210;
Kode lerroa:  t['Rdotaccent'] = 0x1E58;
Kode lerroa:  t['Rdotbelow'] = 0x1E5A;
Kode lerroa:  t['Rdotbelowmacron'] = 0x1E5C;
Kode lerroa:  t['Reharmenian'] = 0x0550;
Kode lerroa:  t['Rfraktur'] = 0x211C;
Kode lerroa:  t['Rho'] = 0x03A1;
Kode lerroa:  t['Ringsmall'] = 0xF6FC;
Kode lerroa:  t['Rinvertedbreve'] = 0x0212;
Kode lerroa:  t['Rlinebelow'] = 0x1E5E;
Kode lerroa:  t['Rmonospace'] = 0xFF32;
Kode lerroa:  t['Rsmall'] = 0xF772;
Kode lerroa:  t['Rsmallinverted'] = 0x0281;
Kode lerroa:  t['Rsmallinvertedsuperior'] = 0x02B6;
Kode lerroa:  t['S'] = 0x0053;
Kode lerroa:  t['SF010000'] = 0x250C;
Kode lerroa:  t['SF020000'] = 0x2514;
Kode lerroa:  t['SF030000'] = 0x2510;
Kode lerroa:  t['SF040000'] = 0x2518;
Kode lerroa:  t['SF050000'] = 0x253C;
Kode lerroa:  t['SF060000'] = 0x252C;
Kode lerroa:  t['SF070000'] = 0x2534;
Kode lerroa:  t['SF080000'] = 0x251C;
Kode lerroa:  t['SF090000'] = 0x2524;
Kode lerroa:  t['SF100000'] = 0x2500;
Kode lerroa:  t['SF110000'] = 0x2502;
Kode lerroa:  t['SF190000'] = 0x2561;
Kode lerroa:  t['SF200000'] = 0x2562;
Kode lerroa:  t['SF210000'] = 0x2556;
Kode lerroa:  t['SF220000'] = 0x2555;
Kode lerroa:  t['SF230000'] = 0x2563;
Kode lerroa:  t['SF240000'] = 0x2551;
Kode lerroa:  t['SF250000'] = 0x2557;
Kode lerroa:  t['SF260000'] = 0x255D;
Kode lerroa:  t['SF270000'] = 0x255C;
Kode lerroa:  t['SF280000'] = 0x255B;
Kode lerroa:  t['SF360000'] = 0x255E;
Kode lerroa:  t['SF370000'] = 0x255F;
Kode lerroa:  t['SF380000'] = 0x255A;
Kode lerroa:  t['SF390000'] = 0x2554;
Kode lerroa:  t['SF400000'] = 0x2569;
Kode lerroa:  t['SF410000'] = 0x2566;
Kode lerroa:  t['SF420000'] = 0x2560;
Kode lerroa:  t['SF430000'] = 0x2550;
Kode lerroa:  t['SF440000'] = 0x256C;
Kode lerroa:  t['SF450000'] = 0x2567;
Kode lerroa:  t['SF460000'] = 0x2568;
Kode lerroa:  t['SF470000'] = 0x2564;
Kode lerroa:  t['SF480000'] = 0x2565;
Kode lerroa:  t['SF490000'] = 0x2559;
Kode lerroa:  t['SF500000'] = 0x2558;
Kode lerroa:  t['SF510000'] = 0x2552;
Kode lerroa:  t['SF520000'] = 0x2553;
Kode lerroa:  t['SF530000'] = 0x256B;
Kode lerroa:  t['SF540000'] = 0x256A;
Kode lerroa:  t['Sacute'] = 0x015A;
Kode lerroa:  t['Sacutedotaccent'] = 0x1E64;
Kode lerroa:  t['Sampigreek'] = 0x03E0;
Kode lerroa:  t['Scaron'] = 0x0160;
Kode lerroa:  t['Scarondotaccent'] = 0x1E66;
Kode lerroa:  t['Scaronsmall'] = 0xF6FD;
Kode lerroa:  t['Scedilla'] = 0x015E;
Kode lerroa:  t['Schwa'] = 0x018F;
Kode lerroa:  t['Schwacyrillic'] = 0x04D8;
Kode lerroa:  t['Schwadieresiscyrillic'] = 0x04DA;
Kode lerroa:  t['Scircle'] = 0x24C8;
Kode lerroa:  t['Scircumflex'] = 0x015C;
Kode lerroa:  t['Scommaaccent'] = 0x0218;
Kode lerroa:  t['Sdotaccent'] = 0x1E60;
Kode lerroa:  t['Sdotbelow'] = 0x1E62;
Kode lerroa:  t['Sdotbelowdotaccent'] = 0x1E68;
Kode lerroa:  t['Seharmenian'] = 0x054D;
Kode lerroa:  t['Sevenroman'] = 0x2166;
Kode lerroa:  t['Shaarmenian'] = 0x0547;
Kode lerroa:  t['Shacyrillic'] = 0x0428;
Kode lerroa:  t['Shchacyrillic'] = 0x0429;
Kode lerroa:  t['Sheicoptic'] = 0x03E2;
Kode lerroa:  t['Shhacyrillic'] = 0x04BA;
Kode lerroa:  t['Shimacoptic'] = 0x03EC;
Kode lerroa:  t['Sigma'] = 0x03A3;
Kode lerroa:  t['Sixroman'] = 0x2165;
Kode lerroa:  t['Smonospace'] = 0xFF33;
Kode lerroa:  t['Softsigncyrillic'] = 0x042C;
Kode lerroa:  t['Ssmall'] = 0xF773;
Kode lerroa:  t['Stigmagreek'] = 0x03DA;
Kode lerroa:  t['T'] = 0x0054;
Kode lerroa:  t['Tau'] = 0x03A4;
Kode lerroa:  t['Tbar'] = 0x0166;
Kode lerroa:  t['Tcaron'] = 0x0164;
Kode lerroa:  t['Tcedilla'] = 0x0162;
Kode lerroa:  t['Tcircle'] = 0x24C9;
Kode lerroa:  t['Tcircumflexbelow'] = 0x1E70;
Kode lerroa:  t['Tcommaaccent'] = 0x0162;
Kode lerroa:  t['Tdotaccent'] = 0x1E6A;
Kode lerroa:  t['Tdotbelow'] = 0x1E6C;
Kode lerroa:  t['Tecyrillic'] = 0x0422;
Kode lerroa:  t['Tedescendercyrillic'] = 0x04AC;
Kode lerroa:  t['Tenroman'] = 0x2169;
Kode lerroa:  t['Tetsecyrillic'] = 0x04B4;
Kode lerroa:  t['Theta'] = 0x0398;
Kode lerroa:  t['Thook'] = 0x01AC;
Kode lerroa:  t['Thorn'] = 0x00DE;
Kode lerroa:  t['Thornsmall'] = 0xF7FE;
Kode lerroa:  t['Threeroman'] = 0x2162;
Kode lerroa:  t['Tildesmall'] = 0xF6FE;
Kode lerroa:  t['Tiwnarmenian'] = 0x054F;
Kode lerroa:  t['Tlinebelow'] = 0x1E6E;
Kode lerroa:  t['Tmonospace'] = 0xFF34;
Kode lerroa:  t['Toarmenian'] = 0x0539;
Kode lerroa:  t['Tonefive'] = 0x01BC;
Kode lerroa:  t['Tonesix'] = 0x0184;
Kode lerroa:  t['Tonetwo'] = 0x01A7;
Kode lerroa:  t['Tretroflexhook'] = 0x01AE;
Kode lerroa:  t['Tsecyrillic'] = 0x0426;
Kode lerroa:  t['Tshecyrillic'] = 0x040B;
Kode lerroa:  t['Tsmall'] = 0xF774;
Kode lerroa:  t['Twelveroman'] = 0x216B;
Kode lerroa:  t['Tworoman'] = 0x2161;
Kode lerroa:  t['U'] = 0x0055;
Kode lerroa:  t['Uacute'] = 0x00DA;
Kode lerroa:  t['Uacutesmall'] = 0xF7FA;
Kode lerroa:  t['Ubreve'] = 0x016C;
Kode lerroa:  t['Ucaron'] = 0x01D3;
Kode lerroa:  t['Ucircle'] = 0x24CA;
Kode lerroa:  t['Ucircumflex'] = 0x00DB;
Kode lerroa:  t['Ucircumflexbelow'] = 0x1E76;
Kode lerroa:  t['Ucircumflexsmall'] = 0xF7FB;
Kode lerroa:  t['Ucyrillic'] = 0x0423;
Kode lerroa:  t['Udblacute'] = 0x0170;
Kode lerroa:  t['Udblgrave'] = 0x0214;
Kode lerroa:  t['Udieresis'] = 0x00DC;
Kode lerroa:  t['Udieresisacute'] = 0x01D7;
Kode lerroa:  t['Udieresisbelow'] = 0x1E72;
Kode lerroa:  t['Udieresiscaron'] = 0x01D9;
Kode lerroa:  t['Udieresiscyrillic'] = 0x04F0;
Kode lerroa:  t['Udieresisgrave'] = 0x01DB;
Kode lerroa:  t['Udieresismacron'] = 0x01D5;
Kode lerroa:  t['Udieresissmall'] = 0xF7FC;
Kode lerroa:  t['Udotbelow'] = 0x1EE4;
Kode lerroa:  t['Ugrave'] = 0x00D9;
Kode lerroa:  t['Ugravesmall'] = 0xF7F9;
Kode lerroa:  t['Uhookabove'] = 0x1EE6;
Kode lerroa:  t['Uhorn'] = 0x01AF;
Kode lerroa:  t['Uhornacute'] = 0x1EE8;
Kode lerroa:  t['Uhorndotbelow'] = 0x1EF0;
Kode lerroa:  t['Uhorngrave'] = 0x1EEA;
Kode lerroa:  t['Uhornhookabove'] = 0x1EEC;
Kode lerroa:  t['Uhorntilde'] = 0x1EEE;
Kode lerroa:  t['Uhungarumlaut'] = 0x0170;
Kode lerroa:  t['Uhungarumlautcyrillic'] = 0x04F2;
Kode lerroa:  t['Uinvertedbreve'] = 0x0216;
Kode lerroa:  t['Ukcyrillic'] = 0x0478;
Kode lerroa:  t['Umacron'] = 0x016A;
Kode lerroa:  t['Umacroncyrillic'] = 0x04EE;
Kode lerroa:  t['Umacrondieresis'] = 0x1E7A;
Kode lerroa:  t['Umonospace'] = 0xFF35;
Kode lerroa:  t['Uogonek'] = 0x0172;
Kode lerroa:  t['Upsilon'] = 0x03A5;
Kode lerroa:  t['Upsilon1'] = 0x03D2;
Kode lerroa:  t['Upsilonacutehooksymbolgreek'] = 0x03D3;
Kode lerroa:  t['Upsilonafrican'] = 0x01B1;
Kode lerroa:  t['Upsilondieresis'] = 0x03AB;
Kode lerroa:  t['Upsilondieresishooksymbolgreek'] = 0x03D4;
Kode lerroa:  t['Upsilonhooksymbol'] = 0x03D2;
Kode lerroa:  t['Upsilontonos'] = 0x038E;
Kode lerroa:  t['Uring'] = 0x016E;
Kode lerroa:  t['Ushortcyrillic'] = 0x040E;
Kode lerroa:  t['Usmall'] = 0xF775;
Kode lerroa:  t['Ustraightcyrillic'] = 0x04AE;
Kode lerroa:  t['Ustraightstrokecyrillic'] = 0x04B0;
Kode lerroa:  t['Utilde'] = 0x0168;
Kode lerroa:  t['Utildeacute'] = 0x1E78;
Kode lerroa:  t['Utildebelow'] = 0x1E74;
Kode lerroa:  t['V'] = 0x0056;
Kode lerroa:  t['Vcircle'] = 0x24CB;
Kode lerroa:  t['Vdotbelow'] = 0x1E7E;
Kode lerroa:  t['Vecyrillic'] = 0x0412;
Kode lerroa:  t['Vewarmenian'] = 0x054E;
Kode lerroa:  t['Vhook'] = 0x01B2;
Kode lerroa:  t['Vmonospace'] = 0xFF36;
Kode lerroa:  t['Voarmenian'] = 0x0548;
Kode lerroa:  t['Vsmall'] = 0xF776;
Kode lerroa:  t['Vtilde'] = 0x1E7C;
Kode lerroa:  t['W'] = 0x0057;
Kode lerroa:  t['Wacute'] = 0x1E82;
Kode lerroa:  t['Wcircle'] = 0x24CC;
Kode lerroa:  t['Wcircumflex'] = 0x0174;
Kode lerroa:  t['Wdieresis'] = 0x1E84;
Kode lerroa:  t['Wdotaccent'] = 0x1E86;
Kode lerroa:  t['Wdotbelow'] = 0x1E88;
Kode lerroa:  t['Wgrave'] = 0x1E80;
Kode lerroa:  t['Wmonospace'] = 0xFF37;
Kode lerroa:  t['Wsmall'] = 0xF777;
Kode lerroa:  t['X'] = 0x0058;
Kode lerroa:  t['Xcircle'] = 0x24CD;
Kode lerroa:  t['Xdieresis'] = 0x1E8C;
Kode lerroa:  t['Xdotaccent'] = 0x1E8A;
Kode lerroa:  t['Xeharmenian'] = 0x053D;
Kode lerroa:  t['Xi'] = 0x039E;
Kode lerroa:  t['Xmonospace'] = 0xFF38;
Kode lerroa:  t['Xsmall'] = 0xF778;
Kode lerroa:  t['Y'] = 0x0059;
Kode lerroa:  t['Yacute'] = 0x00DD;
Kode lerroa:  t['Yacutesmall'] = 0xF7FD;
Kode lerroa:  t['Yatcyrillic'] = 0x0462;
Kode lerroa:  t['Ycircle'] = 0x24CE;
Kode lerroa:  t['Ycircumflex'] = 0x0176;
Kode lerroa:  t['Ydieresis'] = 0x0178;
Kode lerroa:  t['Ydieresissmall'] = 0xF7FF;
Kode lerroa:  t['Ydotaccent'] = 0x1E8E;
Kode lerroa:  t['Ydotbelow'] = 0x1EF4;
Kode lerroa:  t['Yericyrillic'] = 0x042B;
Kode lerroa:  t['Yerudieresiscyrillic'] = 0x04F8;
Kode lerroa:  t['Ygrave'] = 0x1EF2;
Kode lerroa:  t['Yhook'] = 0x01B3;
Kode lerroa:  t['Yhookabove'] = 0x1EF6;
Kode lerroa:  t['Yiarmenian'] = 0x0545;
Kode lerroa:  t['Yicyrillic'] = 0x0407;
Kode lerroa:  t['Yiwnarmenian'] = 0x0552;
Kode lerroa:  t['Ymonospace'] = 0xFF39;
Kode lerroa:  t['Ysmall'] = 0xF779;
Kode lerroa:  t['Ytilde'] = 0x1EF8;
Kode lerroa:  t['Yusbigcyrillic'] = 0x046A;
Kode lerroa:  t['Yusbigiotifiedcyrillic'] = 0x046C;
Kode lerroa:  t['Yuslittlecyrillic'] = 0x0466;
Kode lerroa:  t['Yuslittleiotifiedcyrillic'] = 0x0468;
Kode lerroa:  t['Z'] = 0x005A;
Kode lerroa:  t['Zaarmenian'] = 0x0536;
Kode lerroa:  t['Zacute'] = 0x0179;
Kode lerroa:  t['Zcaron'] = 0x017D;
Kode lerroa:  t['Zcaronsmall'] = 0xF6FF;
Kode lerroa:  t['Zcircle'] = 0x24CF;
Kode lerroa:  t['Zcircumflex'] = 0x1E90;
Kode lerroa:  t['Zdot'] = 0x017B;
Kode lerroa:  t['Zdotaccent'] = 0x017B;
Kode lerroa:  t['Zdotbelow'] = 0x1E92;
Kode lerroa:  t['Zecyrillic'] = 0x0417;
Kode lerroa:  t['Zedescendercyrillic'] = 0x0498;
Kode lerroa:  t['Zedieresiscyrillic'] = 0x04DE;
Kode lerroa:  t['Zeta'] = 0x0396;
Kode lerroa:  t['Zhearmenian'] = 0x053A;
Kode lerroa:  t['Zhebrevecyrillic'] = 0x04C1;
Kode lerroa:  t['Zhecyrillic'] = 0x0416;
Kode lerroa:  t['Zhedescendercyrillic'] = 0x0496;
Kode lerroa:  t['Zhedieresiscyrillic'] = 0x04DC;
Kode lerroa:  t['Zlinebelow'] = 0x1E94;
Kode lerroa:  t['Zmonospace'] = 0xFF3A;
Kode lerroa:  t['Zsmall'] = 0xF77A;
Kode lerroa:  t['Zstroke'] = 0x01B5;
Kode lerroa:  t['a'] = 0x0061;
Kode lerroa:  t['aabengali'] = 0x0986;
Kode lerroa:  t['aacute'] = 0x00E1;
Kode lerroa:  t['aadeva'] = 0x0906;
Kode lerroa:  t['aagujarati'] = 0x0A86;
Kode lerroa:  t['aagurmukhi'] = 0x0A06;
Kode lerroa:  t['aamatragurmukhi'] = 0x0A3E;
Kode lerroa:  t['aarusquare'] = 0x3303;
Kode lerroa:  t['aavowelsignbengali'] = 0x09BE;
Kode lerroa:  t['aavowelsigndeva'] = 0x093E;
Kode lerroa:  t['aavowelsigngujarati'] = 0x0ABE;
Kode lerroa:  t['abbreviationmarkarmenian'] = 0x055F;
Kode lerroa:  t['abbreviationsigndeva'] = 0x0970;
Kode lerroa:  t['abengali'] = 0x0985;
Kode lerroa:  t['abopomofo'] = 0x311A;
Kode lerroa:  t['abreve'] = 0x0103;
Kode lerroa:  t['abreveacute'] = 0x1EAF;
Kode lerroa:  t['abrevecyrillic'] = 0x04D1;
Kode lerroa:  t['abrevedotbelow'] = 0x1EB7;
Kode lerroa:  t['abrevegrave'] = 0x1EB1;
Kode lerroa:  t['abrevehookabove'] = 0x1EB3;
Kode lerroa:  t['abrevetilde'] = 0x1EB5;
Kode lerroa:  t['acaron'] = 0x01CE;
Kode lerroa:  t['acircle'] = 0x24D0;
Kode lerroa:  t['acircumflex'] = 0x00E2;
Kode lerroa:  t['acircumflexacute'] = 0x1EA5;
Kode lerroa:  t['acircumflexdotbelow'] = 0x1EAD;
Kode lerroa:  t['acircumflexgrave'] = 0x1EA7;
Kode lerroa:  t['acircumflexhookabove'] = 0x1EA9;
Kode lerroa:  t['acircumflextilde'] = 0x1EAB;
Kode lerroa:  t['acute'] = 0x00B4;
Kode lerroa:  t['acutebelowcmb'] = 0x0317;
Kode lerroa:  t['acutecmb'] = 0x0301;
Kode lerroa:  t['acutecomb'] = 0x0301;
Kode lerroa:  t['acutedeva'] = 0x0954;
Kode lerroa:  t['acutelowmod'] = 0x02CF;
Kode lerroa:  t['acutetonecmb'] = 0x0341;
Kode lerroa:  t['acyrillic'] = 0x0430;
Kode lerroa:  t['adblgrave'] = 0x0201;
Kode lerroa:  t['addakgurmukhi'] = 0x0A71;
Kode lerroa:  t['adeva'] = 0x0905;
Kode lerroa:  t['adieresis'] = 0x00E4;
Kode lerroa:  t['adieresiscyrillic'] = 0x04D3;
Kode lerroa:  t['adieresismacron'] = 0x01DF;
Kode lerroa:  t['adotbelow'] = 0x1EA1;
Kode lerroa:  t['adotmacron'] = 0x01E1;
Kode lerroa:  t['ae'] = 0x00E6;
Kode lerroa:  t['aeacute'] = 0x01FD;
Kode lerroa:  t['aekorean'] = 0x3150;
Kode lerroa:  t['aemacron'] = 0x01E3;
Kode lerroa:  t['afii00208'] = 0x2015;
Kode lerroa:  t['afii08941'] = 0x20A4;
Kode lerroa:  t['afii10017'] = 0x0410;
Kode lerroa:  t['afii10018'] = 0x0411;
Kode lerroa:  t['afii10019'] = 0x0412;
Kode lerroa:  t['afii10020'] = 0x0413;
Kode lerroa:  t['afii10021'] = 0x0414;
Kode lerroa:  t['afii10022'] = 0x0415;
Kode lerroa:  t['afii10023'] = 0x0401;
Kode lerroa:  t['afii10024'] = 0x0416;
Kode lerroa:  t['afii10025'] = 0x0417;
Kode lerroa:  t['afii10026'] = 0x0418;
Kode lerroa:  t['afii10027'] = 0x0419;
Kode lerroa:  t['afii10028'] = 0x041A;
Kode lerroa:  t['afii10029'] = 0x041B;
Kode lerroa:  t['afii10030'] = 0x041C;
Kode lerroa:  t['afii10031'] = 0x041D;
Kode lerroa:  t['afii10032'] = 0x041E;
Kode lerroa:  t['afii10033'] = 0x041F;
Kode lerroa:  t['afii10034'] = 0x0420;
Kode lerroa:  t['afii10035'] = 0x0421;
Kode lerroa:  t['afii10036'] = 0x0422;
Kode lerroa:  t['afii10037'] = 0x0423;
Kode lerroa:  t['afii10038'] = 0x0424;
Kode lerroa:  t['afii10039'] = 0x0425;
Kode lerroa:  t['afii10040'] = 0x0426;
Kode lerroa:  t['afii10041'] = 0x0427;
Kode lerroa:  t['afii10042'] = 0x0428;
Kode lerroa:  t['afii10043'] = 0x0429;
Kode lerroa:  t['afii10044'] = 0x042A;
Kode lerroa:  t['afii10045'] = 0x042B;
Kode lerroa:  t['afii10046'] = 0x042C;
Kode lerroa:  t['afii10047'] = 0x042D;
Kode lerroa:  t['afii10048'] = 0x042E;
Kode lerroa:  t['afii10049'] = 0x042F;
Kode lerroa:  t['afii10050'] = 0x0490;
Kode lerroa:  t['afii10051'] = 0x0402;
Kode lerroa:  t['afii10052'] = 0x0403;
Kode lerroa:  t['afii10053'] = 0x0404;
Kode lerroa:  t['afii10054'] = 0x0405;
Kode lerroa:  t['afii10055'] = 0x0406;
Kode lerroa:  t['afii10056'] = 0x0407;
Kode lerroa:  t['afii10057'] = 0x0408;
Kode lerroa:  t['afii10058'] = 0x0409;
Kode lerroa:  t['afii10059'] = 0x040A;
Kode lerroa:  t['afii10060'] = 0x040B;
Kode lerroa:  t['afii10061'] = 0x040C;
Kode lerroa:  t['afii10062'] = 0x040E;
Kode lerroa:  t['afii10063'] = 0xF6C4;
Kode lerroa:  t['afii10064'] = 0xF6C5;
Kode lerroa:  t['afii10065'] = 0x0430;
Kode lerroa:  t['afii10066'] = 0x0431;
Kode lerroa:  t['afii10067'] = 0x0432;
Kode lerroa:  t['afii10068'] = 0x0433;
Kode lerroa:  t['afii10069'] = 0x0434;
Kode lerroa:  t['afii10070'] = 0x0435;
Kode lerroa:  t['afii10071'] = 0x0451;
Kode lerroa:  t['afii10072'] = 0x0436;
Kode lerroa:  t['afii10073'] = 0x0437;
Kode lerroa:  t['afii10074'] = 0x0438;
Kode lerroa:  t['afii10075'] = 0x0439;
Kode lerroa:  t['afii10076'] = 0x043A;
Kode lerroa:  t['afii10077'] = 0x043B;
Kode lerroa:  t['afii10078'] = 0x043C;
Kode lerroa:  t['afii10079'] = 0x043D;
Kode lerroa:  t['afii10080'] = 0x043E;
Kode lerroa:  t['afii10081'] = 0x043F;
Kode lerroa:  t['afii10082'] = 0x0440;
Kode lerroa:  t['afii10083'] = 0x0441;
Kode lerroa:  t['afii10084'] = 0x0442;
Kode lerroa:  t['afii10085'] = 0x0443;
Kode lerroa:  t['afii10086'] = 0x0444;
Kode lerroa:  t['afii10087'] = 0x0445;
Kode lerroa:  t['afii10088'] = 0x0446;
Kode lerroa:  t['afii10089'] = 0x0447;
Kode lerroa:  t['afii10090'] = 0x0448;
Kode lerroa:  t['afii10091'] = 0x0449;
Kode lerroa:  t['afii10092'] = 0x044A;
Kode lerroa:  t['afii10093'] = 0x044B;
Kode lerroa:  t['afii10094'] = 0x044C;
Kode lerroa:  t['afii10095'] = 0x044D;
Kode lerroa:  t['afii10096'] = 0x044E;
Kode lerroa:  t['afii10097'] = 0x044F;
Kode lerroa:  t['afii10098'] = 0x0491;
Kode lerroa:  t['afii10099'] = 0x0452;
Kode lerroa:  t['afii10100'] = 0x0453;
Kode lerroa:  t['afii10101'] = 0x0454;
Kode lerroa:  t['afii10102'] = 0x0455;
Kode lerroa:  t['afii10103'] = 0x0456;
Kode lerroa:  t['afii10104'] = 0x0457;
Kode lerroa:  t['afii10105'] = 0x0458;
Kode lerroa:  t['afii10106'] = 0x0459;
Kode lerroa:  t['afii10107'] = 0x045A;
Kode lerroa:  t['afii10108'] = 0x045B;
Kode lerroa:  t['afii10109'] = 0x045C;
Kode lerroa:  t['afii10110'] = 0x045E;
Kode lerroa:  t['afii10145'] = 0x040F;
Kode lerroa:  t['afii10146'] = 0x0462;
Kode lerroa:  t['afii10147'] = 0x0472;
Kode lerroa:  t['afii10148'] = 0x0474;
Kode lerroa:  t['afii10192'] = 0xF6C6;
Kode lerroa:  t['afii10193'] = 0x045F;
Kode lerroa:  t['afii10194'] = 0x0463;
Kode lerroa:  t['afii10195'] = 0x0473;
Kode lerroa:  t['afii10196'] = 0x0475;
Kode lerroa:  t['afii10831'] = 0xF6C7;
Kode lerroa:  t['afii10832'] = 0xF6C8;
Kode lerroa:  t['afii10846'] = 0x04D9;
Kode lerroa:  t['afii299'] = 0x200E;
Kode lerroa:  t['afii300'] = 0x200F;
Kode lerroa:  t['afii301'] = 0x200D;
Kode lerroa:  t['afii57381'] = 0x066A;
Kode lerroa:  t['afii57388'] = 0x060C;
Kode lerroa:  t['afii57392'] = 0x0660;
Kode lerroa:  t['afii57393'] = 0x0661;
Kode lerroa:  t['afii57394'] = 0x0662;
Kode lerroa:  t['afii57395'] = 0x0663;
Kode lerroa:  t['afii57396'] = 0x0664;
Kode lerroa:  t['afii57397'] = 0x0665;
Kode lerroa:  t['afii57398'] = 0x0666;
Kode lerroa:  t['afii57399'] = 0x0667;
Kode lerroa:  t['afii57400'] = 0x0668;
Kode lerroa:  t['afii57401'] = 0x0669;
Kode lerroa:  t['afii57403'] = 0x061B;
Kode lerroa:  t['afii57407'] = 0x061F;
Kode lerroa:  t['afii57409'] = 0x0621;
Kode lerroa:  t['afii57410'] = 0x0622;
Kode lerroa:  t['afii57411'] = 0x0623;
Kode lerroa:  t['afii57412'] = 0x0624;
Kode lerroa:  t['afii57413'] = 0x0625;
Kode lerroa:  t['afii57414'] = 0x0626;
Kode lerroa:  t['afii57415'] = 0x0627;
Kode lerroa:  t['afii57416'] = 0x0628;
Kode lerroa:  t['afii57417'] = 0x0629;
Kode lerroa:  t['afii57418'] = 0x062A;
Kode lerroa:  t['afii57419'] = 0x062B;
Kode lerroa:  t['afii57420'] = 0x062C;
Kode lerroa:  t['afii57421'] = 0x062D;
Kode lerroa:  t['afii57422'] = 0x062E;
Kode lerroa:  t['afii57423'] = 0x062F;
Kode lerroa:  t['afii57424'] = 0x0630;
Kode lerroa:  t['afii57425'] = 0x0631;
Kode lerroa:  t['afii57426'] = 0x0632;
Kode lerroa:  t['afii57427'] = 0x0633;
Kode lerroa:  t['afii57428'] = 0x0634;
Kode lerroa:  t['afii57429'] = 0x0635;
Kode lerroa:  t['afii57430'] = 0x0636;
Kode lerroa:  t['afii57431'] = 0x0637;
Kode lerroa:  t['afii57432'] = 0x0638;
Kode lerroa:  t['afii57433'] = 0x0639;
Kode lerroa:  t['afii57434'] = 0x063A;
Kode lerroa:  t['afii57440'] = 0x0640;
Kode lerroa:  t['afii57441'] = 0x0641;
Kode lerroa:  t['afii57442'] = 0x0642;
Kode lerroa:  t['afii57443'] = 0x0643;
Kode lerroa:  t['afii57444'] = 0x0644;
Kode lerroa:  t['afii57445'] = 0x0645;
Kode lerroa:  t['afii57446'] = 0x0646;
Kode lerroa:  t['afii57448'] = 0x0648;
Kode lerroa:  t['afii57449'] = 0x0649;
Kode lerroa:  t['afii57450'] = 0x064A;
Kode lerroa:  t['afii57451'] = 0x064B;
Kode lerroa:  t['afii57452'] = 0x064C;
Kode lerroa:  t['afii57453'] = 0x064D;
Kode lerroa:  t['afii57454'] = 0x064E;
Kode lerroa:  t['afii57455'] = 0x064F;
Kode lerroa:  t['afii57456'] = 0x0650;
Kode lerroa:  t['afii57457'] = 0x0651;
Kode lerroa:  t['afii57458'] = 0x0652;
Kode lerroa:  t['afii57470'] = 0x0647;
Kode lerroa:  t['afii57505'] = 0x06A4;
Kode lerroa:  t['afii57506'] = 0x067E;
Kode lerroa:  t['afii57507'] = 0x0686;
Kode lerroa:  t['afii57508'] = 0x0698;
Kode lerroa:  t['afii57509'] = 0x06AF;
Kode lerroa:  t['afii57511'] = 0x0679;
Kode lerroa:  t['afii57512'] = 0x0688;
Kode lerroa:  t['afii57513'] = 0x0691;
Kode lerroa:  t['afii57514'] = 0x06BA;
Kode lerroa:  t['afii57519'] = 0x06D2;
Kode lerroa:  t['afii57534'] = 0x06D5;
Kode lerroa:  t['afii57636'] = 0x20AA;
Kode lerroa:  t['afii57645'] = 0x05BE;
Kode lerroa:  t['afii57658'] = 0x05C3;
Kode lerroa:  t['afii57664'] = 0x05D0;
Kode lerroa:  t['afii57665'] = 0x05D1;
Kode lerroa:  t['afii57666'] = 0x05D2;
Kode lerroa:  t['afii57667'] = 0x05D3;
Kode lerroa:  t['afii57668'] = 0x05D4;
Kode lerroa:  t['afii57669'] = 0x05D5;
Kode lerroa:  t['afii57670'] = 0x05D6;
Kode lerroa:  t['afii57671'] = 0x05D7;
Kode lerroa:  t['afii57672'] = 0x05D8;
Kode lerroa:  t['afii57673'] = 0x05D9;
Kode lerroa:  t['afii57674'] = 0x05DA;
Kode lerroa:  t['afii57675'] = 0x05DB;
Kode lerroa:  t['afii57676'] = 0x05DC;
Kode lerroa:  t['afii57677'] = 0x05DD;
Kode lerroa:  t['afii57678'] = 0x05DE;
Kode lerroa:  t['afii57679'] = 0x05DF;
Kode lerroa:  t['afii57680'] = 0x05E0;
Kode lerroa:  t['afii57681'] = 0x05E1;
Kode lerroa:  t['afii57682'] = 0x05E2;
Kode lerroa:  t['afii57683'] = 0x05E3;
Kode lerroa:  t['afii57684'] = 0x05E4;
Kode lerroa:  t['afii57685'] = 0x05E5;
Kode lerroa:  t['afii57686'] = 0x05E6;
Kode lerroa:  t['afii57687'] = 0x05E7;
Kode lerroa:  t['afii57688'] = 0x05E8;
Kode lerroa:  t['afii57689'] = 0x05E9;
Kode lerroa:  t['afii57690'] = 0x05EA;
Kode lerroa:  t['afii57694'] = 0xFB2A;
Kode lerroa:  t['afii57695'] = 0xFB2B;
Kode lerroa:  t['afii57700'] = 0xFB4B;
Kode lerroa:  t['afii57705'] = 0xFB1F;
Kode lerroa:  t['afii57716'] = 0x05F0;
Kode lerroa:  t['afii57717'] = 0x05F1;
Kode lerroa:  t['afii57718'] = 0x05F2;
Kode lerroa:  t['afii57723'] = 0xFB35;
Kode lerroa:  t['afii57793'] = 0x05B4;
Kode lerroa:  t['afii57794'] = 0x05B5;
Kode lerroa:  t['afii57795'] = 0x05B6;
Kode lerroa:  t['afii57796'] = 0x05BB;
Kode lerroa:  t['afii57797'] = 0x05B8;
Kode lerroa:  t['afii57798'] = 0x05B7;
Kode lerroa:  t['afii57799'] = 0x05B0;
Kode lerroa:  t['afii57800'] = 0x05B2;
Kode lerroa:  t['afii57801'] = 0x05B1;
Kode lerroa:  t['afii57802'] = 0x05B3;
Kode lerroa:  t['afii57803'] = 0x05C2;
Kode lerroa:  t['afii57804'] = 0x05C1;
Kode lerroa:  t['afii57806'] = 0x05B9;
Kode lerroa:  t['afii57807'] = 0x05BC;
Kode lerroa:  t['afii57839'] = 0x05BD;
Kode lerroa:  t['afii57841'] = 0x05BF;
Kode lerroa:  t['afii57842'] = 0x05C0;
Kode lerroa:  t['afii57929'] = 0x02BC;
Kode lerroa:  t['afii61248'] = 0x2105;
Kode lerroa:  t['afii61289'] = 0x2113;
Kode lerroa:  t['afii61352'] = 0x2116;
Kode lerroa:  t['afii61573'] = 0x202C;
Kode lerroa:  t['afii61574'] = 0x202D;
Kode lerroa:  t['afii61575'] = 0x202E;
Kode lerroa:  t['afii61664'] = 0x200C;
Kode lerroa:  t['afii63167'] = 0x066D;
Kode lerroa:  t['afii64937'] = 0x02BD;
Kode lerroa:  t['agrave'] = 0x00E0;
Kode lerroa:  t['agujarati'] = 0x0A85;
Kode lerroa:  t['agurmukhi'] = 0x0A05;
Kode lerroa:  t['ahiragana'] = 0x3042;
Kode lerroa:  t['ahookabove'] = 0x1EA3;
Kode lerroa:  t['aibengali'] = 0x0990;
Kode lerroa:  t['aibopomofo'] = 0x311E;
Kode lerroa:  t['aideva'] = 0x0910;
Kode lerroa:  t['aiecyrillic'] = 0x04D5;
Kode lerroa:  t['aigujarati'] = 0x0A90;
Kode lerroa:  t['aigurmukhi'] = 0x0A10;
Kode lerroa:  t['aimatragurmukhi'] = 0x0A48;
Kode lerroa:  t['ainarabic'] = 0x0639;
Kode lerroa:  t['ainfinalarabic'] = 0xFECA;
Kode lerroa:  t['aininitialarabic'] = 0xFECB;
Kode lerroa:  t['ainmedialarabic'] = 0xFECC;
Kode lerroa:  t['ainvertedbreve'] = 0x0203;
Kode lerroa:  t['aivowelsignbengali'] = 0x09C8;
Kode lerroa:  t['aivowelsigndeva'] = 0x0948;
Kode lerroa:  t['aivowelsigngujarati'] = 0x0AC8;
Kode lerroa:  t['akatakana'] = 0x30A2;
Kode lerroa:  t['akatakanahalfwidth'] = 0xFF71;
Kode lerroa:  t['akorean'] = 0x314F;
Kode lerroa:  t['alef'] = 0x05D0;
Kode lerroa:  t['alefarabic'] = 0x0627;
Kode lerroa:  t['alefdageshhebrew'] = 0xFB30;
Kode lerroa:  t['aleffinalarabic'] = 0xFE8E;
Kode lerroa:  t['alefhamzaabovearabic'] = 0x0623;
Kode lerroa:  t['alefhamzaabovefinalarabic'] = 0xFE84;
Kode lerroa:  t['alefhamzabelowarabic'] = 0x0625;
Kode lerroa:  t['alefhamzabelowfinalarabic'] = 0xFE88;
Kode lerroa:  t['alefhebrew'] = 0x05D0;
Kode lerroa:  t['aleflamedhebrew'] = 0xFB4F;
Kode lerroa:  t['alefmaddaabovearabic'] = 0x0622;
Kode lerroa:  t['alefmaddaabovefinalarabic'] = 0xFE82;
Kode lerroa:  t['alefmaksuraarabic'] = 0x0649;
Kode lerroa:  t['alefmaksurafinalarabic'] = 0xFEF0;
Kode lerroa:  t['alefmaksurainitialarabic'] = 0xFEF3;
Kode lerroa:  t['alefmaksuramedialarabic'] = 0xFEF4;
Kode lerroa:  t['alefpatahhebrew'] = 0xFB2E;
Kode lerroa:  t['alefqamatshebrew'] = 0xFB2F;
Kode lerroa:  t['aleph'] = 0x2135;
Kode lerroa:  t['allequal'] = 0x224C;
Kode lerroa:  t['alpha'] = 0x03B1;
Kode lerroa:  t['alphatonos'] = 0x03AC;
Kode lerroa:  t['amacron'] = 0x0101;
Kode lerroa:  t['amonospace'] = 0xFF41;
Kode lerroa:  t['ampersand'] = 0x0026;
Kode lerroa:  t['ampersandmonospace'] = 0xFF06;
Kode lerroa:  t['ampersandsmall'] = 0xF726;
Kode lerroa:  t['amsquare'] = 0x33C2;
Kode lerroa:  t['anbopomofo'] = 0x3122;
Kode lerroa:  t['angbopomofo'] = 0x3124;
Kode lerroa:  t['angbracketleft'] = 0x3008;
Kode lerroa:  t['angbracketright'] = 0x3009;
Kode lerroa:  t['angkhankhuthai'] = 0x0E5A;
Kode lerroa:  t['angle'] = 0x2220;
Kode lerroa:  t['anglebracketleft'] = 0x3008;
Kode lerroa:  t['anglebracketleftvertical'] = 0xFE3F;
Kode lerroa:  t['anglebracketright'] = 0x3009;
Kode lerroa:  t['anglebracketrightvertical'] = 0xFE40;
Kode lerroa:  t['angleleft'] = 0x2329;
Kode lerroa:  t['angleright'] = 0x232A;
Kode lerroa:  t['angstrom'] = 0x212B;
Kode lerroa:  t['anoteleia'] = 0x0387;
Kode lerroa:  t['anudattadeva'] = 0x0952;
Kode lerroa:  t['anusvarabengali'] = 0x0982;
Kode lerroa:  t['anusvaradeva'] = 0x0902;
Kode lerroa:  t['anusvaragujarati'] = 0x0A82;
Kode lerroa:  t['aogonek'] = 0x0105;
Kode lerroa:  t['apaatosquare'] = 0x3300;
Kode lerroa:  t['aparen'] = 0x249C;
Kode lerroa:  t['apostrophearmenian'] = 0x055A;
Kode lerroa:  t['apostrophemod'] = 0x02BC;
Kode lerroa:  t['apple'] = 0xF8FF;
Kode lerroa:  t['approaches'] = 0x2250;
Kode lerroa:  t['approxequal'] = 0x2248;
Kode lerroa:  t['approxequalorimage'] = 0x2252;
Kode lerroa:  t['approximatelyequal'] = 0x2245;
Kode lerroa:  t['araeaekorean'] = 0x318E;
Kode lerroa:  t['araeakorean'] = 0x318D;
Kode lerroa:  t['arc'] = 0x2312;
Kode lerroa:  t['arighthalfring'] = 0x1E9A;
Kode lerroa:  t['aring'] = 0x00E5;
Kode lerroa:  t['aringacute'] = 0x01FB;
Kode lerroa:  t['aringbelow'] = 0x1E01;
Kode lerroa:  t['arrowboth'] = 0x2194;
Kode lerroa:  t['arrowdashdown'] = 0x21E3;
Kode lerroa:  t['arrowdashleft'] = 0x21E0;
Kode lerroa:  t['arrowdashright'] = 0x21E2;
Kode lerroa:  t['arrowdashup'] = 0x21E1;
Kode lerroa:  t['arrowdblboth'] = 0x21D4;
Kode lerroa:  t['arrowdbldown'] = 0x21D3;
Kode lerroa:  t['arrowdblleft'] = 0x21D0;
Kode lerroa:  t['arrowdblright'] = 0x21D2;
Kode lerroa:  t['arrowdblup'] = 0x21D1;
Kode lerroa:  t['arrowdown'] = 0x2193;
Kode lerroa:  t['arrowdownleft'] = 0x2199;
Kode lerroa:  t['arrowdownright'] = 0x2198;
Kode lerroa:  t['arrowdownwhite'] = 0x21E9;
Kode lerroa:  t['arrowheaddownmod'] = 0x02C5;
Kode lerroa:  t['arrowheadleftmod'] = 0x02C2;
Kode lerroa:  t['arrowheadrightmod'] = 0x02C3;
Kode lerroa:  t['arrowheadupmod'] = 0x02C4;
Kode lerroa:  t['arrowhorizex'] = 0xF8E7;
Kode lerroa:  t['arrowleft'] = 0x2190;
Kode lerroa:  t['arrowleftdbl'] = 0x21D0;
Kode lerroa:  t['arrowleftdblstroke'] = 0x21CD;
Kode lerroa:  t['arrowleftoverright'] = 0x21C6;
Kode lerroa:  t['arrowleftwhite'] = 0x21E6;
Kode lerroa:  t['arrowright'] = 0x2192;
Kode lerroa:  t['arrowrightdblstroke'] = 0x21CF;
Kode lerroa:  t['arrowrightheavy'] = 0x279E;
Kode lerroa:  t['arrowrightoverleft'] = 0x21C4;
Kode lerroa:  t['arrowrightwhite'] = 0x21E8;
Kode lerroa:  t['arrowtableft'] = 0x21E4;
Kode lerroa:  t['arrowtabright'] = 0x21E5;
Kode lerroa:  t['arrowup'] = 0x2191;
Kode lerroa:  t['arrowupdn'] = 0x2195;
Kode lerroa:  t['arrowupdnbse'] = 0x21A8;
Kode lerroa:  t['arrowupdownbase'] = 0x21A8;
Kode lerroa:  t['arrowupleft'] = 0x2196;
Kode lerroa:  t['arrowupleftofdown'] = 0x21C5;
Kode lerroa:  t['arrowupright'] = 0x2197;
Kode lerroa:  t['arrowupwhite'] = 0x21E7;
Kode lerroa:  t['arrowvertex'] = 0xF8E6;
Kode lerroa:  t['asciicircum'] = 0x005E;
Kode lerroa:  t['asciicircummonospace'] = 0xFF3E;
Kode lerroa:  t['asciitilde'] = 0x007E;
Kode lerroa:  t['asciitildemonospace'] = 0xFF5E;
Kode lerroa:  t['ascript'] = 0x0251;
Kode lerroa:  t['ascriptturned'] = 0x0252;
Kode lerroa:  t['asmallhiragana'] = 0x3041;
Kode lerroa:  t['asmallkatakana'] = 0x30A1;
Kode lerroa:  t['asmallkatakanahalfwidth'] = 0xFF67;
Kode lerroa:  t['asterisk'] = 0x002A;
Kode lerroa:  t['asteriskaltonearabic'] = 0x066D;
Kode lerroa:  t['asteriskarabic'] = 0x066D;
Kode lerroa:  t['asteriskmath'] = 0x2217;
Kode lerroa:  t['asteriskmonospace'] = 0xFF0A;
Kode lerroa:  t['asterisksmall'] = 0xFE61;
Kode lerroa:  t['asterism'] = 0x2042;
Kode lerroa:  t['asuperior'] = 0xF6E9;
Kode lerroa:  t['asymptoticallyequal'] = 0x2243;
Kode lerroa:  t['at'] = 0x0040;
Kode lerroa:  t['atilde'] = 0x00E3;
Kode lerroa:  t['atmonospace'] = 0xFF20;
Kode lerroa:  t['atsmall'] = 0xFE6B;
Kode lerroa:  t['aturned'] = 0x0250;
Kode lerroa:  t['aubengali'] = 0x0994;
Kode lerroa:  t['aubopomofo'] = 0x3120;
Kode lerroa:  t['audeva'] = 0x0914;
Kode lerroa:  t['augujarati'] = 0x0A94;
Kode lerroa:  t['augurmukhi'] = 0x0A14;
Kode lerroa:  t['aulengthmarkbengali'] = 0x09D7;
Kode lerroa:  t['aumatragurmukhi'] = 0x0A4C;
Kode lerroa:  t['auvowelsignbengali'] = 0x09CC;
Kode lerroa:  t['auvowelsigndeva'] = 0x094C;
Kode lerroa:  t['auvowelsigngujarati'] = 0x0ACC;
Kode lerroa:  t['avagrahadeva'] = 0x093D;
Kode lerroa:  t['aybarmenian'] = 0x0561;
Kode lerroa:  t['ayin'] = 0x05E2;
Kode lerroa:  t['ayinaltonehebrew'] = 0xFB20;
Kode lerroa:  t['ayinhebrew'] = 0x05E2;
Kode lerroa:  t['b'] = 0x0062;
Kode lerroa:  t['babengali'] = 0x09AC;
Kode lerroa:  t['backslash'] = 0x005C;
Kode lerroa:  t['backslashmonospace'] = 0xFF3C;
Kode lerroa:  t['badeva'] = 0x092C;
Kode lerroa:  t['bagujarati'] = 0x0AAC;
Kode lerroa:  t['bagurmukhi'] = 0x0A2C;
Kode lerroa:  t['bahiragana'] = 0x3070;
Kode lerroa:  t['bahtthai'] = 0x0E3F;
Kode lerroa:  t['bakatakana'] = 0x30D0;
Kode lerroa:  t['bar'] = 0x007C;
Kode lerroa:  t['barmonospace'] = 0xFF5C;
Kode lerroa:  t['bbopomofo'] = 0x3105;
Kode lerroa:  t['bcircle'] = 0x24D1;
Kode lerroa:  t['bdotaccent'] = 0x1E03;
Kode lerroa:  t['bdotbelow'] = 0x1E05;
Kode lerroa:  t['beamedsixteenthnotes'] = 0x266C;
Kode lerroa:  t['because'] = 0x2235;
Kode lerroa:  t['becyrillic'] = 0x0431;
Kode lerroa:  t['beharabic'] = 0x0628;
Kode lerroa:  t['behfinalarabic'] = 0xFE90;
Kode lerroa:  t['behinitialarabic'] = 0xFE91;
Kode lerroa:  t['behiragana'] = 0x3079;
Kode lerroa:  t['behmedialarabic'] = 0xFE92;
Kode lerroa:  t['behmeeminitialarabic'] = 0xFC9F;
Kode lerroa:  t['behmeemisolatedarabic'] = 0xFC08;
Kode lerroa:  t['behnoonfinalarabic'] = 0xFC6D;
Kode lerroa:  t['bekatakana'] = 0x30D9;
Kode lerroa:  t['benarmenian'] = 0x0562;
Kode lerroa:  t['bet'] = 0x05D1;
Kode lerroa:  t['beta'] = 0x03B2;
Kode lerroa:  t['betasymbolgreek'] = 0x03D0;
Kode lerroa:  t['betdagesh'] = 0xFB31;
Kode lerroa:  t['betdageshhebrew'] = 0xFB31;
Kode lerroa:  t['bethebrew'] = 0x05D1;
Kode lerroa:  t['betrafehebrew'] = 0xFB4C;
Kode lerroa:  t['bhabengali'] = 0x09AD;
Kode lerroa:  t['bhadeva'] = 0x092D;
Kode lerroa:  t['bhagujarati'] = 0x0AAD;
Kode lerroa:  t['bhagurmukhi'] = 0x0A2D;
Kode lerroa:  t['bhook'] = 0x0253;
Kode lerroa:  t['bihiragana'] = 0x3073;
Kode lerroa:  t['bikatakana'] = 0x30D3;
Kode lerroa:  t['bilabialclick'] = 0x0298;
Kode lerroa:  t['bindigurmukhi'] = 0x0A02;
Kode lerroa:  t['birusquare'] = 0x3331;
Kode lerroa:  t['blackcircle'] = 0x25CF;
Kode lerroa:  t['blackdiamond'] = 0x25C6;
Kode lerroa:  t['blackdownpointingtriangle'] = 0x25BC;
Kode lerroa:  t['blackleftpointingpointer'] = 0x25C4;
Kode lerroa:  t['blackleftpointingtriangle'] = 0x25C0;
Kode lerroa:  t['blacklenticularbracketleft'] = 0x3010;
Kode lerroa:  t['blacklenticularbracketleftvertical'] = 0xFE3B;
Kode lerroa:  t['blacklenticularbracketright'] = 0x3011;
Kode lerroa:  t['blacklenticularbracketrightvertical'] = 0xFE3C;
Kode lerroa:  t['blacklowerlefttriangle'] = 0x25E3;
Kode lerroa:  t['blacklowerrighttriangle'] = 0x25E2;
Kode lerroa:  t['blackrectangle'] = 0x25AC;
Kode lerroa:  t['blackrightpointingpointer'] = 0x25BA;
Kode lerroa:  t['blackrightpointingtriangle'] = 0x25B6;
Kode lerroa:  t['blacksmallsquare'] = 0x25AA;
Kode lerroa:  t['blacksmilingface'] = 0x263B;
Kode lerroa:  t['blacksquare'] = 0x25A0;
Kode lerroa:  t['blackstar'] = 0x2605;
Kode lerroa:  t['blackupperlefttriangle'] = 0x25E4;
Kode lerroa:  t['blackupperrighttriangle'] = 0x25E5;
Kode lerroa:  t['blackuppointingsmalltriangle'] = 0x25B4;
Kode lerroa:  t['blackuppointingtriangle'] = 0x25B2;
Kode lerroa:  t['blank'] = 0x2423;
Kode lerroa:  t['blinebelow'] = 0x1E07;
Kode lerroa:  t['block'] = 0x2588;
Kode lerroa:  t['bmonospace'] = 0xFF42;
Kode lerroa:  t['bobaimaithai'] = 0x0E1A;
Kode lerroa:  t['bohiragana'] = 0x307C;
Kode lerroa:  t['bokatakana'] = 0x30DC;
Kode lerroa:  t['bparen'] = 0x249D;
Kode lerroa:  t['bqsquare'] = 0x33C3;
Kode lerroa:  t['braceex'] = 0xF8F4;
Kode lerroa:  t['braceleft'] = 0x007B;
Kode lerroa:  t['braceleftbt'] = 0xF8F3;
Kode lerroa:  t['braceleftmid'] = 0xF8F2;
Kode lerroa:  t['braceleftmonospace'] = 0xFF5B;
Kode lerroa:  t['braceleftsmall'] = 0xFE5B;
Kode lerroa:  t['bracelefttp'] = 0xF8F1;
Kode lerroa:  t['braceleftvertical'] = 0xFE37;
Kode lerroa:  t['braceright'] = 0x007D;
Kode lerroa:  t['bracerightbt'] = 0xF8FE;
Kode lerroa:  t['bracerightmid'] = 0xF8FD;
Kode lerroa:  t['bracerightmonospace'] = 0xFF5D;
Kode lerroa:  t['bracerightsmall'] = 0xFE5C;
Kode lerroa:  t['bracerighttp'] = 0xF8FC;
Kode lerroa:  t['bracerightvertical'] = 0xFE38;
Kode lerroa:  t['bracketleft'] = 0x005B;
Kode lerroa:  t['bracketleftbt'] = 0xF8F0;
Kode lerroa:  t['bracketleftex'] = 0xF8EF;
Kode lerroa:  t['bracketleftmonospace'] = 0xFF3B;
Kode lerroa:  t['bracketlefttp'] = 0xF8EE;
Kode lerroa:  t['bracketright'] = 0x005D;
Kode lerroa:  t['bracketrightbt'] = 0xF8FB;
Kode lerroa:  t['bracketrightex'] = 0xF8FA;
Kode lerroa:  t['bracketrightmonospace'] = 0xFF3D;
Kode lerroa:  t['bracketrighttp'] = 0xF8F9;
Kode lerroa:  t['breve'] = 0x02D8;
Kode lerroa:  t['brevebelowcmb'] = 0x032E;
Kode lerroa:  t['brevecmb'] = 0x0306;
Kode lerroa:  t['breveinvertedbelowcmb'] = 0x032F;
Kode lerroa:  t['breveinvertedcmb'] = 0x0311;
Kode lerroa:  t['breveinverteddoublecmb'] = 0x0361;
Kode lerroa:  t['bridgebelowcmb'] = 0x032A;
Kode lerroa:  t['bridgeinvertedbelowcmb'] = 0x033A;
Kode lerroa:  t['brokenbar'] = 0x00A6;
Kode lerroa:  t['bstroke'] = 0x0180;
Kode lerroa:  t['bsuperior'] = 0xF6EA;
Kode lerroa:  t['btopbar'] = 0x0183;
Kode lerroa:  t['buhiragana'] = 0x3076;
Kode lerroa:  t['bukatakana'] = 0x30D6;
Kode lerroa:  t['bullet'] = 0x2022;
Kode lerroa:  t['bulletinverse'] = 0x25D8;
Kode lerroa:  t['bulletoperator'] = 0x2219;
Kode lerroa:  t['bullseye'] = 0x25CE;
Kode lerroa:  t['c'] = 0x0063;
Kode lerroa:  t['caarmenian'] = 0x056E;
Kode lerroa:  t['cabengali'] = 0x099A;
Kode lerroa:  t['cacute'] = 0x0107;
Kode lerroa:  t['cadeva'] = 0x091A;
Kode lerroa:  t['cagujarati'] = 0x0A9A;
Kode lerroa:  t['cagurmukhi'] = 0x0A1A;
Kode lerroa:  t['calsquare'] = 0x3388;
Kode lerroa:  t['candrabindubengali'] = 0x0981;
Kode lerroa:  t['candrabinducmb'] = 0x0310;
Kode lerroa:  t['candrabindudeva'] = 0x0901;
Kode lerroa:  t['candrabindugujarati'] = 0x0A81;
Kode lerroa:  t['capslock'] = 0x21EA;
Kode lerroa:  t['careof'] = 0x2105;
Kode lerroa:  t['caron'] = 0x02C7;
Kode lerroa:  t['caronbelowcmb'] = 0x032C;
Kode lerroa:  t['caroncmb'] = 0x030C;
Kode lerroa:  t['carriagereturn'] = 0x21B5;
Kode lerroa:  t['cbopomofo'] = 0x3118;
Kode lerroa:  t['ccaron'] = 0x010D;
Kode lerroa:  t['ccedilla'] = 0x00E7;
Kode lerroa:  t['ccedillaacute'] = 0x1E09;
Kode lerroa:  t['ccircle'] = 0x24D2;
Kode lerroa:  t['ccircumflex'] = 0x0109;
Kode lerroa:  t['ccurl'] = 0x0255;
Kode lerroa:  t['cdot'] = 0x010B;
Kode lerroa:  t['cdotaccent'] = 0x010B;
Kode lerroa:  t['cdsquare'] = 0x33C5;
Kode lerroa:  t['cedilla'] = 0x00B8;
Kode lerroa:  t['cedillacmb'] = 0x0327;
Kode lerroa:  t['cent'] = 0x00A2;
Kode lerroa:  t['centigrade'] = 0x2103;
Kode lerroa:  t['centinferior'] = 0xF6DF;
Kode lerroa:  t['centmonospace'] = 0xFFE0;
Kode lerroa:  t['centoldstyle'] = 0xF7A2;
Kode lerroa:  t['centsuperior'] = 0xF6E0;
Kode lerroa:  t['chaarmenian'] = 0x0579;
Kode lerroa:  t['chabengali'] = 0x099B;
Kode lerroa:  t['chadeva'] = 0x091B;
Kode lerroa:  t['chagujarati'] = 0x0A9B;
Kode lerroa:  t['chagurmukhi'] = 0x0A1B;
Kode lerroa:  t['chbopomofo'] = 0x3114;
Kode lerroa:  t['cheabkhasiancyrillic'] = 0x04BD;
Kode lerroa:  t['checkmark'] = 0x2713;
Kode lerroa:  t['checyrillic'] = 0x0447;
Kode lerroa:  t['chedescenderabkhasiancyrillic'] = 0x04BF;
Kode lerroa:  t['chedescendercyrillic'] = 0x04B7;
Kode lerroa:  t['chedieresiscyrillic'] = 0x04F5;
Kode lerroa:  t['cheharmenian'] = 0x0573;
Kode lerroa:  t['chekhakassiancyrillic'] = 0x04CC;
Kode lerroa:  t['cheverticalstrokecyrillic'] = 0x04B9;
Kode lerroa:  t['chi'] = 0x03C7;
Kode lerroa:  t['chieuchacirclekorean'] = 0x3277;
Kode lerroa:  t['chieuchaparenkorean'] = 0x3217;
Kode lerroa:  t['chieuchcirclekorean'] = 0x3269;
Kode lerroa:  t['chieuchkorean'] = 0x314A;
Kode lerroa:  t['chieuchparenkorean'] = 0x3209;
Kode lerroa:  t['chochangthai'] = 0x0E0A;
Kode lerroa:  t['chochanthai'] = 0x0E08;
Kode lerroa:  t['chochingthai'] = 0x0E09;
Kode lerroa:  t['chochoethai'] = 0x0E0C;
Kode lerroa:  t['chook'] = 0x0188;
Kode lerroa:  t['cieucacirclekorean'] = 0x3276;
Kode lerroa:  t['cieucaparenkorean'] = 0x3216;
Kode lerroa:  t['cieuccirclekorean'] = 0x3268;
Kode lerroa:  t['cieuckorean'] = 0x3148;
Kode lerroa:  t['cieucparenkorean'] = 0x3208;
Kode lerroa:  t['cieucuparenkorean'] = 0x321C;
Kode lerroa:  t['circle'] = 0x25CB;
Kode lerroa:  t['circlecopyrt'] = 0x00A9;
Kode lerroa:  t['circlemultiply'] = 0x2297;
Kode lerroa:  t['circleot'] = 0x2299;
Kode lerroa:  t['circleplus'] = 0x2295;
Kode lerroa:  t['circlepostalmark'] = 0x3036;
Kode lerroa:  t['circlewithlefthalfblack'] = 0x25D0;
Kode lerroa:  t['circlewithrighthalfblack'] = 0x25D1;
Kode lerroa:  t['circumflex'] = 0x02C6;
Kode lerroa:  t['circumflexbelowcmb'] = 0x032D;
Kode lerroa:  t['circumflexcmb'] = 0x0302;
Kode lerroa:  t['clear'] = 0x2327;
Kode lerroa:  t['clickalveolar'] = 0x01C2;
Kode lerroa:  t['clickdental'] = 0x01C0;
Kode lerroa:  t['clicklateral'] = 0x01C1;
Kode lerroa:  t['clickretroflex'] = 0x01C3;
Kode lerroa:  t['club'] = 0x2663;
Kode lerroa:  t['clubsuitblack'] = 0x2663;
Kode lerroa:  t['clubsuitwhite'] = 0x2667;
Kode lerroa:  t['cmcubedsquare'] = 0x33A4;
Kode lerroa:  t['cmonospace'] = 0xFF43;
Kode lerroa:  t['cmsquaredsquare'] = 0x33A0;
Kode lerroa:  t['coarmenian'] = 0x0581;
Kode lerroa:  t['colon'] = 0x003A;
Kode lerroa:  t['colonmonetary'] = 0x20A1;
Kode lerroa:  t['colonmonospace'] = 0xFF1A;
Kode lerroa:  t['colonsign'] = 0x20A1;
Kode lerroa:  t['colonsmall'] = 0xFE55;
Kode lerroa:  t['colontriangularhalfmod'] = 0x02D1;
Kode lerroa:  t['colontriangularmod'] = 0x02D0;
Kode lerroa:  t['comma'] = 0x002C;
Kode lerroa:  t['commaabovecmb'] = 0x0313;
Kode lerroa:  t['commaaboverightcmb'] = 0x0315;
Kode lerroa:  t['commaaccent'] = 0xF6C3;
Kode lerroa:  t['commaarabic'] = 0x060C;
Kode lerroa:  t['commaarmenian'] = 0x055D;
Kode lerroa:  t['commainferior'] = 0xF6E1;
Kode lerroa:  t['commamonospace'] = 0xFF0C;
Kode lerroa:  t['commareversedabovecmb'] = 0x0314;
Kode lerroa:  t['commareversedmod'] = 0x02BD;
Kode lerroa:  t['commasmall'] = 0xFE50;
Kode lerroa:  t['commasuperior'] = 0xF6E2;
Kode lerroa:  t['commaturnedabovecmb'] = 0x0312;
Kode lerroa:  t['commaturnedmod'] = 0x02BB;
Kode lerroa:  t['compass'] = 0x263C;
Kode lerroa:  t['congruent'] = 0x2245;
Kode lerroa:  t['contourintegral'] = 0x222E;
Kode lerroa:  t['control'] = 0x2303;
Kode lerroa:  t['controlACK'] = 0x0006;
Kode lerroa:  t['controlBEL'] = 0x0007;
Kode lerroa:  t['controlBS'] = 0x0008;
Kode lerroa:  t['controlCAN'] = 0x0018;
Kode lerroa:  t['controlCR'] = 0x000D;
Kode lerroa:  t['controlDC1'] = 0x0011;
Kode lerroa:  t['controlDC2'] = 0x0012;
Kode lerroa:  t['controlDC3'] = 0x0013;
Kode lerroa:  t['controlDC4'] = 0x0014;
Kode lerroa:  t['controlDEL'] = 0x007F;
Kode lerroa:  t['controlDLE'] = 0x0010;
Kode lerroa:  t['controlEM'] = 0x0019;
Kode lerroa:  t['controlENQ'] = 0x0005;
Kode lerroa:  t['controlEOT'] = 0x0004;
Kode lerroa:  t['controlESC'] = 0x001B;
Kode lerroa:  t['controlETB'] = 0x0017;
Kode lerroa:  t['controlETX'] = 0x0003;
Kode lerroa:  t['controlFF'] = 0x000C;
Kode lerroa:  t['controlFS'] = 0x001C;
Kode lerroa:  t['controlGS'] = 0x001D;
Kode lerroa:  t['controlHT'] = 0x0009;
Kode lerroa:  t['controlLF'] = 0x000A;
Kode lerroa:  t['controlNAK'] = 0x0015;
Kode lerroa:  t['controlNULL'] = 0x0000;
Kode lerroa:  t['controlRS'] = 0x001E;
Kode lerroa:  t['controlSI'] = 0x000F;
Kode lerroa:  t['controlSO'] = 0x000E;
Kode lerroa:  t['controlSOT'] = 0x0002;
Kode lerroa:  t['controlSTX'] = 0x0001;
Kode lerroa:  t['controlSUB'] = 0x001A;
Kode lerroa:  t['controlSYN'] = 0x0016;
Kode lerroa:  t['controlUS'] = 0x001F;
Kode lerroa:  t['controlVT'] = 0x000B;
Kode lerroa:  t['copyright'] = 0x00A9;
Kode lerroa:  t['copyrightsans'] = 0xF8E9;
Kode lerroa:  t['copyrightserif'] = 0xF6D9;
Kode lerroa:  t['cornerbracketleft'] = 0x300C;
Kode lerroa:  t['cornerbracketlefthalfwidth'] = 0xFF62;
Kode lerroa:  t['cornerbracketleftvertical'] = 0xFE41;
Kode lerroa:  t['cornerbracketright'] = 0x300D;
Kode lerroa:  t['cornerbracketrighthalfwidth'] = 0xFF63;
Kode lerroa:  t['cornerbracketrightvertical'] = 0xFE42;
Kode lerroa:  t['corporationsquare'] = 0x337F;
Kode lerroa:  t['cosquare'] = 0x33C7;
Kode lerroa:  t['coverkgsquare'] = 0x33C6;
Kode lerroa:  t['cparen'] = 0x249E;
Kode lerroa:  t['cruzeiro'] = 0x20A2;
Kode lerroa:  t['cstretched'] = 0x0297;
Kode lerroa:  t['curlyand'] = 0x22CF;
Kode lerroa:  t['curlyor'] = 0x22CE;
Kode lerroa:  t['currency'] = 0x00A4;
Kode lerroa:  t['cyrBreve'] = 0xF6D1;
Kode lerroa:  t['cyrFlex'] = 0xF6D2;
Kode lerroa:  t['cyrbreve'] = 0xF6D4;
Kode lerroa:  t['cyrflex'] = 0xF6D5;
Kode lerroa:  t['d'] = 0x0064;
Kode lerroa:  t['daarmenian'] = 0x0564;
Kode lerroa:  t['dabengali'] = 0x09A6;
Kode lerroa:  t['dadarabic'] = 0x0636;
Kode lerroa:  t['dadeva'] = 0x0926;
Kode lerroa:  t['dadfinalarabic'] = 0xFEBE;
Kode lerroa:  t['dadinitialarabic'] = 0xFEBF;
Kode lerroa:  t['dadmedialarabic'] = 0xFEC0;
Kode lerroa:  t['dagesh'] = 0x05BC;
Kode lerroa:  t['dageshhebrew'] = 0x05BC;
Kode lerroa:  t['dagger'] = 0x2020;
Kode lerroa:  t['daggerdbl'] = 0x2021;
Kode lerroa:  t['dagujarati'] = 0x0AA6;
Kode lerroa:  t['dagurmukhi'] = 0x0A26;
Kode lerroa:  t['dahiragana'] = 0x3060;
Kode lerroa:  t['dakatakana'] = 0x30C0;
Kode lerroa:  t['dalarabic'] = 0x062F;
Kode lerroa:  t['dalet'] = 0x05D3;
Kode lerroa:  t['daletdagesh'] = 0xFB33;
Kode lerroa:  t['daletdageshhebrew'] = 0xFB33;
Kode lerroa:  t['dalethebrew'] = 0x05D3;
Kode lerroa:  t['dalfinalarabic'] = 0xFEAA;
Kode lerroa:  t['dammaarabic'] = 0x064F;
Kode lerroa:  t['dammalowarabic'] = 0x064F;
Kode lerroa:  t['dammatanaltonearabic'] = 0x064C;
Kode lerroa:  t['dammatanarabic'] = 0x064C;
Kode lerroa:  t['danda'] = 0x0964;
Kode lerroa:  t['dargahebrew'] = 0x05A7;
Kode lerroa:  t['dargalefthebrew'] = 0x05A7;
Kode lerroa:  t['dasiapneumatacyrilliccmb'] = 0x0485;
Kode lerroa:  t['dblGrave'] = 0xF6D3;
Kode lerroa:  t['dblanglebracketleft'] = 0x300A;
Kode lerroa:  t['dblanglebracketleftvertical'] = 0xFE3D;
Kode lerroa:  t['dblanglebracketright'] = 0x300B;
Kode lerroa:  t['dblanglebracketrightvertical'] = 0xFE3E;
Kode lerroa:  t['dblarchinvertedbelowcmb'] = 0x032B;
Kode lerroa:  t['dblarrowleft'] = 0x21D4;
Kode lerroa:  t['dblarrowright'] = 0x21D2;
Kode lerroa:  t['dbldanda'] = 0x0965;
Kode lerroa:  t['dblgrave'] = 0xF6D6;
Kode lerroa:  t['dblgravecmb'] = 0x030F;
Kode lerroa:  t['dblintegral'] = 0x222C;
Kode lerroa:  t['dbllowline'] = 0x2017;
Kode lerroa:  t['dbllowlinecmb'] = 0x0333;
Kode lerroa:  t['dbloverlinecmb'] = 0x033F;
Kode lerroa:  t['dblprimemod'] = 0x02BA;
Kode lerroa:  t['dblverticalbar'] = 0x2016;
Kode lerroa:  t['dblverticallineabovecmb'] = 0x030E;
Kode lerroa:  t['dbopomofo'] = 0x3109;
Kode lerroa:  t['dbsquare'] = 0x33C8;
Kode lerroa:  t['dcaron'] = 0x010F;
Kode lerroa:  t['dcedilla'] = 0x1E11;
Kode lerroa:  t['dcircle'] = 0x24D3;
Kode lerroa:  t['dcircumflexbelow'] = 0x1E13;
Kode lerroa:  t['dcroat'] = 0x0111;
Kode lerroa:  t['ddabengali'] = 0x09A1;
Kode lerroa:  t['ddadeva'] = 0x0921;
Kode lerroa:  t['ddagujarati'] = 0x0AA1;
Kode lerroa:  t['ddagurmukhi'] = 0x0A21;
Kode lerroa:  t['ddalarabic'] = 0x0688;
Kode lerroa:  t['ddalfinalarabic'] = 0xFB89;
Kode lerroa:  t['dddhadeva'] = 0x095C;
Kode lerroa:  t['ddhabengali'] = 0x09A2;
Kode lerroa:  t['ddhadeva'] = 0x0922;
Kode lerroa:  t['ddhagujarati'] = 0x0AA2;
Kode lerroa:  t['ddhagurmukhi'] = 0x0A22;
Kode lerroa:  t['ddotaccent'] = 0x1E0B;
Kode lerroa:  t['ddotbelow'] = 0x1E0D;
Kode lerroa:  t['decimalseparatorarabic'] = 0x066B;
Kode lerroa:  t['decimalseparatorpersian'] = 0x066B;
Kode lerroa:  t['decyrillic'] = 0x0434;
Kode lerroa:  t['degree'] = 0x00B0;
Kode lerroa:  t['dehihebrew'] = 0x05AD;
Kode lerroa:  t['dehiragana'] = 0x3067;
Kode lerroa:  t['deicoptic'] = 0x03EF;
Kode lerroa:  t['dekatakana'] = 0x30C7;
Kode lerroa:  t['deleteleft'] = 0x232B;
Kode lerroa:  t['deleteright'] = 0x2326;
Kode lerroa:  t['delta'] = 0x03B4;
Kode lerroa:  t['deltaturned'] = 0x018D;
Kode lerroa:  t['denominatorminusonenumeratorbengali'] = 0x09F8;
Kode lerroa:  t['dezh'] = 0x02A4;
Kode lerroa:  t['dhabengali'] = 0x09A7;
Kode lerroa:  t['dhadeva'] = 0x0927;
Kode lerroa:  t['dhagujarati'] = 0x0AA7;
Kode lerroa:  t['dhagurmukhi'] = 0x0A27;
Kode lerroa:  t['dhook'] = 0x0257;
Kode lerroa:  t['dialytikatonos'] = 0x0385;
Kode lerroa:  t['dialytikatonoscmb'] = 0x0344;
Kode lerroa:  t['diamond'] = 0x2666;
Kode lerroa:  t['diamondsuitwhite'] = 0x2662;
Kode lerroa:  t['dieresis'] = 0x00A8;
Kode lerroa:  t['dieresisacute'] = 0xF6D7;
Kode lerroa:  t['dieresisbelowcmb'] = 0x0324;
Kode lerroa:  t['dieresiscmb'] = 0x0308;
Kode lerroa:  t['dieresisgrave'] = 0xF6D8;
Kode lerroa:  t['dieresistonos'] = 0x0385;
Kode lerroa:  t['dihiragana'] = 0x3062;
Kode lerroa:  t['dikatakana'] = 0x30C2;
Kode lerroa:  t['dittomark'] = 0x3003;
Kode lerroa:  t['divide'] = 0x00F7;
Kode lerroa:  t['divides'] = 0x2223;
Kode lerroa:  t['divisionslash'] = 0x2215;
Kode lerroa:  t['djecyrillic'] = 0x0452;
Kode lerroa:  t['dkshade'] = 0x2593;
Kode lerroa:  t['dlinebelow'] = 0x1E0F;
Kode lerroa:  t['dlsquare'] = 0x3397;
Kode lerroa:  t['dmacron'] = 0x0111;
Kode lerroa:  t['dmonospace'] = 0xFF44;
Kode lerroa:  t['dnblock'] = 0x2584;
Kode lerroa:  t['dochadathai'] = 0x0E0E;
Kode lerroa:  t['dodekthai'] = 0x0E14;
Kode lerroa:  t['dohiragana'] = 0x3069;
Kode lerroa:  t['dokatakana'] = 0x30C9;
Kode lerroa:  t['dollar'] = 0x0024;
Kode lerroa:  t['dollarinferior'] = 0xF6E3;
Kode lerroa:  t['dollarmonospace'] = 0xFF04;
Kode lerroa:  t['dollaroldstyle'] = 0xF724;
Kode lerroa:  t['dollarsmall'] = 0xFE69;
Kode lerroa:  t['dollarsuperior'] = 0xF6E4;
Kode lerroa:  t['dong'] = 0x20AB;
Kode lerroa:  t['dorusquare'] = 0x3326;
Kode lerroa:  t['dotaccent'] = 0x02D9;
Kode lerroa:  t['dotaccentcmb'] = 0x0307;
Kode lerroa:  t['dotbelowcmb'] = 0x0323;
Kode lerroa:  t['dotbelowcomb'] = 0x0323;
Kode lerroa:  t['dotkatakana'] = 0x30FB;
Kode lerroa:  t['dotlessi'] = 0x0131;
Kode lerroa:  t['dotlessj'] = 0xF6BE;
Kode lerroa:  t['dotlessjstrokehook'] = 0x0284;
Kode lerroa:  t['dotmath'] = 0x22C5;
Kode lerroa:  t['dottedcircle'] = 0x25CC;
Kode lerroa:  t['doubleyodpatah'] = 0xFB1F;
Kode lerroa:  t['doubleyodpatahhebrew'] = 0xFB1F;
Kode lerroa:  t['downtackbelowcmb'] = 0x031E;
Kode lerroa:  t['downtackmod'] = 0x02D5;
Kode lerroa:  t['dparen'] = 0x249F;
Kode lerroa:  t['dsuperior'] = 0xF6EB;
Kode lerroa:  t['dtail'] = 0x0256;
Kode lerroa:  t['dtopbar'] = 0x018C;
Kode lerroa:  t['duhiragana'] = 0x3065;
Kode lerroa:  t['dukatakana'] = 0x30C5;
Kode lerroa:  t['dz'] = 0x01F3;
Kode lerroa:  t['dzaltone'] = 0x02A3;
Kode lerroa:  t['dzcaron'] = 0x01C6;
Kode lerroa:  t['dzcurl'] = 0x02A5;
Kode lerroa:  t['dzeabkhasiancyrillic'] = 0x04E1;
Kode lerroa:  t['dzecyrillic'] = 0x0455;
Kode lerroa:  t['dzhecyrillic'] = 0x045F;
Kode lerroa:  t['e'] = 0x0065;
Kode lerroa:  t['eacute'] = 0x00E9;
Kode lerroa:  t['earth'] = 0x2641;
Kode lerroa:  t['ebengali'] = 0x098F;
Kode lerroa:  t['ebopomofo'] = 0x311C;
Kode lerroa:  t['ebreve'] = 0x0115;
Kode lerroa:  t['ecandradeva'] = 0x090D;
Kode lerroa:  t['ecandragujarati'] = 0x0A8D;
Kode lerroa:  t['ecandravowelsigndeva'] = 0x0945;
Kode lerroa:  t['ecandravowelsigngujarati'] = 0x0AC5;
Kode lerroa:  t['ecaron'] = 0x011B;
Kode lerroa:  t['ecedillabreve'] = 0x1E1D;
Kode lerroa:  t['echarmenian'] = 0x0565;
Kode lerroa:  t['echyiwnarmenian'] = 0x0587;
Kode lerroa:  t['ecircle'] = 0x24D4;
Kode lerroa:  t['ecircumflex'] = 0x00EA;
Kode lerroa:  t['ecircumflexacute'] = 0x1EBF;
Kode lerroa:  t['ecircumflexbelow'] = 0x1E19;
Kode lerroa:  t['ecircumflexdotbelow'] = 0x1EC7;
Kode lerroa:  t['ecircumflexgrave'] = 0x1EC1;
Kode lerroa:  t['ecircumflexhookabove'] = 0x1EC3;
Kode lerroa:  t['ecircumflextilde'] = 0x1EC5;
Kode lerroa:  t['ecyrillic'] = 0x0454;
Kode lerroa:  t['edblgrave'] = 0x0205;
Kode lerroa:  t['edeva'] = 0x090F;
Kode lerroa:  t['edieresis'] = 0x00EB;
Kode lerroa:  t['edot'] = 0x0117;
Kode lerroa:  t['edotaccent'] = 0x0117;
Kode lerroa:  t['edotbelow'] = 0x1EB9;
Kode lerroa:  t['eegurmukhi'] = 0x0A0F;
Kode lerroa:  t['eematragurmukhi'] = 0x0A47;
Kode lerroa:  t['efcyrillic'] = 0x0444;
Kode lerroa:  t['egrave'] = 0x00E8;
Kode lerroa:  t['egujarati'] = 0x0A8F;
Kode lerroa:  t['eharmenian'] = 0x0567;
Kode lerroa:  t['ehbopomofo'] = 0x311D;
Kode lerroa:  t['ehiragana'] = 0x3048;
Kode lerroa:  t['ehookabove'] = 0x1EBB;
Kode lerroa:  t['eibopomofo'] = 0x311F;
Kode lerroa:  t['eight'] = 0x0038;
Kode lerroa:  t['eightarabic'] = 0x0668;
Kode lerroa:  t['eightbengali'] = 0x09EE;
Kode lerroa:  t['eightcircle'] = 0x2467;
Kode lerroa:  t['eightcircleinversesansserif'] = 0x2791;
Kode lerroa:  t['eightdeva'] = 0x096E;
Kode lerroa:  t['eighteencircle'] = 0x2471;
Kode lerroa:  t['eighteenparen'] = 0x2485;
Kode lerroa:  t['eighteenperiod'] = 0x2499;
Kode lerroa:  t['eightgujarati'] = 0x0AEE;
Kode lerroa:  t['eightgurmukhi'] = 0x0A6E;
Kode lerroa:  t['eighthackarabic'] = 0x0668;
Kode lerroa:  t['eighthangzhou'] = 0x3028;
Kode lerroa:  t['eighthnotebeamed'] = 0x266B;
Kode lerroa:  t['eightideographicparen'] = 0x3227;
Kode lerroa:  t['eightinferior'] = 0x2088;
Kode lerroa:  t['eightmonospace'] = 0xFF18;
Kode lerroa:  t['eightoldstyle'] = 0xF738;
Kode lerroa:  t['eightparen'] = 0x247B;
Kode lerroa:  t['eightperiod'] = 0x248F;
Kode lerroa:  t['eightpersian'] = 0x06F8;
Kode lerroa:  t['eightroman'] = 0x2177;
Kode lerroa:  t['eightsuperior'] = 0x2078;
Kode lerroa:  t['eightthai'] = 0x0E58;
Kode lerroa:  t['einvertedbreve'] = 0x0207;
Kode lerroa:  t['eiotifiedcyrillic'] = 0x0465;
Kode lerroa:  t['ekatakana'] = 0x30A8;
Kode lerroa:  t['ekatakanahalfwidth'] = 0xFF74;
Kode lerroa:  t['ekonkargurmukhi'] = 0x0A74;
Kode lerroa:  t['ekorean'] = 0x3154;
Kode lerroa:  t['elcyrillic'] = 0x043B;
Kode lerroa:  t['element'] = 0x2208;
Kode lerroa:  t['elevencircle'] = 0x246A;
Kode lerroa:  t['elevenparen'] = 0x247E;
Kode lerroa:  t['elevenperiod'] = 0x2492;
Kode lerroa:  t['elevenroman'] = 0x217A;
Kode lerroa:  t['ellipsis'] = 0x2026;
Kode lerroa:  t['ellipsisvertical'] = 0x22EE;
Kode lerroa:  t['emacron'] = 0x0113;
Kode lerroa:  t['emacronacute'] = 0x1E17;
Kode lerroa:  t['emacrongrave'] = 0x1E15;
Kode lerroa:  t['emcyrillic'] = 0x043C;
Kode lerroa:  t['emdash'] = 0x2014;
Kode lerroa:  t['emdashvertical'] = 0xFE31;
Kode lerroa:  t['emonospace'] = 0xFF45;
Kode lerroa:  t['emphasismarkarmenian'] = 0x055B;
Kode lerroa:  t['emptyset'] = 0x2205;
Kode lerroa:  t['enbopomofo'] = 0x3123;
Kode lerroa:  t['encyrillic'] = 0x043D;
Kode lerroa:  t['endash'] = 0x2013;
Kode lerroa:  t['endashvertical'] = 0xFE32;
Kode lerroa:  t['endescendercyrillic'] = 0x04A3;
Kode lerroa:  t['eng'] = 0x014B;
Kode lerroa:  t['engbopomofo'] = 0x3125;
Kode lerroa:  t['enghecyrillic'] = 0x04A5;
Kode lerroa:  t['enhookcyrillic'] = 0x04C8;
Kode lerroa:  t['enspace'] = 0x2002;
Kode lerroa:  t['eogonek'] = 0x0119;
Kode lerroa:  t['eokorean'] = 0x3153;
Kode lerroa:  t['eopen'] = 0x025B;
Kode lerroa:  t['eopenclosed'] = 0x029A;
Kode lerroa:  t['eopenreversed'] = 0x025C;
Kode lerroa:  t['eopenreversedclosed'] = 0x025E;
Kode lerroa:  t['eopenreversedhook'] = 0x025D;
Kode lerroa:  t['eparen'] = 0x24A0;
Kode lerroa:  t['epsilon'] = 0x03B5;
Kode lerroa:  t['epsilontonos'] = 0x03AD;
Kode lerroa:  t['equal'] = 0x003D;
Kode lerroa:  t['equalmonospace'] = 0xFF1D;
Kode lerroa:  t['equalsmall'] = 0xFE66;
Kode lerroa:  t['equalsuperior'] = 0x207C;
Kode lerroa:  t['equivalence'] = 0x2261;
Kode lerroa:  t['erbopomofo'] = 0x3126;
Kode lerroa:  t['ercyrillic'] = 0x0440;
Kode lerroa:  t['ereversed'] = 0x0258;
Kode lerroa:  t['ereversedcyrillic'] = 0x044D;
Kode lerroa:  t['escyrillic'] = 0x0441;
Kode lerroa:  t['esdescendercyrillic'] = 0x04AB;
Kode lerroa:  t['esh'] = 0x0283;
Kode lerroa:  t['eshcurl'] = 0x0286;
Kode lerroa:  t['eshortdeva'] = 0x090E;
Kode lerroa:  t['eshortvowelsigndeva'] = 0x0946;
Kode lerroa:  t['eshreversedloop'] = 0x01AA;
Kode lerroa:  t['eshsquatreversed'] = 0x0285;
Kode lerroa:  t['esmallhiragana'] = 0x3047;
Kode lerroa:  t['esmallkatakana'] = 0x30A7;
Kode lerroa:  t['esmallkatakanahalfwidth'] = 0xFF6A;
Kode lerroa:  t['estimated'] = 0x212E;
Kode lerroa:  t['esuperior'] = 0xF6EC;
Kode lerroa:  t['eta'] = 0x03B7;
Kode lerroa:  t['etarmenian'] = 0x0568;
Kode lerroa:  t['etatonos'] = 0x03AE;
Kode lerroa:  t['eth'] = 0x00F0;
Kode lerroa:  t['etilde'] = 0x1EBD;
Kode lerroa:  t['etildebelow'] = 0x1E1B;
Kode lerroa:  t['etnahtafoukhhebrew'] = 0x0591;
Kode lerroa:  t['etnahtafoukhlefthebrew'] = 0x0591;
Kode lerroa:  t['etnahtahebrew'] = 0x0591;
Kode lerroa:  t['etnahtalefthebrew'] = 0x0591;
Kode lerroa:  t['eturned'] = 0x01DD;
Kode lerroa:  t['eukorean'] = 0x3161;
Kode lerroa:  t['euro'] = 0x20AC;
Kode lerroa:  t['evowelsignbengali'] = 0x09C7;
Kode lerroa:  t['evowelsigndeva'] = 0x0947;
Kode lerroa:  t['evowelsigngujarati'] = 0x0AC7;
Kode lerroa:  t['exclam'] = 0x0021;
Kode lerroa:  t['exclamarmenian'] = 0x055C;
Kode lerroa:  t['exclamdbl'] = 0x203C;
Kode lerroa:  t['exclamdown'] = 0x00A1;
Kode lerroa:  t['exclamdownsmall'] = 0xF7A1;
Kode lerroa:  t['exclammonospace'] = 0xFF01;
Kode lerroa:  t['exclamsmall'] = 0xF721;
Kode lerroa:  t['existential'] = 0x2203;
Kode lerroa:  t['ezh'] = 0x0292;
Kode lerroa:  t['ezhcaron'] = 0x01EF;
Kode lerroa:  t['ezhcurl'] = 0x0293;
Kode lerroa:  t['ezhreversed'] = 0x01B9;
Kode lerroa:  t['ezhtail'] = 0x01BA;
Kode lerroa:  t['f'] = 0x0066;
Kode lerroa:  t['fadeva'] = 0x095E;
Kode lerroa:  t['fagurmukhi'] = 0x0A5E;
Kode lerroa:  t['fahrenheit'] = 0x2109;
Kode lerroa:  t['fathaarabic'] = 0x064E;
Kode lerroa:  t['fathalowarabic'] = 0x064E;
Kode lerroa:  t['fathatanarabic'] = 0x064B;
Kode lerroa:  t['fbopomofo'] = 0x3108;
Kode lerroa:  t['fcircle'] = 0x24D5;
Kode lerroa:  t['fdotaccent'] = 0x1E1F;
Kode lerroa:  t['feharabic'] = 0x0641;
Kode lerroa:  t['feharmenian'] = 0x0586;
Kode lerroa:  t['fehfinalarabic'] = 0xFED2;
Kode lerroa:  t['fehinitialarabic'] = 0xFED3;
Kode lerroa:  t['fehmedialarabic'] = 0xFED4;
Kode lerroa:  t['feicoptic'] = 0x03E5;
Kode lerroa:  t['female'] = 0x2640;
Kode lerroa:  t['ff'] = 0xFB00;
Kode lerroa:  t['ffi'] = 0xFB03;
Kode lerroa:  t['ffl'] = 0xFB04;
Kode lerroa:  t['fi'] = 0xFB01;
Kode lerroa:  t['fifteencircle'] = 0x246E;
Kode lerroa:  t['fifteenparen'] = 0x2482;
Kode lerroa:  t['fifteenperiod'] = 0x2496;
Kode lerroa:  t['figuredash'] = 0x2012;
Kode lerroa:  t['filledbox'] = 0x25A0;
Kode lerroa:  t['filledrect'] = 0x25AC;
Kode lerroa:  t['finalkaf'] = 0x05DA;
Kode lerroa:  t['finalkafdagesh'] = 0xFB3A;
Kode lerroa:  t['finalkafdageshhebrew'] = 0xFB3A;
Kode lerroa:  t['finalkafhebrew'] = 0x05DA;
Kode lerroa:  t['finalmem'] = 0x05DD;
Kode lerroa:  t['finalmemhebrew'] = 0x05DD;
Kode lerroa:  t['finalnun'] = 0x05DF;
Kode lerroa:  t['finalnunhebrew'] = 0x05DF;
Kode lerroa:  t['finalpe'] = 0x05E3;
Kode lerroa:  t['finalpehebrew'] = 0x05E3;
Kode lerroa:  t['finaltsadi'] = 0x05E5;
Kode lerroa:  t['finaltsadihebrew'] = 0x05E5;
Kode lerroa:  t['firsttonechinese'] = 0x02C9;
Kode lerroa:  t['fisheye'] = 0x25C9;
Kode lerroa:  t['fitacyrillic'] = 0x0473;
Kode lerroa:  t['five'] = 0x0035;
Kode lerroa:  t['fivearabic'] = 0x0665;
Kode lerroa:  t['fivebengali'] = 0x09EB;
Kode lerroa:  t['fivecircle'] = 0x2464;
Kode lerroa:  t['fivecircleinversesansserif'] = 0x278E;
Kode lerroa:  t['fivedeva'] = 0x096B;
Kode lerroa:  t['fiveeighths'] = 0x215D;
Kode lerroa:  t['fivegujarati'] = 0x0AEB;
Kode lerroa:  t['fivegurmukhi'] = 0x0A6B;
Kode lerroa:  t['fivehackarabic'] = 0x0665;
Kode lerroa:  t['fivehangzhou'] = 0x3025;
Kode lerroa:  t['fiveideographicparen'] = 0x3224;
Kode lerroa:  t['fiveinferior'] = 0x2085;
Kode lerroa:  t['fivemonospace'] = 0xFF15;
Kode lerroa:  t['fiveoldstyle'] = 0xF735;
Kode lerroa:  t['fiveparen'] = 0x2478;
Kode lerroa:  t['fiveperiod'] = 0x248C;
Kode lerroa:  t['fivepersian'] = 0x06F5;
Kode lerroa:  t['fiveroman'] = 0x2174;
Kode lerroa:  t['fivesuperior'] = 0x2075;
Kode lerroa:  t['fivethai'] = 0x0E55;
Kode lerroa:  t['fl'] = 0xFB02;
Kode lerroa:  t['florin'] = 0x0192;
Kode lerroa:  t['fmonospace'] = 0xFF46;
Kode lerroa:  t['fmsquare'] = 0x3399;
Kode lerroa:  t['fofanthai'] = 0x0E1F;
Kode lerroa:  t['fofathai'] = 0x0E1D;
Kode lerroa:  t['fongmanthai'] = 0x0E4F;
Kode lerroa:  t['forall'] = 0x2200;
Kode lerroa:  t['four'] = 0x0034;
Kode lerroa:  t['fourarabic'] = 0x0664;
Kode lerroa:  t['fourbengali'] = 0x09EA;
Kode lerroa:  t['fourcircle'] = 0x2463;
Kode lerroa:  t['fourcircleinversesansserif'] = 0x278D;
Kode lerroa:  t['fourdeva'] = 0x096A;
Kode lerroa:  t['fourgujarati'] = 0x0AEA;
Kode lerroa:  t['fourgurmukhi'] = 0x0A6A;
Kode lerroa:  t['fourhackarabic'] = 0x0664;
Kode lerroa:  t['fourhangzhou'] = 0x3024;
Kode lerroa:  t['fourideographicparen'] = 0x3223;
Kode lerroa:  t['fourinferior'] = 0x2084;
Kode lerroa:  t['fourmonospace'] = 0xFF14;
Kode lerroa:  t['fournumeratorbengali'] = 0x09F7;
Kode lerroa:  t['fouroldstyle'] = 0xF734;
Kode lerroa:  t['fourparen'] = 0x2477;
Kode lerroa:  t['fourperiod'] = 0x248B;
Kode lerroa:  t['fourpersian'] = 0x06F4;
Kode lerroa:  t['fourroman'] = 0x2173;
Kode lerroa:  t['foursuperior'] = 0x2074;
Kode lerroa:  t['fourteencircle'] = 0x246D;
Kode lerroa:  t['fourteenparen'] = 0x2481;
Kode lerroa:  t['fourteenperiod'] = 0x2495;
Kode lerroa:  t['fourthai'] = 0x0E54;
Kode lerroa:  t['fourthtonechinese'] = 0x02CB;
Kode lerroa:  t['fparen'] = 0x24A1;
Kode lerroa:  t['fraction'] = 0x2044;
Kode lerroa:  t['franc'] = 0x20A3;
Kode lerroa:  t['g'] = 0x0067;
Kode lerroa:  t['gabengali'] = 0x0997;
Kode lerroa:  t['gacute'] = 0x01F5;
Kode lerroa:  t['gadeva'] = 0x0917;
Kode lerroa:  t['gafarabic'] = 0x06AF;
Kode lerroa:  t['gaffinalarabic'] = 0xFB93;
Kode lerroa:  t['gafinitialarabic'] = 0xFB94;
Kode lerroa:  t['gafmedialarabic'] = 0xFB95;
Kode lerroa:  t['gagujarati'] = 0x0A97;
Kode lerroa:  t['gagurmukhi'] = 0x0A17;
Kode lerroa:  t['gahiragana'] = 0x304C;
Kode lerroa:  t['gakatakana'] = 0x30AC;
Kode lerroa:  t['gamma'] = 0x03B3;
Kode lerroa:  t['gammalatinsmall'] = 0x0263;
Kode lerroa:  t['gammasuperior'] = 0x02E0;
Kode lerroa:  t['gangiacoptic'] = 0x03EB;
Kode lerroa:  t['gbopomofo'] = 0x310D;
Kode lerroa:  t['gbreve'] = 0x011F;
Kode lerroa:  t['gcaron'] = 0x01E7;
Kode lerroa:  t['gcedilla'] = 0x0123;
Kode lerroa:  t['gcircle'] = 0x24D6;
Kode lerroa:  t['gcircumflex'] = 0x011D;
Kode lerroa:  t['gcommaaccent'] = 0x0123;
Kode lerroa:  t['gdot'] = 0x0121;
Kode lerroa:  t['gdotaccent'] = 0x0121;
Kode lerroa:  t['gecyrillic'] = 0x0433;
Kode lerroa:  t['gehiragana'] = 0x3052;
Kode lerroa:  t['gekatakana'] = 0x30B2;
Kode lerroa:  t['geometricallyequal'] = 0x2251;
Kode lerroa:  t['gereshaccenthebrew'] = 0x059C;
Kode lerroa:  t['gereshhebrew'] = 0x05F3;
Kode lerroa:  t['gereshmuqdamhebrew'] = 0x059D;
Kode lerroa:  t['germandbls'] = 0x00DF;
Kode lerroa:  t['gershayimaccenthebrew'] = 0x059E;
Kode lerroa:  t['gershayimhebrew'] = 0x05F4;
Kode lerroa:  t['getamark'] = 0x3013;
Kode lerroa:  t['ghabengali'] = 0x0998;
Kode lerroa:  t['ghadarmenian'] = 0x0572;
Kode lerroa:  t['ghadeva'] = 0x0918;
Kode lerroa:  t['ghagujarati'] = 0x0A98;
Kode lerroa:  t['ghagurmukhi'] = 0x0A18;
Kode lerroa:  t['ghainarabic'] = 0x063A;
Kode lerroa:  t['ghainfinalarabic'] = 0xFECE;
Kode lerroa:  t['ghaininitialarabic'] = 0xFECF;
Kode lerroa:  t['ghainmedialarabic'] = 0xFED0;
Kode lerroa:  t['ghemiddlehookcyrillic'] = 0x0495;
Kode lerroa:  t['ghestrokecyrillic'] = 0x0493;
Kode lerroa:  t['gheupturncyrillic'] = 0x0491;
Kode lerroa:  t['ghhadeva'] = 0x095A;
Kode lerroa:  t['ghhagurmukhi'] = 0x0A5A;
Kode lerroa:  t['ghook'] = 0x0260;
Kode lerroa:  t['ghzsquare'] = 0x3393;
Kode lerroa:  t['gihiragana'] = 0x304E;
Kode lerroa:  t['gikatakana'] = 0x30AE;
Kode lerroa:  t['gimarmenian'] = 0x0563;
Kode lerroa:  t['gimel'] = 0x05D2;
Kode lerroa:  t['gimeldagesh'] = 0xFB32;
Kode lerroa:  t['gimeldageshhebrew'] = 0xFB32;
Kode lerroa:  t['gimelhebrew'] = 0x05D2;
Kode lerroa:  t['gjecyrillic'] = 0x0453;
Kode lerroa:  t['glottalinvertedstroke'] = 0x01BE;
Kode lerroa:  t['glottalstop'] = 0x0294;
Kode lerroa:  t['glottalstopinverted'] = 0x0296;
Kode lerroa:  t['glottalstopmod'] = 0x02C0;
Kode lerroa:  t['glottalstopreversed'] = 0x0295;
Kode lerroa:  t['glottalstopreversedmod'] = 0x02C1;
Kode lerroa:  t['glottalstopreversedsuperior'] = 0x02E4;
Kode lerroa:  t['glottalstopstroke'] = 0x02A1;
Kode lerroa:  t['glottalstopstrokereversed'] = 0x02A2;
Kode lerroa:  t['gmacron'] = 0x1E21;
Kode lerroa:  t['gmonospace'] = 0xFF47;
Kode lerroa:  t['gohiragana'] = 0x3054;
Kode lerroa:  t['gokatakana'] = 0x30B4;
Kode lerroa:  t['gparen'] = 0x24A2;
Kode lerroa:  t['gpasquare'] = 0x33AC;
Kode lerroa:  t['gradient'] = 0x2207;
Kode lerroa:  t['grave'] = 0x0060;
Kode lerroa:  t['gravebelowcmb'] = 0x0316;
Kode lerroa:  t['gravecmb'] = 0x0300;
Kode lerroa:  t['gravecomb'] = 0x0300;
Kode lerroa:  t['gravedeva'] = 0x0953;
Kode lerroa:  t['gravelowmod'] = 0x02CE;
Kode lerroa:  t['gravemonospace'] = 0xFF40;
Kode lerroa:  t['gravetonecmb'] = 0x0340;
Kode lerroa:  t['greater'] = 0x003E;
Kode lerroa:  t['greaterequal'] = 0x2265;
Kode lerroa:  t['greaterequalorless'] = 0x22DB;
Kode lerroa:  t['greatermonospace'] = 0xFF1E;
Kode lerroa:  t['greaterorequivalent'] = 0x2273;
Kode lerroa:  t['greaterorless'] = 0x2277;
Kode lerroa:  t['greateroverequal'] = 0x2267;
Kode lerroa:  t['greatersmall'] = 0xFE65;
Kode lerroa:  t['gscript'] = 0x0261;
Kode lerroa:  t['gstroke'] = 0x01E5;
Kode lerroa:  t['guhiragana'] = 0x3050;
Kode lerroa:  t['guillemotleft'] = 0x00AB;
Kode lerroa:  t['guillemotright'] = 0x00BB;
Kode lerroa:  t['guilsinglleft'] = 0x2039;
Kode lerroa:  t['guilsinglright'] = 0x203A;
Kode lerroa:  t['gukatakana'] = 0x30B0;
Kode lerroa:  t['guramusquare'] = 0x3318;
Kode lerroa:  t['gysquare'] = 0x33C9;
Kode lerroa:  t['h'] = 0x0068;
Kode lerroa:  t['haabkhasiancyrillic'] = 0x04A9;
Kode lerroa:  t['haaltonearabic'] = 0x06C1;
Kode lerroa:  t['habengali'] = 0x09B9;
Kode lerroa:  t['hadescendercyrillic'] = 0x04B3;
Kode lerroa:  t['hadeva'] = 0x0939;
Kode lerroa:  t['hagujarati'] = 0x0AB9;
Kode lerroa:  t['hagurmukhi'] = 0x0A39;
Kode lerroa:  t['haharabic'] = 0x062D;
Kode lerroa:  t['hahfinalarabic'] = 0xFEA2;
Kode lerroa:  t['hahinitialarabic'] = 0xFEA3;
Kode lerroa:  t['hahiragana'] = 0x306F;
Kode lerroa:  t['hahmedialarabic'] = 0xFEA4;
Kode lerroa:  t['haitusquare'] = 0x332A;
Kode lerroa:  t['hakatakana'] = 0x30CF;
Kode lerroa:  t['hakatakanahalfwidth'] = 0xFF8A;
Kode lerroa:  t['halantgurmukhi'] = 0x0A4D;
Kode lerroa:  t['hamzaarabic'] = 0x0621;
Kode lerroa:  t['hamzalowarabic'] = 0x0621;
Kode lerroa:  t['hangulfiller'] = 0x3164;
Kode lerroa:  t['hardsigncyrillic'] = 0x044A;
Kode lerroa:  t['harpoonleftbarbup'] = 0x21BC;
Kode lerroa:  t['harpoonrightbarbup'] = 0x21C0;
Kode lerroa:  t['hasquare'] = 0x33CA;
Kode lerroa:  t['hatafpatah'] = 0x05B2;
Kode lerroa:  t['hatafpatah16'] = 0x05B2;
Kode lerroa:  t['hatafpatah23'] = 0x05B2;
Kode lerroa:  t['hatafpatah2f'] = 0x05B2;
Kode lerroa:  t['hatafpatahhebrew'] = 0x05B2;
Kode lerroa:  t['hatafpatahnarrowhebrew'] = 0x05B2;
Kode lerroa:  t['hatafpatahquarterhebrew'] = 0x05B2;
Kode lerroa:  t['hatafpatahwidehebrew'] = 0x05B2;
Kode lerroa:  t['hatafqamats'] = 0x05B3;
Kode lerroa:  t['hatafqamats1b'] = 0x05B3;
Kode lerroa:  t['hatafqamats28'] = 0x05B3;
Kode lerroa:  t['hatafqamats34'] = 0x05B3;
Kode lerroa:  t['hatafqamatshebrew'] = 0x05B3;
Kode lerroa:  t['hatafqamatsnarrowhebrew'] = 0x05B3;
Kode lerroa:  t['hatafqamatsquarterhebrew'] = 0x05B3;
Kode lerroa:  t['hatafqamatswidehebrew'] = 0x05B3;
Kode lerroa:  t['hatafsegol'] = 0x05B1;
Kode lerroa:  t['hatafsegol17'] = 0x05B1;
Kode lerroa:  t['hatafsegol24'] = 0x05B1;
Kode lerroa:  t['hatafsegol30'] = 0x05B1;
Kode lerroa:  t['hatafsegolhebrew'] = 0x05B1;
Kode lerroa:  t['hatafsegolnarrowhebrew'] = 0x05B1;
Kode lerroa:  t['hatafsegolquarterhebrew'] = 0x05B1;
Kode lerroa:  t['hatafsegolwidehebrew'] = 0x05B1;
Kode lerroa:  t['hbar'] = 0x0127;
Kode lerroa:  t['hbopomofo'] = 0x310F;
Kode lerroa:  t['hbrevebelow'] = 0x1E2B;
Kode lerroa:  t['hcedilla'] = 0x1E29;
Kode lerroa:  t['hcircle'] = 0x24D7;
Kode lerroa:  t['hcircumflex'] = 0x0125;
Kode lerroa:  t['hdieresis'] = 0x1E27;
Kode lerroa:  t['hdotaccent'] = 0x1E23;
Kode lerroa:  t['hdotbelow'] = 0x1E25;
Kode lerroa:  t['he'] = 0x05D4;
Kode lerroa:  t['heart'] = 0x2665;
Kode lerroa:  t['heartsuitblack'] = 0x2665;
Kode lerroa:  t['heartsuitwhite'] = 0x2661;
Kode lerroa:  t['hedagesh'] = 0xFB34;
Kode lerroa:  t['hedageshhebrew'] = 0xFB34;
Kode lerroa:  t['hehaltonearabic'] = 0x06C1;
Kode lerroa:  t['heharabic'] = 0x0647;
Kode lerroa:  t['hehebrew'] = 0x05D4;
Kode lerroa:  t['hehfinalaltonearabic'] = 0xFBA7;
Kode lerroa:  t['hehfinalalttwoarabic'] = 0xFEEA;
Kode lerroa:  t['hehfinalarabic'] = 0xFEEA;
Kode lerroa:  t['hehhamzaabovefinalarabic'] = 0xFBA5;
Kode lerroa:  t['hehhamzaaboveisolatedarabic'] = 0xFBA4;
Kode lerroa:  t['hehinitialaltonearabic'] = 0xFBA8;
Kode lerroa:  t['hehinitialarabic'] = 0xFEEB;
Kode lerroa:  t['hehiragana'] = 0x3078;
Kode lerroa:  t['hehmedialaltonearabic'] = 0xFBA9;
Kode lerroa:  t['hehmedialarabic'] = 0xFEEC;
Kode lerroa:  t['heiseierasquare'] = 0x337B;
Kode lerroa:  t['hekatakana'] = 0x30D8;
Kode lerroa:  t['hekatakanahalfwidth'] = 0xFF8D;
Kode lerroa:  t['hekutaarusquare'] = 0x3336;
Kode lerroa:  t['henghook'] = 0x0267;
Kode lerroa:  t['herutusquare'] = 0x3339;
Kode lerroa:  t['het'] = 0x05D7;
Kode lerroa:  t['hethebrew'] = 0x05D7;
Kode lerroa:  t['hhook'] = 0x0266;
Kode lerroa:  t['hhooksuperior'] = 0x02B1;
Kode lerroa:  t['hieuhacirclekorean'] = 0x327B;
Kode lerroa:  t['hieuhaparenkorean'] = 0x321B;
Kode lerroa:  t['hieuhcirclekorean'] = 0x326D;
Kode lerroa:  t['hieuhkorean'] = 0x314E;
Kode lerroa:  t['hieuhparenkorean'] = 0x320D;
Kode lerroa:  t['hihiragana'] = 0x3072;
Kode lerroa:  t['hikatakana'] = 0x30D2;
Kode lerroa:  t['hikatakanahalfwidth'] = 0xFF8B;
Kode lerroa:  t['hiriq'] = 0x05B4;
Kode lerroa:  t['hiriq14'] = 0x05B4;
Kode lerroa:  t['hiriq21'] = 0x05B4;
Kode lerroa:  t['hiriq2d'] = 0x05B4;
Kode lerroa:  t['hiriqhebrew'] = 0x05B4;
Kode lerroa:  t['hiriqnarrowhebrew'] = 0x05B4;
Kode lerroa:  t['hiriqquarterhebrew'] = 0x05B4;
Kode lerroa:  t['hiriqwidehebrew'] = 0x05B4;
Kode lerroa:  t['hlinebelow'] = 0x1E96;
Kode lerroa:  t['hmonospace'] = 0xFF48;
Kode lerroa:  t['hoarmenian'] = 0x0570;
Kode lerroa:  t['hohipthai'] = 0x0E2B;
Kode lerroa:  t['hohiragana'] = 0x307B;
Kode lerroa:  t['hokatakana'] = 0x30DB;
Kode lerroa:  t['hokatakanahalfwidth'] = 0xFF8E;
Kode lerroa:  t['holam'] = 0x05B9;
Kode lerroa:  t['holam19'] = 0x05B9;
Kode lerroa:  t['holam26'] = 0x05B9;
Kode lerroa:  t['holam32'] = 0x05B9;
Kode lerroa:  t['holamhebrew'] = 0x05B9;
Kode lerroa:  t['holamnarrowhebrew'] = 0x05B9;
Kode lerroa:  t['holamquarterhebrew'] = 0x05B9;
Kode lerroa:  t['holamwidehebrew'] = 0x05B9;
Kode lerroa:  t['honokhukthai'] = 0x0E2E;
Kode lerroa:  t['hookabovecomb'] = 0x0309;
Kode lerroa:  t['hookcmb'] = 0x0309;
Kode lerroa:  t['hookpalatalizedbelowcmb'] = 0x0321;
Kode lerroa:  t['hookretroflexbelowcmb'] = 0x0322;
Kode lerroa:  t['hoonsquare'] = 0x3342;
Kode lerroa:  t['horicoptic'] = 0x03E9;
Kode lerroa:  t['horizontalbar'] = 0x2015;
Kode lerroa:  t['horncmb'] = 0x031B;
Kode lerroa:  t['hotsprings'] = 0x2668;
Kode lerroa:  t['house'] = 0x2302;
Kode lerroa:  t['hparen'] = 0x24A3;
Kode lerroa:  t['hsuperior'] = 0x02B0;
Kode lerroa:  t['hturned'] = 0x0265;
Kode lerroa:  t['huhiragana'] = 0x3075;
Kode lerroa:  t['huiitosquare'] = 0x3333;
Kode lerroa:  t['hukatakana'] = 0x30D5;
Kode lerroa:  t['hukatakanahalfwidth'] = 0xFF8C;
Kode lerroa:  t['hungarumlaut'] = 0x02DD;
Kode lerroa:  t['hungarumlautcmb'] = 0x030B;
Kode lerroa:  t['hv'] = 0x0195;
Kode lerroa:  t['hyphen'] = 0x002D;
Kode lerroa:  t['hypheninferior'] = 0xF6E5;
Kode lerroa:  t['hyphenmonospace'] = 0xFF0D;
Kode lerroa:  t['hyphensmall'] = 0xFE63;
Kode lerroa:  t['hyphensuperior'] = 0xF6E6;
Kode lerroa:  t['hyphentwo'] = 0x2010;
Kode lerroa:  t['i'] = 0x0069;
Kode lerroa:  t['iacute'] = 0x00ED;
Kode lerroa:  t['iacyrillic'] = 0x044F;
Kode lerroa:  t['ibengali'] = 0x0987;
Kode lerroa:  t['ibopomofo'] = 0x3127;
Kode lerroa:  t['ibreve'] = 0x012D;
Kode lerroa:  t['icaron'] = 0x01D0;
Kode lerroa:  t['icircle'] = 0x24D8;
Kode lerroa:  t['icircumflex'] = 0x00EE;
Kode lerroa:  t['icyrillic'] = 0x0456;
Kode lerroa:  t['idblgrave'] = 0x0209;
Kode lerroa:  t['ideographearthcircle'] = 0x328F;
Kode lerroa:  t['ideographfirecircle'] = 0x328B;
Kode lerroa:  t['ideographicallianceparen'] = 0x323F;
Kode lerroa:  t['ideographiccallparen'] = 0x323A;
Kode lerroa:  t['ideographiccentrecircle'] = 0x32A5;
Kode lerroa:  t['ideographicclose'] = 0x3006;
Kode lerroa:  t['ideographiccomma'] = 0x3001;
Kode lerroa:  t['ideographiccommaleft'] = 0xFF64;
Kode lerroa:  t['ideographiccongratulationparen'] = 0x3237;
Kode lerroa:  t['ideographiccorrectcircle'] = 0x32A3;
Kode lerroa:  t['ideographicearthparen'] = 0x322F;
Kode lerroa:  t['ideographicenterpriseparen'] = 0x323D;
Kode lerroa:  t['ideographicexcellentcircle'] = 0x329D;
Kode lerroa:  t['ideographicfestivalparen'] = 0x3240;
Kode lerroa:  t['ideographicfinancialcircle'] = 0x3296;
Kode lerroa:  t['ideographicfinancialparen'] = 0x3236;
Kode lerroa:  t['ideographicfireparen'] = 0x322B;
Kode lerroa:  t['ideographichaveparen'] = 0x3232;
Kode lerroa:  t['ideographichighcircle'] = 0x32A4;
Kode lerroa:  t['ideographiciterationmark'] = 0x3005;
Kode lerroa:  t['ideographiclaborcircle'] = 0x3298;
Kode lerroa:  t['ideographiclaborparen'] = 0x3238;
Kode lerroa:  t['ideographicleftcircle'] = 0x32A7;
Kode lerroa:  t['ideographiclowcircle'] = 0x32A6;
Kode lerroa:  t['ideographicmedicinecircle'] = 0x32A9;
Kode lerroa:  t['ideographicmetalparen'] = 0x322E;
Kode lerroa:  t['ideographicmoonparen'] = 0x322A;
Kode lerroa:  t['ideographicnameparen'] = 0x3234;
Kode lerroa:  t['ideographicperiod'] = 0x3002;
Kode lerroa:  t['ideographicprintcircle'] = 0x329E;
Kode lerroa:  t['ideographicreachparen'] = 0x3243;
Kode lerroa:  t['ideographicrepresentparen'] = 0x3239;
Kode lerroa:  t['ideographicresourceparen'] = 0x323E;
Kode lerroa:  t['ideographicrightcircle'] = 0x32A8;
Kode lerroa:  t['ideographicsecretcircle'] = 0x3299;
Kode lerroa:  t['ideographicselfparen'] = 0x3242;
Kode lerroa:  t['ideographicsocietyparen'] = 0x3233;
Kode lerroa:  t['ideographicspace'] = 0x3000;
Kode lerroa:  t['ideographicspecialparen'] = 0x3235;
Kode lerroa:  t['ideographicstockparen'] = 0x3231;
Kode lerroa:  t['ideographicstudyparen'] = 0x323B;
Kode lerroa:  t['ideographicsunparen'] = 0x3230;
Kode lerroa:  t['ideographicsuperviseparen'] = 0x323C;
Kode lerroa:  t['ideographicwaterparen'] = 0x322C;
Kode lerroa:  t['ideographicwoodparen'] = 0x322D;
Kode lerroa:  t['ideographiczero'] = 0x3007;
Kode lerroa:  t['ideographmetalcircle'] = 0x328E;
Kode lerroa:  t['ideographmooncircle'] = 0x328A;
Kode lerroa:  t['ideographnamecircle'] = 0x3294;
Kode lerroa:  t['ideographsuncircle'] = 0x3290;
Kode lerroa:  t['ideographwatercircle'] = 0x328C;
Kode lerroa:  t['ideographwoodcircle'] = 0x328D;
Kode lerroa:  t['ideva'] = 0x0907;
Kode lerroa:  t['idieresis'] = 0x00EF;
Kode lerroa:  t['idieresisacute'] = 0x1E2F;
Kode lerroa:  t['idieresiscyrillic'] = 0x04E5;
Kode lerroa:  t['idotbelow'] = 0x1ECB;
Kode lerroa:  t['iebrevecyrillic'] = 0x04D7;
Kode lerroa:  t['iecyrillic'] = 0x0435;
Kode lerroa:  t['ieungacirclekorean'] = 0x3275;
Kode lerroa:  t['ieungaparenkorean'] = 0x3215;
Kode lerroa:  t['ieungcirclekorean'] = 0x3267;
Kode lerroa:  t['ieungkorean'] = 0x3147;
Kode lerroa:  t['ieungparenkorean'] = 0x3207;
Kode lerroa:  t['igrave'] = 0x00EC;
Kode lerroa:  t['igujarati'] = 0x0A87;
Kode lerroa:  t['igurmukhi'] = 0x0A07;
Kode lerroa:  t['ihiragana'] = 0x3044;
Kode lerroa:  t['ihookabove'] = 0x1EC9;
Kode lerroa:  t['iibengali'] = 0x0988;
Kode lerroa:  t['iicyrillic'] = 0x0438;
Kode lerroa:  t['iideva'] = 0x0908;
Kode lerroa:  t['iigujarati'] = 0x0A88;
Kode lerroa:  t['iigurmukhi'] = 0x0A08;
Kode lerroa:  t['iimatragurmukhi'] = 0x0A40;
Kode lerroa:  t['iinvertedbreve'] = 0x020B;
Kode lerroa:  t['iishortcyrillic'] = 0x0439;
Kode lerroa:  t['iivowelsignbengali'] = 0x09C0;
Kode lerroa:  t['iivowelsigndeva'] = 0x0940;
Kode lerroa:  t['iivowelsigngujarati'] = 0x0AC0;
Kode lerroa:  t['ij'] = 0x0133;
Kode lerroa:  t['ikatakana'] = 0x30A4;
Kode lerroa:  t['ikatakanahalfwidth'] = 0xFF72;
Kode lerroa:  t['ikorean'] = 0x3163;
Kode lerroa:  t['ilde'] = 0x02DC;
Kode lerroa:  t['iluyhebrew'] = 0x05AC;
Kode lerroa:  t['imacron'] = 0x012B;
Kode lerroa:  t['imacroncyrillic'] = 0x04E3;
Kode lerroa:  t['imageorapproximatelyequal'] = 0x2253;
Kode lerroa:  t['imatragurmukhi'] = 0x0A3F;
Kode lerroa:  t['imonospace'] = 0xFF49;
Kode lerroa:  t['increment'] = 0x2206;
Kode lerroa:  t['infinity'] = 0x221E;
Kode lerroa:  t['iniarmenian'] = 0x056B;
Kode lerroa:  t['integral'] = 0x222B;
Kode lerroa:  t['integralbottom'] = 0x2321;
Kode lerroa:  t['integralbt'] = 0x2321;
Kode lerroa:  t['integralex'] = 0xF8F5;
Kode lerroa:  t['integraltop'] = 0x2320;
Kode lerroa:  t['integraltp'] = 0x2320;
Kode lerroa:  t['intersection'] = 0x2229;
Kode lerroa:  t['intisquare'] = 0x3305;
Kode lerroa:  t['invbullet'] = 0x25D8;
Kode lerroa:  t['invcircle'] = 0x25D9;
Kode lerroa:  t['invsmileface'] = 0x263B;
Kode lerroa:  t['iocyrillic'] = 0x0451;
Kode lerroa:  t['iogonek'] = 0x012F;
Kode lerroa:  t['iota'] = 0x03B9;
Kode lerroa:  t['iotadieresis'] = 0x03CA;
Kode lerroa:  t['iotadieresistonos'] = 0x0390;
Kode lerroa:  t['iotalatin'] = 0x0269;
Kode lerroa:  t['iotatonos'] = 0x03AF;
Kode lerroa:  t['iparen'] = 0x24A4;
Kode lerroa:  t['irigurmukhi'] = 0x0A72;
Kode lerroa:  t['ismallhiragana'] = 0x3043;
Kode lerroa:  t['ismallkatakana'] = 0x30A3;
Kode lerroa:  t['ismallkatakanahalfwidth'] = 0xFF68;
Kode lerroa:  t['issharbengali'] = 0x09FA;
Kode lerroa:  t['istroke'] = 0x0268;
Kode lerroa:  t['isuperior'] = 0xF6ED;
Kode lerroa:  t['iterationhiragana'] = 0x309D;
Kode lerroa:  t['iterationkatakana'] = 0x30FD;
Kode lerroa:  t['itilde'] = 0x0129;
Kode lerroa:  t['itildebelow'] = 0x1E2D;
Kode lerroa:  t['iubopomofo'] = 0x3129;
Kode lerroa:  t['iucyrillic'] = 0x044E;
Kode lerroa:  t['ivowelsignbengali'] = 0x09BF;
Kode lerroa:  t['ivowelsigndeva'] = 0x093F;
Kode lerroa:  t['ivowelsigngujarati'] = 0x0ABF;
Kode lerroa:  t['izhitsacyrillic'] = 0x0475;
Kode lerroa:  t['izhitsadblgravecyrillic'] = 0x0477;
Kode lerroa:  t['j'] = 0x006A;
Kode lerroa:  t['jaarmenian'] = 0x0571;
Kode lerroa:  t['jabengali'] = 0x099C;
Kode lerroa:  t['jadeva'] = 0x091C;
Kode lerroa:  t['jagujarati'] = 0x0A9C;
Kode lerroa:  t['jagurmukhi'] = 0x0A1C;
Kode lerroa:  t['jbopomofo'] = 0x3110;
Kode lerroa:  t['jcaron'] = 0x01F0;
Kode lerroa:  t['jcircle'] = 0x24D9;
Kode lerroa:  t['jcircumflex'] = 0x0135;
Kode lerroa:  t['jcrossedtail'] = 0x029D;
Kode lerroa:  t['jdotlessstroke'] = 0x025F;
Kode lerroa:  t['jecyrillic'] = 0x0458;
Kode lerroa:  t['jeemarabic'] = 0x062C;
Kode lerroa:  t['jeemfinalarabic'] = 0xFE9E;
Kode lerroa:  t['jeeminitialarabic'] = 0xFE9F;
Kode lerroa:  t['jeemmedialarabic'] = 0xFEA0;
Kode lerroa:  t['jeharabic'] = 0x0698;
Kode lerroa:  t['jehfinalarabic'] = 0xFB8B;
Kode lerroa:  t['jhabengali'] = 0x099D;
Kode lerroa:  t['jhadeva'] = 0x091D;
Kode lerroa:  t['jhagujarati'] = 0x0A9D;
Kode lerroa:  t['jhagurmukhi'] = 0x0A1D;
Kode lerroa:  t['jheharmenian'] = 0x057B;
Kode lerroa:  t['jis'] = 0x3004;
Kode lerroa:  t['jmonospace'] = 0xFF4A;
Kode lerroa:  t['jparen'] = 0x24A5;
Kode lerroa:  t['jsuperior'] = 0x02B2;
Kode lerroa:  t['k'] = 0x006B;
Kode lerroa:  t['kabashkircyrillic'] = 0x04A1;
Kode lerroa:  t['kabengali'] = 0x0995;
Kode lerroa:  t['kacute'] = 0x1E31;
Kode lerroa:  t['kacyrillic'] = 0x043A;
Kode lerroa:  t['kadescendercyrillic'] = 0x049B;
Kode lerroa:  t['kadeva'] = 0x0915;
Kode lerroa:  t['kaf'] = 0x05DB;
Kode lerroa:  t['kafarabic'] = 0x0643;
Kode lerroa:  t['kafdagesh'] = 0xFB3B;
Kode lerroa:  t['kafdageshhebrew'] = 0xFB3B;
Kode lerroa:  t['kaffinalarabic'] = 0xFEDA;
Kode lerroa:  t['kafhebrew'] = 0x05DB;
Kode lerroa:  t['kafinitialarabic'] = 0xFEDB;
Kode lerroa:  t['kafmedialarabic'] = 0xFEDC;
Kode lerroa:  t['kafrafehebrew'] = 0xFB4D;
Kode lerroa:  t['kagujarati'] = 0x0A95;
Kode lerroa:  t['kagurmukhi'] = 0x0A15;
Kode lerroa:  t['kahiragana'] = 0x304B;
Kode lerroa:  t['kahookcyrillic'] = 0x04C4;
Kode lerroa:  t['kakatakana'] = 0x30AB;
Kode lerroa:  t['kakatakanahalfwidth'] = 0xFF76;
Kode lerroa:  t['kappa'] = 0x03BA;
Kode lerroa:  t['kappasymbolgreek'] = 0x03F0;
Kode lerroa:  t['kapyeounmieumkorean'] = 0x3171;
Kode lerroa:  t['kapyeounphieuphkorean'] = 0x3184;
Kode lerroa:  t['kapyeounpieupkorean'] = 0x3178;
Kode lerroa:  t['kapyeounssangpieupkorean'] = 0x3179;
Kode lerroa:  t['karoriisquare'] = 0x330D;
Kode lerroa:  t['kashidaautoarabic'] = 0x0640;
Kode lerroa:  t['kashidaautonosidebearingarabic'] = 0x0640;
Kode lerroa:  t['kasmallkatakana'] = 0x30F5;
Kode lerroa:  t['kasquare'] = 0x3384;
Kode lerroa:  t['kasraarabic'] = 0x0650;
Kode lerroa:  t['kasratanarabic'] = 0x064D;
Kode lerroa:  t['kastrokecyrillic'] = 0x049F;
Kode lerroa:  t['katahiraprolongmarkhalfwidth'] = 0xFF70;
Kode lerroa:  t['kaverticalstrokecyrillic'] = 0x049D;
Kode lerroa:  t['kbopomofo'] = 0x310E;
Kode lerroa:  t['kcalsquare'] = 0x3389;
Kode lerroa:  t['kcaron'] = 0x01E9;
Kode lerroa:  t['kcedilla'] = 0x0137;
Kode lerroa:  t['kcircle'] = 0x24DA;
Kode lerroa:  t['kcommaaccent'] = 0x0137;
Kode lerroa:  t['kdotbelow'] = 0x1E33;
Kode lerroa:  t['keharmenian'] = 0x0584;
Kode lerroa:  t['kehiragana'] = 0x3051;
Kode lerroa:  t['kekatakana'] = 0x30B1;
Kode lerroa:  t['kekatakanahalfwidth'] = 0xFF79;
Kode lerroa:  t['kenarmenian'] = 0x056F;
Kode lerroa:  t['kesmallkatakana'] = 0x30F6;
Kode lerroa:  t['kgreenlandic'] = 0x0138;
Kode lerroa:  t['khabengali'] = 0x0996;
Kode lerroa:  t['khacyrillic'] = 0x0445;
Kode lerroa:  t['khadeva'] = 0x0916;
Kode lerroa:  t['khagujarati'] = 0x0A96;
Kode lerroa:  t['khagurmukhi'] = 0x0A16;
Kode lerroa:  t['khaharabic'] = 0x062E;
Kode lerroa:  t['khahfinalarabic'] = 0xFEA6;
Kode lerroa:  t['khahinitialarabic'] = 0xFEA7;
Kode lerroa:  t['khahmedialarabic'] = 0xFEA8;
Kode lerroa:  t['kheicoptic'] = 0x03E7;
Kode lerroa:  t['khhadeva'] = 0x0959;
Kode lerroa:  t['khhagurmukhi'] = 0x0A59;
Kode lerroa:  t['khieukhacirclekorean'] = 0x3278;
Kode lerroa:  t['khieukhaparenkorean'] = 0x3218;
Kode lerroa:  t['khieukhcirclekorean'] = 0x326A;
Kode lerroa:  t['khieukhkorean'] = 0x314B;
Kode lerroa:  t['khieukhparenkorean'] = 0x320A;
Kode lerroa:  t['khokhaithai'] = 0x0E02;
Kode lerroa:  t['khokhonthai'] = 0x0E05;
Kode lerroa:  t['khokhuatthai'] = 0x0E03;
Kode lerroa:  t['khokhwaithai'] = 0x0E04;
Kode lerroa:  t['khomutthai'] = 0x0E5B;
Kode lerroa:  t['khook'] = 0x0199;
Kode lerroa:  t['khorakhangthai'] = 0x0E06;
Kode lerroa:  t['khzsquare'] = 0x3391;
Kode lerroa:  t['kihiragana'] = 0x304D;
Kode lerroa:  t['kikatakana'] = 0x30AD;
Kode lerroa:  t['kikatakanahalfwidth'] = 0xFF77;
Kode lerroa:  t['kiroguramusquare'] = 0x3315;
Kode lerroa:  t['kiromeetorusquare'] = 0x3316;
Kode lerroa:  t['kirosquare'] = 0x3314;
Kode lerroa:  t['kiyeokacirclekorean'] = 0x326E;
Kode lerroa:  t['kiyeokaparenkorean'] = 0x320E;
Kode lerroa:  t['kiyeokcirclekorean'] = 0x3260;
Kode lerroa:  t['kiyeokkorean'] = 0x3131;
Kode lerroa:  t['kiyeokparenkorean'] = 0x3200;
Kode lerroa:  t['kiyeoksioskorean'] = 0x3133;
Kode lerroa:  t['kjecyrillic'] = 0x045C;
Kode lerroa:  t['klinebelow'] = 0x1E35;
Kode lerroa:  t['klsquare'] = 0x3398;
Kode lerroa:  t['kmcubedsquare'] = 0x33A6;
Kode lerroa:  t['kmonospace'] = 0xFF4B;
Kode lerroa:  t['kmsquaredsquare'] = 0x33A2;
Kode lerroa:  t['kohiragana'] = 0x3053;
Kode lerroa:  t['kohmsquare'] = 0x33C0;
Kode lerroa:  t['kokaithai'] = 0x0E01;
Kode lerroa:  t['kokatakana'] = 0x30B3;
Kode lerroa:  t['kokatakanahalfwidth'] = 0xFF7A;
Kode lerroa:  t['kooposquare'] = 0x331E;
Kode lerroa:  t['koppacyrillic'] = 0x0481;
Kode lerroa:  t['koreanstandardsymbol'] = 0x327F;
Kode lerroa:  t['koroniscmb'] = 0x0343;
Kode lerroa:  t['kparen'] = 0x24A6;
Kode lerroa:  t['kpasquare'] = 0x33AA;
Kode lerroa:  t['ksicyrillic'] = 0x046F;
Kode lerroa:  t['ktsquare'] = 0x33CF;
Kode lerroa:  t['kturned'] = 0x029E;
Kode lerroa:  t['kuhiragana'] = 0x304F;
Kode lerroa:  t['kukatakana'] = 0x30AF;
Kode lerroa:  t['kukatakanahalfwidth'] = 0xFF78;
Kode lerroa:  t['kvsquare'] = 0x33B8;
Kode lerroa:  t['kwsquare'] = 0x33BE;
Kode lerroa:  t['l'] = 0x006C;
Kode lerroa:  t['labengali'] = 0x09B2;
Kode lerroa:  t['lacute'] = 0x013A;
Kode lerroa:  t['ladeva'] = 0x0932;
Kode lerroa:  t['lagujarati'] = 0x0AB2;
Kode lerroa:  t['lagurmukhi'] = 0x0A32;
Kode lerroa:  t['lakkhangyaothai'] = 0x0E45;
Kode lerroa:  t['lamaleffinalarabic'] = 0xFEFC;
Kode lerroa:  t['lamalefhamzaabovefinalarabic'] = 0xFEF8;
Kode lerroa:  t['lamalefhamzaaboveisolatedarabic'] = 0xFEF7;
Kode lerroa:  t['lamalefhamzabelowfinalarabic'] = 0xFEFA;
Kode lerroa:  t['lamalefhamzabelowisolatedarabic'] = 0xFEF9;
Kode lerroa:  t['lamalefisolatedarabic'] = 0xFEFB;
Kode lerroa:  t['lamalefmaddaabovefinalarabic'] = 0xFEF6;
Kode lerroa:  t['lamalefmaddaaboveisolatedarabic'] = 0xFEF5;
Kode lerroa:  t['lamarabic'] = 0x0644;
Kode lerroa:  t['lambda'] = 0x03BB;
Kode lerroa:  t['lambdastroke'] = 0x019B;
Kode lerroa:  t['lamed'] = 0x05DC;
Kode lerroa:  t['lameddagesh'] = 0xFB3C;
Kode lerroa:  t['lameddageshhebrew'] = 0xFB3C;
Kode lerroa:  t['lamedhebrew'] = 0x05DC;
Kode lerroa:  t['lamfinalarabic'] = 0xFEDE;
Kode lerroa:  t['lamhahinitialarabic'] = 0xFCCA;
Kode lerroa:  t['laminitialarabic'] = 0xFEDF;
Kode lerroa:  t['lamjeeminitialarabic'] = 0xFCC9;
Kode lerroa:  t['lamkhahinitialarabic'] = 0xFCCB;
Kode lerroa:  t['lamlamhehisolatedarabic'] = 0xFDF2;
Kode lerroa:  t['lammedialarabic'] = 0xFEE0;
Kode lerroa:  t['lammeemhahinitialarabic'] = 0xFD88;
Kode lerroa:  t['lammeeminitialarabic'] = 0xFCCC;
Kode lerroa:  t['largecircle'] = 0x25EF;
Kode lerroa:  t['lbar'] = 0x019A;
Kode lerroa:  t['lbelt'] = 0x026C;
Kode lerroa:  t['lbopomofo'] = 0x310C;
Kode lerroa:  t['lcaron'] = 0x013E;
Kode lerroa:  t['lcedilla'] = 0x013C;
Kode lerroa:  t['lcircle'] = 0x24DB;
Kode lerroa:  t['lcircumflexbelow'] = 0x1E3D;
Kode lerroa:  t['lcommaaccent'] = 0x013C;
Kode lerroa:  t['ldot'] = 0x0140;
Kode lerroa:  t['ldotaccent'] = 0x0140;
Kode lerroa:  t['ldotbelow'] = 0x1E37;
Kode lerroa:  t['ldotbelowmacron'] = 0x1E39;
Kode lerroa:  t['leftangleabovecmb'] = 0x031A;
Kode lerroa:  t['lefttackbelowcmb'] = 0x0318;
Kode lerroa:  t['less'] = 0x003C;
Kode lerroa:  t['lessequal'] = 0x2264;
Kode lerroa:  t['lessequalorgreater'] = 0x22DA;
Kode lerroa:  t['lessmonospace'] = 0xFF1C;
Kode lerroa:  t['lessorequivalent'] = 0x2272;
Kode lerroa:  t['lessorgreater'] = 0x2276;
Kode lerroa:  t['lessoverequal'] = 0x2266;
Kode lerroa:  t['lesssmall'] = 0xFE64;
Kode lerroa:  t['lezh'] = 0x026E;
Kode lerroa:  t['lfblock'] = 0x258C;
Kode lerroa:  t['lhookretroflex'] = 0x026D;
Kode lerroa:  t['lira'] = 0x20A4;
Kode lerroa:  t['liwnarmenian'] = 0x056C;
Kode lerroa:  t['lj'] = 0x01C9;
Kode lerroa:  t['ljecyrillic'] = 0x0459;
Kode lerroa:  t['ll'] = 0xF6C0;
Kode lerroa:  t['lladeva'] = 0x0933;
Kode lerroa:  t['llagujarati'] = 0x0AB3;
Kode lerroa:  t['llinebelow'] = 0x1E3B;
Kode lerroa:  t['llladeva'] = 0x0934;
Kode lerroa:  t['llvocalicbengali'] = 0x09E1;
Kode lerroa:  t['llvocalicdeva'] = 0x0961;
Kode lerroa:  t['llvocalicvowelsignbengali'] = 0x09E3;
Kode lerroa:  t['llvocalicvowelsigndeva'] = 0x0963;
Kode lerroa:  t['lmiddletilde'] = 0x026B;
Kode lerroa:  t['lmonospace'] = 0xFF4C;
Kode lerroa:  t['lmsquare'] = 0x33D0;
Kode lerroa:  t['lochulathai'] = 0x0E2C;
Kode lerroa:  t['logicaland'] = 0x2227;
Kode lerroa:  t['logicalnot'] = 0x00AC;
Kode lerroa:  t['logicalnotreversed'] = 0x2310;
Kode lerroa:  t['logicalor'] = 0x2228;
Kode lerroa:  t['lolingthai'] = 0x0E25;
Kode lerroa:  t['longs'] = 0x017F;
Kode lerroa:  t['lowlinecenterline'] = 0xFE4E;
Kode lerroa:  t['lowlinecmb'] = 0x0332;
Kode lerroa:  t['lowlinedashed'] = 0xFE4D;
Kode lerroa:  t['lozenge'] = 0x25CA;
Kode lerroa:  t['lparen'] = 0x24A7;
Kode lerroa:  t['lslash'] = 0x0142;
Kode lerroa:  t['lsquare'] = 0x2113;
Kode lerroa:  t['lsuperior'] = 0xF6EE;
Kode lerroa:  t['ltshade'] = 0x2591;
Kode lerroa:  t['luthai'] = 0x0E26;
Kode lerroa:  t['lvocalicbengali'] = 0x098C;
Kode lerroa:  t['lvocalicdeva'] = 0x090C;
Kode lerroa:  t['lvocalicvowelsignbengali'] = 0x09E2;
Kode lerroa:  t['lvocalicvowelsigndeva'] = 0x0962;
Kode lerroa:  t['lxsquare'] = 0x33D3;
Kode lerroa:  t['m'] = 0x006D;
Kode lerroa:  t['mabengali'] = 0x09AE;
Kode lerroa:  t['macron'] = 0x00AF;
Kode lerroa:  t['macronbelowcmb'] = 0x0331;
Kode lerroa:  t['macroncmb'] = 0x0304;
Kode lerroa:  t['macronlowmod'] = 0x02CD;
Kode lerroa:  t['macronmonospace'] = 0xFFE3;
Kode lerroa:  t['macute'] = 0x1E3F;
Kode lerroa:  t['madeva'] = 0x092E;
Kode lerroa:  t['magujarati'] = 0x0AAE;
Kode lerroa:  t['magurmukhi'] = 0x0A2E;
Kode lerroa:  t['mahapakhhebrew'] = 0x05A4;
Kode lerroa:  t['mahapakhlefthebrew'] = 0x05A4;
Kode lerroa:  t['mahiragana'] = 0x307E;
Kode lerroa:  t['maichattawalowleftthai'] = 0xF895;
Kode lerroa:  t['maichattawalowrightthai'] = 0xF894;
Kode lerroa:  t['maichattawathai'] = 0x0E4B;
Kode lerroa:  t['maichattawaupperleftthai'] = 0xF893;
Kode lerroa:  t['maieklowleftthai'] = 0xF88C;
Kode lerroa:  t['maieklowrightthai'] = 0xF88B;
Kode lerroa:  t['maiekthai'] = 0x0E48;
Kode lerroa:  t['maiekupperleftthai'] = 0xF88A;
Kode lerroa:  t['maihanakatleftthai'] = 0xF884;
Kode lerroa:  t['maihanakatthai'] = 0x0E31;
Kode lerroa:  t['maitaikhuleftthai'] = 0xF889;
Kode lerroa:  t['maitaikhuthai'] = 0x0E47;
Kode lerroa:  t['maitholowleftthai'] = 0xF88F;
Kode lerroa:  t['maitholowrightthai'] = 0xF88E;
Kode lerroa:  t['maithothai'] = 0x0E49;
Kode lerroa:  t['maithoupperleftthai'] = 0xF88D;
Kode lerroa:  t['maitrilowleftthai'] = 0xF892;
Kode lerroa:  t['maitrilowrightthai'] = 0xF891;
Kode lerroa:  t['maitrithai'] = 0x0E4A;
Kode lerroa:  t['maitriupperleftthai'] = 0xF890;
Kode lerroa:  t['maiyamokthai'] = 0x0E46;
Kode lerroa:  t['makatakana'] = 0x30DE;
Kode lerroa:  t['makatakanahalfwidth'] = 0xFF8F;
Kode lerroa:  t['male'] = 0x2642;
Kode lerroa:  t['mansyonsquare'] = 0x3347;
Kode lerroa:  t['maqafhebrew'] = 0x05BE;
Kode lerroa:  t['mars'] = 0x2642;
Kode lerroa:  t['masoracirclehebrew'] = 0x05AF;
Kode lerroa:  t['masquare'] = 0x3383;
Kode lerroa:  t['mbopomofo'] = 0x3107;
Kode lerroa:  t['mbsquare'] = 0x33D4;
Kode lerroa:  t['mcircle'] = 0x24DC;
Kode lerroa:  t['mcubedsquare'] = 0x33A5;
Kode lerroa:  t['mdotaccent'] = 0x1E41;
Kode lerroa:  t['mdotbelow'] = 0x1E43;
Kode lerroa:  t['meemarabic'] = 0x0645;
Kode lerroa:  t['meemfinalarabic'] = 0xFEE2;
Kode lerroa:  t['meeminitialarabic'] = 0xFEE3;
Kode lerroa:  t['meemmedialarabic'] = 0xFEE4;
Kode lerroa:  t['meemmeeminitialarabic'] = 0xFCD1;
Kode lerroa:  t['meemmeemisolatedarabic'] = 0xFC48;
Kode lerroa:  t['meetorusquare'] = 0x334D;
Kode lerroa:  t['mehiragana'] = 0x3081;
Kode lerroa:  t['meizierasquare'] = 0x337E;
Kode lerroa:  t['mekatakana'] = 0x30E1;
Kode lerroa:  t['mekatakanahalfwidth'] = 0xFF92;
Kode lerroa:  t['mem'] = 0x05DE;
Kode lerroa:  t['memdagesh'] = 0xFB3E;
Kode lerroa:  t['memdageshhebrew'] = 0xFB3E;
Kode lerroa:  t['memhebrew'] = 0x05DE;
Kode lerroa:  t['menarmenian'] = 0x0574;
Kode lerroa:  t['merkhahebrew'] = 0x05A5;
Kode lerroa:  t['merkhakefulahebrew'] = 0x05A6;
Kode lerroa:  t['merkhakefulalefthebrew'] = 0x05A6;
Kode lerroa:  t['merkhalefthebrew'] = 0x05A5;
Kode lerroa:  t['mhook'] = 0x0271;
Kode lerroa:  t['mhzsquare'] = 0x3392;
Kode lerroa:  t['middledotkatakanahalfwidth'] = 0xFF65;
Kode lerroa:  t['middot'] = 0x00B7;
Kode lerroa:  t['mieumacirclekorean'] = 0x3272;
Kode lerroa:  t['mieumaparenkorean'] = 0x3212;
Kode lerroa:  t['mieumcirclekorean'] = 0x3264;
Kode lerroa:  t['mieumkorean'] = 0x3141;
Kode lerroa:  t['mieumpansioskorean'] = 0x3170;
Kode lerroa:  t['mieumparenkorean'] = 0x3204;
Kode lerroa:  t['mieumpieupkorean'] = 0x316E;
Kode lerroa:  t['mieumsioskorean'] = 0x316F;
Kode lerroa:  t['mihiragana'] = 0x307F;
Kode lerroa:  t['mikatakana'] = 0x30DF;
Kode lerroa:  t['mikatakanahalfwidth'] = 0xFF90;
Kode lerroa:  t['minus'] = 0x2212;
Kode lerroa:  t['minusbelowcmb'] = 0x0320;
Kode lerroa:  t['minuscircle'] = 0x2296;
Kode lerroa:  t['minusmod'] = 0x02D7;
Kode lerroa:  t['minusplus'] = 0x2213;
Kode lerroa:  t['minute'] = 0x2032;
Kode lerroa:  t['miribaarusquare'] = 0x334A;
Kode lerroa:  t['mirisquare'] = 0x3349;
Kode lerroa:  t['mlonglegturned'] = 0x0270;
Kode lerroa:  t['mlsquare'] = 0x3396;
Kode lerroa:  t['mmcubedsquare'] = 0x33A3;
Kode lerroa:  t['mmonospace'] = 0xFF4D;
Kode lerroa:  t['mmsquaredsquare'] = 0x339F;
Kode lerroa:  t['mohiragana'] = 0x3082;
Kode lerroa:  t['mohmsquare'] = 0x33C1;
Kode lerroa:  t['mokatakana'] = 0x30E2;
Kode lerroa:  t['mokatakanahalfwidth'] = 0xFF93;
Kode lerroa:  t['molsquare'] = 0x33D6;
Kode lerroa:  t['momathai'] = 0x0E21;
Kode lerroa:  t['moverssquare'] = 0x33A7;
Kode lerroa:  t['moverssquaredsquare'] = 0x33A8;
Kode lerroa:  t['mparen'] = 0x24A8;
Kode lerroa:  t['mpasquare'] = 0x33AB;
Kode lerroa:  t['mssquare'] = 0x33B3;
Kode lerroa:  t['msuperior'] = 0xF6EF;
Kode lerroa:  t['mturned'] = 0x026F;
Kode lerroa:  t['mu'] = 0x00B5;
Kode lerroa:  t['mu1'] = 0x00B5;
Kode lerroa:  t['muasquare'] = 0x3382;
Kode lerroa:  t['muchgreater'] = 0x226B;
Kode lerroa:  t['muchless'] = 0x226A;
Kode lerroa:  t['mufsquare'] = 0x338C;
Kode lerroa:  t['mugreek'] = 0x03BC;
Kode lerroa:  t['mugsquare'] = 0x338D;
Kode lerroa:  t['muhiragana'] = 0x3080;
Kode lerroa:  t['mukatakana'] = 0x30E0;
Kode lerroa:  t['mukatakanahalfwidth'] = 0xFF91;
Kode lerroa:  t['mulsquare'] = 0x3395;
Kode lerroa:  t['multiply'] = 0x00D7;
Kode lerroa:  t['mumsquare'] = 0x339B;
Kode lerroa:  t['munahhebrew'] = 0x05A3;
Kode lerroa:  t['munahlefthebrew'] = 0x05A3;
Kode lerroa:  t['musicalnote'] = 0x266A;
Kode lerroa:  t['musicalnotedbl'] = 0x266B;
Kode lerroa:  t['musicflatsign'] = 0x266D;
Kode lerroa:  t['musicsharpsign'] = 0x266F;
Kode lerroa:  t['mussquare'] = 0x33B2;
Kode lerroa:  t['muvsquare'] = 0x33B6;
Kode lerroa:  t['muwsquare'] = 0x33BC;
Kode lerroa:  t['mvmegasquare'] = 0x33B9;
Kode lerroa:  t['mvsquare'] = 0x33B7;
Kode lerroa:  t['mwmegasquare'] = 0x33BF;
Kode lerroa:  t['mwsquare'] = 0x33BD;
Kode lerroa:  t['n'] = 0x006E;
Kode lerroa:  t['nabengali'] = 0x09A8;
Kode lerroa:  t['nabla'] = 0x2207;
Kode lerroa:  t['nacute'] = 0x0144;
Kode lerroa:  t['nadeva'] = 0x0928;
Kode lerroa:  t['nagujarati'] = 0x0AA8;
Kode lerroa:  t['nagurmukhi'] = 0x0A28;
Kode lerroa:  t['nahiragana'] = 0x306A;
Kode lerroa:  t['nakatakana'] = 0x30CA;
Kode lerroa:  t['nakatakanahalfwidth'] = 0xFF85;
Kode lerroa:  t['napostrophe'] = 0x0149;
Kode lerroa:  t['nasquare'] = 0x3381;
Kode lerroa:  t['nbopomofo'] = 0x310B;
Kode lerroa:  t['nbspace'] = 0x00A0;
Kode lerroa:  t['ncaron'] = 0x0148;
Kode lerroa:  t['ncedilla'] = 0x0146;
Kode lerroa:  t['ncircle'] = 0x24DD;
Kode lerroa:  t['ncircumflexbelow'] = 0x1E4B;
Kode lerroa:  t['ncommaaccent'] = 0x0146;
Kode lerroa:  t['ndotaccent'] = 0x1E45;
Kode lerroa:  t['ndotbelow'] = 0x1E47;
Kode lerroa:  t['nehiragana'] = 0x306D;
Kode lerroa:  t['nekatakana'] = 0x30CD;
Kode lerroa:  t['nekatakanahalfwidth'] = 0xFF88;
Kode lerroa:  t['newsheqelsign'] = 0x20AA;
Kode lerroa:  t['nfsquare'] = 0x338B;
Kode lerroa:  t['ngabengali'] = 0x0999;
Kode lerroa:  t['ngadeva'] = 0x0919;
Kode lerroa:  t['ngagujarati'] = 0x0A99;
Kode lerroa:  t['ngagurmukhi'] = 0x0A19;
Kode lerroa:  t['ngonguthai'] = 0x0E07;
Kode lerroa:  t['nhiragana'] = 0x3093;
Kode lerroa:  t['nhookleft'] = 0x0272;
Kode lerroa:  t['nhookretroflex'] = 0x0273;
Kode lerroa:  t['nieunacirclekorean'] = 0x326F;
Kode lerroa:  t['nieunaparenkorean'] = 0x320F;
Kode lerroa:  t['nieuncieuckorean'] = 0x3135;
Kode lerroa:  t['nieuncirclekorean'] = 0x3261;
Kode lerroa:  t['nieunhieuhkorean'] = 0x3136;
Kode lerroa:  t['nieunkorean'] = 0x3134;
Kode lerroa:  t['nieunpansioskorean'] = 0x3168;
Kode lerroa:  t['nieunparenkorean'] = 0x3201;
Kode lerroa:  t['nieunsioskorean'] = 0x3167;
Kode lerroa:  t['nieuntikeutkorean'] = 0x3166;
Kode lerroa:  t['nihiragana'] = 0x306B;
Kode lerroa:  t['nikatakana'] = 0x30CB;
Kode lerroa:  t['nikatakanahalfwidth'] = 0xFF86;
Kode lerroa:  t['nikhahitleftthai'] = 0xF899;
Kode lerroa:  t['nikhahitthai'] = 0x0E4D;
Kode lerroa:  t['nine'] = 0x0039;
Kode lerroa:  t['ninearabic'] = 0x0669;
Kode lerroa:  t['ninebengali'] = 0x09EF;
Kode lerroa:  t['ninecircle'] = 0x2468;
Kode lerroa:  t['ninecircleinversesansserif'] = 0x2792;
Kode lerroa:  t['ninedeva'] = 0x096F;
Kode lerroa:  t['ninegujarati'] = 0x0AEF;
Kode lerroa:  t['ninegurmukhi'] = 0x0A6F;
Kode lerroa:  t['ninehackarabic'] = 0x0669;
Kode lerroa:  t['ninehangzhou'] = 0x3029;
Kode lerroa:  t['nineideographicparen'] = 0x3228;
Kode lerroa:  t['nineinferior'] = 0x2089;
Kode lerroa:  t['ninemonospace'] = 0xFF19;
Kode lerroa:  t['nineoldstyle'] = 0xF739;
Kode lerroa:  t['nineparen'] = 0x247C;
Kode lerroa:  t['nineperiod'] = 0x2490;
Kode lerroa:  t['ninepersian'] = 0x06F9;
Kode lerroa:  t['nineroman'] = 0x2178;
Kode lerroa:  t['ninesuperior'] = 0x2079;
Kode lerroa:  t['nineteencircle'] = 0x2472;
Kode lerroa:  t['nineteenparen'] = 0x2486;
Kode lerroa:  t['nineteenperiod'] = 0x249A;
Kode lerroa:  t['ninethai'] = 0x0E59;
Kode lerroa:  t['nj'] = 0x01CC;
Kode lerroa:  t['njecyrillic'] = 0x045A;
Kode lerroa:  t['nkatakana'] = 0x30F3;
Kode lerroa:  t['nkatakanahalfwidth'] = 0xFF9D;
Kode lerroa:  t['nlegrightlong'] = 0x019E;
Kode lerroa:  t['nlinebelow'] = 0x1E49;
Kode lerroa:  t['nmonospace'] = 0xFF4E;
Kode lerroa:  t['nmsquare'] = 0x339A;
Kode lerroa:  t['nnabengali'] = 0x09A3;
Kode lerroa:  t['nnadeva'] = 0x0923;
Kode lerroa:  t['nnagujarati'] = 0x0AA3;
Kode lerroa:  t['nnagurmukhi'] = 0x0A23;
Kode lerroa:  t['nnnadeva'] = 0x0929;
Kode lerroa:  t['nohiragana'] = 0x306E;
Kode lerroa:  t['nokatakana'] = 0x30CE;
Kode lerroa:  t['nokatakanahalfwidth'] = 0xFF89;
Kode lerroa:  t['nonbreakingspace'] = 0x00A0;
Kode lerroa:  t['nonenthai'] = 0x0E13;
Kode lerroa:  t['nonuthai'] = 0x0E19;
Kode lerroa:  t['noonarabic'] = 0x0646;
Kode lerroa:  t['noonfinalarabic'] = 0xFEE6;
Kode lerroa:  t['noonghunnaarabic'] = 0x06BA;
Kode lerroa:  t['noonghunnafinalarabic'] = 0xFB9F;
Kode lerroa:  t['nooninitialarabic'] = 0xFEE7;
Kode lerroa:  t['noonjeeminitialarabic'] = 0xFCD2;
Kode lerroa:  t['noonjeemisolatedarabic'] = 0xFC4B;
Kode lerroa:  t['noonmedialarabic'] = 0xFEE8;
Kode lerroa:  t['noonmeeminitialarabic'] = 0xFCD5;
Kode lerroa:  t['noonmeemisolatedarabic'] = 0xFC4E;
Kode lerroa:  t['noonnoonfinalarabic'] = 0xFC8D;
Kode lerroa:  t['notcontains'] = 0x220C;
Kode lerroa:  t['notelement'] = 0x2209;
Kode lerroa:  t['notelementof'] = 0x2209;
Kode lerroa:  t['notequal'] = 0x2260;
Kode lerroa:  t['notgreater'] = 0x226F;
Kode lerroa:  t['notgreaternorequal'] = 0x2271;
Kode lerroa:  t['notgreaternorless'] = 0x2279;
Kode lerroa:  t['notidentical'] = 0x2262;
Kode lerroa:  t['notless'] = 0x226E;
Kode lerroa:  t['notlessnorequal'] = 0x2270;
Kode lerroa:  t['notparallel'] = 0x2226;
Kode lerroa:  t['notprecedes'] = 0x2280;
Kode lerroa:  t['notsubset'] = 0x2284;
Kode lerroa:  t['notsucceeds'] = 0x2281;
Kode lerroa:  t['notsuperset'] = 0x2285;
Kode lerroa:  t['nowarmenian'] = 0x0576;
Kode lerroa:  t['nparen'] = 0x24A9;
Kode lerroa:  t['nssquare'] = 0x33B1;
Kode lerroa:  t['nsuperior'] = 0x207F;
Kode lerroa:  t['ntilde'] = 0x00F1;
Kode lerroa:  t['nu'] = 0x03BD;
Kode lerroa:  t['nuhiragana'] = 0x306C;
Kode lerroa:  t['nukatakana'] = 0x30CC;
Kode lerroa:  t['nukatakanahalfwidth'] = 0xFF87;
Kode lerroa:  t['nuktabengali'] = 0x09BC;
Kode lerroa:  t['nuktadeva'] = 0x093C;
Kode lerroa:  t['nuktagujarati'] = 0x0ABC;
Kode lerroa:  t['nuktagurmukhi'] = 0x0A3C;
Kode lerroa:  t['numbersign'] = 0x0023;
Kode lerroa:  t['numbersignmonospace'] = 0xFF03;
Kode lerroa:  t['numbersignsmall'] = 0xFE5F;
Kode lerroa:  t['numeralsigngreek'] = 0x0374;
Kode lerroa:  t['numeralsignlowergreek'] = 0x0375;
Kode lerroa:  t['numero'] = 0x2116;
Kode lerroa:  t['nun'] = 0x05E0;
Kode lerroa:  t['nundagesh'] = 0xFB40;
Kode lerroa:  t['nundageshhebrew'] = 0xFB40;
Kode lerroa:  t['nunhebrew'] = 0x05E0;
Kode lerroa:  t['nvsquare'] = 0x33B5;
Kode lerroa:  t['nwsquare'] = 0x33BB;
Kode lerroa:  t['nyabengali'] = 0x099E;
Kode lerroa:  t['nyadeva'] = 0x091E;
Kode lerroa:  t['nyagujarati'] = 0x0A9E;
Kode lerroa:  t['nyagurmukhi'] = 0x0A1E;
Kode lerroa:  t['o'] = 0x006F;
Kode lerroa:  t['oacute'] = 0x00F3;
Kode lerroa:  t['oangthai'] = 0x0E2D;
Kode lerroa:  t['obarred'] = 0x0275;
Kode lerroa:  t['obarredcyrillic'] = 0x04E9;
Kode lerroa:  t['obarreddieresiscyrillic'] = 0x04EB;
Kode lerroa:  t['obengali'] = 0x0993;
Kode lerroa:  t['obopomofo'] = 0x311B;
Kode lerroa:  t['obreve'] = 0x014F;
Kode lerroa:  t['ocandradeva'] = 0x0911;
Kode lerroa:  t['ocandragujarati'] = 0x0A91;
Kode lerroa:  t['ocandravowelsigndeva'] = 0x0949;
Kode lerroa:  t['ocandravowelsigngujarati'] = 0x0AC9;
Kode lerroa:  t['ocaron'] = 0x01D2;
Kode lerroa:  t['ocircle'] = 0x24DE;
Kode lerroa:  t['ocircumflex'] = 0x00F4;
Kode lerroa:  t['ocircumflexacute'] = 0x1ED1;
Kode lerroa:  t['ocircumflexdotbelow'] = 0x1ED9;
Kode lerroa:  t['ocircumflexgrave'] = 0x1ED3;
Kode lerroa:  t['ocircumflexhookabove'] = 0x1ED5;
Kode lerroa:  t['ocircumflextilde'] = 0x1ED7;
Kode lerroa:  t['ocyrillic'] = 0x043E;
Kode lerroa:  t['odblacute'] = 0x0151;
Kode lerroa:  t['odblgrave'] = 0x020D;
Kode lerroa:  t['odeva'] = 0x0913;
Kode lerroa:  t['odieresis'] = 0x00F6;
Kode lerroa:  t['odieresiscyrillic'] = 0x04E7;
Kode lerroa:  t['odotbelow'] = 0x1ECD;
Kode lerroa:  t['oe'] = 0x0153;
Kode lerroa:  t['oekorean'] = 0x315A;
Kode lerroa:  t['ogonek'] = 0x02DB;
Kode lerroa:  t['ogonekcmb'] = 0x0328;
Kode lerroa:  t['ograve'] = 0x00F2;
Kode lerroa:  t['ogujarati'] = 0x0A93;
Kode lerroa:  t['oharmenian'] = 0x0585;
Kode lerroa:  t['ohiragana'] = 0x304A;
Kode lerroa:  t['ohookabove'] = 0x1ECF;
Kode lerroa:  t['ohorn'] = 0x01A1;
Kode lerroa:  t['ohornacute'] = 0x1EDB;
Kode lerroa:  t['ohorndotbelow'] = 0x1EE3;
Kode lerroa:  t['ohorngrave'] = 0x1EDD;
Kode lerroa:  t['ohornhookabove'] = 0x1EDF;
Kode lerroa:  t['ohorntilde'] = 0x1EE1;
Kode lerroa:  t['ohungarumlaut'] = 0x0151;
Kode lerroa:  t['oi'] = 0x01A3;
Kode lerroa:  t['oinvertedbreve'] = 0x020F;
Kode lerroa:  t['okatakana'] = 0x30AA;
Kode lerroa:  t['okatakanahalfwidth'] = 0xFF75;
Kode lerroa:  t['okorean'] = 0x3157;
Kode lerroa:  t['olehebrew'] = 0x05AB;
Kode lerroa:  t['omacron'] = 0x014D;
Kode lerroa:  t['omacronacute'] = 0x1E53;
Kode lerroa:  t['omacrongrave'] = 0x1E51;
Kode lerroa:  t['omdeva'] = 0x0950;
Kode lerroa:  t['omega'] = 0x03C9;
Kode lerroa:  t['omega1'] = 0x03D6;
Kode lerroa:  t['omegacyrillic'] = 0x0461;
Kode lerroa:  t['omegalatinclosed'] = 0x0277;
Kode lerroa:  t['omegaroundcyrillic'] = 0x047B;
Kode lerroa:  t['omegatitlocyrillic'] = 0x047D;
Kode lerroa:  t['omegatonos'] = 0x03CE;
Kode lerroa:  t['omgujarati'] = 0x0AD0;
Kode lerroa:  t['omicron'] = 0x03BF;
Kode lerroa:  t['omicrontonos'] = 0x03CC;
Kode lerroa:  t['omonospace'] = 0xFF4F;
Kode lerroa:  t['one'] = 0x0031;
Kode lerroa:  t['onearabic'] = 0x0661;
Kode lerroa:  t['onebengali'] = 0x09E7;
Kode lerroa:  t['onecircle'] = 0x2460;
Kode lerroa:  t['onecircleinversesansserif'] = 0x278A;
Kode lerroa:  t['onedeva'] = 0x0967;
Kode lerroa:  t['onedotenleader'] = 0x2024;
Kode lerroa:  t['oneeighth'] = 0x215B;
Kode lerroa:  t['onefitted'] = 0xF6DC;
Kode lerroa:  t['onegujarati'] = 0x0AE7;
Kode lerroa:  t['onegurmukhi'] = 0x0A67;
Kode lerroa:  t['onehackarabic'] = 0x0661;
Kode lerroa:  t['onehalf'] = 0x00BD;
Kode lerroa:  t['onehangzhou'] = 0x3021;
Kode lerroa:  t['oneideographicparen'] = 0x3220;
Kode lerroa:  t['oneinferior'] = 0x2081;
Kode lerroa:  t['onemonospace'] = 0xFF11;
Kode lerroa:  t['onenumeratorbengali'] = 0x09F4;
Kode lerroa:  t['oneoldstyle'] = 0xF731;
Kode lerroa:  t['oneparen'] = 0x2474;
Kode lerroa:  t['oneperiod'] = 0x2488;
Kode lerroa:  t['onepersian'] = 0x06F1;
Kode lerroa:  t['onequarter'] = 0x00BC;
Kode lerroa:  t['oneroman'] = 0x2170;
Kode lerroa:  t['onesuperior'] = 0x00B9;
Kode lerroa:  t['onethai'] = 0x0E51;
Kode lerroa:  t['onethird'] = 0x2153;
Kode lerroa:  t['oogonek'] = 0x01EB;
Kode lerroa:  t['oogonekmacron'] = 0x01ED;
Kode lerroa:  t['oogurmukhi'] = 0x0A13;
Kode lerroa:  t['oomatragurmukhi'] = 0x0A4B;
Kode lerroa:  t['oopen'] = 0x0254;
Kode lerroa:  t['oparen'] = 0x24AA;
Kode lerroa:  t['openbullet'] = 0x25E6;
Kode lerroa:  t['option'] = 0x2325;
Kode lerroa:  t['ordfeminine'] = 0x00AA;
Kode lerroa:  t['ordmasculine'] = 0x00BA;
Kode lerroa:  t['orthogonal'] = 0x221F;
Kode lerroa:  t['oshortdeva'] = 0x0912;
Kode lerroa:  t['oshortvowelsigndeva'] = 0x094A;
Kode lerroa:  t['oslash'] = 0x00F8;
Kode lerroa:  t['oslashacute'] = 0x01FF;
Kode lerroa:  t['osmallhiragana'] = 0x3049;
Kode lerroa:  t['osmallkatakana'] = 0x30A9;
Kode lerroa:  t['osmallkatakanahalfwidth'] = 0xFF6B;
Kode lerroa:  t['ostrokeacute'] = 0x01FF;
Kode lerroa:  t['osuperior'] = 0xF6F0;
Kode lerroa:  t['otcyrillic'] = 0x047F;
Kode lerroa:  t['otilde'] = 0x00F5;
Kode lerroa:  t['otildeacute'] = 0x1E4D;
Kode lerroa:  t['otildedieresis'] = 0x1E4F;
Kode lerroa:  t['oubopomofo'] = 0x3121;
Kode lerroa:  t['overline'] = 0x203E;
Kode lerroa:  t['overlinecenterline'] = 0xFE4A;
Kode lerroa:  t['overlinecmb'] = 0x0305;
Kode lerroa:  t['overlinedashed'] = 0xFE49;
Kode lerroa:  t['overlinedblwavy'] = 0xFE4C;
Kode lerroa:  t['overlinewavy'] = 0xFE4B;
Kode lerroa:  t['overscore'] = 0x00AF;
Kode lerroa:  t['ovowelsignbengali'] = 0x09CB;
Kode lerroa:  t['ovowelsigndeva'] = 0x094B;
Kode lerroa:  t['ovowelsigngujarati'] = 0x0ACB;
Kode lerroa:  t['p'] = 0x0070;
Kode lerroa:  t['paampssquare'] = 0x3380;
Kode lerroa:  t['paasentosquare'] = 0x332B;
Kode lerroa:  t['pabengali'] = 0x09AA;
Kode lerroa:  t['pacute'] = 0x1E55;
Kode lerroa:  t['padeva'] = 0x092A;
Kode lerroa:  t['pagedown'] = 0x21DF;
Kode lerroa:  t['pageup'] = 0x21DE;
Kode lerroa:  t['pagujarati'] = 0x0AAA;
Kode lerroa:  t['pagurmukhi'] = 0x0A2A;
Kode lerroa:  t['pahiragana'] = 0x3071;
Kode lerroa:  t['paiyannoithai'] = 0x0E2F;
Kode lerroa:  t['pakatakana'] = 0x30D1;
Kode lerroa:  t['palatalizationcyrilliccmb'] = 0x0484;
Kode lerroa:  t['palochkacyrillic'] = 0x04C0;
Kode lerroa:  t['pansioskorean'] = 0x317F;
Kode lerroa:  t['paragraph'] = 0x00B6;
Kode lerroa:  t['parallel'] = 0x2225;
Kode lerroa:  t['parenleft'] = 0x0028;
Kode lerroa:  t['parenleftaltonearabic'] = 0xFD3E;
Kode lerroa:  t['parenleftbt'] = 0xF8ED;
Kode lerroa:  t['parenleftex'] = 0xF8EC;
Kode lerroa:  t['parenleftinferior'] = 0x208D;
Kode lerroa:  t['parenleftmonospace'] = 0xFF08;
Kode lerroa:  t['parenleftsmall'] = 0xFE59;
Kode lerroa:  t['parenleftsuperior'] = 0x207D;
Kode lerroa:  t['parenlefttp'] = 0xF8EB;
Kode lerroa:  t['parenleftvertical'] = 0xFE35;
Kode lerroa:  t['parenright'] = 0x0029;
Kode lerroa:  t['parenrightaltonearabic'] = 0xFD3F;
Kode lerroa:  t['parenrightbt'] = 0xF8F8;
Kode lerroa:  t['parenrightex'] = 0xF8F7;
Kode lerroa:  t['parenrightinferior'] = 0x208E;
Kode lerroa:  t['parenrightmonospace'] = 0xFF09;
Kode lerroa:  t['parenrightsmall'] = 0xFE5A;
Kode lerroa:  t['parenrightsuperior'] = 0x207E;
Kode lerroa:  t['parenrighttp'] = 0xF8F6;
Kode lerroa:  t['parenrightvertical'] = 0xFE36;
Kode lerroa:  t['partialdiff'] = 0x2202;
Kode lerroa:  t['paseqhebrew'] = 0x05C0;
Kode lerroa:  t['pashtahebrew'] = 0x0599;
Kode lerroa:  t['pasquare'] = 0x33A9;
Kode lerroa:  t['patah'] = 0x05B7;
Kode lerroa:  t['patah11'] = 0x05B7;
Kode lerroa:  t['patah1d'] = 0x05B7;
Kode lerroa:  t['patah2a'] = 0x05B7;
Kode lerroa:  t['patahhebrew'] = 0x05B7;
Kode lerroa:  t['patahnarrowhebrew'] = 0x05B7;
Kode lerroa:  t['patahquarterhebrew'] = 0x05B7;
Kode lerroa:  t['patahwidehebrew'] = 0x05B7;
Kode lerroa:  t['pazerhebrew'] = 0x05A1;
Kode lerroa:  t['pbopomofo'] = 0x3106;
Kode lerroa:  t['pcircle'] = 0x24DF;
Kode lerroa:  t['pdotaccent'] = 0x1E57;
Kode lerroa:  t['pe'] = 0x05E4;
Kode lerroa:  t['pecyrillic'] = 0x043F;
Kode lerroa:  t['pedagesh'] = 0xFB44;
Kode lerroa:  t['pedageshhebrew'] = 0xFB44;
Kode lerroa:  t['peezisquare'] = 0x333B;
Kode lerroa:  t['pefinaldageshhebrew'] = 0xFB43;
Kode lerroa:  t['peharabic'] = 0x067E;
Kode lerroa:  t['peharmenian'] = 0x057A;
Kode lerroa:  t['pehebrew'] = 0x05E4;
Kode lerroa:  t['pehfinalarabic'] = 0xFB57;
Kode lerroa:  t['pehinitialarabic'] = 0xFB58;
Kode lerroa:  t['pehiragana'] = 0x307A;
Kode lerroa:  t['pehmedialarabic'] = 0xFB59;
Kode lerroa:  t['pekatakana'] = 0x30DA;
Kode lerroa:  t['pemiddlehookcyrillic'] = 0x04A7;
Kode lerroa:  t['perafehebrew'] = 0xFB4E;
Kode lerroa:  t['percent'] = 0x0025;
Kode lerroa:  t['percentarabic'] = 0x066A;
Kode lerroa:  t['percentmonospace'] = 0xFF05;
Kode lerroa:  t['percentsmall'] = 0xFE6A;
Kode lerroa:  t['period'] = 0x002E;
Kode lerroa:  t['periodarmenian'] = 0x0589;
Kode lerroa:  t['periodcentered'] = 0x00B7;
Kode lerroa:  t['periodhalfwidth'] = 0xFF61;
Kode lerroa:  t['periodinferior'] = 0xF6E7;
Kode lerroa:  t['periodmonospace'] = 0xFF0E;
Kode lerroa:  t['periodsmall'] = 0xFE52;
Kode lerroa:  t['periodsuperior'] = 0xF6E8;
Kode lerroa:  t['perispomenigreekcmb'] = 0x0342;
Kode lerroa:  t['perpendicular'] = 0x22A5;
Kode lerroa:  t['perthousand'] = 0x2030;
Kode lerroa:  t['peseta'] = 0x20A7;
Kode lerroa:  t['pfsquare'] = 0x338A;
Kode lerroa:  t['phabengali'] = 0x09AB;
Kode lerroa:  t['phadeva'] = 0x092B;
Kode lerroa:  t['phagujarati'] = 0x0AAB;
Kode lerroa:  t['phagurmukhi'] = 0x0A2B;
Kode lerroa:  t['phi'] = 0x03C6;
Kode lerroa:  t['phi1'] = 0x03D5;
Kode lerroa:  t['phieuphacirclekorean'] = 0x327A;
Kode lerroa:  t['phieuphaparenkorean'] = 0x321A;
Kode lerroa:  t['phieuphcirclekorean'] = 0x326C;
Kode lerroa:  t['phieuphkorean'] = 0x314D;
Kode lerroa:  t['phieuphparenkorean'] = 0x320C;
Kode lerroa:  t['philatin'] = 0x0278;
Kode lerroa:  t['phinthuthai'] = 0x0E3A;
Kode lerroa:  t['phisymbolgreek'] = 0x03D5;
Kode lerroa:  t['phook'] = 0x01A5;
Kode lerroa:  t['phophanthai'] = 0x0E1E;
Kode lerroa:  t['phophungthai'] = 0x0E1C;
Kode lerroa:  t['phosamphaothai'] = 0x0E20;
Kode lerroa:  t['pi'] = 0x03C0;
Kode lerroa:  t['pieupacirclekorean'] = 0x3273;
Kode lerroa:  t['pieupaparenkorean'] = 0x3213;
Kode lerroa:  t['pieupcieuckorean'] = 0x3176;
Kode lerroa:  t['pieupcirclekorean'] = 0x3265;
Kode lerroa:  t['pieupkiyeokkorean'] = 0x3172;
Kode lerroa:  t['pieupkorean'] = 0x3142;
Kode lerroa:  t['pieupparenkorean'] = 0x3205;
Kode lerroa:  t['pieupsioskiyeokkorean'] = 0x3174;
Kode lerroa:  t['pieupsioskorean'] = 0x3144;
Kode lerroa:  t['pieupsiostikeutkorean'] = 0x3175;
Kode lerroa:  t['pieupthieuthkorean'] = 0x3177;
Kode lerroa:  t['pieuptikeutkorean'] = 0x3173;
Kode lerroa:  t['pihiragana'] = 0x3074;
Kode lerroa:  t['pikatakana'] = 0x30D4;
Kode lerroa:  t['pisymbolgreek'] = 0x03D6;
Kode lerroa:  t['piwrarmenian'] = 0x0583;
Kode lerroa:  t['plus'] = 0x002B;
Kode lerroa:  t['plusbelowcmb'] = 0x031F;
Kode lerroa:  t['pluscircle'] = 0x2295;
Kode lerroa:  t['plusminus'] = 0x00B1;
Kode lerroa:  t['plusmod'] = 0x02D6;
Kode lerroa:  t['plusmonospace'] = 0xFF0B;
Kode lerroa:  t['plussmall'] = 0xFE62;
Kode lerroa:  t['plussuperior'] = 0x207A;
Kode lerroa:  t['pmonospace'] = 0xFF50;
Kode lerroa:  t['pmsquare'] = 0x33D8;
Kode lerroa:  t['pohiragana'] = 0x307D;
Kode lerroa:  t['pointingindexdownwhite'] = 0x261F;
Kode lerroa:  t['pointingindexleftwhite'] = 0x261C;
Kode lerroa:  t['pointingindexrightwhite'] = 0x261E;
Kode lerroa:  t['pointingindexupwhite'] = 0x261D;
Kode lerroa:  t['pokatakana'] = 0x30DD;
Kode lerroa:  t['poplathai'] = 0x0E1B;
Kode lerroa:  t['postalmark'] = 0x3012;
Kode lerroa:  t['postalmarkface'] = 0x3020;
Kode lerroa:  t['pparen'] = 0x24AB;
Kode lerroa:  t['precedes'] = 0x227A;
Kode lerroa:  t['prescription'] = 0x211E;
Kode lerroa:  t['primemod'] = 0x02B9;
Kode lerroa:  t['primereversed'] = 0x2035;
Kode lerroa:  t['product'] = 0x220F;
Kode lerroa:  t['projective'] = 0x2305;
Kode lerroa:  t['prolongedkana'] = 0x30FC;
Kode lerroa:  t['propellor'] = 0x2318;
Kode lerroa:  t['propersubset'] = 0x2282;
Kode lerroa:  t['propersuperset'] = 0x2283;
Kode lerroa:  t['proportion'] = 0x2237;
Kode lerroa:  t['proportional'] = 0x221D;
Kode lerroa:  t['psi'] = 0x03C8;
Kode lerroa:  t['psicyrillic'] = 0x0471;
Kode lerroa:  t['psilipneumatacyrilliccmb'] = 0x0486;
Kode lerroa:  t['pssquare'] = 0x33B0;
Kode lerroa:  t['puhiragana'] = 0x3077;
Kode lerroa:  t['pukatakana'] = 0x30D7;
Kode lerroa:  t['pvsquare'] = 0x33B4;
Kode lerroa:  t['pwsquare'] = 0x33BA;
Kode lerroa:  t['q'] = 0x0071;
Kode lerroa:  t['qadeva'] = 0x0958;
Kode lerroa:  t['qadmahebrew'] = 0x05A8;
Kode lerroa:  t['qafarabic'] = 0x0642;
Kode lerroa:  t['qaffinalarabic'] = 0xFED6;
Kode lerroa:  t['qafinitialarabic'] = 0xFED7;
Kode lerroa:  t['qafmedialarabic'] = 0xFED8;
Kode lerroa:  t['qamats'] = 0x05B8;
Kode lerroa:  t['qamats10'] = 0x05B8;
Kode lerroa:  t['qamats1a'] = 0x05B8;
Kode lerroa:  t['qamats1c'] = 0x05B8;
Kode lerroa:  t['qamats27'] = 0x05B8;
Kode lerroa:  t['qamats29'] = 0x05B8;
Kode lerroa:  t['qamats33'] = 0x05B8;
Kode lerroa:  t['qamatsde'] = 0x05B8;
Kode lerroa:  t['qamatshebrew'] = 0x05B8;
Kode lerroa:  t['qamatsnarrowhebrew'] = 0x05B8;
Kode lerroa:  t['qamatsqatanhebrew'] = 0x05B8;
Kode lerroa:  t['qamatsqatannarrowhebrew'] = 0x05B8;
Kode lerroa:  t['qamatsqatanquarterhebrew'] = 0x05B8;
Kode lerroa:  t['qamatsqatanwidehebrew'] = 0x05B8;
Kode lerroa:  t['qamatsquarterhebrew'] = 0x05B8;
Kode lerroa:  t['qamatswidehebrew'] = 0x05B8;
Kode lerroa:  t['qarneyparahebrew'] = 0x059F;
Kode lerroa:  t['qbopomofo'] = 0x3111;
Kode lerroa:  t['qcircle'] = 0x24E0;
Kode lerroa:  t['qhook'] = 0x02A0;
Kode lerroa:  t['qmonospace'] = 0xFF51;
Kode lerroa:  t['qof'] = 0x05E7;
Kode lerroa:  t['qofdagesh'] = 0xFB47;
Kode lerroa:  t['qofdageshhebrew'] = 0xFB47;
Kode lerroa:  t['qofhebrew'] = 0x05E7;
Kode lerroa:  t['qparen'] = 0x24AC;
Kode lerroa:  t['quarternote'] = 0x2669;
Kode lerroa:  t['qubuts'] = 0x05BB;
Kode lerroa:  t['qubuts18'] = 0x05BB;
Kode lerroa:  t['qubuts25'] = 0x05BB;
Kode lerroa:  t['qubuts31'] = 0x05BB;
Kode lerroa:  t['qubutshebrew'] = 0x05BB;
Kode lerroa:  t['qubutsnarrowhebrew'] = 0x05BB;
Kode lerroa:  t['qubutsquarterhebrew'] = 0x05BB;
Kode lerroa:  t['qubutswidehebrew'] = 0x05BB;
Kode lerroa:  t['question'] = 0x003F;
Kode lerroa:  t['questionarabic'] = 0x061F;
Kode lerroa:  t['questionarmenian'] = 0x055E;
Kode lerroa:  t['questiondown'] = 0x00BF;
Kode lerroa:  t['questiondownsmall'] = 0xF7BF;
Kode lerroa:  t['questiongreek'] = 0x037E;
Kode lerroa:  t['questionmonospace'] = 0xFF1F;
Kode lerroa:  t['questionsmall'] = 0xF73F;
Kode lerroa:  t['quotedbl'] = 0x0022;
Kode lerroa:  t['quotedblbase'] = 0x201E;
Kode lerroa:  t['quotedblleft'] = 0x201C;
Kode lerroa:  t['quotedblmonospace'] = 0xFF02;
Kode lerroa:  t['quotedblprime'] = 0x301E;
Kode lerroa:  t['quotedblprimereversed'] = 0x301D;
Kode lerroa:  t['quotedblright'] = 0x201D;
Kode lerroa:  t['quoteleft'] = 0x2018;
Kode lerroa:  t['quoteleftreversed'] = 0x201B;
Kode lerroa:  t['quotereversed'] = 0x201B;
Kode lerroa:  t['quoteright'] = 0x2019;
Kode lerroa:  t['quoterightn'] = 0x0149;
Kode lerroa:  t['quotesinglbase'] = 0x201A;
Kode lerroa:  t['quotesingle'] = 0x0027;
Kode lerroa:  t['quotesinglemonospace'] = 0xFF07;
Kode lerroa:  t['r'] = 0x0072;
Kode lerroa:  t['raarmenian'] = 0x057C;
Kode lerroa:  t['rabengali'] = 0x09B0;
Kode lerroa:  t['racute'] = 0x0155;
Kode lerroa:  t['radeva'] = 0x0930;
Kode lerroa:  t['radical'] = 0x221A;
Kode lerroa:  t['radicalex'] = 0xF8E5;
Kode lerroa:  t['radoverssquare'] = 0x33AE;
Kode lerroa:  t['radoverssquaredsquare'] = 0x33AF;
Kode lerroa:  t['radsquare'] = 0x33AD;
Kode lerroa:  t['rafe'] = 0x05BF;
Kode lerroa:  t['rafehebrew'] = 0x05BF;
Kode lerroa:  t['ragujarati'] = 0x0AB0;
Kode lerroa:  t['ragurmukhi'] = 0x0A30;
Kode lerroa:  t['rahiragana'] = 0x3089;
Kode lerroa:  t['rakatakana'] = 0x30E9;
Kode lerroa:  t['rakatakanahalfwidth'] = 0xFF97;
Kode lerroa:  t['ralowerdiagonalbengali'] = 0x09F1;
Kode lerroa:  t['ramiddlediagonalbengali'] = 0x09F0;
Kode lerroa:  t['ramshorn'] = 0x0264;
Kode lerroa:  t['ratio'] = 0x2236;
Kode lerroa:  t['rbopomofo'] = 0x3116;
Kode lerroa:  t['rcaron'] = 0x0159;
Kode lerroa:  t['rcedilla'] = 0x0157;
Kode lerroa:  t['rcircle'] = 0x24E1;
Kode lerroa:  t['rcommaaccent'] = 0x0157;
Kode lerroa:  t['rdblgrave'] = 0x0211;
Kode lerroa:  t['rdotaccent'] = 0x1E59;
Kode lerroa:  t['rdotbelow'] = 0x1E5B;
Kode lerroa:  t['rdotbelowmacron'] = 0x1E5D;
Kode lerroa:  t['referencemark'] = 0x203B;
Kode lerroa:  t['reflexsubset'] = 0x2286;
Kode lerroa:  t['reflexsuperset'] = 0x2287;
Kode lerroa:  t['registered'] = 0x00AE;
Kode lerroa:  t['registersans'] = 0xF8E8;
Kode lerroa:  t['registerserif'] = 0xF6DA;
Kode lerroa:  t['reharabic'] = 0x0631;
Kode lerroa:  t['reharmenian'] = 0x0580;
Kode lerroa:  t['rehfinalarabic'] = 0xFEAE;
Kode lerroa:  t['rehiragana'] = 0x308C;
Kode lerroa:  t['rekatakana'] = 0x30EC;
Kode lerroa:  t['rekatakanahalfwidth'] = 0xFF9A;
Kode lerroa:  t['resh'] = 0x05E8;
Kode lerroa:  t['reshdageshhebrew'] = 0xFB48;
Kode lerroa:  t['reshhebrew'] = 0x05E8;
Kode lerroa:  t['reversedtilde'] = 0x223D;
Kode lerroa:  t['reviahebrew'] = 0x0597;
Kode lerroa:  t['reviamugrashhebrew'] = 0x0597;
Kode lerroa:  t['revlogicalnot'] = 0x2310;
Kode lerroa:  t['rfishhook'] = 0x027E;
Kode lerroa:  t['rfishhookreversed'] = 0x027F;
Kode lerroa:  t['rhabengali'] = 0x09DD;
Kode lerroa:  t['rhadeva'] = 0x095D;
Kode lerroa:  t['rho'] = 0x03C1;
Kode lerroa:  t['rhook'] = 0x027D;
Kode lerroa:  t['rhookturned'] = 0x027B;
Kode lerroa:  t['rhookturnedsuperior'] = 0x02B5;
Kode lerroa:  t['rhosymbolgreek'] = 0x03F1;
Kode lerroa:  t['rhotichookmod'] = 0x02DE;
Kode lerroa:  t['rieulacirclekorean'] = 0x3271;
Kode lerroa:  t['rieulaparenkorean'] = 0x3211;
Kode lerroa:  t['rieulcirclekorean'] = 0x3263;
Kode lerroa:  t['rieulhieuhkorean'] = 0x3140;
Kode lerroa:  t['rieulkiyeokkorean'] = 0x313A;
Kode lerroa:  t['rieulkiyeoksioskorean'] = 0x3169;
Kode lerroa:  t['rieulkorean'] = 0x3139;
Kode lerroa:  t['rieulmieumkorean'] = 0x313B;
Kode lerroa:  t['rieulpansioskorean'] = 0x316C;
Kode lerroa:  t['rieulparenkorean'] = 0x3203;
Kode lerroa:  t['rieulphieuphkorean'] = 0x313F;
Kode lerroa:  t['rieulpieupkorean'] = 0x313C;
Kode lerroa:  t['rieulpieupsioskorean'] = 0x316B;
Kode lerroa:  t['rieulsioskorean'] = 0x313D;
Kode lerroa:  t['rieulthieuthkorean'] = 0x313E;
Kode lerroa:  t['rieultikeutkorean'] = 0x316A;
Kode lerroa:  t['rieulyeorinhieuhkorean'] = 0x316D;
Kode lerroa:  t['rightangle'] = 0x221F;
Kode lerroa:  t['righttackbelowcmb'] = 0x0319;
Kode lerroa:  t['righttriangle'] = 0x22BF;
Kode lerroa:  t['rihiragana'] = 0x308A;
Kode lerroa:  t['rikatakana'] = 0x30EA;
Kode lerroa:  t['rikatakanahalfwidth'] = 0xFF98;
Kode lerroa:  t['ring'] = 0x02DA;
Kode lerroa:  t['ringbelowcmb'] = 0x0325;
Kode lerroa:  t['ringcmb'] = 0x030A;
Kode lerroa:  t['ringhalfleft'] = 0x02BF;
Kode lerroa:  t['ringhalfleftarmenian'] = 0x0559;
Kode lerroa:  t['ringhalfleftbelowcmb'] = 0x031C;
Kode lerroa:  t['ringhalfleftcentered'] = 0x02D3;
Kode lerroa:  t['ringhalfright'] = 0x02BE;
Kode lerroa:  t['ringhalfrightbelowcmb'] = 0x0339;
Kode lerroa:  t['ringhalfrightcentered'] = 0x02D2;
Kode lerroa:  t['rinvertedbreve'] = 0x0213;
Kode lerroa:  t['rittorusquare'] = 0x3351;
Kode lerroa:  t['rlinebelow'] = 0x1E5F;
Kode lerroa:  t['rlongleg'] = 0x027C;
Kode lerroa:  t['rlonglegturned'] = 0x027A;
Kode lerroa:  t['rmonospace'] = 0xFF52;
Kode lerroa:  t['rohiragana'] = 0x308D;
Kode lerroa:  t['rokatakana'] = 0x30ED;
Kode lerroa:  t['rokatakanahalfwidth'] = 0xFF9B;
Kode lerroa:  t['roruathai'] = 0x0E23;
Kode lerroa:  t['rparen'] = 0x24AD;
Kode lerroa:  t['rrabengali'] = 0x09DC;
Kode lerroa:  t['rradeva'] = 0x0931;
Kode lerroa:  t['rragurmukhi'] = 0x0A5C;
Kode lerroa:  t['rreharabic'] = 0x0691;
Kode lerroa:  t['rrehfinalarabic'] = 0xFB8D;
Kode lerroa:  t['rrvocalicbengali'] = 0x09E0;
Kode lerroa:  t['rrvocalicdeva'] = 0x0960;
Kode lerroa:  t['rrvocalicgujarati'] = 0x0AE0;
Kode lerroa:  t['rrvocalicvowelsignbengali'] = 0x09C4;
Kode lerroa:  t['rrvocalicvowelsigndeva'] = 0x0944;
Kode lerroa:  t['rrvocalicvowelsigngujarati'] = 0x0AC4;
Kode lerroa:  t['rsuperior'] = 0xF6F1;
Kode lerroa:  t['rtblock'] = 0x2590;
Kode lerroa:  t['rturned'] = 0x0279;
Kode lerroa:  t['rturnedsuperior'] = 0x02B4;
Kode lerroa:  t['ruhiragana'] = 0x308B;
Kode lerroa:  t['rukatakana'] = 0x30EB;
Kode lerroa:  t['rukatakanahalfwidth'] = 0xFF99;
Kode lerroa:  t['rupeemarkbengali'] = 0x09F2;
Kode lerroa:  t['rupeesignbengali'] = 0x09F3;
Kode lerroa:  t['rupiah'] = 0xF6DD;
Kode lerroa:  t['ruthai'] = 0x0E24;
Kode lerroa:  t['rvocalicbengali'] = 0x098B;
Kode lerroa:  t['rvocalicdeva'] = 0x090B;
Kode lerroa:  t['rvocalicgujarati'] = 0x0A8B;
Kode lerroa:  t['rvocalicvowelsignbengali'] = 0x09C3;
Kode lerroa:  t['rvocalicvowelsigndeva'] = 0x0943;
Kode lerroa:  t['rvocalicvowelsigngujarati'] = 0x0AC3;
Kode lerroa:  t['s'] = 0x0073;
Kode lerroa:  t['sabengali'] = 0x09B8;
Kode lerroa:  t['sacute'] = 0x015B;
Kode lerroa:  t['sacutedotaccent'] = 0x1E65;
Kode lerroa:  t['sadarabic'] = 0x0635;
Kode lerroa:  t['sadeva'] = 0x0938;
Kode lerroa:  t['sadfinalarabic'] = 0xFEBA;
Kode lerroa:  t['sadinitialarabic'] = 0xFEBB;
Kode lerroa:  t['sadmedialarabic'] = 0xFEBC;
Kode lerroa:  t['sagujarati'] = 0x0AB8;
Kode lerroa:  t['sagurmukhi'] = 0x0A38;
Kode lerroa:  t['sahiragana'] = 0x3055;
Kode lerroa:  t['sakatakana'] = 0x30B5;
Kode lerroa:  t['sakatakanahalfwidth'] = 0xFF7B;
Kode lerroa:  t['sallallahoualayhewasallamarabic'] = 0xFDFA;
Kode lerroa:  t['samekh'] = 0x05E1;
Kode lerroa:  t['samekhdagesh'] = 0xFB41;
Kode lerroa:  t['samekhdageshhebrew'] = 0xFB41;
Kode lerroa:  t['samekhhebrew'] = 0x05E1;
Kode lerroa:  t['saraaathai'] = 0x0E32;
Kode lerroa:  t['saraaethai'] = 0x0E41;
Kode lerroa:  t['saraaimaimalaithai'] = 0x0E44;
Kode lerroa:  t['saraaimaimuanthai'] = 0x0E43;
Kode lerroa:  t['saraamthai'] = 0x0E33;
Kode lerroa:  t['saraathai'] = 0x0E30;
Kode lerroa:  t['saraethai'] = 0x0E40;
Kode lerroa:  t['saraiileftthai'] = 0xF886;
Kode lerroa:  t['saraiithai'] = 0x0E35;
Kode lerroa:  t['saraileftthai'] = 0xF885;
Kode lerroa:  t['saraithai'] = 0x0E34;
Kode lerroa:  t['saraothai'] = 0x0E42;
Kode lerroa:  t['saraueeleftthai'] = 0xF888;
Kode lerroa:  t['saraueethai'] = 0x0E37;
Kode lerroa:  t['saraueleftthai'] = 0xF887;
Kode lerroa:  t['sarauethai'] = 0x0E36;
Kode lerroa:  t['sarauthai'] = 0x0E38;
Kode lerroa:  t['sarauuthai'] = 0x0E39;
Kode lerroa:  t['sbopomofo'] = 0x3119;
Kode lerroa:  t['scaron'] = 0x0161;
Kode lerroa:  t['scarondotaccent'] = 0x1E67;
Kode lerroa:  t['scedilla'] = 0x015F;
Kode lerroa:  t['schwa'] = 0x0259;
Kode lerroa:  t['schwacyrillic'] = 0x04D9;
Kode lerroa:  t['schwadieresiscyrillic'] = 0x04DB;
Kode lerroa:  t['schwahook'] = 0x025A;
Kode lerroa:  t['scircle'] = 0x24E2;
Kode lerroa:  t['scircumflex'] = 0x015D;
Kode lerroa:  t['scommaaccent'] = 0x0219;
Kode lerroa:  t['sdotaccent'] = 0x1E61;
Kode lerroa:  t['sdotbelow'] = 0x1E63;
Kode lerroa:  t['sdotbelowdotaccent'] = 0x1E69;
Kode lerroa:  t['seagullbelowcmb'] = 0x033C;
Kode lerroa:  t['second'] = 0x2033;
Kode lerroa:  t['secondtonechinese'] = 0x02CA;
Kode lerroa:  t['section'] = 0x00A7;
Kode lerroa:  t['seenarabic'] = 0x0633;
Kode lerroa:  t['seenfinalarabic'] = 0xFEB2;
Kode lerroa:  t['seeninitialarabic'] = 0xFEB3;
Kode lerroa:  t['seenmedialarabic'] = 0xFEB4;
Kode lerroa:  t['segol'] = 0x05B6;
Kode lerroa:  t['segol13'] = 0x05B6;
Kode lerroa:  t['segol1f'] = 0x05B6;
Kode lerroa:  t['segol2c'] = 0x05B6;
Kode lerroa:  t['segolhebrew'] = 0x05B6;
Kode lerroa:  t['segolnarrowhebrew'] = 0x05B6;
Kode lerroa:  t['segolquarterhebrew'] = 0x05B6;
Kode lerroa:  t['segoltahebrew'] = 0x0592;
Kode lerroa:  t['segolwidehebrew'] = 0x05B6;
Kode lerroa:  t['seharmenian'] = 0x057D;
Kode lerroa:  t['sehiragana'] = 0x305B;
Kode lerroa:  t['sekatakana'] = 0x30BB;
Kode lerroa:  t['sekatakanahalfwidth'] = 0xFF7E;
Kode lerroa:  t['semicolon'] = 0x003B;
Kode lerroa:  t['semicolonarabic'] = 0x061B;
Kode lerroa:  t['semicolonmonospace'] = 0xFF1B;
Kode lerroa:  t['semicolonsmall'] = 0xFE54;
Kode lerroa:  t['semivoicedmarkkana'] = 0x309C;
Kode lerroa:  t['semivoicedmarkkanahalfwidth'] = 0xFF9F;
Kode lerroa:  t['sentisquare'] = 0x3322;
Kode lerroa:  t['sentosquare'] = 0x3323;
Kode lerroa:  t['seven'] = 0x0037;
Kode lerroa:  t['sevenarabic'] = 0x0667;
Kode lerroa:  t['sevenbengali'] = 0x09ED;
Kode lerroa:  t['sevencircle'] = 0x2466;
Kode lerroa:  t['sevencircleinversesansserif'] = 0x2790;
Kode lerroa:  t['sevendeva'] = 0x096D;
Kode lerroa:  t['seveneighths'] = 0x215E;
Kode lerroa:  t['sevengujarati'] = 0x0AED;
Kode lerroa:  t['sevengurmukhi'] = 0x0A6D;
Kode lerroa:  t['sevenhackarabic'] = 0x0667;
Kode lerroa:  t['sevenhangzhou'] = 0x3027;
Kode lerroa:  t['sevenideographicparen'] = 0x3226;
Kode lerroa:  t['seveninferior'] = 0x2087;
Kode lerroa:  t['sevenmonospace'] = 0xFF17;
Kode lerroa:  t['sevenoldstyle'] = 0xF737;
Kode lerroa:  t['sevenparen'] = 0x247A;
Kode lerroa:  t['sevenperiod'] = 0x248E;
Kode lerroa:  t['sevenpersian'] = 0x06F7;
Kode lerroa:  t['sevenroman'] = 0x2176;
Kode lerroa:  t['sevensuperior'] = 0x2077;
Kode lerroa:  t['seventeencircle'] = 0x2470;
Kode lerroa:  t['seventeenparen'] = 0x2484;
Kode lerroa:  t['seventeenperiod'] = 0x2498;
Kode lerroa:  t['seventhai'] = 0x0E57;
Kode lerroa:  t['sfthyphen'] = 0x00AD;
Kode lerroa:  t['shaarmenian'] = 0x0577;
Kode lerroa:  t['shabengali'] = 0x09B6;
Kode lerroa:  t['shacyrillic'] = 0x0448;
Kode lerroa:  t['shaddaarabic'] = 0x0651;
Kode lerroa:  t['shaddadammaarabic'] = 0xFC61;
Kode lerroa:  t['shaddadammatanarabic'] = 0xFC5E;
Kode lerroa:  t['shaddafathaarabic'] = 0xFC60;
Kode lerroa:  t['shaddakasraarabic'] = 0xFC62;
Kode lerroa:  t['shaddakasratanarabic'] = 0xFC5F;
Kode lerroa:  t['shade'] = 0x2592;
Kode lerroa:  t['shadedark'] = 0x2593;
Kode lerroa:  t['shadelight'] = 0x2591;
Kode lerroa:  t['shademedium'] = 0x2592;
Kode lerroa:  t['shadeva'] = 0x0936;
Kode lerroa:  t['shagujarati'] = 0x0AB6;
Kode lerroa:  t['shagurmukhi'] = 0x0A36;
Kode lerroa:  t['shalshelethebrew'] = 0x0593;
Kode lerroa:  t['shbopomofo'] = 0x3115;
Kode lerroa:  t['shchacyrillic'] = 0x0449;
Kode lerroa:  t['sheenarabic'] = 0x0634;
Kode lerroa:  t['sheenfinalarabic'] = 0xFEB6;
Kode lerroa:  t['sheeninitialarabic'] = 0xFEB7;
Kode lerroa:  t['sheenmedialarabic'] = 0xFEB8;
Kode lerroa:  t['sheicoptic'] = 0x03E3;
Kode lerroa:  t['sheqel'] = 0x20AA;
Kode lerroa:  t['sheqelhebrew'] = 0x20AA;
Kode lerroa:  t['sheva'] = 0x05B0;
Kode lerroa:  t['sheva115'] = 0x05B0;
Kode lerroa:  t['sheva15'] = 0x05B0;
Kode lerroa:  t['sheva22'] = 0x05B0;
Kode lerroa:  t['sheva2e'] = 0x05B0;
Kode lerroa:  t['shevahebrew'] = 0x05B0;
Kode lerroa:  t['shevanarrowhebrew'] = 0x05B0;
Kode lerroa:  t['shevaquarterhebrew'] = 0x05B0;
Kode lerroa:  t['shevawidehebrew'] = 0x05B0;
Kode lerroa:  t['shhacyrillic'] = 0x04BB;
Kode lerroa:  t['shimacoptic'] = 0x03ED;
Kode lerroa:  t['shin'] = 0x05E9;
Kode lerroa:  t['shindagesh'] = 0xFB49;
Kode lerroa:  t['shindageshhebrew'] = 0xFB49;
Kode lerroa:  t['shindageshshindot'] = 0xFB2C;
Kode lerroa:  t['shindageshshindothebrew'] = 0xFB2C;
Kode lerroa:  t['shindageshsindot'] = 0xFB2D;
Kode lerroa:  t['shindageshsindothebrew'] = 0xFB2D;
Kode lerroa:  t['shindothebrew'] = 0x05C1;
Kode lerroa:  t['shinhebrew'] = 0x05E9;
Kode lerroa:  t['shinshindot'] = 0xFB2A;
Kode lerroa:  t['shinshindothebrew'] = 0xFB2A;
Kode lerroa:  t['shinsindot'] = 0xFB2B;
Kode lerroa:  t['shinsindothebrew'] = 0xFB2B;
Kode lerroa:  t['shook'] = 0x0282;
Kode lerroa:  t['sigma'] = 0x03C3;
Kode lerroa:  t['sigma1'] = 0x03C2;
Kode lerroa:  t['sigmafinal'] = 0x03C2;
Kode lerroa:  t['sigmalunatesymbolgreek'] = 0x03F2;
Kode lerroa:  t['sihiragana'] = 0x3057;
Kode lerroa:  t['sikatakana'] = 0x30B7;
Kode lerroa:  t['sikatakanahalfwidth'] = 0xFF7C;
Kode lerroa:  t['siluqhebrew'] = 0x05BD;
Kode lerroa:  t['siluqlefthebrew'] = 0x05BD;
Kode lerroa:  t['similar'] = 0x223C;
Kode lerroa:  t['sindothebrew'] = 0x05C2;
Kode lerroa:  t['siosacirclekorean'] = 0x3274;
Kode lerroa:  t['siosaparenkorean'] = 0x3214;
Kode lerroa:  t['sioscieuckorean'] = 0x317E;
Kode lerroa:  t['sioscirclekorean'] = 0x3266;
Kode lerroa:  t['sioskiyeokkorean'] = 0x317A;
Kode lerroa:  t['sioskorean'] = 0x3145;
Kode lerroa:  t['siosnieunkorean'] = 0x317B;
Kode lerroa:  t['siosparenkorean'] = 0x3206;
Kode lerroa:  t['siospieupkorean'] = 0x317D;
Kode lerroa:  t['siostikeutkorean'] = 0x317C;
Kode lerroa:  t['six'] = 0x0036;
Kode lerroa:  t['sixarabic'] = 0x0666;
Kode lerroa:  t['sixbengali'] = 0x09EC;
Kode lerroa:  t['sixcircle'] = 0x2465;
Kode lerroa:  t['sixcircleinversesansserif'] = 0x278F;
Kode lerroa:  t['sixdeva'] = 0x096C;
Kode lerroa:  t['sixgujarati'] = 0x0AEC;
Kode lerroa:  t['sixgurmukhi'] = 0x0A6C;
Kode lerroa:  t['sixhackarabic'] = 0x0666;
Kode lerroa:  t['sixhangzhou'] = 0x3026;
Kode lerroa:  t['sixideographicparen'] = 0x3225;
Kode lerroa:  t['sixinferior'] = 0x2086;
Kode lerroa:  t['sixmonospace'] = 0xFF16;
Kode lerroa:  t['sixoldstyle'] = 0xF736;
Kode lerroa:  t['sixparen'] = 0x2479;
Kode lerroa:  t['sixperiod'] = 0x248D;
Kode lerroa:  t['sixpersian'] = 0x06F6;
Kode lerroa:  t['sixroman'] = 0x2175;
Kode lerroa:  t['sixsuperior'] = 0x2076;
Kode lerroa:  t['sixteencircle'] = 0x246F;
Kode lerroa:  t['sixteencurrencydenominatorbengali'] = 0x09F9;
Kode lerroa:  t['sixteenparen'] = 0x2483;
Kode lerroa:  t['sixteenperiod'] = 0x2497;
Kode lerroa:  t['sixthai'] = 0x0E56;
Kode lerroa:  t['slash'] = 0x002F;
Kode lerroa:  t['slashmonospace'] = 0xFF0F;
Kode lerroa:  t['slong'] = 0x017F;
Kode lerroa:  t['slongdotaccent'] = 0x1E9B;
Kode lerroa:  t['smileface'] = 0x263A;
Kode lerroa:  t['smonospace'] = 0xFF53;
Kode lerroa:  t['sofpasuqhebrew'] = 0x05C3;
Kode lerroa:  t['softhyphen'] = 0x00AD;
Kode lerroa:  t['softsigncyrillic'] = 0x044C;
Kode lerroa:  t['sohiragana'] = 0x305D;
Kode lerroa:  t['sokatakana'] = 0x30BD;
Kode lerroa:  t['sokatakanahalfwidth'] = 0xFF7F;
Kode lerroa:  t['soliduslongoverlaycmb'] = 0x0338;
Kode lerroa:  t['solidusshortoverlaycmb'] = 0x0337;
Kode lerroa:  t['sorusithai'] = 0x0E29;
Kode lerroa:  t['sosalathai'] = 0x0E28;
Kode lerroa:  t['sosothai'] = 0x0E0B;
Kode lerroa:  t['sosuathai'] = 0x0E2A;
Kode lerroa:  t['space'] = 0x0020;
Kode lerroa:  t['spacehackarabic'] = 0x0020;
Kode lerroa:  t['spade'] = 0x2660;
Kode lerroa:  t['spadesuitblack'] = 0x2660;
Kode lerroa:  t['spadesuitwhite'] = 0x2664;
Kode lerroa:  t['sparen'] = 0x24AE;
Kode lerroa:  t['squarebelowcmb'] = 0x033B;
Kode lerroa:  t['squarecc'] = 0x33C4;
Kode lerroa:  t['squarecm'] = 0x339D;
Kode lerroa:  t['squarediagonalcrosshatchfill'] = 0x25A9;
Kode lerroa:  t['squarehorizontalfill'] = 0x25A4;
Kode lerroa:  t['squarekg'] = 0x338F;
Kode lerroa:  t['squarekm'] = 0x339E;
Kode lerroa:  t['squarekmcapital'] = 0x33CE;
Kode lerroa:  t['squareln'] = 0x33D1;
Kode lerroa:  t['squarelog'] = 0x33D2;
Kode lerroa:  t['squaremg'] = 0x338E;
Kode lerroa:  t['squaremil'] = 0x33D5;
Kode lerroa:  t['squaremm'] = 0x339C;
Kode lerroa:  t['squaremsquared'] = 0x33A1;
Kode lerroa:  t['squareorthogonalcrosshatchfill'] = 0x25A6;
Kode lerroa:  t['squareupperlefttolowerrightfill'] = 0x25A7;
Kode lerroa:  t['squareupperrighttolowerleftfill'] = 0x25A8;
Kode lerroa:  t['squareverticalfill'] = 0x25A5;
Kode lerroa:  t['squarewhitewithsmallblack'] = 0x25A3;
Kode lerroa:  t['srsquare'] = 0x33DB;
Kode lerroa:  t['ssabengali'] = 0x09B7;
Kode lerroa:  t['ssadeva'] = 0x0937;
Kode lerroa:  t['ssagujarati'] = 0x0AB7;
Kode lerroa:  t['ssangcieuckorean'] = 0x3149;
Kode lerroa:  t['ssanghieuhkorean'] = 0x3185;
Kode lerroa:  t['ssangieungkorean'] = 0x3180;
Kode lerroa:  t['ssangkiyeokkorean'] = 0x3132;
Kode lerroa:  t['ssangnieunkorean'] = 0x3165;
Kode lerroa:  t['ssangpieupkorean'] = 0x3143;
Kode lerroa:  t['ssangsioskorean'] = 0x3146;
Kode lerroa:  t['ssangtikeutkorean'] = 0x3138;
Kode lerroa:  t['ssuperior'] = 0xF6F2;
Kode lerroa:  t['sterling'] = 0x00A3;
Kode lerroa:  t['sterlingmonospace'] = 0xFFE1;
Kode lerroa:  t['strokelongoverlaycmb'] = 0x0336;
Kode lerroa:  t['strokeshortoverlaycmb'] = 0x0335;
Kode lerroa:  t['subset'] = 0x2282;
Kode lerroa:  t['subsetnotequal'] = 0x228A;
Kode lerroa:  t['subsetorequal'] = 0x2286;
Kode lerroa:  t['succeeds'] = 0x227B;
Kode lerroa:  t['suchthat'] = 0x220B;
Kode lerroa:  t['suhiragana'] = 0x3059;
Kode lerroa:  t['sukatakana'] = 0x30B9;
Kode lerroa:  t['sukatakanahalfwidth'] = 0xFF7D;
Kode lerroa:  t['sukunarabic'] = 0x0652;
Kode lerroa:  t['summation'] = 0x2211;
Kode lerroa:  t['sun'] = 0x263C;
Kode lerroa:  t['superset'] = 0x2283;
Kode lerroa:  t['supersetnotequal'] = 0x228B;
Kode lerroa:  t['supersetorequal'] = 0x2287;
Kode lerroa:  t['svsquare'] = 0x33DC;
Kode lerroa:  t['syouwaerasquare'] = 0x337C;
Kode lerroa:  t['t'] = 0x0074;
Kode lerroa:  t['tabengali'] = 0x09A4;
Kode lerroa:  t['tackdown'] = 0x22A4;
Kode lerroa:  t['tackleft'] = 0x22A3;
Kode lerroa:  t['tadeva'] = 0x0924;
Kode lerroa:  t['tagujarati'] = 0x0AA4;
Kode lerroa:  t['tagurmukhi'] = 0x0A24;
Kode lerroa:  t['taharabic'] = 0x0637;
Kode lerroa:  t['tahfinalarabic'] = 0xFEC2;
Kode lerroa:  t['tahinitialarabic'] = 0xFEC3;
Kode lerroa:  t['tahiragana'] = 0x305F;
Kode lerroa:  t['tahmedialarabic'] = 0xFEC4;
Kode lerroa:  t['taisyouerasquare'] = 0x337D;
Kode lerroa:  t['takatakana'] = 0x30BF;
Kode lerroa:  t['takatakanahalfwidth'] = 0xFF80;
Kode lerroa:  t['tatweelarabic'] = 0x0640;
Kode lerroa:  t['tau'] = 0x03C4;
Kode lerroa:  t['tav'] = 0x05EA;
Kode lerroa:  t['tavdages'] = 0xFB4A;
Kode lerroa:  t['tavdagesh'] = 0xFB4A;
Kode lerroa:  t['tavdageshhebrew'] = 0xFB4A;
Kode lerroa:  t['tavhebrew'] = 0x05EA;
Kode lerroa:  t['tbar'] = 0x0167;
Kode lerroa:  t['tbopomofo'] = 0x310A;
Kode lerroa:  t['tcaron'] = 0x0165;
Kode lerroa:  t['tccurl'] = 0x02A8;
Kode lerroa:  t['tcedilla'] = 0x0163;
Kode lerroa:  t['tcheharabic'] = 0x0686;
Kode lerroa:  t['tchehfinalarabic'] = 0xFB7B;
Kode lerroa:  t['tchehinitialarabic'] = 0xFB7C;
Kode lerroa:  t['tchehmedialarabic'] = 0xFB7D;
Kode lerroa:  t['tcircle'] = 0x24E3;
Kode lerroa:  t['tcircumflexbelow'] = 0x1E71;
Kode lerroa:  t['tcommaaccent'] = 0x0163;
Kode lerroa:  t['tdieresis'] = 0x1E97;
Kode lerroa:  t['tdotaccent'] = 0x1E6B;
Kode lerroa:  t['tdotbelow'] = 0x1E6D;
Kode lerroa:  t['tecyrillic'] = 0x0442;
Kode lerroa:  t['tedescendercyrillic'] = 0x04AD;
Kode lerroa:  t['teharabic'] = 0x062A;
Kode lerroa:  t['tehfinalarabic'] = 0xFE96;
Kode lerroa:  t['tehhahinitialarabic'] = 0xFCA2;
Kode lerroa:  t['tehhahisolatedarabic'] = 0xFC0C;
Kode lerroa:  t['tehinitialarabic'] = 0xFE97;
Kode lerroa:  t['tehiragana'] = 0x3066;
Kode lerroa:  t['tehjeeminitialarabic'] = 0xFCA1;
Kode lerroa:  t['tehjeemisolatedarabic'] = 0xFC0B;
Kode lerroa:  t['tehmarbutaarabic'] = 0x0629;
Kode lerroa:  t['tehmarbutafinalarabic'] = 0xFE94;
Kode lerroa:  t['tehmedialarabic'] = 0xFE98;
Kode lerroa:  t['tehmeeminitialarabic'] = 0xFCA4;
Kode lerroa:  t['tehmeemisolatedarabic'] = 0xFC0E;
Kode lerroa:  t['tehnoonfinalarabic'] = 0xFC73;
Kode lerroa:  t['tekatakana'] = 0x30C6;
Kode lerroa:  t['tekatakanahalfwidth'] = 0xFF83;
Kode lerroa:  t['telephone'] = 0x2121;
Kode lerroa:  t['telephoneblack'] = 0x260E;
Kode lerroa:  t['telishagedolahebrew'] = 0x05A0;
Kode lerroa:  t['telishaqetanahebrew'] = 0x05A9;
Kode lerroa:  t['tencircle'] = 0x2469;
Kode lerroa:  t['tenideographicparen'] = 0x3229;
Kode lerroa:  t['tenparen'] = 0x247D;
Kode lerroa:  t['tenperiod'] = 0x2491;
Kode lerroa:  t['tenroman'] = 0x2179;
Kode lerroa:  t['tesh'] = 0x02A7;
Kode lerroa:  t['tet'] = 0x05D8;
Kode lerroa:  t['tetdagesh'] = 0xFB38;
Kode lerroa:  t['tetdageshhebrew'] = 0xFB38;
Kode lerroa:  t['tethebrew'] = 0x05D8;
Kode lerroa:  t['tetsecyrillic'] = 0x04B5;
Kode lerroa:  t['tevirhebrew'] = 0x059B;
Kode lerroa:  t['tevirlefthebrew'] = 0x059B;
Kode lerroa:  t['thabengali'] = 0x09A5;
Kode lerroa:  t['thadeva'] = 0x0925;
Kode lerroa:  t['thagujarati'] = 0x0AA5;
Kode lerroa:  t['thagurmukhi'] = 0x0A25;
Kode lerroa:  t['thalarabic'] = 0x0630;
Kode lerroa:  t['thalfinalarabic'] = 0xFEAC;
Kode lerroa:  t['thanthakhatlowleftthai'] = 0xF898;
Kode lerroa:  t['thanthakhatlowrightthai'] = 0xF897;
Kode lerroa:  t['thanthakhatthai'] = 0x0E4C;
Kode lerroa:  t['thanthakhatupperleftthai'] = 0xF896;
Kode lerroa:  t['theharabic'] = 0x062B;
Kode lerroa:  t['thehfinalarabic'] = 0xFE9A;
Kode lerroa:  t['thehinitialarabic'] = 0xFE9B;
Kode lerroa:  t['thehmedialarabic'] = 0xFE9C;
Kode lerroa:  t['thereexists'] = 0x2203;
Kode lerroa:  t['therefore'] = 0x2234;
Kode lerroa:  t['theta'] = 0x03B8;
Kode lerroa:  t['theta1'] = 0x03D1;
Kode lerroa:  t['thetasymbolgreek'] = 0x03D1;
Kode lerroa:  t['thieuthacirclekorean'] = 0x3279;
Kode lerroa:  t['thieuthaparenkorean'] = 0x3219;
Kode lerroa:  t['thieuthcirclekorean'] = 0x326B;
Kode lerroa:  t['thieuthkorean'] = 0x314C;
Kode lerroa:  t['thieuthparenkorean'] = 0x320B;
Kode lerroa:  t['thirteencircle'] = 0x246C;
Kode lerroa:  t['thirteenparen'] = 0x2480;
Kode lerroa:  t['thirteenperiod'] = 0x2494;
Kode lerroa:  t['thonangmonthothai'] = 0x0E11;
Kode lerroa:  t['thook'] = 0x01AD;
Kode lerroa:  t['thophuthaothai'] = 0x0E12;
Kode lerroa:  t['thorn'] = 0x00FE;
Kode lerroa:  t['thothahanthai'] = 0x0E17;
Kode lerroa:  t['thothanthai'] = 0x0E10;
Kode lerroa:  t['thothongthai'] = 0x0E18;
Kode lerroa:  t['thothungthai'] = 0x0E16;
Kode lerroa:  t['thousandcyrillic'] = 0x0482;
Kode lerroa:  t['thousandsseparatorarabic'] = 0x066C;
Kode lerroa:  t['thousandsseparatorpersian'] = 0x066C;
Kode lerroa:  t['three'] = 0x0033;
Kode lerroa:  t['threearabic'] = 0x0663;
Kode lerroa:  t['threebengali'] = 0x09E9;
Kode lerroa:  t['threecircle'] = 0x2462;
Kode lerroa:  t['threecircleinversesansserif'] = 0x278C;
Kode lerroa:  t['threedeva'] = 0x0969;
Kode lerroa:  t['threeeighths'] = 0x215C;
Kode lerroa:  t['threegujarati'] = 0x0AE9;
Kode lerroa:  t['threegurmukhi'] = 0x0A69;
Kode lerroa:  t['threehackarabic'] = 0x0663;
Kode lerroa:  t['threehangzhou'] = 0x3023;
Kode lerroa:  t['threeideographicparen'] = 0x3222;
Kode lerroa:  t['threeinferior'] = 0x2083;
Kode lerroa:  t['threemonospace'] = 0xFF13;
Kode lerroa:  t['threenumeratorbengali'] = 0x09F6;
Kode lerroa:  t['threeoldstyle'] = 0xF733;
Kode lerroa:  t['threeparen'] = 0x2476;
Kode lerroa:  t['threeperiod'] = 0x248A;
Kode lerroa:  t['threepersian'] = 0x06F3;
Kode lerroa:  t['threequarters'] = 0x00BE;
Kode lerroa:  t['threequartersemdash'] = 0xF6DE;
Kode lerroa:  t['threeroman'] = 0x2172;
Kode lerroa:  t['threesuperior'] = 0x00B3;
Kode lerroa:  t['threethai'] = 0x0E53;
Kode lerroa:  t['thzsquare'] = 0x3394;
Kode lerroa:  t['tihiragana'] = 0x3061;
Kode lerroa:  t['tikatakana'] = 0x30C1;
Kode lerroa:  t['tikatakanahalfwidth'] = 0xFF81;
Kode lerroa:  t['tikeutacirclekorean'] = 0x3270;
Kode lerroa:  t['tikeutaparenkorean'] = 0x3210;
Kode lerroa:  t['tikeutcirclekorean'] = 0x3262;
Kode lerroa:  t['tikeutkorean'] = 0x3137;
Kode lerroa:  t['tikeutparenkorean'] = 0x3202;
Kode lerroa:  t['tilde'] = 0x02DC;
Kode lerroa:  t['tildebelowcmb'] = 0x0330;
Kode lerroa:  t['tildecmb'] = 0x0303;
Kode lerroa:  t['tildecomb'] = 0x0303;
Kode lerroa:  t['tildedoublecmb'] = 0x0360;
Kode lerroa:  t['tildeoperator'] = 0x223C;
Kode lerroa:  t['tildeoverlaycmb'] = 0x0334;
Kode lerroa:  t['tildeverticalcmb'] = 0x033E;
Kode lerroa:  t['timescircle'] = 0x2297;
Kode lerroa:  t['tipehahebrew'] = 0x0596;
Kode lerroa:  t['tipehalefthebrew'] = 0x0596;
Kode lerroa:  t['tippigurmukhi'] = 0x0A70;
Kode lerroa:  t['titlocyrilliccmb'] = 0x0483;
Kode lerroa:  t['tiwnarmenian'] = 0x057F;
Kode lerroa:  t['tlinebelow'] = 0x1E6F;
Kode lerroa:  t['tmonospace'] = 0xFF54;
Kode lerroa:  t['toarmenian'] = 0x0569;
Kode lerroa:  t['tohiragana'] = 0x3068;
Kode lerroa:  t['tokatakana'] = 0x30C8;
Kode lerroa:  t['tokatakanahalfwidth'] = 0xFF84;
Kode lerroa:  t['tonebarextrahighmod'] = 0x02E5;
Kode lerroa:  t['tonebarextralowmod'] = 0x02E9;
Kode lerroa:  t['tonebarhighmod'] = 0x02E6;
Kode lerroa:  t['tonebarlowmod'] = 0x02E8;
Kode lerroa:  t['tonebarmidmod'] = 0x02E7;
Kode lerroa:  t['tonefive'] = 0x01BD;
Kode lerroa:  t['tonesix'] = 0x0185;
Kode lerroa:  t['tonetwo'] = 0x01A8;
Kode lerroa:  t['tonos'] = 0x0384;
Kode lerroa:  t['tonsquare'] = 0x3327;
Kode lerroa:  t['topatakthai'] = 0x0E0F;
Kode lerroa:  t['tortoiseshellbracketleft'] = 0x3014;
Kode lerroa:  t['tortoiseshellbracketleftsmall'] = 0xFE5D;
Kode lerroa:  t['tortoiseshellbracketleftvertical'] = 0xFE39;
Kode lerroa:  t['tortoiseshellbracketright'] = 0x3015;
Kode lerroa:  t['tortoiseshellbracketrightsmall'] = 0xFE5E;
Kode lerroa:  t['tortoiseshellbracketrightvertical'] = 0xFE3A;
Kode lerroa:  t['totaothai'] = 0x0E15;
Kode lerroa:  t['tpalatalhook'] = 0x01AB;
Kode lerroa:  t['tparen'] = 0x24AF;
Kode lerroa:  t['trademark'] = 0x2122;
Kode lerroa:  t['trademarksans'] = 0xF8EA;
Kode lerroa:  t['trademarkserif'] = 0xF6DB;
Kode lerroa:  t['tretroflexhook'] = 0x0288;
Kode lerroa:  t['triagdn'] = 0x25BC;
Kode lerroa:  t['triaglf'] = 0x25C4;
Kode lerroa:  t['triagrt'] = 0x25BA;
Kode lerroa:  t['triagup'] = 0x25B2;
Kode lerroa:  t['ts'] = 0x02A6;
Kode lerroa:  t['tsadi'] = 0x05E6;
Kode lerroa:  t['tsadidagesh'] = 0xFB46;
Kode lerroa:  t['tsadidageshhebrew'] = 0xFB46;
Kode lerroa:  t['tsadihebrew'] = 0x05E6;
Kode lerroa:  t['tsecyrillic'] = 0x0446;
Kode lerroa:  t['tsere'] = 0x05B5;
Kode lerroa:  t['tsere12'] = 0x05B5;
Kode lerroa:  t['tsere1e'] = 0x05B5;
Kode lerroa:  t['tsere2b'] = 0x05B5;
Kode lerroa:  t['tserehebrew'] = 0x05B5;
Kode lerroa:  t['tserenarrowhebrew'] = 0x05B5;
Kode lerroa:  t['tserequarterhebrew'] = 0x05B5;
Kode lerroa:  t['tserewidehebrew'] = 0x05B5;
Kode lerroa:  t['tshecyrillic'] = 0x045B;
Kode lerroa:  t['tsuperior'] = 0xF6F3;
Kode lerroa:  t['ttabengali'] = 0x099F;
Kode lerroa:  t['ttadeva'] = 0x091F;
Kode lerroa:  t['ttagujarati'] = 0x0A9F;
Kode lerroa:  t['ttagurmukhi'] = 0x0A1F;
Kode lerroa:  t['tteharabic'] = 0x0679;
Kode lerroa:  t['ttehfinalarabic'] = 0xFB67;
Kode lerroa:  t['ttehinitialarabic'] = 0xFB68;
Kode lerroa:  t['ttehmedialarabic'] = 0xFB69;
Kode lerroa:  t['tthabengali'] = 0x09A0;
Kode lerroa:  t['tthadeva'] = 0x0920;
Kode lerroa:  t['tthagujarati'] = 0x0AA0;
Kode lerroa:  t['tthagurmukhi'] = 0x0A20;
Kode lerroa:  t['tturned'] = 0x0287;
Kode lerroa:  t['tuhiragana'] = 0x3064;
Kode lerroa:  t['tukatakana'] = 0x30C4;
Kode lerroa:  t['tukatakanahalfwidth'] = 0xFF82;
Kode lerroa:  t['tusmallhiragana'] = 0x3063;
Kode lerroa:  t['tusmallkatakana'] = 0x30C3;
Kode lerroa:  t['tusmallkatakanahalfwidth'] = 0xFF6F;
Kode lerroa:  t['twelvecircle'] = 0x246B;
Kode lerroa:  t['twelveparen'] = 0x247F;
Kode lerroa:  t['twelveperiod'] = 0x2493;
Kode lerroa:  t['twelveroman'] = 0x217B;
Kode lerroa:  t['twentycircle'] = 0x2473;
Kode lerroa:  t['twentyhangzhou'] = 0x5344;
Kode lerroa:  t['twentyparen'] = 0x2487;
Kode lerroa:  t['twentyperiod'] = 0x249B;
Kode lerroa:  t['two'] = 0x0032;
Kode lerroa:  t['twoarabic'] = 0x0662;
Kode lerroa:  t['twobengali'] = 0x09E8;
Kode lerroa:  t['twocircle'] = 0x2461;
Kode lerroa:  t['twocircleinversesansserif'] = 0x278B;
Kode lerroa:  t['twodeva'] = 0x0968;
Kode lerroa:  t['twodotenleader'] = 0x2025;
Kode lerroa:  t['twodotleader'] = 0x2025;
Kode lerroa:  t['twodotleadervertical'] = 0xFE30;
Kode lerroa:  t['twogujarati'] = 0x0AE8;
Kode lerroa:  t['twogurmukhi'] = 0x0A68;
Kode lerroa:  t['twohackarabic'] = 0x0662;
Kode lerroa:  t['twohangzhou'] = 0x3022;
Kode lerroa:  t['twoideographicparen'] = 0x3221;
Kode lerroa:  t['twoinferior'] = 0x2082;
Kode lerroa:  t['twomonospace'] = 0xFF12;
Kode lerroa:  t['twonumeratorbengali'] = 0x09F5;
Kode lerroa:  t['twooldstyle'] = 0xF732;
Kode lerroa:  t['twoparen'] = 0x2475;
Kode lerroa:  t['twoperiod'] = 0x2489;
Kode lerroa:  t['twopersian'] = 0x06F2;
Kode lerroa:  t['tworoman'] = 0x2171;
Kode lerroa:  t['twostroke'] = 0x01BB;
Kode lerroa:  t['twosuperior'] = 0x00B2;
Kode lerroa:  t['twothai'] = 0x0E52;
Kode lerroa:  t['twothirds'] = 0x2154;
Kode lerroa:  t['u'] = 0x0075;
Kode lerroa:  t['uacute'] = 0x00FA;
Kode lerroa:  t['ubar'] = 0x0289;
Kode lerroa:  t['ubengali'] = 0x0989;
Kode lerroa:  t['ubopomofo'] = 0x3128;
Kode lerroa:  t['ubreve'] = 0x016D;
Kode lerroa:  t['ucaron'] = 0x01D4;
Kode lerroa:  t['ucircle'] = 0x24E4;
Kode lerroa:  t['ucircumflex'] = 0x00FB;
Kode lerroa:  t['ucircumflexbelow'] = 0x1E77;
Kode lerroa:  t['ucyrillic'] = 0x0443;
Kode lerroa:  t['udattadeva'] = 0x0951;
Kode lerroa:  t['udblacute'] = 0x0171;
Kode lerroa:  t['udblgrave'] = 0x0215;
Kode lerroa:  t['udeva'] = 0x0909;
Kode lerroa:  t['udieresis'] = 0x00FC;
Kode lerroa:  t['udieresisacute'] = 0x01D8;
Kode lerroa:  t['udieresisbelow'] = 0x1E73;
Kode lerroa:  t['udieresiscaron'] = 0x01DA;
Kode lerroa:  t['udieresiscyrillic'] = 0x04F1;
Kode lerroa:  t['udieresisgrave'] = 0x01DC;
Kode lerroa:  t['udieresismacron'] = 0x01D6;
Kode lerroa:  t['udotbelow'] = 0x1EE5;
Kode lerroa:  t['ugrave'] = 0x00F9;
Kode lerroa:  t['ugujarati'] = 0x0A89;
Kode lerroa:  t['ugurmukhi'] = 0x0A09;
Kode lerroa:  t['uhiragana'] = 0x3046;
Kode lerroa:  t['uhookabove'] = 0x1EE7;
Kode lerroa:  t['uhorn'] = 0x01B0;
Kode lerroa:  t['uhornacute'] = 0x1EE9;
Kode lerroa:  t['uhorndotbelow'] = 0x1EF1;
Kode lerroa:  t['uhorngrave'] = 0x1EEB;
Kode lerroa:  t['uhornhookabove'] = 0x1EED;
Kode lerroa:  t['uhorntilde'] = 0x1EEF;
Kode lerroa:  t['uhungarumlaut'] = 0x0171;
Kode lerroa:  t['uhungarumlautcyrillic'] = 0x04F3;
Kode lerroa:  t['uinvertedbreve'] = 0x0217;
Kode lerroa:  t['ukatakana'] = 0x30A6;
Kode lerroa:  t['ukatakanahalfwidth'] = 0xFF73;
Kode lerroa:  t['ukcyrillic'] = 0x0479;
Kode lerroa:  t['ukorean'] = 0x315C;
Kode lerroa:  t['umacron'] = 0x016B;
Kode lerroa:  t['umacroncyrillic'] = 0x04EF;
Kode lerroa:  t['umacrondieresis'] = 0x1E7B;
Kode lerroa:  t['umatragurmukhi'] = 0x0A41;
Kode lerroa:  t['umonospace'] = 0xFF55;
Kode lerroa:  t['underscore'] = 0x005F;
Kode lerroa:  t['underscoredbl'] = 0x2017;
Kode lerroa:  t['underscoremonospace'] = 0xFF3F;
Kode lerroa:  t['underscorevertical'] = 0xFE33;
Kode lerroa:  t['underscorewavy'] = 0xFE4F;
Kode lerroa:  t['union'] = 0x222A;
Kode lerroa:  t['universal'] = 0x2200;
Kode lerroa:  t['uogonek'] = 0x0173;
Kode lerroa:  t['uparen'] = 0x24B0;
Kode lerroa:  t['upblock'] = 0x2580;
Kode lerroa:  t['upperdothebrew'] = 0x05C4;
Kode lerroa:  t['upsilon'] = 0x03C5;
Kode lerroa:  t['upsilondieresis'] = 0x03CB;
Kode lerroa:  t['upsilondieresistonos'] = 0x03B0;
Kode lerroa:  t['upsilonlatin'] = 0x028A;
Kode lerroa:  t['upsilontonos'] = 0x03CD;
Kode lerroa:  t['uptackbelowcmb'] = 0x031D;
Kode lerroa:  t['uptackmod'] = 0x02D4;
Kode lerroa:  t['uragurmukhi'] = 0x0A73;
Kode lerroa:  t['uring'] = 0x016F;
Kode lerroa:  t['ushortcyrillic'] = 0x045E;
Kode lerroa:  t['usmallhiragana'] = 0x3045;
Kode lerroa:  t['usmallkatakana'] = 0x30A5;
Kode lerroa:  t['usmallkatakanahalfwidth'] = 0xFF69;
Kode lerroa:  t['ustraightcyrillic'] = 0x04AF;
Kode lerroa:  t['ustraightstrokecyrillic'] = 0x04B1;
Kode lerroa:  t['utilde'] = 0x0169;
Kode lerroa:  t['utildeacute'] = 0x1E79;
Kode lerroa:  t['utildebelow'] = 0x1E75;
Kode lerroa:  t['uubengali'] = 0x098A;
Kode lerroa:  t['uudeva'] = 0x090A;
Kode lerroa:  t['uugujarati'] = 0x0A8A;
Kode lerroa:  t['uugurmukhi'] = 0x0A0A;
Kode lerroa:  t['uumatragurmukhi'] = 0x0A42;
Kode lerroa:  t['uuvowelsignbengali'] = 0x09C2;
Kode lerroa:  t['uuvowelsigndeva'] = 0x0942;
Kode lerroa:  t['uuvowelsigngujarati'] = 0x0AC2;
Kode lerroa:  t['uvowelsignbengali'] = 0x09C1;
Kode lerroa:  t['uvowelsigndeva'] = 0x0941;
Kode lerroa:  t['uvowelsigngujarati'] = 0x0AC1;
Kode lerroa:  t['v'] = 0x0076;
Kode lerroa:  t['vadeva'] = 0x0935;
Kode lerroa:  t['vagujarati'] = 0x0AB5;
Kode lerroa:  t['vagurmukhi'] = 0x0A35;
Kode lerroa:  t['vakatakana'] = 0x30F7;
Kode lerroa:  t['vav'] = 0x05D5;
Kode lerroa:  t['vavdagesh'] = 0xFB35;
Kode lerroa:  t['vavdagesh65'] = 0xFB35;
Kode lerroa:  t['vavdageshhebrew'] = 0xFB35;
Kode lerroa:  t['vavhebrew'] = 0x05D5;
Kode lerroa:  t['vavholam'] = 0xFB4B;
Kode lerroa:  t['vavholamhebrew'] = 0xFB4B;
Kode lerroa:  t['vavvavhebrew'] = 0x05F0;
Kode lerroa:  t['vavyodhebrew'] = 0x05F1;
Kode lerroa:  t['vcircle'] = 0x24E5;
Kode lerroa:  t['vdotbelow'] = 0x1E7F;
Kode lerroa:  t['vecyrillic'] = 0x0432;
Kode lerroa:  t['veharabic'] = 0x06A4;
Kode lerroa:  t['vehfinalarabic'] = 0xFB6B;
Kode lerroa:  t['vehinitialarabic'] = 0xFB6C;
Kode lerroa:  t['vehmedialarabic'] = 0xFB6D;
Kode lerroa:  t['vekatakana'] = 0x30F9;
Kode lerroa:  t['venus'] = 0x2640;
Kode lerroa:  t['verticalbar'] = 0x007C;
Kode lerroa:  t['verticallineabovecmb'] = 0x030D;
Kode lerroa:  t['verticallinebelowcmb'] = 0x0329;
Kode lerroa:  t['verticallinelowmod'] = 0x02CC;
Kode lerroa:  t['verticallinemod'] = 0x02C8;
Kode lerroa:  t['vewarmenian'] = 0x057E;
Kode lerroa:  t['vhook'] = 0x028B;
Kode lerroa:  t['vikatakana'] = 0x30F8;
Kode lerroa:  t['viramabengali'] = 0x09CD;
Kode lerroa:  t['viramadeva'] = 0x094D;
Kode lerroa:  t['viramagujarati'] = 0x0ACD;
Kode lerroa:  t['visargabengali'] = 0x0983;
Kode lerroa:  t['visargadeva'] = 0x0903;
Kode lerroa:  t['visargagujarati'] = 0x0A83;
Kode lerroa:  t['vmonospace'] = 0xFF56;
Kode lerroa:  t['voarmenian'] = 0x0578;
Kode lerroa:  t['voicediterationhiragana'] = 0x309E;
Kode lerroa:  t['voicediterationkatakana'] = 0x30FE;
Kode lerroa:  t['voicedmarkkana'] = 0x309B;
Kode lerroa:  t['voicedmarkkanahalfwidth'] = 0xFF9E;
Kode lerroa:  t['vokatakana'] = 0x30FA;
Kode lerroa:  t['vparen'] = 0x24B1;
Kode lerroa:  t['vtilde'] = 0x1E7D;
Kode lerroa:  t['vturned'] = 0x028C;
Kode lerroa:  t['vuhiragana'] = 0x3094;
Kode lerroa:  t['vukatakana'] = 0x30F4;
Kode lerroa:  t['w'] = 0x0077;
Kode lerroa:  t['wacute'] = 0x1E83;
Kode lerroa:  t['waekorean'] = 0x3159;
Kode lerroa:  t['wahiragana'] = 0x308F;
Kode lerroa:  t['wakatakana'] = 0x30EF;
Kode lerroa:  t['wakatakanahalfwidth'] = 0xFF9C;
Kode lerroa:  t['wakorean'] = 0x3158;
Kode lerroa:  t['wasmallhiragana'] = 0x308E;
Kode lerroa:  t['wasmallkatakana'] = 0x30EE;
Kode lerroa:  t['wattosquare'] = 0x3357;
Kode lerroa:  t['wavedash'] = 0x301C;
Kode lerroa:  t['wavyunderscorevertical'] = 0xFE34;
Kode lerroa:  t['wawarabic'] = 0x0648;
Kode lerroa:  t['wawfinalarabic'] = 0xFEEE;
Kode lerroa:  t['wawhamzaabovearabic'] = 0x0624;
Kode lerroa:  t['wawhamzaabovefinalarabic'] = 0xFE86;
Kode lerroa:  t['wbsquare'] = 0x33DD;
Kode lerroa:  t['wcircle'] = 0x24E6;
Kode lerroa:  t['wcircumflex'] = 0x0175;
Kode lerroa:  t['wdieresis'] = 0x1E85;
Kode lerroa:  t['wdotaccent'] = 0x1E87;
Kode lerroa:  t['wdotbelow'] = 0x1E89;
Kode lerroa:  t['wehiragana'] = 0x3091;
Kode lerroa:  t['weierstrass'] = 0x2118;
Kode lerroa:  t['wekatakana'] = 0x30F1;
Kode lerroa:  t['wekorean'] = 0x315E;
Kode lerroa:  t['weokorean'] = 0x315D;
Kode lerroa:  t['wgrave'] = 0x1E81;
Kode lerroa:  t['whitebullet'] = 0x25E6;
Kode lerroa:  t['whitecircle'] = 0x25CB;
Kode lerroa:  t['whitecircleinverse'] = 0x25D9;
Kode lerroa:  t['whitecornerbracketleft'] = 0x300E;
Kode lerroa:  t['whitecornerbracketleftvertical'] = 0xFE43;
Kode lerroa:  t['whitecornerbracketright'] = 0x300F;
Kode lerroa:  t['whitecornerbracketrightvertical'] = 0xFE44;
Kode lerroa:  t['whitediamond'] = 0x25C7;
Kode lerroa:  t['whitediamondcontainingblacksmalldiamond'] = 0x25C8;
Kode lerroa:  t['whitedownpointingsmalltriangle'] = 0x25BF;
Kode lerroa:  t['whitedownpointingtriangle'] = 0x25BD;
Kode lerroa:  t['whiteleftpointingsmalltriangle'] = 0x25C3;
Kode lerroa:  t['whiteleftpointingtriangle'] = 0x25C1;
Kode lerroa:  t['whitelenticularbracketleft'] = 0x3016;
Kode lerroa:  t['whitelenticularbracketright'] = 0x3017;
Kode lerroa:  t['whiterightpointingsmalltriangle'] = 0x25B9;
Kode lerroa:  t['whiterightpointingtriangle'] = 0x25B7;
Kode lerroa:  t['whitesmallsquare'] = 0x25AB;
Kode lerroa:  t['whitesmilingface'] = 0x263A;
Kode lerroa:  t['whitesquare'] = 0x25A1;
Kode lerroa:  t['whitestar'] = 0x2606;
Kode lerroa:  t['whitetelephone'] = 0x260F;
Kode lerroa:  t['whitetortoiseshellbracketleft'] = 0x3018;
Kode lerroa:  t['whitetortoiseshellbracketright'] = 0x3019;
Kode lerroa:  t['whiteuppointingsmalltriangle'] = 0x25B5;
Kode lerroa:  t['whiteuppointingtriangle'] = 0x25B3;
Kode lerroa:  t['wihiragana'] = 0x3090;
Kode lerroa:  t['wikatakana'] = 0x30F0;
Kode lerroa:  t['wikorean'] = 0x315F;
Kode lerroa:  t['wmonospace'] = 0xFF57;
Kode lerroa:  t['wohiragana'] = 0x3092;
Kode lerroa:  t['wokatakana'] = 0x30F2;
Kode lerroa:  t['wokatakanahalfwidth'] = 0xFF66;
Kode lerroa:  t['won'] = 0x20A9;
Kode lerroa:  t['wonmonospace'] = 0xFFE6;
Kode lerroa:  t['wowaenthai'] = 0x0E27;
Kode lerroa:  t['wparen'] = 0x24B2;
Kode lerroa:  t['wring'] = 0x1E98;
Kode lerroa:  t['wsuperior'] = 0x02B7;
Kode lerroa:  t['wturned'] = 0x028D;
Kode lerroa:  t['wynn'] = 0x01BF;
Kode lerroa:  t['x'] = 0x0078;
Kode lerroa:  t['xabovecmb'] = 0x033D;
Kode lerroa:  t['xbopomofo'] = 0x3112;
Kode lerroa:  t['xcircle'] = 0x24E7;
Kode lerroa:  t['xdieresis'] = 0x1E8D;
Kode lerroa:  t['xdotaccent'] = 0x1E8B;
Kode lerroa:  t['xeharmenian'] = 0x056D;
Kode lerroa:  t['xi'] = 0x03BE;
Kode lerroa:  t['xmonospace'] = 0xFF58;
Kode lerroa:  t['xparen'] = 0x24B3;
Kode lerroa:  t['xsuperior'] = 0x02E3;
Kode lerroa:  t['y'] = 0x0079;
Kode lerroa:  t['yaadosquare'] = 0x334E;
Kode lerroa:  t['yabengali'] = 0x09AF;
Kode lerroa:  t['yacute'] = 0x00FD;
Kode lerroa:  t['yadeva'] = 0x092F;
Kode lerroa:  t['yaekorean'] = 0x3152;
Kode lerroa:  t['yagujarati'] = 0x0AAF;
Kode lerroa:  t['yagurmukhi'] = 0x0A2F;
Kode lerroa:  t['yahiragana'] = 0x3084;
Kode lerroa:  t['yakatakana'] = 0x30E4;
Kode lerroa:  t['yakatakanahalfwidth'] = 0xFF94;
Kode lerroa:  t['yakorean'] = 0x3151;
Kode lerroa:  t['yamakkanthai'] = 0x0E4E;
Kode lerroa:  t['yasmallhiragana'] = 0x3083;
Kode lerroa:  t['yasmallkatakana'] = 0x30E3;
Kode lerroa:  t['yasmallkatakanahalfwidth'] = 0xFF6C;
Kode lerroa:  t['yatcyrillic'] = 0x0463;
Kode lerroa:  t['ycircle'] = 0x24E8;
Kode lerroa:  t['ycircumflex'] = 0x0177;
Kode lerroa:  t['ydieresis'] = 0x00FF;
Kode lerroa:  t['ydotaccent'] = 0x1E8F;
Kode lerroa:  t['ydotbelow'] = 0x1EF5;
Kode lerroa:  t['yeharabic'] = 0x064A;
Kode lerroa:  t['yehbarreearabic'] = 0x06D2;
Kode lerroa:  t['yehbarreefinalarabic'] = 0xFBAF;
Kode lerroa:  t['yehfinalarabic'] = 0xFEF2;
Kode lerroa:  t['yehhamzaabovearabic'] = 0x0626;
Kode lerroa:  t['yehhamzaabovefinalarabic'] = 0xFE8A;
Kode lerroa:  t['yehhamzaaboveinitialarabic'] = 0xFE8B;
Kode lerroa:  t['yehhamzaabovemedialarabic'] = 0xFE8C;
Kode lerroa:  t['yehinitialarabic'] = 0xFEF3;
Kode lerroa:  t['yehmedialarabic'] = 0xFEF4;
Kode lerroa:  t['yehmeeminitialarabic'] = 0xFCDD;
Kode lerroa:  t['yehmeemisolatedarabic'] = 0xFC58;
Kode lerroa:  t['yehnoonfinalarabic'] = 0xFC94;
Kode lerroa:  t['yehthreedotsbelowarabic'] = 0x06D1;
Kode lerroa:  t['yekorean'] = 0x3156;
Kode lerroa:  t['yen'] = 0x00A5;
Kode lerroa:  t['yenmonospace'] = 0xFFE5;
Kode lerroa:  t['yeokorean'] = 0x3155;
Kode lerroa:  t['yeorinhieuhkorean'] = 0x3186;
Kode lerroa:  t['yerahbenyomohebrew'] = 0x05AA;
Kode lerroa:  t['yerahbenyomolefthebrew'] = 0x05AA;
Kode lerroa:  t['yericyrillic'] = 0x044B;
Kode lerroa:  t['yerudieresiscyrillic'] = 0x04F9;
Kode lerroa:  t['yesieungkorean'] = 0x3181;
Kode lerroa:  t['yesieungpansioskorean'] = 0x3183;
Kode lerroa:  t['yesieungsioskorean'] = 0x3182;
Kode lerroa:  t['yetivhebrew'] = 0x059A;
Kode lerroa:  t['ygrave'] = 0x1EF3;
Kode lerroa:  t['yhook'] = 0x01B4;
Kode lerroa:  t['yhookabove'] = 0x1EF7;
Kode lerroa:  t['yiarmenian'] = 0x0575;
Kode lerroa:  t['yicyrillic'] = 0x0457;
Kode lerroa:  t['yikorean'] = 0x3162;
Kode lerroa:  t['yinyang'] = 0x262F;
Kode lerroa:  t['yiwnarmenian'] = 0x0582;
Kode lerroa:  t['ymonospace'] = 0xFF59;
Kode lerroa:  t['yod'] = 0x05D9;
Kode lerroa:  t['yoddagesh'] = 0xFB39;
Kode lerroa:  t['yoddageshhebrew'] = 0xFB39;
Kode lerroa:  t['yodhebrew'] = 0x05D9;
Kode lerroa:  t['yodyodhebrew'] = 0x05F2;
Kode lerroa:  t['yodyodpatahhebrew'] = 0xFB1F;
Kode lerroa:  t['yohiragana'] = 0x3088;
Kode lerroa:  t['yoikorean'] = 0x3189;
Kode lerroa:  t['yokatakana'] = 0x30E8;
Kode lerroa:  t['yokatakanahalfwidth'] = 0xFF96;
Kode lerroa:  t['yokorean'] = 0x315B;
Kode lerroa:  t['yosmallhiragana'] = 0x3087;
Kode lerroa:  t['yosmallkatakana'] = 0x30E7;
Kode lerroa:  t['yosmallkatakanahalfwidth'] = 0xFF6E;
Kode lerroa:  t['yotgreek'] = 0x03F3;
Kode lerroa:  t['yoyaekorean'] = 0x3188;
Kode lerroa:  t['yoyakorean'] = 0x3187;
Kode lerroa:  t['yoyakthai'] = 0x0E22;
Kode lerroa:  t['yoyingthai'] = 0x0E0D;
Kode lerroa:  t['yparen'] = 0x24B4;
Kode lerroa:  t['ypogegrammeni'] = 0x037A;
Kode lerroa:  t['ypogegrammenigreekcmb'] = 0x0345;
Kode lerroa:  t['yr'] = 0x01A6;
Kode lerroa:  t['yring'] = 0x1E99;
Kode lerroa:  t['ysuperior'] = 0x02B8;
Kode lerroa:  t['ytilde'] = 0x1EF9;
Kode lerroa:  t['yturned'] = 0x028E;
Kode lerroa:  t['yuhiragana'] = 0x3086;
Kode lerroa:  t['yuikorean'] = 0x318C;
Kode lerroa:  t['yukatakana'] = 0x30E6;
Kode lerroa:  t['yukatakanahalfwidth'] = 0xFF95;
Kode lerroa:  t['yukorean'] = 0x3160;
Kode lerroa:  t['yusbigcyrillic'] = 0x046B;
Kode lerroa:  t['yusbigiotifiedcyrillic'] = 0x046D;
Kode lerroa:  t['yuslittlecyrillic'] = 0x0467;
Kode lerroa:  t['yuslittleiotifiedcyrillic'] = 0x0469;
Kode lerroa:  t['yusmallhiragana'] = 0x3085;
Kode lerroa:  t['yusmallkatakana'] = 0x30E5;
Kode lerroa:  t['yusmallkatakanahalfwidth'] = 0xFF6D;
Kode lerroa:  t['yuyekorean'] = 0x318B;
Kode lerroa:  t['yuyeokorean'] = 0x318A;
Kode lerroa:  t['yyabengali'] = 0x09DF;
Kode lerroa:  t['yyadeva'] = 0x095F;
Kode lerroa:  t['z'] = 0x007A;
Kode lerroa:  t['zaarmenian'] = 0x0566;
Kode lerroa:  t['zacute'] = 0x017A;
Kode lerroa:  t['zadeva'] = 0x095B;
Kode lerroa:  t['zagurmukhi'] = 0x0A5B;
Kode lerroa:  t['zaharabic'] = 0x0638;
Kode lerroa:  t['zahfinalarabic'] = 0xFEC6;
Kode lerroa:  t['zahinitialarabic'] = 0xFEC7;
Kode lerroa:  t['zahiragana'] = 0x3056;
Kode lerroa:  t['zahmedialarabic'] = 0xFEC8;
Kode lerroa:  t['zainarabic'] = 0x0632;
Kode lerroa:  t['zainfinalarabic'] = 0xFEB0;
Kode lerroa:  t['zakatakana'] = 0x30B6;
Kode lerroa:  t['zaqefgadolhebrew'] = 0x0595;
Kode lerroa:  t['zaqefqatanhebrew'] = 0x0594;
Kode lerroa:  t['zarqahebrew'] = 0x0598;
Kode lerroa:  t['zayin'] = 0x05D6;
Kode lerroa:  t['zayindagesh'] = 0xFB36;
Kode lerroa:  t['zayindageshhebrew'] = 0xFB36;
Kode lerroa:  t['zayinhebrew'] = 0x05D6;
Kode lerroa:  t['zbopomofo'] = 0x3117;
Kode lerroa:  t['zcaron'] = 0x017E;
Kode lerroa:  t['zcircle'] = 0x24E9;
Kode lerroa:  t['zcircumflex'] = 0x1E91;
Kode lerroa:  t['zcurl'] = 0x0291;
Kode lerroa:  t['zdot'] = 0x017C;
Kode lerroa:  t['zdotaccent'] = 0x017C;
Kode lerroa:  t['zdotbelow'] = 0x1E93;
Kode lerroa:  t['zecyrillic'] = 0x0437;
Kode lerroa:  t['zedescendercyrillic'] = 0x0499;
Kode lerroa:  t['zedieresiscyrillic'] = 0x04DF;
Kode lerroa:  t['zehiragana'] = 0x305C;
Kode lerroa:  t['zekatakana'] = 0x30BC;
Kode lerroa:  t['zero'] = 0x0030;
Kode lerroa:  t['zeroarabic'] = 0x0660;
Kode lerroa:  t['zerobengali'] = 0x09E6;
Kode lerroa:  t['zerodeva'] = 0x0966;
Kode lerroa:  t['zerogujarati'] = 0x0AE6;
Kode lerroa:  t['zerogurmukhi'] = 0x0A66;
Kode lerroa:  t['zerohackarabic'] = 0x0660;
Kode lerroa:  t['zeroinferior'] = 0x2080;
Kode lerroa:  t['zeromonospace'] = 0xFF10;
Kode lerroa:  t['zerooldstyle'] = 0xF730;
Kode lerroa:  t['zeropersian'] = 0x06F0;
Kode lerroa:  t['zerosuperior'] = 0x2070;
Kode lerroa:  t['zerothai'] = 0x0E50;
Kode lerroa:  t['zerowidthjoiner'] = 0xFEFF;
Kode lerroa:  t['zerowidthnonjoiner'] = 0x200C;
Kode lerroa:  t['zerowidthspace'] = 0x200B;
Kode lerroa:  t['zeta'] = 0x03B6;
Kode lerroa:  t['zhbopomofo'] = 0x3113;
Kode lerroa:  t['zhearmenian'] = 0x056A;
Kode lerroa:  t['zhebrevecyrillic'] = 0x04C2;
Kode lerroa:  t['zhecyrillic'] = 0x0436;
Kode lerroa:  t['zhedescendercyrillic'] = 0x0497;
Kode lerroa:  t['zhedieresiscyrillic'] = 0x04DD;
Kode lerroa:  t['zihiragana'] = 0x3058;
Kode lerroa:  t['zikatakana'] = 0x30B8;
Kode lerroa:  t['zinorhebrew'] = 0x05AE;
Kode lerroa:  t['zlinebelow'] = 0x1E95;
Kode lerroa:  t['zmonospace'] = 0xFF5A;
Kode lerroa:  t['zohiragana'] = 0x305E;
Kode lerroa:  t['zokatakana'] = 0x30BE;
Kode lerroa:  t['zparen'] = 0x24B5;
Kode lerroa:  t['zretroflexhook'] = 0x0290;
Kode lerroa:  t['zstroke'] = 0x01B6;
Kode lerroa:  t['zuhiragana'] = 0x305A;
Kode lerroa:  t['zukatakana'] = 0x30BA;
Kode lerroa:  t['.notdef'] = 0x0000;
Kode lerroa:  t['angbracketleftbig'] = 0x2329;
Kode lerroa:  t['angbracketleftBig'] = 0x2329;
Kode lerroa:  t['angbracketleftbigg'] = 0x2329;
Kode lerroa:  t['angbracketleftBigg'] = 0x2329;
Kode lerroa:  t['angbracketrightBig'] = 0x232A;
Kode lerroa:  t['angbracketrightbig'] = 0x232A;
Kode lerroa:  t['angbracketrightBigg'] = 0x232A;
Kode lerroa:  t['angbracketrightbigg'] = 0x232A;
Kode lerroa:  t['arrowhookleft'] = 0x21AA;
Kode lerroa:  t['arrowhookright'] = 0x21A9;
Kode lerroa:  t['arrowlefttophalf'] = 0x21BC;
Kode lerroa:  t['arrowleftbothalf'] = 0x21BD;
Kode lerroa:  t['arrownortheast'] = 0x2197;
Kode lerroa:  t['arrownorthwest'] = 0x2196;
Kode lerroa:  t['arrowrighttophalf'] = 0x21C0;
Kode lerroa:  t['arrowrightbothalf'] = 0x21C1;
Kode lerroa:  t['arrowsoutheast'] = 0x2198;
Kode lerroa:  t['arrowsouthwest'] = 0x2199;
Kode lerroa:  t['backslashbig'] = 0x2216;
Kode lerroa:  t['backslashBig'] = 0x2216;
Kode lerroa:  t['backslashBigg'] = 0x2216;
Kode lerroa:  t['backslashbigg'] = 0x2216;
Kode lerroa:  t['bardbl'] = 0x2016;
Kode lerroa:  t['bracehtipdownleft'] = 0xFE37;
Kode lerroa:  t['bracehtipdownright'] = 0xFE37;
Kode lerroa:  t['bracehtipupleft'] = 0xFE38;
Kode lerroa:  t['bracehtipupright'] = 0xFE38;
Kode lerroa:  t['braceleftBig'] = 0x007B;
Kode lerroa:  t['braceleftbig'] = 0x007B;
Kode lerroa:  t['braceleftbigg'] = 0x007B;
Kode lerroa:  t['braceleftBigg'] = 0x007B;
Kode lerroa:  t['bracerightBig'] = 0x007D;
Kode lerroa:  t['bracerightbig'] = 0x007D;
Kode lerroa:  t['bracerightbigg'] = 0x007D;
Kode lerroa:  t['bracerightBigg'] = 0x007D;
Kode lerroa:  t['bracketleftbig'] = 0x005B;
Kode lerroa:  t['bracketleftBig'] = 0x005B;
Kode lerroa:  t['bracketleftbigg'] = 0x005B;
Kode lerroa:  t['bracketleftBigg'] = 0x005B;
Kode lerroa:  t['bracketrightBig'] = 0x005D;
Kode lerroa:  t['bracketrightbig'] = 0x005D;
Kode lerroa:  t['bracketrightbigg'] = 0x005D;
Kode lerroa:  t['bracketrightBigg'] = 0x005D;
Kode lerroa:  t['ceilingleftbig'] = 0x2308;
Kode lerroa:  t['ceilingleftBig'] = 0x2308;
Kode lerroa:  t['ceilingleftBigg'] = 0x2308;
Kode lerroa:  t['ceilingleftbigg'] = 0x2308;
Kode lerroa:  t['ceilingrightbig'] = 0x2309;
Kode lerroa:  t['ceilingrightBig'] = 0x2309;
Kode lerroa:  t['ceilingrightbigg'] = 0x2309;
Kode lerroa:  t['ceilingrightBigg'] = 0x2309;
Kode lerroa:  t['circledotdisplay'] = 0x2299;
Kode lerroa:  t['circledottext'] = 0x2299;
Kode lerroa:  t['circlemultiplydisplay'] = 0x2297;
Kode lerroa:  t['circlemultiplytext'] = 0x2297;
Kode lerroa:  t['circleplusdisplay'] = 0x2295;
Kode lerroa:  t['circleplustext'] = 0x2295;
Kode lerroa:  t['contintegraldisplay'] = 0x222E;
Kode lerroa:  t['contintegraltext'] = 0x222E;
Kode lerroa:  t['coproductdisplay'] = 0x2210;
Kode lerroa:  t['coproducttext'] = 0x2210;
Kode lerroa:  t['floorleftBig'] = 0x230A;
Kode lerroa:  t['floorleftbig'] = 0x230A;
Kode lerroa:  t['floorleftbigg'] = 0x230A;
Kode lerroa:  t['floorleftBigg'] = 0x230A;
Kode lerroa:  t['floorrightbig'] = 0x230B;
Kode lerroa:  t['floorrightBig'] = 0x230B;
Kode lerroa:  t['floorrightBigg'] = 0x230B;
Kode lerroa:  t['floorrightbigg'] = 0x230B;
Kode lerroa:  t['hatwide'] = 0x0302;
Kode lerroa:  t['hatwider'] = 0x0302;
Kode lerroa:  t['hatwidest'] = 0x0302;
Kode lerroa:  t['intercal'] = 0x1D40;
Kode lerroa:  t['integraldisplay'] = 0x222B;
Kode lerroa:  t['integraltext'] = 0x222B;
Kode lerroa:  t['intersectiondisplay'] = 0x22C2;
Kode lerroa:  t['intersectiontext'] = 0x22C2;
Kode lerroa:  t['logicalanddisplay'] = 0x2227;
Kode lerroa:  t['logicalandtext'] = 0x2227;
Kode lerroa:  t['logicalordisplay'] = 0x2228;
Kode lerroa:  t['logicalortext'] = 0x2228;
Kode lerroa:  t['parenleftBig'] = 0x0028;
Kode lerroa:  t['parenleftbig'] = 0x0028;
Kode lerroa:  t['parenleftBigg'] = 0x0028;
Kode lerroa:  t['parenleftbigg'] = 0x0028;
Kode lerroa:  t['parenrightBig'] = 0x0029;
Kode lerroa:  t['parenrightbig'] = 0x0029;
Kode lerroa:  t['parenrightBigg'] = 0x0029;
Kode lerroa:  t['parenrightbigg'] = 0x0029;
Kode lerroa:  t['prime'] = 0x2032;
Kode lerroa:  t['productdisplay'] = 0x220F;
Kode lerroa:  t['producttext'] = 0x220F;
Kode lerroa:  t['radicalbig'] = 0x221A;
Kode lerroa:  t['radicalBig'] = 0x221A;
Kode lerroa:  t['radicalBigg'] = 0x221A;
Kode lerroa:  t['radicalbigg'] = 0x221A;
Kode lerroa:  t['radicalbt'] = 0x221A;
Kode lerroa:  t['radicaltp'] = 0x221A;
Kode lerroa:  t['radicalvertex'] = 0x221A;
Kode lerroa:  t['slashbig'] = 0x002F;
Kode lerroa:  t['slashBig'] = 0x002F;
Kode lerroa:  t['slashBigg'] = 0x002F;
Kode lerroa:  t['slashbigg'] = 0x002F;
Kode lerroa:  t['summationdisplay'] = 0x2211;
Kode lerroa:  t['summationtext'] = 0x2211;
Kode lerroa:  t['tildewide'] = 0x02DC;
Kode lerroa:  t['tildewider'] = 0x02DC;
Kode lerroa:  t['tildewidest'] = 0x02DC;
Kode lerroa:  t['uniondisplay'] = 0x22C3;
Kode lerroa:  t['unionmultidisplay'] = 0x228E;
Kode lerroa:  t['unionmultitext'] = 0x228E;
Kode lerroa:  t['unionsqdisplay'] = 0x2294;
Kode lerroa:  t['unionsqtext'] = 0x2294;
Kode lerroa:  t['uniontext'] = 0x22C3;
Kode lerroa:  t['vextenddouble'] = 0x2225;
Kode lerroa:  t['vextendsingle'] = 0x2223;
Kode lerroa: });
Kode lerroa: var getDingbatsGlyphsUnicode = getLookupTableFactory(function (t) {
Kode lerroa:  t['space'] = 0x0020;
Kode lerroa:  t['a1'] = 0x2701;
Kode lerroa:  t['a2'] = 0x2702;
Kode lerroa:  t['a202'] = 0x2703;
Kode lerroa:  t['a3'] = 0x2704;
Kode lerroa:  t['a4'] = 0x260E;
Kode lerroa:  t['a5'] = 0x2706;
Kode lerroa:  t['a119'] = 0x2707;
Kode lerroa:  t['a118'] = 0x2708;
Kode lerroa:  t['a117'] = 0x2709;
Kode lerroa:  t['a11'] = 0x261B;
Kode lerroa:  t['a12'] = 0x261E;
Kode lerroa:  t['a13'] = 0x270C;
Kode lerroa:  t['a14'] = 0x270D;
Kode lerroa:  t['a15'] = 0x270E;
Kode lerroa:  t['a16'] = 0x270F;
Kode lerroa:  t['a105'] = 0x2710;
Kode lerroa:  t['a17'] = 0x2711;
Kode lerroa:  t['a18'] = 0x2712;
Kode lerroa:  t['a19'] = 0x2713;
Kode lerroa:  t['a20'] = 0x2714;
Kode lerroa:  t['a21'] = 0x2715;
Kode lerroa:  t['a22'] = 0x2716;
Kode lerroa:  t['a23'] = 0x2717;
Kode lerroa:  t['a24'] = 0x2718;
Kode lerroa:  t['a25'] = 0x2719;
Kode lerroa:  t['a26'] = 0x271A;
Kode lerroa:  t['a27'] = 0x271B;
Kode lerroa:  t['a28'] = 0x271C;
Kode lerroa:  t['a6'] = 0x271D;
Kode lerroa:  t['a7'] = 0x271E;
Kode lerroa:  t['a8'] = 0x271F;
Kode lerroa:  t['a9'] = 0x2720;
Kode lerroa:  t['a10'] = 0x2721;
Kode lerroa:  t['a29'] = 0x2722;
Kode lerroa:  t['a30'] = 0x2723;
Kode lerroa:  t['a31'] = 0x2724;
Kode lerroa:  t['a32'] = 0x2725;
Kode lerroa:  t['a33'] = 0x2726;
Kode lerroa:  t['a34'] = 0x2727;
Kode lerroa:  t['a35'] = 0x2605;
Kode lerroa:  t['a36'] = 0x2729;
Kode lerroa:  t['a37'] = 0x272A;
Kode lerroa:  t['a38'] = 0x272B;
Kode lerroa:  t['a39'] = 0x272C;
Kode lerroa:  t['a40'] = 0x272D;
Kode lerroa:  t['a41'] = 0x272E;
Kode lerroa:  t['a42'] = 0x272F;
Kode lerroa:  t['a43'] = 0x2730;
Kode lerroa:  t['a44'] = 0x2731;
Kode lerroa:  t['a45'] = 0x2732;
Kode lerroa:  t['a46'] = 0x2733;
Kode lerroa:  t['a47'] = 0x2734;
Kode lerroa:  t['a48'] = 0x2735;
Kode lerroa:  t['a49'] = 0x2736;
Kode lerroa:  t['a50'] = 0x2737;
Kode lerroa:  t['a51'] = 0x2738;
Kode lerroa:  t['a52'] = 0x2739;
Kode lerroa:  t['a53'] = 0x273A;
Kode lerroa:  t['a54'] = 0x273B;
Kode lerroa:  t['a55'] = 0x273C;
Kode lerroa:  t['a56'] = 0x273D;
Kode lerroa:  t['a57'] = 0x273E;
Kode lerroa:  t['a58'] = 0x273F;
Kode lerroa:  t['a59'] = 0x2740;
Kode lerroa:  t['a60'] = 0x2741;
Kode lerroa:  t['a61'] = 0x2742;
Kode lerroa:  t['a62'] = 0x2743;
Kode lerroa:  t['a63'] = 0x2744;
Kode lerroa:  t['a64'] = 0x2745;
Kode lerroa:  t['a65'] = 0x2746;
Kode lerroa:  t['a66'] = 0x2747;
Kode lerroa:  t['a67'] = 0x2748;
Kode lerroa:  t['a68'] = 0x2749;
Kode lerroa:  t['a69'] = 0x274A;
Kode lerroa:  t['a70'] = 0x274B;
Kode lerroa:  t['a71'] = 0x25CF;
Kode lerroa:  t['a72'] = 0x274D;
Kode lerroa:  t['a73'] = 0x25A0;
Kode lerroa:  t['a74'] = 0x274F;
Kode lerroa:  t['a203'] = 0x2750;
Kode lerroa:  t['a75'] = 0x2751;
Kode lerroa:  t['a204'] = 0x2752;
Kode lerroa:  t['a76'] = 0x25B2;
Kode lerroa:  t['a77'] = 0x25BC;
Kode lerroa:  t['a78'] = 0x25C6;
Kode lerroa:  t['a79'] = 0x2756;
Kode lerroa:  t['a81'] = 0x25D7;
Kode lerroa:  t['a82'] = 0x2758;
Kode lerroa:  t['a83'] = 0x2759;
Kode lerroa:  t['a84'] = 0x275A;
Kode lerroa:  t['a97'] = 0x275B;
Kode lerroa:  t['a98'] = 0x275C;
Kode lerroa:  t['a99'] = 0x275D;
Kode lerroa:  t['a100'] = 0x275E;
Kode lerroa:  t['a101'] = 0x2761;
Kode lerroa:  t['a102'] = 0x2762;
Kode lerroa:  t['a103'] = 0x2763;
Kode lerroa:  t['a104'] = 0x2764;
Kode lerroa:  t['a106'] = 0x2765;
Kode lerroa:  t['a107'] = 0x2766;
Kode lerroa:  t['a108'] = 0x2767;
Kode lerroa:  t['a112'] = 0x2663;
Kode lerroa:  t['a111'] = 0x2666;
Kode lerroa:  t['a110'] = 0x2665;
Kode lerroa:  t['a109'] = 0x2660;
Kode lerroa:  t['a120'] = 0x2460;
Kode lerroa:  t['a121'] = 0x2461;
Kode lerroa:  t['a122'] = 0x2462;
Kode lerroa:  t['a123'] = 0x2463;
Kode lerroa:  t['a124'] = 0x2464;
Kode lerroa:  t['a125'] = 0x2465;
Kode lerroa:  t['a126'] = 0x2466;
Kode lerroa:  t['a127'] = 0x2467;
Kode lerroa:  t['a128'] = 0x2468;
Kode lerroa:  t['a129'] = 0x2469;
Kode lerroa:  t['a130'] = 0x2776;
Kode lerroa:  t['a131'] = 0x2777;
Kode lerroa:  t['a132'] = 0x2778;
Kode lerroa:  t['a133'] = 0x2779;
Kode lerroa:  t['a134'] = 0x277A;
Kode lerroa:  t['a135'] = 0x277B;
Kode lerroa:  t['a136'] = 0x277C;
Kode lerroa:  t['a137'] = 0x277D;
Kode lerroa:  t['a138'] = 0x277E;
Kode lerroa:  t['a139'] = 0x277F;
Kode lerroa:  t['a140'] = 0x2780;
Kode lerroa:  t['a141'] = 0x2781;
Kode lerroa:  t['a142'] = 0x2782;
Kode lerroa:  t['a143'] = 0x2783;
Kode lerroa:  t['a144'] = 0x2784;
Kode lerroa:  t['a145'] = 0x2785;
Kode lerroa:  t['a146'] = 0x2786;
Kode lerroa:  t['a147'] = 0x2787;
Kode lerroa:  t['a148'] = 0x2788;
Kode lerroa:  t['a149'] = 0x2789;
Kode lerroa:  t['a150'] = 0x278A;
Kode lerroa:  t['a151'] = 0x278B;
Kode lerroa:  t['a152'] = 0x278C;
Kode lerroa:  t['a153'] = 0x278D;
Kode lerroa:  t['a154'] = 0x278E;
Kode lerroa:  t['a155'] = 0x278F;
Kode lerroa:  t['a156'] = 0x2790;
Kode lerroa:  t['a157'] = 0x2791;
Kode lerroa:  t['a158'] = 0x2792;
Kode lerroa:  t['a159'] = 0x2793;
Kode lerroa:  t['a160'] = 0x2794;
Kode lerroa:  t['a161'] = 0x2192;
Kode lerroa:  t['a163'] = 0x2194;
Kode lerroa:  t['a164'] = 0x2195;
Kode lerroa:  t['a196'] = 0x2798;
Kode lerroa:  t['a165'] = 0x2799;
Kode lerroa:  t['a192'] = 0x279A;
Kode lerroa:  t['a166'] = 0x279B;
Kode lerroa:  t['a167'] = 0x279C;
Kode lerroa:  t['a168'] = 0x279D;
Kode lerroa:  t['a169'] = 0x279E;
Kode lerroa:  t['a170'] = 0x279F;
Kode lerroa:  t['a171'] = 0x27A0;
Kode lerroa:  t['a172'] = 0x27A1;
Kode lerroa:  t['a173'] = 0x27A2;
Kode lerroa:  t['a162'] = 0x27A3;
Kode lerroa:  t['a174'] = 0x27A4;
Kode lerroa:  t['a175'] = 0x27A5;
Kode lerroa:  t['a176'] = 0x27A6;
Kode lerroa:  t['a177'] = 0x27A7;
Kode lerroa:  t['a178'] = 0x27A8;
Kode lerroa:  t['a179'] = 0x27A9;
Kode lerroa:  t['a193'] = 0x27AA;
Kode lerroa:  t['a180'] = 0x27AB;
Kode lerroa:  t['a199'] = 0x27AC;
Kode lerroa:  t['a181'] = 0x27AD;
Kode lerroa:  t['a200'] = 0x27AE;
Kode lerroa:  t['a182'] = 0x27AF;
Kode lerroa:  t['a201'] = 0x27B1;
Kode lerroa:  t['a183'] = 0x27B2;
Kode lerroa:  t['a184'] = 0x27B3;
Kode lerroa:  t['a197'] = 0x27B4;
Kode lerroa:  t['a185'] = 0x27B5;
Kode lerroa:  t['a194'] = 0x27B6;
Kode lerroa:  t['a198'] = 0x27B7;
Kode lerroa:  t['a186'] = 0x27B8;
Kode lerroa:  t['a195'] = 0x27B9;
Kode lerroa:  t['a187'] = 0x27BA;
Kode lerroa:  t['a188'] = 0x27BB;
Kode lerroa:  t['a189'] = 0x27BC;
Kode lerroa:  t['a190'] = 0x27BD;
Kode lerroa:  t['a191'] = 0x27BE;
Kode lerroa:  t['a89'] = 0x2768;
Kode lerroa:  t['a90'] = 0x2769;
Kode lerroa:  t['a93'] = 0x276A;
Kode lerroa:  t['a94'] = 0x276B;
Kode lerroa:  t['a91'] = 0x276C;
Kode lerroa:  t['a92'] = 0x276D;
Kode lerroa:  t['a205'] = 0x276E;
Kode lerroa:  t['a85'] = 0x276F;
Kode lerroa:  t['a206'] = 0x2770;
Kode lerroa:  t['a86'] = 0x2771;
Kode lerroa:  t['a87'] = 0x2772;
Kode lerroa:  t['a88'] = 0x2773;
Kode lerroa:  t['a95'] = 0x2774;
Kode lerroa:  t['a96'] = 0x2775;
Kode lerroa:  t['.notdef'] = 0x0000;
Kode lerroa: });
Kode lerroa: exports.getGlyphsUnicode = getGlyphsUnicode;
Kode lerroa: exports.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 48 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = !__w_pdfjs_require__(10) && !__w_pdfjs_require__(11)(function () {
Kode lerroa:   return Object.defineProperty(__w_pdfjs_require__(35)('div'), 'a', {
Kode lerroa:     get: function get() {
Kode lerroa:       return 7;
Kode lerroa:     }
Kode lerroa:   }).a != 7;
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 49 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var hide = __w_pdfjs_require__(8);
Kode lerroa: var uid = __w_pdfjs_require__(17);
Kode lerroa: var TYPED = uid('typed_array');
Kode lerroa: var VIEW = uid('view');
Kode lerroa: var ABV = !!(global.ArrayBuffer && global.DataView);
Kode lerroa: var CONSTR = ABV;
Kode lerroa: var i = 0;
Kode lerroa: var l = 9;
Kode lerroa: var Typed;
Kode lerroa: var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');
Kode lerroa: while (i < l) {
Kode lerroa:   if (Typed = global[TypedArrayConstructors[i++]]) {
Kode lerroa:     hide(Typed.prototype, TYPED, true);
Kode lerroa:     hide(Typed.prototype, VIEW, true);
Kode lerroa:   } else CONSTR = false;
Kode lerroa: }
Kode lerroa: module.exports = {
Kode lerroa:   ABV: ABV,
Kode lerroa:   CONSTR: CONSTR,
Kode lerroa:   TYPED: TYPED,
Kode lerroa:   VIEW: VIEW
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 50 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toInteger = __w_pdfjs_require__(18);
Kode lerroa: var toLength = __w_pdfjs_require__(14);
Kode lerroa: module.exports = function (it) {
Kode lerroa:   if (it === undefined) return 0;
Kode lerroa:   var number = toInteger(it);
Kode lerroa:   var length = toLength(number);
Kode lerroa:   if (number !== length) throw RangeError('Wrong length!');
Kode lerroa:   return length;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 51 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $keys = __w_pdfjs_require__(52);
Kode lerroa: var hiddenKeys = __w_pdfjs_require__(40).concat('length', 'prototype');
Kode lerroa: exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
Kode lerroa:   return $keys(O, hiddenKeys);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 52 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var has = __w_pdfjs_require__(12);
Kode lerroa: var toIObject = __w_pdfjs_require__(30);
Kode lerroa: var arrayIndexOf = __w_pdfjs_require__(53)(false);
Kode lerroa: var IE_PROTO = __w_pdfjs_require__(39)('IE_PROTO');
Kode lerroa: module.exports = function (object, names) {
Kode lerroa:   var O = toIObject(object);
Kode lerroa:   var i = 0;
Kode lerroa:   var result = [];
Kode lerroa:   var key;
Kode lerroa:   for (key in O) {
Kode lerroa:     if (key != IE_PROTO) has(O, key) && result.push(key);
Kode lerroa:   }while (names.length > i) {
Kode lerroa:     if (has(O, key = names[i++])) {
Kode lerroa:       ~arrayIndexOf(result, key) || result.push(key);
Kode lerroa:     }
Kode lerroa:   }return result;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 53 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toIObject = __w_pdfjs_require__(30);
Kode lerroa: var toLength = __w_pdfjs_require__(14);
Kode lerroa: var toAbsoluteIndex = __w_pdfjs_require__(31);
Kode lerroa: module.exports = function (IS_INCLUDES) {
Kode lerroa:   return function ($this, el, fromIndex) {
Kode lerroa:     var O = toIObject($this);
Kode lerroa:     var length = toLength(O.length);
Kode lerroa:     var index = toAbsoluteIndex(fromIndex, length);
Kode lerroa:     var value;
Kode lerroa:     if (IS_INCLUDES && el != el) while (length > index) {
Kode lerroa:       value = O[index++];
Kode lerroa:       if (value != value) return true;
Kode lerroa:     } else for (; length > index; index++) {
Kode lerroa:       if (IS_INCLUDES || index in O) {
Kode lerroa:         if (O[index] === el) return IS_INCLUDES || index || 0;
Kode lerroa:       }
Kode lerroa:     }return !IS_INCLUDES && -1;
Kode lerroa:   };
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 54 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var core = __w_pdfjs_require__(6);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var SHARED = '__core-js_shared__';
Kode lerroa: var store = global[SHARED] || (global[SHARED] = {});
Kode lerroa: (module.exports = function (key, value) {
Kode lerroa:   return store[key] || (store[key] = value !== undefined ? value : {});
Kode lerroa: })('versions', []).push({
Kode lerroa:   version: core.version,
Kode lerroa:   mode: __w_pdfjs_require__(21) ? 'pure' : 'global',
Kode lerroa:   copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
Kode lerroa: });
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 55 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var toObject = __w_pdfjs_require__(19);
Kode lerroa: var toAbsoluteIndex = __w_pdfjs_require__(31);
Kode lerroa: var toLength = __w_pdfjs_require__(14);
Kode lerroa: module.exports = function fill(value) {
Kode lerroa:   var O = toObject(this);
Kode lerroa:   var length = toLength(O.length);
Kode lerroa:   var aLen = arguments.length;
Kode lerroa:   var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
Kode lerroa:   var end = aLen > 2 ? arguments[2] : undefined;
Kode lerroa:   var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
Kode lerroa:   while (endPos > index) {
Kode lerroa:     O[index++] = value;
Kode lerroa:   }return O;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 56 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var Iterators = __w_pdfjs_require__(20);
Kode lerroa: var ITERATOR = __w_pdfjs_require__(4)('iterator');
Kode lerroa: var ArrayProto = Array.prototype;
Kode lerroa: module.exports = function (it) {
Kode lerroa:   return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 57 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(9);
Kode lerroa: var dPs = __w_pdfjs_require__(90);
Kode lerroa: var enumBugKeys = __w_pdfjs_require__(40);
Kode lerroa: var IE_PROTO = __w_pdfjs_require__(39)('IE_PROTO');
Kode lerroa: var Empty = function Empty() {};
Kode lerroa: var PROTOTYPE = 'prototype';
Kode lerroa: var _createDict = function createDict() {
Kode lerroa:   var iframe = __w_pdfjs_require__(35)('iframe');
Kode lerroa:   var i = enumBugKeys.length;
Kode lerroa:   var lt = '<';
Kode lerroa:   var gt = '>';
Kode lerroa:   var iframeDocument;
Kode lerroa:   iframe.style.display = 'none';
Kode lerroa:   __w_pdfjs_require__(58).appendChild(iframe);
Kode lerroa:   iframe.src = 'javascript:';
Kode lerroa:   iframeDocument = iframe.contentWindow.document;
Kode lerroa:   iframeDocument.open();
Kode lerroa:   iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
Kode lerroa:   iframeDocument.close();
Kode lerroa:   _createDict = iframeDocument.F;
Kode lerroa:   while (i--) {
Kode lerroa:     delete _createDict[PROTOTYPE][enumBugKeys[i]];
Kode lerroa:   }return _createDict();
Kode lerroa: };
Kode lerroa: module.exports = Object.create || function create(O, Properties) {
Kode lerroa:   var result;
Kode lerroa:   if (O !== null) {
Kode lerroa:     Empty[PROTOTYPE] = anObject(O);
Kode lerroa:     result = new Empty();
Kode lerroa:     Empty[PROTOTYPE] = null;
Kode lerroa:     result[IE_PROTO] = O;
Kode lerroa:   } else result = _createDict();
Kode lerroa:   return Properties === undefined ? result : dPs(result, Properties);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 58 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var document = __w_pdfjs_require__(1).document;
Kode lerroa: module.exports = document && document.documentElement;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 59 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var has = __w_pdfjs_require__(12);
Kode lerroa: var toObject = __w_pdfjs_require__(19);
Kode lerroa: var IE_PROTO = __w_pdfjs_require__(39)('IE_PROTO');
Kode lerroa: var ObjectProto = Object.prototype;
Kode lerroa: module.exports = Object.getPrototypeOf || function (O) {
Kode lerroa:   O = toObject(O);
Kode lerroa:   if (has(O, IE_PROTO)) return O[IE_PROTO];
Kode lerroa:   if (typeof O.constructor == 'function' && O instanceof O.constructor) {
Kode lerroa:     return O.constructor.prototype;
Kode lerroa:   }
Kode lerroa:   return O instanceof Object ? ObjectProto : null;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 60 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var classof = __w_pdfjs_require__(32);
Kode lerroa: var ITERATOR = __w_pdfjs_require__(4)('iterator');
Kode lerroa: var Iterators = __w_pdfjs_require__(20);
Kode lerroa: module.exports = __w_pdfjs_require__(6).getIteratorMethod = function (it) {
Kode lerroa:   if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 61 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var addToUnscopables = __w_pdfjs_require__(94);
Kode lerroa: var step = __w_pdfjs_require__(95);
Kode lerroa: var Iterators = __w_pdfjs_require__(20);
Kode lerroa: var toIObject = __w_pdfjs_require__(30);
Kode lerroa: module.exports = __w_pdfjs_require__(62)(Array, 'Array', function (iterated, kind) {
Kode lerroa:   this._t = toIObject(iterated);
Kode lerroa:   this._i = 0;
Kode lerroa:   this._k = kind;
Kode lerroa: }, function () {
Kode lerroa:   var O = this._t;
Kode lerroa:   var kind = this._k;
Kode lerroa:   var index = this._i++;
Kode lerroa:   if (!O || index >= O.length) {
Kode lerroa:     this._t = undefined;
Kode lerroa:     return step(1);
Kode lerroa:   }
Kode lerroa:   if (kind == 'keys') return step(0, index);
Kode lerroa:   if (kind == 'values') return step(0, O[index]);
Kode lerroa:   return step(0, [index, O[index]]);
Kode lerroa: }, 'values');
Kode lerroa: Iterators.Arguments = Iterators.Array;
Kode lerroa: addToUnscopables('keys');
Kode lerroa: addToUnscopables('values');
Kode lerroa: addToUnscopables('entries');
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 62 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var LIBRARY = __w_pdfjs_require__(21);
Kode lerroa: var $export = __w_pdfjs_require__(7);
Kode lerroa: var redefine = __w_pdfjs_require__(16);
Kode lerroa: var hide = __w_pdfjs_require__(8);
Kode lerroa: var Iterators = __w_pdfjs_require__(20);
Kode lerroa: var $iterCreate = __w_pdfjs_require__(96);
Kode lerroa: var setToStringTag = __w_pdfjs_require__(26);
Kode lerroa: var getPrototypeOf = __w_pdfjs_require__(59);
Kode lerroa: var ITERATOR = __w_pdfjs_require__(4)('iterator');
Kode lerroa: var BUGGY = !([].keys && 'next' in [].keys());
Kode lerroa: var FF_ITERATOR = '@@iterator';
Kode lerroa: var KEYS = 'keys';
Kode lerroa: var VALUES = 'values';
Kode lerroa: var returnThis = function returnThis() {
Kode lerroa:   return this;
Kode lerroa: };
Kode lerroa: module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
Kode lerroa:   $iterCreate(Constructor, NAME, next);
Kode lerroa:   var getMethod = function getMethod(kind) {
Kode lerroa:     if (!BUGGY && kind in proto) return proto[kind];
Kode lerroa:     switch (kind) {
Kode lerroa:       case KEYS:
Kode lerroa:         return function keys() {
Kode lerroa:           return new Constructor(this, kind);
Kode lerroa:         };
Kode lerroa:       case VALUES:
Kode lerroa:         return function values() {
Kode lerroa:           return new Constructor(this, kind);
Kode lerroa:         };
Kode lerroa:     }
Kode lerroa:     return function entries() {
Kode lerroa:       return new Constructor(this, kind);
Kode lerroa:     };
Kode lerroa:   };
Kode lerroa:   var TAG = NAME + ' Iterator';
Kode lerroa:   var DEF_VALUES = DEFAULT == VALUES;
Kode lerroa:   var VALUES_BUG = false;
Kode lerroa:   var proto = Base.prototype;
Kode lerroa:   var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
Kode lerroa:   var $default = $native || getMethod(DEFAULT);
Kode lerroa:   var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
Kode lerroa:   var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
Kode lerroa:   var methods, key, IteratorPrototype;
Kode lerroa:   if ($anyNative) {
Kode lerroa:     IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
Kode lerroa:     if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
Kode lerroa:       setToStringTag(IteratorPrototype, TAG, true);
Kode lerroa:       if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (DEF_VALUES && $native && $native.name !== VALUES) {
Kode lerroa:     VALUES_BUG = true;
Kode lerroa:     $default = function values() {
Kode lerroa:       return $native.call(this);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
Kode lerroa:     hide(proto, ITERATOR, $default);
Kode lerroa:   }
Kode lerroa:   Iterators[NAME] = $default;
Kode lerroa:   Iterators[TAG] = returnThis;
Kode lerroa:   if (DEFAULT) {
Kode lerroa:     methods = {
Kode lerroa:       values: DEF_VALUES ? $default : getMethod(VALUES),
Kode lerroa:       keys: IS_SET ? $default : getMethod(KEYS),
Kode lerroa:       entries: $entries
Kode lerroa:     };
Kode lerroa:     if (FORCED) for (key in methods) {
Kode lerroa:       if (!(key in proto)) redefine(proto, key, methods[key]);
Kode lerroa:     } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
Kode lerroa:   }
Kode lerroa:   return methods;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 63 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var dP = __w_pdfjs_require__(15);
Kode lerroa: var DESCRIPTORS = __w_pdfjs_require__(10);
Kode lerroa: var SPECIES = __w_pdfjs_require__(4)('species');
Kode lerroa: module.exports = function (KEY) {
Kode lerroa:   var C = global[KEY];
Kode lerroa:   if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
Kode lerroa:     configurable: true,
Kode lerroa:     get: function get() {
Kode lerroa:       return this;
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 64 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var pIE = __w_pdfjs_require__(65);
Kode lerroa: var createDesc = __w_pdfjs_require__(29);
Kode lerroa: var toIObject = __w_pdfjs_require__(30);
Kode lerroa: var toPrimitive = __w_pdfjs_require__(36);
Kode lerroa: var has = __w_pdfjs_require__(12);
Kode lerroa: var IE8_DOM_DEFINE = __w_pdfjs_require__(48);
Kode lerroa: var gOPD = Object.getOwnPropertyDescriptor;
Kode lerroa: exports.f = __w_pdfjs_require__(10) ? gOPD : function getOwnPropertyDescriptor(O, P) {
Kode lerroa:   O = toIObject(O);
Kode lerroa:   P = toPrimitive(P, true);
Kode lerroa:   if (IE8_DOM_DEFINE) try {
Kode lerroa:     return gOPD(O, P);
Kode lerroa:   } catch (e) {}
Kode lerroa:   if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 65 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: exports.f = {}.propertyIsEnumerable;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 66 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var classof = __w_pdfjs_require__(32);
Kode lerroa: var test = {};
Kode lerroa: test[__w_pdfjs_require__(4)('toStringTag')] = 'z';
Kode lerroa: if (test + '' != '[object z]') {
Kode lerroa:   __w_pdfjs_require__(16)(Object.prototype, 'toString', function toString() {
Kode lerroa:     return '[object ' + classof(this) + ']';
Kode lerroa:   }, true);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 67 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var $iterators = __w_pdfjs_require__(61);
Kode lerroa: var getKeys = __w_pdfjs_require__(41);
Kode lerroa: var redefine = __w_pdfjs_require__(16);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var hide = __w_pdfjs_require__(8);
Kode lerroa: var Iterators = __w_pdfjs_require__(20);
Kode lerroa: var wks = __w_pdfjs_require__(4);
Kode lerroa: var ITERATOR = wks('iterator');
Kode lerroa: var TO_STRING_TAG = wks('toStringTag');
Kode lerroa: var ArrayValues = Iterators.Array;
Kode lerroa: var DOMIterables = {
Kode lerroa:   CSSRuleList: true,
Kode lerroa:   CSSStyleDeclaration: false,
Kode lerroa:   CSSValueList: false,
Kode lerroa:   ClientRectList: false,
Kode lerroa:   DOMRectList: false,
Kode lerroa:   DOMStringList: false,
Kode lerroa:   DOMTokenList: true,
Kode lerroa:   DataTransferItemList: false,
Kode lerroa:   FileList: false,
Kode lerroa:   HTMLAllCollection: false,
Kode lerroa:   HTMLCollection: false,
Kode lerroa:   HTMLFormElement: false,
Kode lerroa:   HTMLSelectElement: false,
Kode lerroa:   MediaList: true,
Kode lerroa:   MimeTypeArray: false,
Kode lerroa:   NamedNodeMap: false,
Kode lerroa:   NodeList: true,
Kode lerroa:   PaintRequestList: false,
Kode lerroa:   Plugin: false,
Kode lerroa:   PluginArray: false,
Kode lerroa:   SVGLengthList: false,
Kode lerroa:   SVGNumberList: false,
Kode lerroa:   SVGPathSegList: false,
Kode lerroa:   SVGPointList: false,
Kode lerroa:   SVGStringList: false,
Kode lerroa:   SVGTransformList: false,
Kode lerroa:   SourceBufferList: false,
Kode lerroa:   StyleSheetList: true,
Kode lerroa:   TextTrackCueList: false,
Kode lerroa:   TextTrackList: false,
Kode lerroa:   TouchList: false
Kode lerroa: };
Kode lerroa: for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
Kode lerroa:   var NAME = collections[i];
Kode lerroa:   var explicit = DOMIterables[NAME];
Kode lerroa:   var Collection = global[NAME];
Kode lerroa:   var proto = Collection && Collection.prototype;
Kode lerroa:   var key;
Kode lerroa:   if (proto) {
Kode lerroa:     if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
Kode lerroa:     if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
Kode lerroa:     Iterators[NAME] = ArrayValues;
Kode lerroa:     if (explicit) for (key in $iterators) {
Kode lerroa:       if (!proto[key]) redefine(proto, key, $iterators[key], true);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 68 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var ctx = __w_pdfjs_require__(13);
Kode lerroa: var invoke = __w_pdfjs_require__(108);
Kode lerroa: var html = __w_pdfjs_require__(58);
Kode lerroa: var cel = __w_pdfjs_require__(35);
Kode lerroa: var global = __w_pdfjs_require__(1);
Kode lerroa: var process = global.process;
Kode lerroa: var setTask = global.setImmediate;
Kode lerroa: var clearTask = global.clearImmediate;
Kode lerroa: var MessageChannel = global.MessageChannel;
Kode lerroa: var Dispatch = global.Dispatch;
Kode lerroa: var counter = 0;
Kode lerroa: var queue = {};
Kode lerroa: var ONREADYSTATECHANGE = 'onreadystatechange';
Kode lerroa: var defer, channel, port;
Kode lerroa: var run = function run() {
Kode lerroa:   var id = +this;
Kode lerroa:   if (queue.hasOwnProperty(id)) {
Kode lerroa:     var fn = queue[id];
Kode lerroa:     delete queue[id];
Kode lerroa:     fn();
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var listener = function listener(event) {
Kode lerroa:   run.call(event.data);
Kode lerroa: };
Kode lerroa: if (!setTask || !clearTask) {
Kode lerroa:   setTask = function setImmediate(fn) {
Kode lerroa:     var args = [];
Kode lerroa:     var i = 1;
Kode lerroa:     while (arguments.length > i) {
Kode lerroa:       args.push(arguments[i++]);
Kode lerroa:     }queue[++counter] = function () {
Kode lerroa:       invoke(typeof fn == 'function' ? fn : Function(fn), args);
Kode lerroa:     };
Kode lerroa:     defer(counter);
Kode lerroa:     return counter;
Kode lerroa:   };
Kode lerroa:   clearTask = function clearImmediate(id) {
Kode lerroa:     delete queue[id];
Kode lerroa:   };
Kode lerroa:   if (__w_pdfjs_require__(25)(process) == 'process') {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       process.nextTick(ctx(run, id, 1));
Kode lerroa:     };
Kode lerroa:   } else if (Dispatch && Dispatch.now) {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       Dispatch.now(ctx(run, id, 1));
Kode lerroa:     };
Kode lerroa:   } else if (MessageChannel) {
Kode lerroa:     channel = new MessageChannel();
Kode lerroa:     port = channel.port2;
Kode lerroa:     channel.port1.onmessage = listener;
Kode lerroa:     defer = ctx(port.postMessage, port, 1);
Kode lerroa:   } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       global.postMessage(id + '', '*');
Kode lerroa:     };
Kode lerroa:     global.addEventListener('message', listener, false);
Kode lerroa:   } else if (ONREADYSTATECHANGE in cel('script')) {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
Kode lerroa:         html.removeChild(this);
Kode lerroa:         run.call(id);
Kode lerroa:       };
Kode lerroa:     };
Kode lerroa:   } else {
Kode lerroa:     defer = function defer(id) {
Kode lerroa:       setTimeout(ctx(run, id, 1), 0);
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: module.exports = {
Kode lerroa:   set: setTask,
Kode lerroa:   clear: clearTask
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 69 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: module.exports = function (exec) {
Kode lerroa:   try {
Kode lerroa:     return {
Kode lerroa:       e: false,
Kode lerroa:       v: exec()
Kode lerroa:     };
Kode lerroa:   } catch (e) {
Kode lerroa:     return {
Kode lerroa:       e: true,
Kode lerroa:       v: e
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 70 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var anObject = __w_pdfjs_require__(9);
Kode lerroa: var isObject = __w_pdfjs_require__(3);
Kode lerroa: var newPromiseCapability = __w_pdfjs_require__(45);
Kode lerroa: module.exports = function (C, x) {
Kode lerroa:   anObject(C);
Kode lerroa:   if (isObject(x) && x.constructor === C) return x;
Kode lerroa:   var promiseCapability = newPromiseCapability.f(C);
Kode lerroa:   var resolve = promiseCapability.resolve;
Kode lerroa:   resolve(x);
Kode lerroa:   return promiseCapability.promise;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 71 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var isObject = __w_pdfjs_require__(3);
Kode lerroa: module.exports = function (it, TYPE) {
Kode lerroa:   if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
Kode lerroa:   return it;
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 72 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.ChunkedStreamManager = exports.ChunkedStream = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var ChunkedStream = function ChunkedStreamClosure() {
Kode lerroa:   function ChunkedStream(length, chunkSize, manager) {
Kode lerroa:     this.bytes = new Uint8Array(length);
Kode lerroa:     this.start = 0;
Kode lerroa:     this.pos = 0;
Kode lerroa:     this.end = length;
Kode lerroa:     this.chunkSize = chunkSize;
Kode lerroa:     this.loadedChunks = [];
Kode lerroa:     this.numChunksLoaded = 0;
Kode lerroa:     this.numChunks = Math.ceil(length / chunkSize);
Kode lerroa:     this.manager = manager;
Kode lerroa:     this.progressiveDataLength = 0;
Kode lerroa:     this.lastSuccessfulEnsureByteChunk = -1;
Kode lerroa:   }
Kode lerroa:   ChunkedStream.prototype = {
Kode lerroa:     getMissingChunks: function ChunkedStream_getMissingChunks() {
Kode lerroa:       var chunks = [];
Kode lerroa:       for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
Kode lerroa:         if (!this.loadedChunks[chunk]) {
Kode lerroa:           chunks.push(chunk);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return chunks;
Kode lerroa:     },
Kode lerroa:     getBaseStreams: function ChunkedStream_getBaseStreams() {
Kode lerroa:       return [this];
Kode lerroa:     },
Kode lerroa:     allChunksLoaded: function ChunkedStream_allChunksLoaded() {
Kode lerroa:       return this.numChunksLoaded === this.numChunks;
Kode lerroa:     },
Kode lerroa:     onReceiveData: function ChunkedStream_onReceiveData(begin, chunk) {
Kode lerroa:       var end = begin + chunk.byteLength;
Kode lerroa:       if (begin % this.chunkSize !== 0) {
Kode lerroa:         throw new Error('Bad begin offset: ' + begin);
Kode lerroa:       }
Kode lerroa:       var length = this.bytes.length;
Kode lerroa:       if (end % this.chunkSize !== 0 && end !== length) {
Kode lerroa:         throw new Error('Bad end offset: ' + end);
Kode lerroa:       }
Kode lerroa:       this.bytes.set(new Uint8Array(chunk), begin);
Kode lerroa:       var chunkSize = this.chunkSize;
Kode lerroa:       var beginChunk = Math.floor(begin / chunkSize);
Kode lerroa:       var endChunk = Math.floor((end - 1) / chunkSize) + 1;
Kode lerroa:       var curChunk;
Kode lerroa:       for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
Kode lerroa:         if (!this.loadedChunks[curChunk]) {
Kode lerroa:           this.loadedChunks[curChunk] = true;
Kode lerroa:           ++this.numChunksLoaded;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     onReceiveProgressiveData: function ChunkedStream_onReceiveProgressiveData(data) {
Kode lerroa:       var position = this.progressiveDataLength;
Kode lerroa:       var beginChunk = Math.floor(position / this.chunkSize);
Kode lerroa:       this.bytes.set(new Uint8Array(data), position);
Kode lerroa:       position += data.byteLength;
Kode lerroa:       this.progressiveDataLength = position;
Kode lerroa:       var endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
Kode lerroa:       var curChunk;
Kode lerroa:       for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
Kode lerroa:         if (!this.loadedChunks[curChunk]) {
Kode lerroa:           this.loadedChunks[curChunk] = true;
Kode lerroa:           ++this.numChunksLoaded;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     ensureByte: function ChunkedStream_ensureByte(pos) {
Kode lerroa:       var chunk = Math.floor(pos / this.chunkSize);
Kode lerroa:       if (chunk === this.lastSuccessfulEnsureByteChunk) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!this.loadedChunks[chunk]) {
Kode lerroa:         throw new _util.MissingDataException(pos, pos + 1);
Kode lerroa:       }
Kode lerroa:       this.lastSuccessfulEnsureByteChunk = chunk;
Kode lerroa:     },
Kode lerroa:     ensureRange: function ChunkedStream_ensureRange(begin, end) {
Kode lerroa:       if (begin >= end) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (end <= this.progressiveDataLength) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var chunkSize = this.chunkSize;
Kode lerroa:       var beginChunk = Math.floor(begin / chunkSize);
Kode lerroa:       var endChunk = Math.floor((end - 1) / chunkSize) + 1;
Kode lerroa:       for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
Kode lerroa:         if (!this.loadedChunks[chunk]) {
Kode lerroa:           throw new _util.MissingDataException(begin, end);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
Kode lerroa:       var chunk,
Kode lerroa:           numChunks = this.numChunks;
Kode lerroa:       for (var i = 0; i < numChunks; ++i) {
Kode lerroa:         chunk = (beginChunk + i) % numChunks;
Kode lerroa:         if (!this.loadedChunks[chunk]) {
Kode lerroa:           return chunk;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return null;
Kode lerroa:     },
Kode lerroa:     hasChunk: function ChunkedStream_hasChunk(chunk) {
Kode lerroa:       return !!this.loadedChunks[chunk];
Kode lerroa:     },
Kode lerroa:     get length() {
Kode lerroa:       return this.end - this.start;
Kode lerroa:     },
Kode lerroa:     get isEmpty() {
Kode lerroa:       return this.length === 0;
Kode lerroa:     },
Kode lerroa:     getByte: function ChunkedStream_getByte() {
Kode lerroa:       var pos = this.pos;
Kode lerroa:       if (pos >= this.end) {
Kode lerroa:         return -1;
Kode lerroa:       }
Kode lerroa:       this.ensureByte(pos);
Kode lerroa:       return this.bytes[this.pos++];
Kode lerroa:     },
Kode lerroa:     getUint16: function ChunkedStream_getUint16() {
Kode lerroa:       var b0 = this.getByte();
Kode lerroa:       var b1 = this.getByte();
Kode lerroa:       if (b0 === -1 || b1 === -1) {
Kode lerroa:         return -1;
Kode lerroa:       }
Kode lerroa:       return (b0 << 8) + b1;
Kode lerroa:     },
Kode lerroa:     getInt32: function ChunkedStream_getInt32() {
Kode lerroa:       var b0 = this.getByte();
Kode lerroa:       var b1 = this.getByte();
Kode lerroa:       var b2 = this.getByte();
Kode lerroa:       var b3 = this.getByte();
Kode lerroa:       return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
Kode lerroa:     },
Kode lerroa:     getBytes: function ChunkedStream_getBytes(length) {
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var pos = this.pos;
Kode lerroa:       var strEnd = this.end;
Kode lerroa:       if (!length) {
Kode lerroa:         this.ensureRange(pos, strEnd);
Kode lerroa:         return bytes.subarray(pos, strEnd);
Kode lerroa:       }
Kode lerroa:       var end = pos + length;
Kode lerroa:       if (end > strEnd) {
Kode lerroa:         end = strEnd;
Kode lerroa:       }
Kode lerroa:       this.ensureRange(pos, end);
Kode lerroa:       this.pos = end;
Kode lerroa:       return bytes.subarray(pos, end);
Kode lerroa:     },
Kode lerroa:     peekByte: function ChunkedStream_peekByte() {
Kode lerroa:       var peekedByte = this.getByte();
Kode lerroa:       this.pos--;
Kode lerroa:       return peekedByte;
Kode lerroa:     },
Kode lerroa:     peekBytes: function ChunkedStream_peekBytes(length) {
Kode lerroa:       var bytes = this.getBytes(length);
Kode lerroa:       this.pos -= bytes.length;
Kode lerroa:       return bytes;
Kode lerroa:     },
Kode lerroa:     getByteRange: function ChunkedStream_getBytes(begin, end) {
Kode lerroa:       this.ensureRange(begin, end);
Kode lerroa:       return this.bytes.subarray(begin, end);
Kode lerroa:     },
Kode lerroa:     skip: function ChunkedStream_skip(n) {
Kode lerroa:       if (!n) {
Kode lerroa:         n = 1;
Kode lerroa:       }
Kode lerroa:       this.pos += n;
Kode lerroa:     },
Kode lerroa:     reset: function ChunkedStream_reset() {
Kode lerroa:       this.pos = this.start;
Kode lerroa:     },
Kode lerroa:     moveStart: function ChunkedStream_moveStart() {
Kode lerroa:       this.start = this.pos;
Kode lerroa:     },
Kode lerroa:     makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
Kode lerroa:       this.ensureRange(start, start + length);
Kode lerroa:       function ChunkedStreamSubstream() {}
Kode lerroa:       ChunkedStreamSubstream.prototype = Object.create(this);
Kode lerroa:       ChunkedStreamSubstream.prototype.getMissingChunks = function () {
Kode lerroa:         var chunkSize = this.chunkSize;
Kode lerroa:         var beginChunk = Math.floor(this.start / chunkSize);
Kode lerroa:         var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
Kode lerroa:         var missingChunks = [];
Kode lerroa:         for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
Kode lerroa:           if (!this.loadedChunks[chunk]) {
Kode lerroa:             missingChunks.push(chunk);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return missingChunks;
Kode lerroa:       };
Kode lerroa:       var subStream = new ChunkedStreamSubstream();
Kode lerroa:       subStream.pos = subStream.start = start;
Kode lerroa:       subStream.end = start + length || this.end;
Kode lerroa:       subStream.dict = dict;
Kode lerroa:       return subStream;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return ChunkedStream;
Kode lerroa: }();
Kode lerroa: var ChunkedStreamManager = function ChunkedStreamManagerClosure() {
Kode lerroa:   function ChunkedStreamManager(pdfNetworkStream, args) {
Kode lerroa:     var chunkSize = args.rangeChunkSize;
Kode lerroa:     var length = args.length;
Kode lerroa:     this.stream = new ChunkedStream(length, chunkSize, this);
Kode lerroa:     this.length = length;
Kode lerroa:     this.chunkSize = chunkSize;
Kode lerroa:     this.pdfNetworkStream = pdfNetworkStream;
Kode lerroa:     this.url = args.url;
Kode lerroa:     this.disableAutoFetch = args.disableAutoFetch;
Kode lerroa:     this.msgHandler = args.msgHandler;
Kode lerroa:     this.currRequestId = 0;
Kode lerroa:     this.chunksNeededByRequest = Object.create(null);
Kode lerroa:     this.requestsByChunk = Object.create(null);
Kode lerroa:     this.promisesByRequest = Object.create(null);
Kode lerroa:     this.progressiveDataLength = 0;
Kode lerroa:     this.aborted = false;
Kode lerroa:     this._loadedStreamCapability = (0, _util.createPromiseCapability)();
Kode lerroa:   }
Kode lerroa:   ChunkedStreamManager.prototype = {
Kode lerroa:     onLoadedStream: function ChunkedStreamManager_getLoadedStream() {
Kode lerroa:       return this._loadedStreamCapability.promise;
Kode lerroa:     },
Kode lerroa:     sendRequest: function ChunkedStreamManager_sendRequest(begin, end) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
Kode lerroa:       if (!rangeReader.isStreamingSupported) {
Kode lerroa:         rangeReader.onProgress = this.onProgress.bind(this);
Kode lerroa:       }
Kode lerroa:       var chunks = [],
Kode lerroa:           loaded = 0;
Kode lerroa:       var manager = this;
Kode lerroa:       var promise = new Promise(function (resolve, reject) {
Kode lerroa:         var readChunk = function readChunk(chunk) {
Kode lerroa:           try {
Kode lerroa:             if (!chunk.done) {
Kode lerroa:               var data = chunk.value;
Kode lerroa:               chunks.push(data);
Kode lerroa:               loaded += (0, _util.arrayByteLength)(data);
Kode lerroa:               if (rangeReader.isStreamingSupported) {
Kode lerroa:                 manager.onProgress({ loaded: loaded });
Kode lerroa:               }
Kode lerroa:               rangeReader.read().then(readChunk, reject);
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             var chunkData = (0, _util.arraysToBytes)(chunks);
Kode lerroa:             chunks = null;
Kode lerroa:             resolve(chunkData);
Kode lerroa:           } catch (e) {
Kode lerroa:             reject(e);
Kode lerroa:           }
Kode lerroa:         };
Kode lerroa:         rangeReader.read().then(readChunk, reject);
Kode lerroa:       });
Kode lerroa:       promise.then(function (data) {
Kode lerroa:         if (_this.aborted) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         _this.onReceiveData({
Kode lerroa:           chunk: data,
Kode lerroa:           begin: begin
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     requestAllChunks: function ChunkedStreamManager_requestAllChunks() {
Kode lerroa:       var missingChunks = this.stream.getMissingChunks();
Kode lerroa:       this._requestChunks(missingChunks);
Kode lerroa:       return this._loadedStreamCapability.promise;
Kode lerroa:     },
Kode lerroa:     _requestChunks: function ChunkedStreamManager_requestChunks(chunks) {
Kode lerroa:       var requestId = this.currRequestId++;
Kode lerroa:       var i, ii;
Kode lerroa:       var chunksNeeded = Object.create(null);
Kode lerroa:       this.chunksNeededByRequest[requestId] = chunksNeeded;
Kode lerroa:       for (i = 0, ii = chunks.length; i < ii; i++) {
Kode lerroa:         if (!this.stream.hasChunk(chunks[i])) {
Kode lerroa:           chunksNeeded[chunks[i]] = true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if ((0, _util.isEmptyObj)(chunksNeeded)) {
Kode lerroa:         return Promise.resolve();
Kode lerroa:       }
Kode lerroa:       var capability = (0, _util.createPromiseCapability)();
Kode lerroa:       this.promisesByRequest[requestId] = capability;
Kode lerroa:       var chunksToRequest = [];
Kode lerroa:       for (var chunk in chunksNeeded) {
Kode lerroa:         chunk = chunk | 0;
Kode lerroa:         if (!(chunk in this.requestsByChunk)) {
Kode lerroa:           this.requestsByChunk[chunk] = [];
Kode lerroa:           chunksToRequest.push(chunk);
Kode lerroa:         }
Kode lerroa:         this.requestsByChunk[chunk].push(requestId);
Kode lerroa:       }
Kode lerroa:       if (!chunksToRequest.length) {
Kode lerroa:         return capability.promise;
Kode lerroa:       }
Kode lerroa:       var groupedChunksToRequest = this.groupChunks(chunksToRequest);
Kode lerroa:       for (i = 0; i < groupedChunksToRequest.length; ++i) {
Kode lerroa:         var groupedChunk = groupedChunksToRequest[i];
Kode lerroa:         var begin = groupedChunk.beginChunk * this.chunkSize;
Kode lerroa:         var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
Kode lerroa:         this.sendRequest(begin, end);
Kode lerroa:       }
Kode lerroa:       return capability.promise;
Kode lerroa:     },
Kode lerroa:     getStream: function ChunkedStreamManager_getStream() {
Kode lerroa:       return this.stream;
Kode lerroa:     },
Kode lerroa:     requestRange: function ChunkedStreamManager_requestRange(begin, end) {
Kode lerroa:       end = Math.min(end, this.length);
Kode lerroa:       var beginChunk = this.getBeginChunk(begin);
Kode lerroa:       var endChunk = this.getEndChunk(end);
Kode lerroa:       var chunks = [];
Kode lerroa:       for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
Kode lerroa:         chunks.push(chunk);
Kode lerroa:       }
Kode lerroa:       return this._requestChunks(chunks);
Kode lerroa:     },
Kode lerroa:     requestRanges: function ChunkedStreamManager_requestRanges(ranges) {
Kode lerroa:       ranges = ranges || [];
Kode lerroa:       var chunksToRequest = [];
Kode lerroa:       for (var i = 0; i < ranges.length; i++) {
Kode lerroa:         var beginChunk = this.getBeginChunk(ranges[i].begin);
Kode lerroa:         var endChunk = this.getEndChunk(ranges[i].end);
Kode lerroa:         for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
Kode lerroa:           if (chunksToRequest.indexOf(chunk) < 0) {
Kode lerroa:             chunksToRequest.push(chunk);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       chunksToRequest.sort(function (a, b) {
Kode lerroa:         return a - b;
Kode lerroa:       });
Kode lerroa:       return this._requestChunks(chunksToRequest);
Kode lerroa:     },
Kode lerroa:     groupChunks: function ChunkedStreamManager_groupChunks(chunks) {
Kode lerroa:       var groupedChunks = [];
Kode lerroa:       var beginChunk = -1;
Kode lerroa:       var prevChunk = -1;
Kode lerroa:       for (var i = 0; i < chunks.length; ++i) {
Kode lerroa:         var chunk = chunks[i];
Kode lerroa:         if (beginChunk < 0) {
Kode lerroa:           beginChunk = chunk;
Kode lerroa:         }
Kode lerroa:         if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
Kode lerroa:           groupedChunks.push({
Kode lerroa:             beginChunk: beginChunk,
Kode lerroa:             endChunk: prevChunk + 1
Kode lerroa:           });
Kode lerroa:           beginChunk = chunk;
Kode lerroa:         }
Kode lerroa:         if (i + 1 === chunks.length) {
Kode lerroa:           groupedChunks.push({
Kode lerroa:             beginChunk: beginChunk,
Kode lerroa:             endChunk: chunk + 1
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         prevChunk = chunk;
Kode lerroa:       }
Kode lerroa:       return groupedChunks;
Kode lerroa:     },
Kode lerroa:     onProgress: function ChunkedStreamManager_onProgress(args) {
Kode lerroa:       var bytesLoaded = this.stream.numChunksLoaded * this.chunkSize + args.loaded;
Kode lerroa:       this.msgHandler.send('DocProgress', {
Kode lerroa:         loaded: bytesLoaded,
Kode lerroa:         total: this.length
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     onReceiveData: function ChunkedStreamManager_onReceiveData(args) {
Kode lerroa:       var chunk = args.chunk;
Kode lerroa:       var isProgressive = args.begin === undefined;
Kode lerroa:       var begin = isProgressive ? this.progressiveDataLength : args.begin;
Kode lerroa:       var end = begin + chunk.byteLength;
Kode lerroa:       var beginChunk = Math.floor(begin / this.chunkSize);
Kode lerroa:       var endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
Kode lerroa:       if (isProgressive) {
Kode lerroa:         this.stream.onReceiveProgressiveData(chunk);
Kode lerroa:         this.progressiveDataLength = end;
Kode lerroa:       } else {
Kode lerroa:         this.stream.onReceiveData(begin, chunk);
Kode lerroa:       }
Kode lerroa:       if (this.stream.allChunksLoaded()) {
Kode lerroa:         this._loadedStreamCapability.resolve(this.stream);
Kode lerroa:       }
Kode lerroa:       var loadedRequests = [];
Kode lerroa:       var i, requestId;
Kode lerroa:       for (chunk = beginChunk; chunk < endChunk; ++chunk) {
Kode lerroa:         var requestIds = this.requestsByChunk[chunk] || [];
Kode lerroa:         delete this.requestsByChunk[chunk];
Kode lerroa:         for (i = 0; i < requestIds.length; ++i) {
Kode lerroa:           requestId = requestIds[i];
Kode lerroa:           var chunksNeeded = this.chunksNeededByRequest[requestId];
Kode lerroa:           if (chunk in chunksNeeded) {
Kode lerroa:             delete chunksNeeded[chunk];
Kode lerroa:           }
Kode lerroa:           if (!(0, _util.isEmptyObj)(chunksNeeded)) {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           loadedRequests.push(requestId);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (!this.disableAutoFetch && (0, _util.isEmptyObj)(this.requestsByChunk)) {
Kode lerroa:         var nextEmptyChunk;
Kode lerroa:         if (this.stream.numChunksLoaded === 1) {
Kode lerroa:           var lastChunk = this.stream.numChunks - 1;
Kode lerroa:           if (!this.stream.hasChunk(lastChunk)) {
Kode lerroa:             nextEmptyChunk = lastChunk;
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
Kode lerroa:         }
Kode lerroa:         if (Number.isInteger(nextEmptyChunk)) {
Kode lerroa:           this._requestChunks([nextEmptyChunk]);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (i = 0; i < loadedRequests.length; ++i) {
Kode lerroa:         requestId = loadedRequests[i];
Kode lerroa:         var capability = this.promisesByRequest[requestId];
Kode lerroa:         delete this.promisesByRequest[requestId];
Kode lerroa:         capability.resolve();
Kode lerroa:       }
Kode lerroa:       this.msgHandler.send('DocProgress', {
Kode lerroa:         loaded: this.stream.numChunksLoaded * this.chunkSize,
Kode lerroa:         total: this.length
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     onError: function ChunkedStreamManager_onError(err) {
Kode lerroa:       this._loadedStreamCapability.reject(err);
Kode lerroa:     },
Kode lerroa:     getBeginChunk: function ChunkedStreamManager_getBeginChunk(begin) {
Kode lerroa:       var chunk = Math.floor(begin / this.chunkSize);
Kode lerroa:       return chunk;
Kode lerroa:     },
Kode lerroa:     getEndChunk: function ChunkedStreamManager_getEndChunk(end) {
Kode lerroa:       var chunk = Math.floor((end - 1) / this.chunkSize) + 1;
Kode lerroa:       return chunk;
Kode lerroa:     },
Kode lerroa:     abort: function ChunkedStreamManager_abort() {
Kode lerroa:       this.aborted = true;
Kode lerroa:       if (this.pdfNetworkStream) {
Kode lerroa:         this.pdfNetworkStream.cancelAllRequests('abort');
Kode lerroa:       }
Kode lerroa:       for (var requestId in this.promisesByRequest) {
Kode lerroa:         var capability = this.promisesByRequest[requestId];
Kode lerroa:         capability.reject(new Error('Request was aborted'));
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return ChunkedStreamManager;
Kode lerroa: }();
Kode lerroa: exports.ChunkedStream = ChunkedStream;
Kode lerroa: exports.ChunkedStreamManager = ChunkedStreamManager;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 73 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.FileSpec = exports.XRef = exports.ObjectLoader = exports.Catalog = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var _parser = __w_pdfjs_require__(34);
Kode lerroa: 
Kode lerroa: var _chunked_stream = __w_pdfjs_require__(72);
Kode lerroa: 
Kode lerroa: var _crypto = __w_pdfjs_require__(76);
Kode lerroa: 
Kode lerroa: var _colorspace = __w_pdfjs_require__(27);
Kode lerroa: 
Kode lerroa: var Catalog = function CatalogClosure() {
Kode lerroa:   function Catalog(pdfManager, xref, pageFactory) {
Kode lerroa:     this.pdfManager = pdfManager;
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.catDict = xref.getCatalogObj();
Kode lerroa:     if (!(0, _primitives.isDict)(this.catDict)) {
Kode lerroa:       throw new _util.FormatError('catalog object is not a dictionary');
Kode lerroa:     }
Kode lerroa:     this.fontCache = new _primitives.RefSetCache();
Kode lerroa:     this.builtInCMapCache = Object.create(null);
Kode lerroa:     this.pageKidsCountCache = new _primitives.RefSetCache();
Kode lerroa:     this.pageFactory = pageFactory;
Kode lerroa:     this.pagePromises = [];
Kode lerroa:   }
Kode lerroa:   Catalog.prototype = {
Kode lerroa:     get metadata() {
Kode lerroa:       var streamRef = this.catDict.getRaw('Metadata');
Kode lerroa:       if (!(0, _primitives.isRef)(streamRef)) {
Kode lerroa:         return (0, _util.shadow)(this, 'metadata', null);
Kode lerroa:       }
Kode lerroa:       var encryptMetadata = !this.xref.encrypt ? false : this.xref.encrypt.encryptMetadata;
Kode lerroa:       var stream = this.xref.fetch(streamRef, !encryptMetadata);
Kode lerroa:       var metadata;
Kode lerroa:       if (stream && (0, _primitives.isDict)(stream.dict)) {
Kode lerroa:         var type = stream.dict.get('Type');
Kode lerroa:         var subtype = stream.dict.get('Subtype');
Kode lerroa:         if ((0, _primitives.isName)(type, 'Metadata') && (0, _primitives.isName)(subtype, 'XML')) {
Kode lerroa:           try {
Kode lerroa:             metadata = (0, _util.stringToUTF8String)((0, _util.bytesToString)(stream.getBytes()));
Kode lerroa:           } catch (e) {
Kode lerroa:             if (e instanceof _util.MissingDataException) {
Kode lerroa:               throw e;
Kode lerroa:             }
Kode lerroa:             (0, _util.info)('Skipping invalid metadata.');
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'metadata', metadata);
Kode lerroa:     },
Kode lerroa:     get toplevelPagesDict() {
Kode lerroa:       var pagesObj = this.catDict.get('Pages');
Kode lerroa:       if (!(0, _primitives.isDict)(pagesObj)) {
Kode lerroa:         throw new _util.FormatError('invalid top-level pages dictionary');
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'toplevelPagesDict', pagesObj);
Kode lerroa:     },
Kode lerroa:     get documentOutline() {
Kode lerroa:       var obj = null;
Kode lerroa:       try {
Kode lerroa:         obj = this.readDocumentOutline();
Kode lerroa:       } catch (ex) {
Kode lerroa:         if (ex instanceof _util.MissingDataException) {
Kode lerroa:           throw ex;
Kode lerroa:         }
Kode lerroa:         (0, _util.warn)('Unable to read document outline');
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'documentOutline', obj);
Kode lerroa:     },
Kode lerroa:     readDocumentOutline: function Catalog_readDocumentOutline() {
Kode lerroa:       var obj = this.catDict.get('Outlines');
Kode lerroa:       if (!(0, _primitives.isDict)(obj)) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       obj = obj.getRaw('First');
Kode lerroa:       if (!(0, _primitives.isRef)(obj)) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var root = { items: [] };
Kode lerroa:       var queue = [{
Kode lerroa:         obj: obj,
Kode lerroa:         parent: root
Kode lerroa:       }];
Kode lerroa:       var processed = new _primitives.RefSet();
Kode lerroa:       processed.put(obj);
Kode lerroa:       var xref = this.xref,
Kode lerroa:           blackColor = new Uint8Array(3);
Kode lerroa:       while (queue.length > 0) {
Kode lerroa:         var i = queue.shift();
Kode lerroa:         var outlineDict = xref.fetchIfRef(i.obj);
Kode lerroa:         if (outlineDict === null) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (!outlineDict.has('Title')) {
Kode lerroa:           throw new _util.FormatError('Invalid outline item');
Kode lerroa:         }
Kode lerroa:         var data = {
Kode lerroa:           url: null,
Kode lerroa:           dest: null
Kode lerroa:         };
Kode lerroa:         Catalog.parseDestDictionary({
Kode lerroa:           destDict: outlineDict,
Kode lerroa:           resultObj: data,
Kode lerroa:           docBaseUrl: this.pdfManager.docBaseUrl
Kode lerroa:         });
Kode lerroa:         var title = outlineDict.get('Title');
Kode lerroa:         var flags = outlineDict.get('F') || 0;
Kode lerroa:         var color = outlineDict.getArray('C'),
Kode lerroa:             rgbColor = blackColor;
Kode lerroa:         if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
Kode lerroa:           rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
Kode lerroa:         }
Kode lerroa:         var outlineItem = {
Kode lerroa:           dest: data.dest,
Kode lerroa:           url: data.url,
Kode lerroa:           unsafeUrl: data.unsafeUrl,
Kode lerroa:           newWindow: data.newWindow,
Kode lerroa:           title: (0, _util.stringToPDFString)(title),
Kode lerroa:           color: rgbColor,
Kode lerroa:           count: outlineDict.get('Count'),
Kode lerroa:           bold: !!(flags & 2),
Kode lerroa:           italic: !!(flags & 1),
Kode lerroa:           items: []
Kode lerroa:         };
Kode lerroa:         i.parent.items.push(outlineItem);
Kode lerroa:         obj = outlineDict.getRaw('First');
Kode lerroa:         if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
Kode lerroa:           queue.push({
Kode lerroa:             obj: obj,
Kode lerroa:             parent: outlineItem
Kode lerroa:           });
Kode lerroa:           processed.put(obj);
Kode lerroa:         }
Kode lerroa:         obj = outlineDict.getRaw('Next');
Kode lerroa:         if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
Kode lerroa:           queue.push({
Kode lerroa:             obj: obj,
Kode lerroa:             parent: i.parent
Kode lerroa:           });
Kode lerroa:           processed.put(obj);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return root.items.length > 0 ? root.items : null;
Kode lerroa:     },
Kode lerroa:     get numPages() {
Kode lerroa:       var obj = this.toplevelPagesDict.get('Count');
Kode lerroa:       if (!Number.isInteger(obj)) {
Kode lerroa:         throw new _util.FormatError('page count in top level pages object is not an integer');
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'numPages', obj);
Kode lerroa:     },
Kode lerroa:     get destinations() {
Kode lerroa:       function fetchDestination(dest) {
Kode lerroa:         return (0, _primitives.isDict)(dest) ? dest.get('D') : dest;
Kode lerroa:       }
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var dests = {},
Kode lerroa:           nameTreeRef,
Kode lerroa:           nameDictionaryRef;
Kode lerroa:       var obj = this.catDict.get('Names');
Kode lerroa:       if (obj && obj.has('Dests')) {
Kode lerroa:         nameTreeRef = obj.getRaw('Dests');
Kode lerroa:       } else if (this.catDict.has('Dests')) {
Kode lerroa:         nameDictionaryRef = this.catDict.get('Dests');
Kode lerroa:       }
Kode lerroa:       if (nameDictionaryRef) {
Kode lerroa:         obj = nameDictionaryRef;
Kode lerroa:         obj.forEach(function catalogForEach(key, value) {
Kode lerroa:           if (!value) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           dests[key] = fetchDestination(value);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       if (nameTreeRef) {
Kode lerroa:         var nameTree = new NameTree(nameTreeRef, xref);
Kode lerroa:         var names = nameTree.getAll();
Kode lerroa:         for (var name in names) {
Kode lerroa:           dests[name] = fetchDestination(names[name]);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'destinations', dests);
Kode lerroa:     },
Kode lerroa:     getDestination: function Catalog_getDestination(destinationId) {
Kode lerroa:       function fetchDestination(dest) {
Kode lerroa:         return (0, _primitives.isDict)(dest) ? dest.get('D') : dest;
Kode lerroa:       }
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var dest = null,
Kode lerroa:           nameTreeRef,
Kode lerroa:           nameDictionaryRef;
Kode lerroa:       var obj = this.catDict.get('Names');
Kode lerroa:       if (obj && obj.has('Dests')) {
Kode lerroa:         nameTreeRef = obj.getRaw('Dests');
Kode lerroa:       } else if (this.catDict.has('Dests')) {
Kode lerroa:         nameDictionaryRef = this.catDict.get('Dests');
Kode lerroa:       }
Kode lerroa:       if (nameDictionaryRef) {
Kode lerroa:         var value = nameDictionaryRef.get(destinationId);
Kode lerroa:         if (value) {
Kode lerroa:           dest = fetchDestination(value);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (nameTreeRef) {
Kode lerroa:         var nameTree = new NameTree(nameTreeRef, xref);
Kode lerroa:         dest = fetchDestination(nameTree.get(destinationId));
Kode lerroa:       }
Kode lerroa:       return dest;
Kode lerroa:     },
Kode lerroa:     get pageLabels() {
Kode lerroa:       var obj = null;
Kode lerroa:       try {
Kode lerroa:         obj = this.readPageLabels();
Kode lerroa:       } catch (ex) {
Kode lerroa:         if (ex instanceof _util.MissingDataException) {
Kode lerroa:           throw ex;
Kode lerroa:         }
Kode lerroa:         (0, _util.warn)('Unable to read page labels.');
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'pageLabels', obj);
Kode lerroa:     },
Kode lerroa:     readPageLabels: function Catalog_readPageLabels() {
Kode lerroa:       var obj = this.catDict.getRaw('PageLabels');
Kode lerroa:       if (!obj) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var pageLabels = new Array(this.numPages);
Kode lerroa:       var style = null;
Kode lerroa:       var prefix = '';
Kode lerroa:       var numberTree = new NumberTree(obj, this.xref);
Kode lerroa:       var nums = numberTree.getAll();
Kode lerroa:       var currentLabel = '',
Kode lerroa:           currentIndex = 1;
Kode lerroa:       for (var i = 0, ii = this.numPages; i < ii; i++) {
Kode lerroa:         if (i in nums) {
Kode lerroa:           var labelDict = nums[i];
Kode lerroa:           if (!(0, _primitives.isDict)(labelDict)) {
Kode lerroa:             throw new _util.FormatError('The PageLabel is not a dictionary.');
Kode lerroa:           }
Kode lerroa:           var type = labelDict.get('Type');
Kode lerroa:           if (type && !(0, _primitives.isName)(type, 'PageLabel')) {
Kode lerroa:             throw new _util.FormatError('Invalid type in PageLabel dictionary.');
Kode lerroa:           }
Kode lerroa:           var s = labelDict.get('S');
Kode lerroa:           if (s && !(0, _primitives.isName)(s)) {
Kode lerroa:             throw new _util.FormatError('Invalid style in PageLabel dictionary.');
Kode lerroa:           }
Kode lerroa:           style = s ? s.name : null;
Kode lerroa:           var p = labelDict.get('P');
Kode lerroa:           if (p && !(0, _util.isString)(p)) {
Kode lerroa:             throw new _util.FormatError('Invalid prefix in PageLabel dictionary.');
Kode lerroa:           }
Kode lerroa:           prefix = p ? (0, _util.stringToPDFString)(p) : '';
Kode lerroa:           var st = labelDict.get('St');
Kode lerroa:           if (st && !(Number.isInteger(st) && st >= 1)) {
Kode lerroa:             throw new _util.FormatError('Invalid start in PageLabel dictionary.');
Kode lerroa:           }
Kode lerroa:           currentIndex = st || 1;
Kode lerroa:         }
Kode lerroa:         switch (style) {
Kode lerroa:           case 'D':
Kode lerroa:             currentLabel = currentIndex;
Kode lerroa:             break;
Kode lerroa:           case 'R':
Kode lerroa:           case 'r':
Kode lerroa:             currentLabel = _util.Util.toRoman(currentIndex, style === 'r');
Kode lerroa:             break;
Kode lerroa:           case 'A':
Kode lerroa:           case 'a':
Kode lerroa:             var LIMIT = 26;
Kode lerroa:             var A_UPPER_CASE = 0x41,
Kode lerroa:                 A_LOWER_CASE = 0x61;
Kode lerroa:             var baseCharCode = style === 'a' ? A_LOWER_CASE : A_UPPER_CASE;
Kode lerroa:             var letterIndex = currentIndex - 1;
Kode lerroa:             var character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
Kode lerroa:             var charBuf = [];
Kode lerroa:             for (var j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
Kode lerroa:               charBuf.push(character);
Kode lerroa:             }
Kode lerroa:             currentLabel = charBuf.join('');
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             if (style) {
Kode lerroa:               throw new _util.FormatError('Invalid style "' + style + '" in PageLabel dictionary.');
Kode lerroa:             }
Kode lerroa:         }
Kode lerroa:         pageLabels[i] = prefix + currentLabel;
Kode lerroa:         currentLabel = '';
Kode lerroa:         currentIndex++;
Kode lerroa:       }
Kode lerroa:       return pageLabels;
Kode lerroa:     },
Kode lerroa:     get pageMode() {
Kode lerroa:       var obj = this.catDict.get('PageMode');
Kode lerroa:       var pageMode = 'UseNone';
Kode lerroa:       if ((0, _primitives.isName)(obj)) {
Kode lerroa:         switch (obj.name) {
Kode lerroa:           case 'UseNone':
Kode lerroa:           case 'UseOutlines':
Kode lerroa:           case 'UseThumbs':
Kode lerroa:           case 'FullScreen':
Kode lerroa:           case 'UseOC':
Kode lerroa:           case 'UseAttachments':
Kode lerroa:             pageMode = obj.name;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'pageMode', pageMode);
Kode lerroa:     },
Kode lerroa:     get attachments() {
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var attachments = null,
Kode lerroa:           nameTreeRef;
Kode lerroa:       var obj = this.catDict.get('Names');
Kode lerroa:       if (obj) {
Kode lerroa:         nameTreeRef = obj.getRaw('EmbeddedFiles');
Kode lerroa:       }
Kode lerroa:       if (nameTreeRef) {
Kode lerroa:         var nameTree = new NameTree(nameTreeRef, xref);
Kode lerroa:         var names = nameTree.getAll();
Kode lerroa:         for (var name in names) {
Kode lerroa:           var fs = new FileSpec(names[name], xref);
Kode lerroa:           if (!attachments) {
Kode lerroa:             attachments = Object.create(null);
Kode lerroa:           }
Kode lerroa:           attachments[(0, _util.stringToPDFString)(name)] = fs.serializable;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'attachments', attachments);
Kode lerroa:     },
Kode lerroa:     get javaScript() {
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var obj = this.catDict.get('Names');
Kode lerroa:       var javaScript = [];
Kode lerroa:       function appendIfJavaScriptDict(jsDict) {
Kode lerroa:         var type = jsDict.get('S');
Kode lerroa:         if (!(0, _primitives.isName)(type, 'JavaScript')) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var js = jsDict.get('JS');
Kode lerroa:         if ((0, _primitives.isStream)(js)) {
Kode lerroa:           js = (0, _util.bytesToString)(js.getBytes());
Kode lerroa:         } else if (!(0, _util.isString)(js)) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         javaScript.push((0, _util.stringToPDFString)(js));
Kode lerroa:       }
Kode lerroa:       if (obj && obj.has('JavaScript')) {
Kode lerroa:         var nameTree = new NameTree(obj.getRaw('JavaScript'), xref);
Kode lerroa:         var names = nameTree.getAll();
Kode lerroa:         for (var name in names) {
Kode lerroa:           var jsDict = names[name];
Kode lerroa:           if ((0, _primitives.isDict)(jsDict)) {
Kode lerroa:             appendIfJavaScriptDict(jsDict);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var openactionDict = this.catDict.get('OpenAction');
Kode lerroa:       if ((0, _primitives.isDict)(openactionDict, 'Action')) {
Kode lerroa:         var actionType = openactionDict.get('S');
Kode lerroa:         if ((0, _primitives.isName)(actionType, 'Named')) {
Kode lerroa:           var action = openactionDict.get('N');
Kode lerroa:           if ((0, _primitives.isName)(action, 'Print')) {
Kode lerroa:             javaScript.push('print({});');
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           appendIfJavaScriptDict(openactionDict);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return (0, _util.shadow)(this, 'javaScript', javaScript);
Kode lerroa:     },
Kode lerroa:     cleanup: function Catalog_cleanup() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       this.pageKidsCountCache.clear();
Kode lerroa:       var promises = [];
Kode lerroa:       this.fontCache.forEach(function (promise) {
Kode lerroa:         promises.push(promise);
Kode lerroa:       });
Kode lerroa:       return Promise.all(promises).then(function (translatedFonts) {
Kode lerroa:         for (var i = 0, ii = translatedFonts.length; i < ii; i++) {
Kode lerroa:           var font = translatedFonts[i].dict;
Kode lerroa:           delete font.translated;
Kode lerroa:         }
Kode lerroa:         _this.fontCache.clear();
Kode lerroa:         _this.builtInCMapCache = Object.create(null);
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getPage: function Catalog_getPage(pageIndex) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (!(pageIndex in this.pagePromises)) {
Kode lerroa:         this.pagePromises[pageIndex] = this.getPageDict(pageIndex).then(function (_ref) {
Kode lerroa:           var _ref2 = _slicedToArray(_ref, 2),
Kode lerroa:               dict = _ref2[0],
Kode lerroa:               ref = _ref2[1];
Kode lerroa: 
Kode lerroa:           return _this2.pageFactory.createPage(pageIndex, dict, ref, _this2.fontCache, _this2.builtInCMapCache);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       return this.pagePromises[pageIndex];
Kode lerroa:     },
Kode lerroa:     getPageDict: function Catalog_getPageDict(pageIndex) {
Kode lerroa:       var capability = (0, _util.createPromiseCapability)();
Kode lerroa:       var nodesToVisit = [this.catDict.getRaw('Pages')];
Kode lerroa:       var count,
Kode lerroa:           currentPageIndex = 0;
Kode lerroa:       var xref = this.xref,
Kode lerroa:           pageKidsCountCache = this.pageKidsCountCache;
Kode lerroa:       function next() {
Kode lerroa:         while (nodesToVisit.length) {
Kode lerroa:           var currentNode = nodesToVisit.pop();
Kode lerroa:           if ((0, _primitives.isRef)(currentNode)) {
Kode lerroa:             count = pageKidsCountCache.get(currentNode);
Kode lerroa:             if (count > 0 && currentPageIndex + count < pageIndex) {
Kode lerroa:               currentPageIndex += count;
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             xref.fetchAsync(currentNode).then(function (obj) {
Kode lerroa:               if ((0, _primitives.isDict)(obj, 'Page') || (0, _primitives.isDict)(obj) && !obj.has('Kids')) {
Kode lerroa:                 if (pageIndex === currentPageIndex) {
Kode lerroa:                   if (currentNode && !pageKidsCountCache.has(currentNode)) {
Kode lerroa:                     pageKidsCountCache.put(currentNode, 1);
Kode lerroa:                   }
Kode lerroa:                   capability.resolve([obj, currentNode]);
Kode lerroa:                 } else {
Kode lerroa:                   currentPageIndex++;
Kode lerroa:                   next();
Kode lerroa:                 }
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               nodesToVisit.push(obj);
Kode lerroa:               next();
Kode lerroa:             }, capability.reject);
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           if (!(0, _primitives.isDict)(currentNode)) {
Kode lerroa:             capability.reject(new _util.FormatError('page dictionary kid reference points to wrong type of object'));
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           count = currentNode.get('Count');
Kode lerroa:           var objId = currentNode.objId;
Kode lerroa:           if (objId && !pageKidsCountCache.has(objId)) {
Kode lerroa:             pageKidsCountCache.put(objId, count);
Kode lerroa:           }
Kode lerroa:           if (currentPageIndex + count <= pageIndex) {
Kode lerroa:             currentPageIndex += count;
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           var kids = currentNode.get('Kids');
Kode lerroa:           if (!Array.isArray(kids)) {
Kode lerroa:             capability.reject(new _util.FormatError('page dictionary kids object is not an array'));
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           for (var last = kids.length - 1; last >= 0; last--) {
Kode lerroa:             nodesToVisit.push(kids[last]);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         capability.reject(new Error('Page index ' + pageIndex + ' not found.'));
Kode lerroa:       }
Kode lerroa:       next();
Kode lerroa:       return capability.promise;
Kode lerroa:     },
Kode lerroa:     getPageIndex: function Catalog_getPageIndex(pageRef) {
Kode lerroa:       var xref = this.xref;
Kode lerroa:       function pagesBeforeRef(kidRef) {
Kode lerroa:         var total = 0;
Kode lerroa:         var parentRef;
Kode lerroa:         return xref.fetchAsync(kidRef).then(function (node) {
Kode lerroa:           if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, 'Page') && !((0, _primitives.isDict)(node) && !node.has('Type') && node.has('Contents'))) {
Kode lerroa:             throw new _util.FormatError('The reference does not point to a /Page Dict.');
Kode lerroa:           }
Kode lerroa:           if (!node) {
Kode lerroa:             return null;
Kode lerroa:           }
Kode lerroa:           if (!(0, _primitives.isDict)(node)) {
Kode lerroa:             throw new _util.FormatError('node must be a Dict.');
Kode lerroa:           }
Kode lerroa:           parentRef = node.getRaw('Parent');
Kode lerroa:           return node.getAsync('Parent');
Kode lerroa:         }).then(function (parent) {
Kode lerroa:           if (!parent) {
Kode lerroa:             return null;
Kode lerroa:           }
Kode lerroa:           if (!(0, _primitives.isDict)(parent)) {
Kode lerroa:             throw new _util.FormatError('parent must be a Dict.');
Kode lerroa:           }
Kode lerroa:           return parent.getAsync('Kids');
Kode lerroa:         }).then(function (kids) {
Kode lerroa:           if (!kids) {
Kode lerroa:             return null;
Kode lerroa:           }
Kode lerroa:           var kidPromises = [];
Kode lerroa:           var found = false;
Kode lerroa:           for (var i = 0; i < kids.length; i++) {
Kode lerroa:             var kid = kids[i];
Kode lerroa:             if (!(0, _primitives.isRef)(kid)) {
Kode lerroa:               throw new _util.FormatError('kid must be a Ref.');
Kode lerroa:             }
Kode lerroa:             if (kid.num === kidRef.num) {
Kode lerroa:               found = true;
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:             kidPromises.push(xref.fetchAsync(kid).then(function (kid) {
Kode lerroa:               if (kid.has('Count')) {
Kode lerroa:                 var count = kid.get('Count');
Kode lerroa:                 total += count;
Kode lerroa:               } else {
Kode lerroa:                 total++;
Kode lerroa:               }
Kode lerroa:             }));
Kode lerroa:           }
Kode lerroa:           if (!found) {
Kode lerroa:             throw new _util.FormatError('kid ref not found in parents kids');
Kode lerroa:           }
Kode lerroa:           return Promise.all(kidPromises).then(function () {
Kode lerroa:             return [total, parentRef];
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var total = 0;
Kode lerroa:       function next(ref) {
Kode lerroa:         return pagesBeforeRef(ref).then(function (args) {
Kode lerroa:           if (!args) {
Kode lerroa:             return total;
Kode lerroa:           }
Kode lerroa:           var count = args[0];
Kode lerroa:           var parentRef = args[1];
Kode lerroa:           total += count;
Kode lerroa:           return next(parentRef);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       return next(pageRef);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   Catalog.parseDestDictionary = function Catalog_parseDestDictionary(params) {
Kode lerroa:     function addDefaultProtocolToUrl(url) {
Kode lerroa:       if (url.indexOf('www.') === 0) {
Kode lerroa:         return 'http://' + url;
Kode lerroa:       }
Kode lerroa:       return url;
Kode lerroa:     }
Kode lerroa:     function tryConvertUrlEncoding(url) {
Kode lerroa:       try {
Kode lerroa:         return (0, _util.stringToUTF8String)(url);
Kode lerroa:       } catch (e) {
Kode lerroa:         return url;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var destDict = params.destDict;
Kode lerroa:     if (!(0, _primitives.isDict)(destDict)) {
Kode lerroa:       (0, _util.warn)('parseDestDictionary: "destDict" must be a dictionary.');
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var resultObj = params.resultObj;
Kode lerroa:     if ((typeof resultObj === 'undefined' ? 'undefined' : _typeof(resultObj)) !== 'object') {
Kode lerroa:       (0, _util.warn)('parseDestDictionary: "resultObj" must be an object.');
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var docBaseUrl = params.docBaseUrl || null;
Kode lerroa:     var action = destDict.get('A'),
Kode lerroa:         url,
Kode lerroa:         dest;
Kode lerroa:     if (!(0, _primitives.isDict)(action) && destDict.has('Dest')) {
Kode lerroa:       action = destDict.get('Dest');
Kode lerroa:     }
Kode lerroa:     if ((0, _primitives.isDict)(action)) {
Kode lerroa:       var actionType = action.get('S');
Kode lerroa:       if (!(0, _primitives.isName)(actionType)) {
Kode lerroa:         (0, _util.warn)('parseDestDictionary: Invalid type in Action dictionary.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var actionName = actionType.name;
Kode lerroa:       switch (actionName) {
Kode lerroa:         case 'URI':
Kode lerroa:           url = action.get('URI');
Kode lerroa:           if ((0, _primitives.isName)(url)) {
Kode lerroa:             url = '/' + url.name;
Kode lerroa:           } else if ((0, _util.isString)(url)) {
Kode lerroa:             url = addDefaultProtocolToUrl(url);
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'GoTo':
Kode lerroa:           dest = action.get('D');
Kode lerroa:           break;
Kode lerroa:         case 'Launch':
Kode lerroa:         case 'GoToR':
Kode lerroa:           var urlDict = action.get('F');
Kode lerroa:           if ((0, _primitives.isDict)(urlDict)) {
Kode lerroa:             url = urlDict.get('F') || null;
Kode lerroa:           } else if ((0, _util.isString)(urlDict)) {
Kode lerroa:             url = urlDict;
Kode lerroa:           }
Kode lerroa:           var remoteDest = action.get('D');
Kode lerroa:           if (remoteDest) {
Kode lerroa:             if ((0, _primitives.isName)(remoteDest)) {
Kode lerroa:               remoteDest = remoteDest.name;
Kode lerroa:             }
Kode lerroa:             if ((0, _util.isString)(url)) {
Kode lerroa:               var baseUrl = url.split('#')[0];
Kode lerroa:               if ((0, _util.isString)(remoteDest)) {
Kode lerroa:                 url = baseUrl + '#' + remoteDest;
Kode lerroa:               } else if (Array.isArray(remoteDest)) {
Kode lerroa:                 url = baseUrl + '#' + JSON.stringify(remoteDest);
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           var newWindow = action.get('NewWindow');
Kode lerroa:           if ((0, _util.isBool)(newWindow)) {
Kode lerroa:             resultObj.newWindow = newWindow;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'Named':
Kode lerroa:           var namedAction = action.get('N');
Kode lerroa:           if ((0, _primitives.isName)(namedAction)) {
Kode lerroa:             resultObj.action = namedAction.name;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'JavaScript':
Kode lerroa:           var jsAction = action.get('JS'),
Kode lerroa:               js;
Kode lerroa:           if ((0, _primitives.isStream)(jsAction)) {
Kode lerroa:             js = (0, _util.bytesToString)(jsAction.getBytes());
Kode lerroa:           } else if ((0, _util.isString)(jsAction)) {
Kode lerroa:             js = jsAction;
Kode lerroa:           }
Kode lerroa:           if (js) {
Kode lerroa:             var URL_OPEN_METHODS = ['app.launchURL', 'window.open'];
Kode lerroa:             var regex = new RegExp('^\\s*(' + URL_OPEN_METHODS.join('|').split('.').join('\\.') + ')\\((?:\'|\")([^\'\"]*)(?:\'|\")(?:,\\s*(\\w+)\\)|\\))', 'i');
Kode lerroa:             var jsUrl = regex.exec((0, _util.stringToPDFString)(js));
Kode lerroa:             if (jsUrl && jsUrl[2]) {
Kode lerroa:               url = jsUrl[2];
Kode lerroa:               if (jsUrl[3] === 'true' && jsUrl[1] === 'app.launchURL') {
Kode lerroa:                 resultObj.newWindow = true;
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         default:
Kode lerroa:           (0, _util.warn)('parseDestDictionary: Unsupported Action type "' + actionName + '".');
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     } else if (destDict.has('Dest')) {
Kode lerroa:       dest = destDict.get('Dest');
Kode lerroa:     }
Kode lerroa:     if ((0, _util.isString)(url)) {
Kode lerroa:       url = tryConvertUrlEncoding(url);
Kode lerroa:       var absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl);
Kode lerroa:       if (absoluteUrl) {
Kode lerroa:         resultObj.url = absoluteUrl.href;
Kode lerroa:       }
Kode lerroa:       resultObj.unsafeUrl = url;
Kode lerroa:     }
Kode lerroa:     if (dest) {
Kode lerroa:       if ((0, _primitives.isName)(dest)) {
Kode lerroa:         dest = dest.name;
Kode lerroa:       }
Kode lerroa:       if ((0, _util.isString)(dest) || Array.isArray(dest)) {
Kode lerroa:         resultObj.dest = dest;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Catalog;
Kode lerroa: }();
Kode lerroa: var XRef = function XRefClosure() {
Kode lerroa:   function XRef(stream, pdfManager) {
Kode lerroa:     this.stream = stream;
Kode lerroa:     this.pdfManager = pdfManager;
Kode lerroa:     this.entries = [];
Kode lerroa:     this.xrefstms = Object.create(null);
Kode lerroa:     this.cache = [];
Kode lerroa:     this.stats = {
Kode lerroa:       streamTypes: [],
Kode lerroa:       fontTypes: []
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   XRef.prototype = {
Kode lerroa:     setStartXRef: function XRef_setStartXRef(startXRef) {
Kode lerroa:       this.startXRefQueue = [startXRef];
Kode lerroa:     },
Kode lerroa:     parse: function XRef_parse(recoveryMode) {
Kode lerroa:       var trailerDict;
Kode lerroa:       if (!recoveryMode) {
Kode lerroa:         trailerDict = this.readXRef();
Kode lerroa:       } else {
Kode lerroa:         (0, _util.warn)('Indexing all PDF objects');
Kode lerroa:         trailerDict = this.indexObjects();
Kode lerroa:       }
Kode lerroa:       trailerDict.assignXref(this);
Kode lerroa:       this.trailer = trailerDict;
Kode lerroa:       var encrypt = trailerDict.get('Encrypt');
Kode lerroa:       if ((0, _primitives.isDict)(encrypt)) {
Kode lerroa:         var ids = trailerDict.get('ID');
Kode lerroa:         var fileId = ids && ids.length ? ids[0] : '';
Kode lerroa:         encrypt.suppressEncryption = true;
Kode lerroa:         this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
Kode lerroa:       }
Kode lerroa:       if (!(this.root = trailerDict.get('Root'))) {
Kode lerroa:         throw new _util.FormatError('Invalid root reference');
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     processXRefTable: function XRef_processXRefTable(parser) {
Kode lerroa:       if (!('tableState' in this)) {
Kode lerroa:         this.tableState = {
Kode lerroa:           entryNum: 0,
Kode lerroa:           streamPos: parser.lexer.stream.pos,
Kode lerroa:           parserBuf1: parser.buf1,
Kode lerroa:           parserBuf2: parser.buf2
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:       var obj = this.readXRefTable(parser);
Kode lerroa:       if (!(0, _primitives.isCmd)(obj, 'trailer')) {
Kode lerroa:         throw new _util.FormatError('Invalid XRef table: could not find trailer dictionary');
Kode lerroa:       }
Kode lerroa:       var dict = parser.getObj();
Kode lerroa:       if (!(0, _primitives.isDict)(dict) && dict.dict) {
Kode lerroa:         dict = dict.dict;
Kode lerroa:       }
Kode lerroa:       if (!(0, _primitives.isDict)(dict)) {
Kode lerroa:         throw new _util.FormatError('Invalid XRef table: could not parse trailer dictionary');
Kode lerroa:       }
Kode lerroa:       delete this.tableState;
Kode lerroa:       return dict;
Kode lerroa:     },
Kode lerroa:     readXRefTable: function XRef_readXRefTable(parser) {
Kode lerroa:       var stream = parser.lexer.stream;
Kode lerroa:       var tableState = this.tableState;
Kode lerroa:       stream.pos = tableState.streamPos;
Kode lerroa:       parser.buf1 = tableState.parserBuf1;
Kode lerroa:       parser.buf2 = tableState.parserBuf2;
Kode lerroa:       var obj;
Kode lerroa:       while (true) {
Kode lerroa:         if (!('firstEntryNum' in tableState) || !('entryCount' in tableState)) {
Kode lerroa:           if ((0, _primitives.isCmd)(obj = parser.getObj(), 'trailer')) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           tableState.firstEntryNum = obj;
Kode lerroa:           tableState.entryCount = parser.getObj();
Kode lerroa:         }
Kode lerroa:         var first = tableState.firstEntryNum;
Kode lerroa:         var count = tableState.entryCount;
Kode lerroa:         if (!Number.isInteger(first) || !Number.isInteger(count)) {
Kode lerroa:           throw new _util.FormatError('Invalid XRef table: wrong types in subsection header');
Kode lerroa:         }
Kode lerroa:         for (var i = tableState.entryNum; i < count; i++) {
Kode lerroa:           tableState.streamPos = stream.pos;
Kode lerroa:           tableState.entryNum = i;
Kode lerroa:           tableState.parserBuf1 = parser.buf1;
Kode lerroa:           tableState.parserBuf2 = parser.buf2;
Kode lerroa:           var entry = {};
Kode lerroa:           entry.offset = parser.getObj();
Kode lerroa:           entry.gen = parser.getObj();
Kode lerroa:           var type = parser.getObj();
Kode lerroa:           if ((0, _primitives.isCmd)(type, 'f')) {
Kode lerroa:             entry.free = true;
Kode lerroa:           } else if ((0, _primitives.isCmd)(type, 'n')) {
Kode lerroa:             entry.uncompressed = true;
Kode lerroa:           }
Kode lerroa:           if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
Kode lerroa:             throw new _util.FormatError('Invalid entry in XRef subsection: ' + first + ', ' + count);
Kode lerroa:           }
Kode lerroa:           if (i === 0 && entry.free && first === 1) {
Kode lerroa:             first = 0;
Kode lerroa:           }
Kode lerroa:           if (!this.entries[i + first]) {
Kode lerroa:             this.entries[i + first] = entry;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         tableState.entryNum = 0;
Kode lerroa:         tableState.streamPos = stream.pos;
Kode lerroa:         tableState.parserBuf1 = parser.buf1;
Kode lerroa:         tableState.parserBuf2 = parser.buf2;
Kode lerroa:         delete tableState.firstEntryNum;
Kode lerroa:         delete tableState.entryCount;
Kode lerroa:       }
Kode lerroa:       if (this.entries[0] && !this.entries[0].free) {
Kode lerroa:         throw new _util.FormatError('Invalid XRef table: unexpected first object');
Kode lerroa:       }
Kode lerroa:       return obj;
Kode lerroa:     },
Kode lerroa:     processXRefStream: function XRef_processXRefStream(stream) {
Kode lerroa:       if (!('streamState' in this)) {
Kode lerroa:         var streamParameters = stream.dict;
Kode lerroa:         var byteWidths = streamParameters.get('W');
Kode lerroa:         var range = streamParameters.get('Index');
Kode lerroa:         if (!range) {
Kode lerroa:           range = [0, streamParameters.get('Size')];
Kode lerroa:         }
Kode lerroa:         this.streamState = {
Kode lerroa:           entryRanges: range,
Kode lerroa:           byteWidths: byteWidths,
Kode lerroa:           entryNum: 0,
Kode lerroa:           streamPos: stream.pos
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:       this.readXRefStream(stream);
Kode lerroa:       delete this.streamState;
Kode lerroa:       return stream.dict;
Kode lerroa:     },
Kode lerroa:     readXRefStream: function XRef_readXRefStream(stream) {
Kode lerroa:       var i, j;
Kode lerroa:       var streamState = this.streamState;
Kode lerroa:       stream.pos = streamState.streamPos;
Kode lerroa:       var byteWidths = streamState.byteWidths;
Kode lerroa:       var typeFieldWidth = byteWidths[0];
Kode lerroa:       var offsetFieldWidth = byteWidths[1];
Kode lerroa:       var generationFieldWidth = byteWidths[2];
Kode lerroa:       var entryRanges = streamState.entryRanges;
Kode lerroa:       while (entryRanges.length > 0) {
Kode lerroa:         var first = entryRanges[0];
Kode lerroa:         var n = entryRanges[1];
Kode lerroa:         if (!Number.isInteger(first) || !Number.isInteger(n)) {
Kode lerroa:           throw new _util.FormatError('Invalid XRef range fields: ' + first + ', ' + n);
Kode lerroa:         }
Kode lerroa:         if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
Kode lerroa:           throw new _util.FormatError('Invalid XRef entry fields length: ' + first + ', ' + n);
Kode lerroa:         }
Kode lerroa:         for (i = streamState.entryNum; i < n; ++i) {
Kode lerroa:           streamState.entryNum = i;
Kode lerroa:           streamState.streamPos = stream.pos;
Kode lerroa:           var type = 0,
Kode lerroa:               offset = 0,
Kode lerroa:               generation = 0;
Kode lerroa:           for (j = 0; j < typeFieldWidth; ++j) {
Kode lerroa:             type = type << 8 | stream.getByte();
Kode lerroa:           }
Kode lerroa:           if (typeFieldWidth === 0) {
Kode lerroa:             type = 1;
Kode lerroa:           }
Kode lerroa:           for (j = 0; j < offsetFieldWidth; ++j) {
Kode lerroa:             offset = offset << 8 | stream.getByte();
Kode lerroa:           }
Kode lerroa:           for (j = 0; j < generationFieldWidth; ++j) {
Kode lerroa:             generation = generation << 8 | stream.getByte();
Kode lerroa:           }
Kode lerroa:           var entry = {};
Kode lerroa:           entry.offset = offset;
Kode lerroa:           entry.gen = generation;
Kode lerroa:           switch (type) {
Kode lerroa:             case 0:
Kode lerroa:               entry.free = true;
Kode lerroa:               break;
Kode lerroa:             case 1:
Kode lerroa:               entry.uncompressed = true;
Kode lerroa:               break;
Kode lerroa:             case 2:
Kode lerroa:               break;
Kode lerroa:             default:
Kode lerroa:               throw new _util.FormatError('Invalid XRef entry type: ' + type);
Kode lerroa:           }
Kode lerroa:           if (!this.entries[first + i]) {
Kode lerroa:             this.entries[first + i] = entry;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         streamState.entryNum = 0;
Kode lerroa:         streamState.streamPos = stream.pos;
Kode lerroa:         entryRanges.splice(0, 2);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     indexObjects: function XRef_indexObjects() {
Kode lerroa:       var TAB = 0x9,
Kode lerroa:           LF = 0xA,
Kode lerroa:           CR = 0xD,
Kode lerroa:           SPACE = 0x20;
Kode lerroa:       var PERCENT = 0x25,
Kode lerroa:           LT = 0x3C;
Kode lerroa:       function readToken(data, offset) {
Kode lerroa:         var token = '',
Kode lerroa:             ch = data[offset];
Kode lerroa:         while (ch !== LF && ch !== CR && ch !== LT) {
Kode lerroa:           if (++offset >= data.length) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           token += String.fromCharCode(ch);
Kode lerroa:           ch = data[offset];
Kode lerroa:         }
Kode lerroa:         return token;
Kode lerroa:       }
Kode lerroa:       function skipUntil(data, offset, what) {
Kode lerroa:         var length = what.length,
Kode lerroa:             dataLength = data.length;
Kode lerroa:         var skipped = 0;
Kode lerroa:         while (offset < dataLength) {
Kode lerroa:           var i = 0;
Kode lerroa:           while (i < length && data[offset + i] === what[i]) {
Kode lerroa:             ++i;
Kode lerroa:           }
Kode lerroa:           if (i >= length) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           offset++;
Kode lerroa:           skipped++;
Kode lerroa:         }
Kode lerroa:         return skipped;
Kode lerroa:       }
Kode lerroa:       var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
Kode lerroa:       var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
Kode lerroa:       var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
Kode lerroa:       var endobjBytes = new Uint8Array([101, 110, 100, 111, 98, 106]);
Kode lerroa:       var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
Kode lerroa:       this.entries.length = 0;
Kode lerroa:       var stream = this.stream;
Kode lerroa:       stream.pos = 0;
Kode lerroa:       var buffer = stream.getBytes();
Kode lerroa:       var position = stream.start,
Kode lerroa:           length = buffer.length;
Kode lerroa:       var trailers = [],
Kode lerroa:           xrefStms = [];
Kode lerroa:       while (position < length) {
Kode lerroa:         var ch = buffer[position];
Kode lerroa:         if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
Kode lerroa:           ++position;
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (ch === PERCENT) {
Kode lerroa:           do {
Kode lerroa:             ++position;
Kode lerroa:             if (position >= length) {
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:             ch = buffer[position];
Kode lerroa:           } while (ch !== LF && ch !== CR);
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var token = readToken(buffer, position);
Kode lerroa:         var m;
Kode lerroa:         if (token.indexOf('xref') === 0 && (token.length === 4 || /\s/.test(token[4]))) {
Kode lerroa:           position += skipUntil(buffer, position, trailerBytes);
Kode lerroa:           trailers.push(position);
Kode lerroa:           position += skipUntil(buffer, position, startxrefBytes);
Kode lerroa:         } else if (m = objRegExp.exec(token)) {
Kode lerroa:           if (typeof this.entries[m[1]] === 'undefined') {
Kode lerroa:             this.entries[m[1]] = {
Kode lerroa:               offset: position - stream.start,
Kode lerroa:               gen: m[2] | 0,
Kode lerroa:               uncompressed: true
Kode lerroa:             };
Kode lerroa:           }
Kode lerroa:           var contentLength = skipUntil(buffer, position, endobjBytes) + 7;
Kode lerroa:           var content = buffer.subarray(position, position + contentLength);
Kode lerroa:           var xrefTagOffset = skipUntil(content, 0, xrefBytes);
Kode lerroa:           if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
Kode lerroa:             xrefStms.push(position - stream.start);
Kode lerroa:             this.xrefstms[position - stream.start] = 1;
Kode lerroa:           }
Kode lerroa:           position += contentLength;
Kode lerroa:         } else if (token.indexOf('trailer') === 0 && (token.length === 7 || /\s/.test(token[7]))) {
Kode lerroa:           trailers.push(position);
Kode lerroa:           position += skipUntil(buffer, position, startxrefBytes);
Kode lerroa:         } else {
Kode lerroa:           position += token.length + 1;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var i, ii;
Kode lerroa:       for (i = 0, ii = xrefStms.length; i < ii; ++i) {
Kode lerroa:         this.startXRefQueue.push(xrefStms[i]);
Kode lerroa:         this.readXRef(true);
Kode lerroa:       }
Kode lerroa:       var dict;
Kode lerroa:       for (i = 0, ii = trailers.length; i < ii; ++i) {
Kode lerroa:         stream.pos = trailers[i];
Kode lerroa:         var parser = new _parser.Parser(new _parser.Lexer(stream), true, this, true);
Kode lerroa:         var obj = parser.getObj();
Kode lerroa:         if (!(0, _primitives.isCmd)(obj, 'trailer')) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         dict = parser.getObj();
Kode lerroa:         if (!(0, _primitives.isDict)(dict)) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (dict.has('ID')) {
Kode lerroa:           return dict;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (dict) {
Kode lerroa:         return dict;
Kode lerroa:       }
Kode lerroa:       throw new _util.InvalidPDFException('Invalid PDF structure');
Kode lerroa:     },
Kode lerroa:     readXRef: function XRef_readXRef(recoveryMode) {
Kode lerroa:       var stream = this.stream;
Kode lerroa:       var startXRefParsedCache = Object.create(null);
Kode lerroa:       try {
Kode lerroa:         while (this.startXRefQueue.length) {
Kode lerroa:           var startXRef = this.startXRefQueue[0];
Kode lerroa:           if (startXRefParsedCache[startXRef]) {
Kode lerroa:             (0, _util.warn)('readXRef - skipping XRef table since it was already parsed.');
Kode lerroa:             this.startXRefQueue.shift();
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           startXRefParsedCache[startXRef] = true;
Kode lerroa:           stream.pos = startXRef + stream.start;
Kode lerroa:           var parser = new _parser.Parser(new _parser.Lexer(stream), true, this);
Kode lerroa:           var obj = parser.getObj();
Kode lerroa:           var dict;
Kode lerroa:           if ((0, _primitives.isCmd)(obj, 'xref')) {
Kode lerroa:             dict = this.processXRefTable(parser);
Kode lerroa:             if (!this.topDict) {
Kode lerroa:               this.topDict = dict;
Kode lerroa:             }
Kode lerroa:             obj = dict.get('XRefStm');
Kode lerroa:             if (Number.isInteger(obj)) {
Kode lerroa:               var pos = obj;
Kode lerroa:               if (!(pos in this.xrefstms)) {
Kode lerroa:                 this.xrefstms[pos] = 1;
Kode lerroa:                 this.startXRefQueue.push(pos);
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           } else if (Number.isInteger(obj)) {
Kode lerroa:             if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), 'obj') || !(0, _primitives.isStream)(obj = parser.getObj())) {
Kode lerroa:               throw new _util.FormatError('Invalid XRef stream');
Kode lerroa:             }
Kode lerroa:             dict = this.processXRefStream(obj);
Kode lerroa:             if (!this.topDict) {
Kode lerroa:               this.topDict = dict;
Kode lerroa:             }
Kode lerroa:             if (!dict) {
Kode lerroa:               throw new _util.FormatError('Failed to read XRef stream');
Kode lerroa:             }
Kode lerroa:           } else {
Kode lerroa:             throw new _util.FormatError('Invalid XRef stream header');
Kode lerroa:           }
Kode lerroa:           obj = dict.get('Prev');
Kode lerroa:           if (Number.isInteger(obj)) {
Kode lerroa:             this.startXRefQueue.push(obj);
Kode lerroa:           } else if ((0, _primitives.isRef)(obj)) {
Kode lerroa:             this.startXRefQueue.push(obj.num);
Kode lerroa:           }
Kode lerroa:           this.startXRefQueue.shift();
Kode lerroa:         }
Kode lerroa:         return this.topDict;
Kode lerroa:       } catch (e) {
Kode lerroa:         if (e instanceof _util.MissingDataException) {
Kode lerroa:           throw e;
Kode lerroa:         }
Kode lerroa:         (0, _util.info)('(while reading XRef): ' + e);
Kode lerroa:       }
Kode lerroa:       if (recoveryMode) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       throw new _util.XRefParseException();
Kode lerroa:     },
Kode lerroa:     getEntry: function XRef_getEntry(i) {
Kode lerroa:       var xrefEntry = this.entries[i];
Kode lerroa:       if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
Kode lerroa:         return xrefEntry;
Kode lerroa:       }
Kode lerroa:       return null;
Kode lerroa:     },
Kode lerroa:     fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
Kode lerroa:       if (!(0, _primitives.isRef)(obj)) {
Kode lerroa:         return obj;
Kode lerroa:       }
Kode lerroa:       return this.fetch(obj, suppressEncryption);
Kode lerroa:     },
Kode lerroa:     fetch: function XRef_fetch(ref, suppressEncryption) {
Kode lerroa:       if (!(0, _primitives.isRef)(ref)) {
Kode lerroa:         throw new Error('ref object is not a reference');
Kode lerroa:       }
Kode lerroa:       var num = ref.num;
Kode lerroa:       if (num in this.cache) {
Kode lerroa:         var cacheEntry = this.cache[num];
Kode lerroa:         if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
Kode lerroa:           cacheEntry.objId = ref.toString();
Kode lerroa:         }
Kode lerroa:         return cacheEntry;
Kode lerroa:       }
Kode lerroa:       var xrefEntry = this.getEntry(num);
Kode lerroa:       if (xrefEntry === null) {
Kode lerroa:         return this.cache[num] = null;
Kode lerroa:       }
Kode lerroa:       if (xrefEntry.uncompressed) {
Kode lerroa:         xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
Kode lerroa:       } else {
Kode lerroa:         xrefEntry = this.fetchCompressed(xrefEntry, suppressEncryption);
Kode lerroa:       }
Kode lerroa:       if ((0, _primitives.isDict)(xrefEntry)) {
Kode lerroa:         xrefEntry.objId = ref.toString();
Kode lerroa:       } else if ((0, _primitives.isStream)(xrefEntry)) {
Kode lerroa:         xrefEntry.dict.objId = ref.toString();
Kode lerroa:       }
Kode lerroa:       return xrefEntry;
Kode lerroa:     },
Kode lerroa:     fetchUncompressed: function XRef_fetchUncompressed(ref, xrefEntry, suppressEncryption) {
Kode lerroa:       var gen = ref.gen;
Kode lerroa:       var num = ref.num;
Kode lerroa:       if (xrefEntry.gen !== gen) {
Kode lerroa:         throw new _util.FormatError('inconsistent generation in XRef');
Kode lerroa:       }
Kode lerroa:       var stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
Kode lerroa:       var parser = new _parser.Parser(new _parser.Lexer(stream), true, this);
Kode lerroa:       var obj1 = parser.getObj();
Kode lerroa:       var obj2 = parser.getObj();
Kode lerroa:       var obj3 = parser.getObj();
Kode lerroa:       if (!Number.isInteger(obj1)) {
Kode lerroa:         obj1 = parseInt(obj1, 10);
Kode lerroa:       }
Kode lerroa:       if (!Number.isInteger(obj2)) {
Kode lerroa:         obj2 = parseInt(obj2, 10);
Kode lerroa:       }
Kode lerroa:       if (obj1 !== num || obj2 !== gen || !(0, _primitives.isCmd)(obj3)) {
Kode lerroa:         throw new _util.FormatError('bad XRef entry');
Kode lerroa:       }
Kode lerroa:       if (obj3.cmd !== 'obj') {
Kode lerroa:         if (obj3.cmd.indexOf('obj') === 0) {
Kode lerroa:           num = parseInt(obj3.cmd.substring(3), 10);
Kode lerroa:           if (!Number.isNaN(num)) {
Kode lerroa:             return num;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         throw new _util.FormatError('bad XRef entry');
Kode lerroa:       }
Kode lerroa:       if (this.encrypt && !suppressEncryption) {
Kode lerroa:         xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
Kode lerroa:       } else {
Kode lerroa:         xrefEntry = parser.getObj();
Kode lerroa:       }
Kode lerroa:       if (!(0, _primitives.isStream)(xrefEntry)) {
Kode lerroa:         this.cache[num] = xrefEntry;
Kode lerroa:       }
Kode lerroa:       return xrefEntry;
Kode lerroa:     },
Kode lerroa:     fetchCompressed: function XRef_fetchCompressed(xrefEntry, suppressEncryption) {
Kode lerroa:       var tableOffset = xrefEntry.offset;
Kode lerroa:       var stream = this.fetch(new _primitives.Ref(tableOffset, 0));
Kode lerroa:       if (!(0, _primitives.isStream)(stream)) {
Kode lerroa:         throw new _util.FormatError('bad ObjStm stream');
Kode lerroa:       }
Kode lerroa:       var first = stream.dict.get('First');
Kode lerroa:       var n = stream.dict.get('N');
Kode lerroa:       if (!Number.isInteger(first) || !Number.isInteger(n)) {
Kode lerroa:         throw new _util.FormatError('invalid first and n parameters for ObjStm stream');
Kode lerroa:       }
Kode lerroa:       var parser = new _parser.Parser(new _parser.Lexer(stream), false, this);
Kode lerroa:       parser.allowStreams = true;
Kode lerroa:       var i,
Kode lerroa:           entries = [],
Kode lerroa:           num,
Kode lerroa:           nums = [];
Kode lerroa:       for (i = 0; i < n; ++i) {
Kode lerroa:         num = parser.getObj();
Kode lerroa:         if (!Number.isInteger(num)) {
Kode lerroa:           throw new _util.FormatError('invalid object number in the ObjStm stream: ' + num);
Kode lerroa:         }
Kode lerroa:         nums.push(num);
Kode lerroa:         var offset = parser.getObj();
Kode lerroa:         if (!Number.isInteger(offset)) {
Kode lerroa:           throw new _util.FormatError('invalid object offset in the ObjStm stream: ' + offset);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (i = 0; i < n; ++i) {
Kode lerroa:         entries.push(parser.getObj());
Kode lerroa:         if ((0, _primitives.isCmd)(parser.buf1, 'endobj')) {
Kode lerroa:           parser.shift();
Kode lerroa:         }
Kode lerroa:         num = nums[i];
Kode lerroa:         var entry = this.entries[num];
Kode lerroa:         if (entry && entry.offset === tableOffset && entry.gen === i) {
Kode lerroa:           this.cache[num] = entries[i];
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       xrefEntry = entries[xrefEntry.gen];
Kode lerroa:       if (xrefEntry === undefined) {
Kode lerroa:         throw new _util.FormatError('bad XRef entry for compressed object');
Kode lerroa:       }
Kode lerroa:       return xrefEntry;
Kode lerroa:     },
Kode lerroa:     fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {
Kode lerroa:       if (!(0, _primitives.isRef)(obj)) {
Kode lerroa:         return Promise.resolve(obj);
Kode lerroa:       }
Kode lerroa:       return this.fetchAsync(obj, suppressEncryption);
Kode lerroa:     },
Kode lerroa:     fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {
Kode lerroa:       var streamManager = this.stream.manager;
Kode lerroa:       var xref = this;
Kode lerroa:       return new Promise(function tryFetch(resolve, reject) {
Kode lerroa:         try {
Kode lerroa:           resolve(xref.fetch(ref, suppressEncryption));
Kode lerroa:         } catch (e) {
Kode lerroa:           if (e instanceof _util.MissingDataException) {
Kode lerroa:             streamManager.requestRange(e.begin, e.end).then(function () {
Kode lerroa:               tryFetch(resolve, reject);
Kode lerroa:             }, reject);
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           reject(e);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getCatalogObj: function XRef_getCatalogObj() {
Kode lerroa:       return this.root;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return XRef;
Kode lerroa: }();
Kode lerroa: var NameOrNumberTree = function NameOrNumberTreeClosure() {
Kode lerroa:   function NameOrNumberTree(root, xref) {
Kode lerroa:     throw new Error('Cannot initialize NameOrNumberTree.');
Kode lerroa:   }
Kode lerroa:   NameOrNumberTree.prototype = {
Kode lerroa:     getAll: function NameOrNumberTree_getAll() {
Kode lerroa:       var dict = Object.create(null);
Kode lerroa:       if (!this.root) {
Kode lerroa:         return dict;
Kode lerroa:       }
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var processed = new _primitives.RefSet();
Kode lerroa:       processed.put(this.root);
Kode lerroa:       var queue = [this.root];
Kode lerroa:       while (queue.length > 0) {
Kode lerroa:         var i, n;
Kode lerroa:         var obj = xref.fetchIfRef(queue.shift());
Kode lerroa:         if (!(0, _primitives.isDict)(obj)) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (obj.has('Kids')) {
Kode lerroa:           var kids = obj.get('Kids');
Kode lerroa:           for (i = 0, n = kids.length; i < n; i++) {
Kode lerroa:             var kid = kids[i];
Kode lerroa:             if (processed.has(kid)) {
Kode lerroa:               throw new _util.FormatError('Duplicate entry in "' + this._type + '" tree.');
Kode lerroa:             }
Kode lerroa:             queue.push(kid);
Kode lerroa:             processed.put(kid);
Kode lerroa:           }
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var entries = obj.get(this._type);
Kode lerroa:         if (Array.isArray(entries)) {
Kode lerroa:           for (i = 0, n = entries.length; i < n; i += 2) {
Kode lerroa:             dict[xref.fetchIfRef(entries[i])] = xref.fetchIfRef(entries[i + 1]);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return dict;
Kode lerroa:     },
Kode lerroa:     get: function NameOrNumberTree_get(key) {
Kode lerroa:       if (!this.root) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var kidsOrEntries = xref.fetchIfRef(this.root);
Kode lerroa:       var loopCount = 0;
Kode lerroa:       var MAX_LEVELS = 10;
Kode lerroa:       var l, r, m;
Kode lerroa:       while (kidsOrEntries.has('Kids')) {
Kode lerroa:         if (++loopCount > MAX_LEVELS) {
Kode lerroa:           (0, _util.warn)('Search depth limit reached for "' + this._type + '" tree.');
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:         var kids = kidsOrEntries.get('Kids');
Kode lerroa:         if (!Array.isArray(kids)) {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:         l = 0;
Kode lerroa:         r = kids.length - 1;
Kode lerroa:         while (l <= r) {
Kode lerroa:           m = l + r >> 1;
Kode lerroa:           var kid = xref.fetchIfRef(kids[m]);
Kode lerroa:           var limits = kid.get('Limits');
Kode lerroa:           if (key < xref.fetchIfRef(limits[0])) {
Kode lerroa:             r = m - 1;
Kode lerroa:           } else if (key > xref.fetchIfRef(limits[1])) {
Kode lerroa:             l = m + 1;
Kode lerroa:           } else {
Kode lerroa:             kidsOrEntries = xref.fetchIfRef(kids[m]);
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (l > r) {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var entries = kidsOrEntries.get(this._type);
Kode lerroa:       if (Array.isArray(entries)) {
Kode lerroa:         l = 0;
Kode lerroa:         r = entries.length - 2;
Kode lerroa:         while (l <= r) {
Kode lerroa:           m = l + r & ~1;
Kode lerroa:           var currentKey = xref.fetchIfRef(entries[m]);
Kode lerroa:           if (key < currentKey) {
Kode lerroa:             r = m - 2;
Kode lerroa:           } else if (key > currentKey) {
Kode lerroa:             l = m + 2;
Kode lerroa:           } else {
Kode lerroa:             return xref.fetchIfRef(entries[m + 1]);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return NameOrNumberTree;
Kode lerroa: }();
Kode lerroa: var NameTree = function NameTreeClosure() {
Kode lerroa:   function NameTree(root, xref) {
Kode lerroa:     this.root = root;
Kode lerroa:     this.xref = xref;
Kode lerroa:     this._type = 'Names';
Kode lerroa:   }
Kode lerroa:   _util.Util.inherit(NameTree, NameOrNumberTree, {});
Kode lerroa:   return NameTree;
Kode lerroa: }();
Kode lerroa: var NumberTree = function NumberTreeClosure() {
Kode lerroa:   function NumberTree(root, xref) {
Kode lerroa:     this.root = root;
Kode lerroa:     this.xref = xref;
Kode lerroa:     this._type = 'Nums';
Kode lerroa:   }
Kode lerroa:   _util.Util.inherit(NumberTree, NameOrNumberTree, {});
Kode lerroa:   return NumberTree;
Kode lerroa: }();
Kode lerroa: var FileSpec = function FileSpecClosure() {
Kode lerroa:   function FileSpec(root, xref) {
Kode lerroa:     if (!root || !(0, _primitives.isDict)(root)) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.root = root;
Kode lerroa:     if (root.has('FS')) {
Kode lerroa:       this.fs = root.get('FS');
Kode lerroa:     }
Kode lerroa:     this.description = root.has('Desc') ? (0, _util.stringToPDFString)(root.get('Desc')) : '';
Kode lerroa:     if (root.has('RF')) {
Kode lerroa:       (0, _util.warn)('Related file specifications are not supported');
Kode lerroa:     }
Kode lerroa:     this.contentAvailable = true;
Kode lerroa:     if (!root.has('EF')) {
Kode lerroa:       this.contentAvailable = false;
Kode lerroa:       (0, _util.warn)('Non-embedded file specifications are not supported');
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function pickPlatformItem(dict) {
Kode lerroa:     if (dict.has('UF')) {
Kode lerroa:       return dict.get('UF');
Kode lerroa:     } else if (dict.has('F')) {
Kode lerroa:       return dict.get('F');
Kode lerroa:     } else if (dict.has('Unix')) {
Kode lerroa:       return dict.get('Unix');
Kode lerroa:     } else if (dict.has('Mac')) {
Kode lerroa:       return dict.get('Mac');
Kode lerroa:     } else if (dict.has('DOS')) {
Kode lerroa:       return dict.get('DOS');
Kode lerroa:     }
Kode lerroa:     return null;
Kode lerroa:   }
Kode lerroa:   FileSpec.prototype = {
Kode lerroa:     get filename() {
Kode lerroa:       if (!this._filename && this.root) {
Kode lerroa:         var filename = pickPlatformItem(this.root) || 'unnamed';
Kode lerroa:         this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\/g, '\\').replace(/\\\//g, '/').replace(/\\/g, '/');
Kode lerroa:       }
Kode lerroa:       return this._filename;
Kode lerroa:     },
Kode lerroa:     get content() {
Kode lerroa:       if (!this.contentAvailable) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       if (!this.contentRef && this.root) {
Kode lerroa:         this.contentRef = pickPlatformItem(this.root.get('EF'));
Kode lerroa:       }
Kode lerroa:       var content = null;
Kode lerroa:       if (this.contentRef) {
Kode lerroa:         var xref = this.xref;
Kode lerroa:         var fileObj = xref.fetchIfRef(this.contentRef);
Kode lerroa:         if (fileObj && (0, _primitives.isStream)(fileObj)) {
Kode lerroa:           content = fileObj.getBytes();
Kode lerroa:         } else {
Kode lerroa:           (0, _util.warn)('Embedded file specification points to non-existing/invalid ' + 'content');
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         (0, _util.warn)('Embedded file specification does not have a content');
Kode lerroa:       }
Kode lerroa:       return content;
Kode lerroa:     },
Kode lerroa:     get serializable() {
Kode lerroa:       return {
Kode lerroa:         filename: this.filename,
Kode lerroa:         content: this.content
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return FileSpec;
Kode lerroa: }();
Kode lerroa: var ObjectLoader = function () {
Kode lerroa:   function mayHaveChildren(value) {
Kode lerroa:     return (0, _primitives.isRef)(value) || (0, _primitives.isDict)(value) || Array.isArray(value) || (0, _primitives.isStream)(value);
Kode lerroa:   }
Kode lerroa:   function addChildren(node, nodesToVisit) {
Kode lerroa:     if ((0, _primitives.isDict)(node) || (0, _primitives.isStream)(node)) {
Kode lerroa:       var dict = (0, _primitives.isDict)(node) ? node : node.dict;
Kode lerroa:       var dictKeys = dict.getKeys();
Kode lerroa:       for (var i = 0, ii = dictKeys.length; i < ii; i++) {
Kode lerroa:         var rawValue = dict.getRaw(dictKeys[i]);
Kode lerroa:         if (mayHaveChildren(rawValue)) {
Kode lerroa:           nodesToVisit.push(rawValue);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else if (Array.isArray(node)) {
Kode lerroa:       for (var _i = 0, _ii = node.length; _i < _ii; _i++) {
Kode lerroa:         var value = node[_i];
Kode lerroa:         if (mayHaveChildren(value)) {
Kode lerroa:           nodesToVisit.push(value);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function ObjectLoader(dict, keys, xref) {
Kode lerroa:     this.dict = dict;
Kode lerroa:     this.keys = keys;
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.refSet = null;
Kode lerroa:     this.capability = null;
Kode lerroa:   }
Kode lerroa:   ObjectLoader.prototype = {
Kode lerroa:     load: function load() {
Kode lerroa:       this.capability = (0, _util.createPromiseCapability)();
Kode lerroa:       if (!(this.xref.stream instanceof _chunked_stream.ChunkedStream) || this.xref.stream.getMissingChunks().length === 0) {
Kode lerroa:         this.capability.resolve();
Kode lerroa:         return this.capability.promise;
Kode lerroa:       }
Kode lerroa:       var keys = this.keys,
Kode lerroa:           dict = this.dict;
Kode lerroa: 
Kode lerroa:       this.refSet = new _primitives.RefSet();
Kode lerroa:       var nodesToVisit = [];
Kode lerroa:       for (var i = 0, ii = keys.length; i < ii; i++) {
Kode lerroa:         var rawValue = dict.getRaw(keys[i]);
Kode lerroa:         if (rawValue !== undefined) {
Kode lerroa:           nodesToVisit.push(rawValue);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this._walk(nodesToVisit);
Kode lerroa:       return this.capability.promise;
Kode lerroa:     },
Kode lerroa:     _walk: function _walk(nodesToVisit) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       var nodesToRevisit = [];
Kode lerroa:       var pendingRequests = [];
Kode lerroa:       while (nodesToVisit.length) {
Kode lerroa:         var currentNode = nodesToVisit.pop();
Kode lerroa:         if ((0, _primitives.isRef)(currentNode)) {
Kode lerroa:           if (this.refSet.has(currentNode)) {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           try {
Kode lerroa:             this.refSet.put(currentNode);
Kode lerroa:             currentNode = this.xref.fetch(currentNode);
Kode lerroa:           } catch (ex) {
Kode lerroa:             if (!(ex instanceof _util.MissingDataException)) {
Kode lerroa:               throw ex;
Kode lerroa:             }
Kode lerroa:             nodesToRevisit.push(currentNode);
Kode lerroa:             pendingRequests.push({
Kode lerroa:               begin: ex.begin,
Kode lerroa:               end: ex.end
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (currentNode && currentNode.getBaseStreams) {
Kode lerroa:           var baseStreams = currentNode.getBaseStreams();
Kode lerroa:           var foundMissingData = false;
Kode lerroa:           for (var i = 0, ii = baseStreams.length; i < ii; i++) {
Kode lerroa:             var stream = baseStreams[i];
Kode lerroa:             if (stream.getMissingChunks && stream.getMissingChunks().length) {
Kode lerroa:               foundMissingData = true;
Kode lerroa:               pendingRequests.push({
Kode lerroa:                 begin: stream.start,
Kode lerroa:                 end: stream.end
Kode lerroa:               });
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           if (foundMissingData) {
Kode lerroa:             nodesToRevisit.push(currentNode);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         addChildren(currentNode, nodesToVisit);
Kode lerroa:       }
Kode lerroa:       if (pendingRequests.length) {
Kode lerroa:         this.xref.stream.manager.requestRanges(pendingRequests).then(function () {
Kode lerroa:           for (var _i2 = 0, _ii2 = nodesToRevisit.length; _i2 < _ii2; _i2++) {
Kode lerroa:             var node = nodesToRevisit[_i2];
Kode lerroa:             if ((0, _primitives.isRef)(node)) {
Kode lerroa:               _this3.refSet.remove(node);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           _this3._walk(nodesToRevisit);
Kode lerroa:         }, this.capability.reject);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.refSet = null;
Kode lerroa:       this.capability.resolve();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return ObjectLoader;
Kode lerroa: }();
Kode lerroa: exports.Catalog = Catalog;
Kode lerroa: exports.ObjectLoader = ObjectLoader;
Kode lerroa: exports.XRef = XRef;
Kode lerroa: exports.FileSpec = FileSpec;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 74 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.JpxImage = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _arithmetic_decoder = __w_pdfjs_require__(75);
Kode lerroa: 
Kode lerroa: var JpxError = function JpxErrorClosure() {
Kode lerroa:   function JpxError(msg) {
Kode lerroa:     this.message = 'JPX error: ' + msg;
Kode lerroa:   }
Kode lerroa:   JpxError.prototype = new Error();
Kode lerroa:   JpxError.prototype.name = 'JpxError';
Kode lerroa:   JpxError.constructor = JpxError;
Kode lerroa:   return JpxError;
Kode lerroa: }();
Kode lerroa: var JpxImage = function JpxImageClosure() {
Kode lerroa:   var SubbandsGainLog2 = {
Kode lerroa:     'LL': 0,
Kode lerroa:     'LH': 1,
Kode lerroa:     'HL': 1,
Kode lerroa:     'HH': 2
Kode lerroa:   };
Kode lerroa:   function JpxImage() {
Kode lerroa:     this.failOnCorruptedImage = false;
Kode lerroa:   }
Kode lerroa:   JpxImage.prototype = {
Kode lerroa:     parse: function JpxImage_parse(data) {
Kode lerroa:       var head = (0, _util.readUint16)(data, 0);
Kode lerroa:       if (head === 0xFF4F) {
Kode lerroa:         this.parseCodestream(data, 0, data.length);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var position = 0,
Kode lerroa:           length = data.length;
Kode lerroa:       while (position < length) {
Kode lerroa:         var headerSize = 8;
Kode lerroa:         var lbox = (0, _util.readUint32)(data, position);
Kode lerroa:         var tbox = (0, _util.readUint32)(data, position + 4);
Kode lerroa:         position += headerSize;
Kode lerroa:         if (lbox === 1) {
Kode lerroa:           lbox = (0, _util.readUint32)(data, position) * 4294967296 + (0, _util.readUint32)(data, position + 4);
Kode lerroa:           position += 8;
Kode lerroa:           headerSize += 8;
Kode lerroa:         }
Kode lerroa:         if (lbox === 0) {
Kode lerroa:           lbox = length - position + headerSize;
Kode lerroa:         }
Kode lerroa:         if (lbox < headerSize) {
Kode lerroa:           throw new JpxError('Invalid box field size');
Kode lerroa:         }
Kode lerroa:         var dataLength = lbox - headerSize;
Kode lerroa:         var jumpDataLength = true;
Kode lerroa:         switch (tbox) {
Kode lerroa:           case 0x6A703268:
Kode lerroa:             jumpDataLength = false;
Kode lerroa:             break;
Kode lerroa:           case 0x636F6C72:
Kode lerroa:             var method = data[position];
Kode lerroa:             if (method === 1) {
Kode lerroa:               var colorspace = (0, _util.readUint32)(data, position + 3);
Kode lerroa:               switch (colorspace) {
Kode lerroa:                 case 16:
Kode lerroa:                 case 17:
Kode lerroa:                 case 18:
Kode lerroa:                   break;
Kode lerroa:                 default:
Kode lerroa:                   (0, _util.warn)('Unknown colorspace ' + colorspace);
Kode lerroa:                   break;
Kode lerroa:               }
Kode lerroa:             } else if (method === 2) {
Kode lerroa:               (0, _util.info)('ICC profile not supported');
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 0x6A703263:
Kode lerroa:             this.parseCodestream(data, position, position + dataLength);
Kode lerroa:             break;
Kode lerroa:           case 0x6A502020:
Kode lerroa:             if ((0, _util.readUint32)(data, position) !== 0x0d0a870a) {
Kode lerroa:               (0, _util.warn)('Invalid JP2 signature');
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 0x6A501A1A:
Kode lerroa:           case 0x66747970:
Kode lerroa:           case 0x72726571:
Kode lerroa:           case 0x72657320:
Kode lerroa:           case 0x69686472:
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             var headerType = String.fromCharCode(tbox >> 24 & 0xFF, tbox >> 16 & 0xFF, tbox >> 8 & 0xFF, tbox & 0xFF);
Kode lerroa:             (0, _util.warn)('Unsupported header type ' + tbox + ' (' + headerType + ')');
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         if (jumpDataLength) {
Kode lerroa:           position += dataLength;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     parseImageProperties: function JpxImage_parseImageProperties(stream) {
Kode lerroa:       var newByte = stream.getByte();
Kode lerroa:       while (newByte >= 0) {
Kode lerroa:         var oldByte = newByte;
Kode lerroa:         newByte = stream.getByte();
Kode lerroa:         var code = oldByte << 8 | newByte;
Kode lerroa:         if (code === 0xFF51) {
Kode lerroa:           stream.skip(4);
Kode lerroa:           var Xsiz = stream.getInt32() >>> 0;
Kode lerroa:           var Ysiz = stream.getInt32() >>> 0;
Kode lerroa:           var XOsiz = stream.getInt32() >>> 0;
Kode lerroa:           var YOsiz = stream.getInt32() >>> 0;
Kode lerroa:           stream.skip(16);
Kode lerroa:           var Csiz = stream.getUint16();
Kode lerroa:           this.width = Xsiz - XOsiz;
Kode lerroa:           this.height = Ysiz - YOsiz;
Kode lerroa:           this.componentsCount = Csiz;
Kode lerroa:           this.bitsPerComponent = 8;
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       throw new JpxError('No size marker found in JPX stream');
Kode lerroa:     },
Kode lerroa:     parseCodestream: function JpxImage_parseCodestream(data, start, end) {
Kode lerroa:       var context = {};
Kode lerroa:       var doNotRecover = false;
Kode lerroa:       try {
Kode lerroa:         var position = start;
Kode lerroa:         while (position + 1 < end) {
Kode lerroa:           var code = (0, _util.readUint16)(data, position);
Kode lerroa:           position += 2;
Kode lerroa:           var length = 0,
Kode lerroa:               j,
Kode lerroa:               sqcd,
Kode lerroa:               spqcds,
Kode lerroa:               spqcdSize,
Kode lerroa:               scalarExpounded,
Kode lerroa:               tile;
Kode lerroa:           switch (code) {
Kode lerroa:             case 0xFF4F:
Kode lerroa:               context.mainHeader = true;
Kode lerroa:               break;
Kode lerroa:             case 0xFFD9:
Kode lerroa:               break;
Kode lerroa:             case 0xFF51:
Kode lerroa:               length = (0, _util.readUint16)(data, position);
Kode lerroa:               var siz = {};
Kode lerroa:               siz.Xsiz = (0, _util.readUint32)(data, position + 4);
Kode lerroa:               siz.Ysiz = (0, _util.readUint32)(data, position + 8);
Kode lerroa:               siz.XOsiz = (0, _util.readUint32)(data, position + 12);
Kode lerroa:               siz.YOsiz = (0, _util.readUint32)(data, position + 16);
Kode lerroa:               siz.XTsiz = (0, _util.readUint32)(data, position + 20);
Kode lerroa:               siz.YTsiz = (0, _util.readUint32)(data, position + 24);
Kode lerroa:               siz.XTOsiz = (0, _util.readUint32)(data, position + 28);
Kode lerroa:               siz.YTOsiz = (0, _util.readUint32)(data, position + 32);
Kode lerroa:               var componentsCount = (0, _util.readUint16)(data, position + 36);
Kode lerroa:               siz.Csiz = componentsCount;
Kode lerroa:               var components = [];
Kode lerroa:               j = position + 38;
Kode lerroa:               for (var i = 0; i < componentsCount; i++) {
Kode lerroa:                 var component = {
Kode lerroa:                   precision: (data[j] & 0x7F) + 1,
Kode lerroa:                   isSigned: !!(data[j] & 0x80),
Kode lerroa:                   XRsiz: data[j + 1],
Kode lerroa:                   YRsiz: data[j + 1]
Kode lerroa:                 };
Kode lerroa:                 calculateComponentDimensions(component, siz);
Kode lerroa:                 components.push(component);
Kode lerroa:               }
Kode lerroa:               context.SIZ = siz;
Kode lerroa:               context.components = components;
Kode lerroa:               calculateTileGrids(context, components);
Kode lerroa:               context.QCC = [];
Kode lerroa:               context.COC = [];
Kode lerroa:               break;
Kode lerroa:             case 0xFF5C:
Kode lerroa:               length = (0, _util.readUint16)(data, position);
Kode lerroa:               var qcd = {};
Kode lerroa:               j = position + 2;
Kode lerroa:               sqcd = data[j++];
Kode lerroa:               switch (sqcd & 0x1F) {
Kode lerroa:                 case 0:
Kode lerroa:                   spqcdSize = 8;
Kode lerroa:                   scalarExpounded = true;
Kode lerroa:                   break;
Kode lerroa:                 case 1:
Kode lerroa:                   spqcdSize = 16;
Kode lerroa:                   scalarExpounded = false;
Kode lerroa:                   break;
Kode lerroa:                 case 2:
Kode lerroa:                   spqcdSize = 16;
Kode lerroa:                   scalarExpounded = true;
Kode lerroa:                   break;
Kode lerroa:                 default:
Kode lerroa:                   throw new Error('Invalid SQcd value ' + sqcd);
Kode lerroa:               }
Kode lerroa:               qcd.noQuantization = spqcdSize === 8;
Kode lerroa:               qcd.scalarExpounded = scalarExpounded;
Kode lerroa:               qcd.guardBits = sqcd >> 5;
Kode lerroa:               spqcds = [];
Kode lerroa:               while (j < length + position) {
Kode lerroa:                 var spqcd = {};
Kode lerroa:                 if (spqcdSize === 8) {
Kode lerroa:                   spqcd.epsilon = data[j++] >> 3;
Kode lerroa:                   spqcd.mu = 0;
Kode lerroa:                 } else {
Kode lerroa:                   spqcd.epsilon = data[j] >> 3;
Kode lerroa:                   spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
Kode lerroa:                   j += 2;
Kode lerroa:                 }
Kode lerroa:                 spqcds.push(spqcd);
Kode lerroa:               }
Kode lerroa:               qcd.SPqcds = spqcds;
Kode lerroa:               if (context.mainHeader) {
Kode lerroa:                 context.QCD = qcd;
Kode lerroa:               } else {
Kode lerroa:                 context.currentTile.QCD = qcd;
Kode lerroa:                 context.currentTile.QCC = [];
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             case 0xFF5D:
Kode lerroa:               length = (0, _util.readUint16)(data, position);
Kode lerroa:               var qcc = {};
Kode lerroa:               j = position + 2;
Kode lerroa:               var cqcc;
Kode lerroa:               if (context.SIZ.Csiz < 257) {
Kode lerroa:                 cqcc = data[j++];
Kode lerroa:               } else {
Kode lerroa:                 cqcc = (0, _util.readUint16)(data, j);
Kode lerroa:                 j += 2;
Kode lerroa:               }
Kode lerroa:               sqcd = data[j++];
Kode lerroa:               switch (sqcd & 0x1F) {
Kode lerroa:                 case 0:
Kode lerroa:                   spqcdSize = 8;
Kode lerroa:                   scalarExpounded = true;
Kode lerroa:                   break;
Kode lerroa:                 case 1:
Kode lerroa:                   spqcdSize = 16;
Kode lerroa:                   scalarExpounded = false;
Kode lerroa:                   break;
Kode lerroa:                 case 2:
Kode lerroa:                   spqcdSize = 16;
Kode lerroa:                   scalarExpounded = true;
Kode lerroa:                   break;
Kode lerroa:                 default:
Kode lerroa:                   throw new Error('Invalid SQcd value ' + sqcd);
Kode lerroa:               }
Kode lerroa:               qcc.noQuantization = spqcdSize === 8;
Kode lerroa:               qcc.scalarExpounded = scalarExpounded;
Kode lerroa:               qcc.guardBits = sqcd >> 5;
Kode lerroa:               spqcds = [];
Kode lerroa:               while (j < length + position) {
Kode lerroa:                 spqcd = {};
Kode lerroa:                 if (spqcdSize === 8) {
Kode lerroa:                   spqcd.epsilon = data[j++] >> 3;
Kode lerroa:                   spqcd.mu = 0;
Kode lerroa:                 } else {
Kode lerroa:                   spqcd.epsilon = data[j] >> 3;
Kode lerroa:                   spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
Kode lerroa:                   j += 2;
Kode lerroa:                 }
Kode lerroa:                 spqcds.push(spqcd);
Kode lerroa:               }
Kode lerroa:               qcc.SPqcds = spqcds;
Kode lerroa:               if (context.mainHeader) {
Kode lerroa:                 context.QCC[cqcc] = qcc;
Kode lerroa:               } else {
Kode lerroa:                 context.currentTile.QCC[cqcc] = qcc;
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             case 0xFF52:
Kode lerroa:               length = (0, _util.readUint16)(data, position);
Kode lerroa:               var cod = {};
Kode lerroa:               j = position + 2;
Kode lerroa:               var scod = data[j++];
Kode lerroa:               cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
Kode lerroa:               cod.sopMarkerUsed = !!(scod & 2);
Kode lerroa:               cod.ephMarkerUsed = !!(scod & 4);
Kode lerroa:               cod.progressionOrder = data[j++];
Kode lerroa:               cod.layersCount = (0, _util.readUint16)(data, j);
Kode lerroa:               j += 2;
Kode lerroa:               cod.multipleComponentTransform = data[j++];
Kode lerroa:               cod.decompositionLevelsCount = data[j++];
Kode lerroa:               cod.xcb = (data[j++] & 0xF) + 2;
Kode lerroa:               cod.ycb = (data[j++] & 0xF) + 2;
Kode lerroa:               var blockStyle = data[j++];
Kode lerroa:               cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
Kode lerroa:               cod.resetContextProbabilities = !!(blockStyle & 2);
Kode lerroa:               cod.terminationOnEachCodingPass = !!(blockStyle & 4);
Kode lerroa:               cod.verticalyStripe = !!(blockStyle & 8);
Kode lerroa:               cod.predictableTermination = !!(blockStyle & 16);
Kode lerroa:               cod.segmentationSymbolUsed = !!(blockStyle & 32);
Kode lerroa:               cod.reversibleTransformation = data[j++];
Kode lerroa:               if (cod.entropyCoderWithCustomPrecincts) {
Kode lerroa:                 var precinctsSizes = [];
Kode lerroa:                 while (j < length + position) {
Kode lerroa:                   var precinctsSize = data[j++];
Kode lerroa:                   precinctsSizes.push({
Kode lerroa:                     PPx: precinctsSize & 0xF,
Kode lerroa:                     PPy: precinctsSize >> 4
Kode lerroa:                   });
Kode lerroa:                 }
Kode lerroa:                 cod.precinctsSizes = precinctsSizes;
Kode lerroa:               }
Kode lerroa:               var unsupported = [];
Kode lerroa:               if (cod.selectiveArithmeticCodingBypass) {
Kode lerroa:                 unsupported.push('selectiveArithmeticCodingBypass');
Kode lerroa:               }
Kode lerroa:               if (cod.resetContextProbabilities) {
Kode lerroa:                 unsupported.push('resetContextProbabilities');
Kode lerroa:               }
Kode lerroa:               if (cod.terminationOnEachCodingPass) {
Kode lerroa:                 unsupported.push('terminationOnEachCodingPass');
Kode lerroa:               }
Kode lerroa:               if (cod.verticalyStripe) {
Kode lerroa:                 unsupported.push('verticalyStripe');
Kode lerroa:               }
Kode lerroa:               if (cod.predictableTermination) {
Kode lerroa:                 unsupported.push('predictableTermination');
Kode lerroa:               }
Kode lerroa:               if (unsupported.length > 0) {
Kode lerroa:                 doNotRecover = true;
Kode lerroa:                 throw new Error('Unsupported COD options (' + unsupported.join(', ') + ')');
Kode lerroa:               }
Kode lerroa:               if (context.mainHeader) {
Kode lerroa:                 context.COD = cod;
Kode lerroa:               } else {
Kode lerroa:                 context.currentTile.COD = cod;
Kode lerroa:                 context.currentTile.COC = [];
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             case 0xFF90:
Kode lerroa:               length = (0, _util.readUint16)(data, position);
Kode lerroa:               tile = {};
Kode lerroa:               tile.index = (0, _util.readUint16)(data, position + 2);
Kode lerroa:               tile.length = (0, _util.readUint32)(data, position + 4);
Kode lerroa:               tile.dataEnd = tile.length + position - 2;
Kode lerroa:               tile.partIndex = data[position + 8];
Kode lerroa:               tile.partsCount = data[position + 9];
Kode lerroa:               context.mainHeader = false;
Kode lerroa:               if (tile.partIndex === 0) {
Kode lerroa:                 tile.COD = context.COD;
Kode lerroa:                 tile.COC = context.COC.slice(0);
Kode lerroa:                 tile.QCD = context.QCD;
Kode lerroa:                 tile.QCC = context.QCC.slice(0);
Kode lerroa:               }
Kode lerroa:               context.currentTile = tile;
Kode lerroa:               break;
Kode lerroa:             case 0xFF93:
Kode lerroa:               tile = context.currentTile;
Kode lerroa:               if (tile.partIndex === 0) {
Kode lerroa:                 initializeTile(context, tile.index);
Kode lerroa:                 buildPackets(context);
Kode lerroa:               }
Kode lerroa:               length = tile.dataEnd - position;
Kode lerroa:               parseTilePackets(context, data, position, length);
Kode lerroa:               break;
Kode lerroa:             case 0xFF55:
Kode lerroa:             case 0xFF57:
Kode lerroa:             case 0xFF58:
Kode lerroa:             case 0xFF64:
Kode lerroa:               length = (0, _util.readUint16)(data, position);
Kode lerroa:               break;
Kode lerroa:             case 0xFF53:
Kode lerroa:               throw new Error('Codestream code 0xFF53 (COC) is ' + 'not implemented');
Kode lerroa:             default:
Kode lerroa:               throw new Error('Unknown codestream code: ' + code.toString(16));
Kode lerroa:           }
Kode lerroa:           position += length;
Kode lerroa:         }
Kode lerroa:       } catch (e) {
Kode lerroa:         if (doNotRecover || this.failOnCorruptedImage) {
Kode lerroa:           throw new JpxError(e.message);
Kode lerroa:         } else {
Kode lerroa:           (0, _util.warn)('JPX: Trying to recover from: ' + e.message);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.tiles = transformComponents(context);
Kode lerroa:       this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
Kode lerroa:       this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
Kode lerroa:       this.componentsCount = context.SIZ.Csiz;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   function calculateComponentDimensions(component, siz) {
Kode lerroa:     component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
Kode lerroa:     component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
Kode lerroa:     component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
Kode lerroa:     component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
Kode lerroa:     component.width = component.x1 - component.x0;
Kode lerroa:     component.height = component.y1 - component.y0;
Kode lerroa:   }
Kode lerroa:   function calculateTileGrids(context, components) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tile,
Kode lerroa:         tiles = [];
Kode lerroa:     var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
Kode lerroa:     var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
Kode lerroa:     for (var q = 0; q < numYtiles; q++) {
Kode lerroa:       for (var p = 0; p < numXtiles; p++) {
Kode lerroa:         tile = {};
Kode lerroa:         tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
Kode lerroa:         tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
Kode lerroa:         tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
Kode lerroa:         tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
Kode lerroa:         tile.width = tile.tx1 - tile.tx0;
Kode lerroa:         tile.height = tile.ty1 - tile.ty0;
Kode lerroa:         tile.components = [];
Kode lerroa:         tiles.push(tile);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     context.tiles = tiles;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     for (var i = 0, ii = componentsCount; i < ii; i++) {
Kode lerroa:       var component = components[i];
Kode lerroa:       for (var j = 0, jj = tiles.length; j < jj; j++) {
Kode lerroa:         var tileComponent = {};
Kode lerroa:         tile = tiles[j];
Kode lerroa:         tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
Kode lerroa:         tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
Kode lerroa:         tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
Kode lerroa:         tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
Kode lerroa:         tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
Kode lerroa:         tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
Kode lerroa:         tile.components[i] = tileComponent;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function getBlocksDimensions(context, component, r) {
Kode lerroa:     var codOrCoc = component.codingStyleParameters;
Kode lerroa:     var result = {};
Kode lerroa:     if (!codOrCoc.entropyCoderWithCustomPrecincts) {
Kode lerroa:       result.PPx = 15;
Kode lerroa:       result.PPy = 15;
Kode lerroa:     } else {
Kode lerroa:       result.PPx = codOrCoc.precinctsSizes[r].PPx;
Kode lerroa:       result.PPy = codOrCoc.precinctsSizes[r].PPy;
Kode lerroa:     }
Kode lerroa:     result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
Kode lerroa:     result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
Kode lerroa:     return result;
Kode lerroa:   }
Kode lerroa:   function buildPrecincts(context, resolution, dimensions) {
Kode lerroa:     var precinctWidth = 1 << dimensions.PPx;
Kode lerroa:     var precinctHeight = 1 << dimensions.PPy;
Kode lerroa:     var isZeroRes = resolution.resLevel === 0;
Kode lerroa:     var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
Kode lerroa:     var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
Kode lerroa:     var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
Kode lerroa:     var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
Kode lerroa:     var numprecincts = numprecinctswide * numprecinctshigh;
Kode lerroa:     resolution.precinctParameters = {
Kode lerroa:       precinctWidth: precinctWidth,
Kode lerroa:       precinctHeight: precinctHeight,
Kode lerroa:       numprecinctswide: numprecinctswide,
Kode lerroa:       numprecinctshigh: numprecinctshigh,
Kode lerroa:       numprecincts: numprecincts,
Kode lerroa:       precinctWidthInSubband: precinctWidthInSubband,
Kode lerroa:       precinctHeightInSubband: precinctHeightInSubband
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function buildCodeblocks(context, subband, dimensions) {
Kode lerroa:     var xcb_ = dimensions.xcb_;
Kode lerroa:     var ycb_ = dimensions.ycb_;
Kode lerroa:     var codeblockWidth = 1 << xcb_;
Kode lerroa:     var codeblockHeight = 1 << ycb_;
Kode lerroa:     var cbx0 = subband.tbx0 >> xcb_;
Kode lerroa:     var cby0 = subband.tby0 >> ycb_;
Kode lerroa:     var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
Kode lerroa:     var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
Kode lerroa:     var precinctParameters = subband.resolution.precinctParameters;
Kode lerroa:     var codeblocks = [];
Kode lerroa:     var precincts = [];
Kode lerroa:     var i, j, codeblock, precinctNumber;
Kode lerroa:     for (j = cby0; j < cby1; j++) {
Kode lerroa:       for (i = cbx0; i < cbx1; i++) {
Kode lerroa:         codeblock = {
Kode lerroa:           cbx: i,
Kode lerroa:           cby: j,
Kode lerroa:           tbx0: codeblockWidth * i,
Kode lerroa:           tby0: codeblockHeight * j,
Kode lerroa:           tbx1: codeblockWidth * (i + 1),
Kode lerroa:           tby1: codeblockHeight * (j + 1)
Kode lerroa:         };
Kode lerroa:         codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
Kode lerroa:         codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
Kode lerroa:         codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
Kode lerroa:         codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
Kode lerroa:         var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
Kode lerroa:         var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
Kode lerroa:         precinctNumber = pi + pj * precinctParameters.numprecinctswide;
Kode lerroa:         codeblock.precinctNumber = precinctNumber;
Kode lerroa:         codeblock.subbandType = subband.type;
Kode lerroa:         codeblock.Lblock = 3;
Kode lerroa:         if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         codeblocks.push(codeblock);
Kode lerroa:         var precinct = precincts[precinctNumber];
Kode lerroa:         if (precinct !== undefined) {
Kode lerroa:           if (i < precinct.cbxMin) {
Kode lerroa:             precinct.cbxMin = i;
Kode lerroa:           } else if (i > precinct.cbxMax) {
Kode lerroa:             precinct.cbxMax = i;
Kode lerroa:           }
Kode lerroa:           if (j < precinct.cbyMin) {
Kode lerroa:             precinct.cbxMin = j;
Kode lerroa:           } else if (j > precinct.cbyMax) {
Kode lerroa:             precinct.cbyMax = j;
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           precincts[precinctNumber] = precinct = {
Kode lerroa:             cbxMin: i,
Kode lerroa:             cbyMin: j,
Kode lerroa:             cbxMax: i,
Kode lerroa:             cbyMax: j
Kode lerroa:           };
Kode lerroa:         }
Kode lerroa:         codeblock.precinct = precinct;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     subband.codeblockParameters = {
Kode lerroa:       codeblockWidth: xcb_,
Kode lerroa:       codeblockHeight: ycb_,
Kode lerroa:       numcodeblockwide: cbx1 - cbx0 + 1,
Kode lerroa:       numcodeblockhigh: cby1 - cby0 + 1
Kode lerroa:     };
Kode lerroa:     subband.codeblocks = codeblocks;
Kode lerroa:     subband.precincts = precincts;
Kode lerroa:   }
Kode lerroa:   function createPacket(resolution, precinctNumber, layerNumber) {
Kode lerroa:     var precinctCodeblocks = [];
Kode lerroa:     var subbands = resolution.subbands;
Kode lerroa:     for (var i = 0, ii = subbands.length; i < ii; i++) {
Kode lerroa:       var subband = subbands[i];
Kode lerroa:       var codeblocks = subband.codeblocks;
Kode lerroa:       for (var j = 0, jj = codeblocks.length; j < jj; j++) {
Kode lerroa:         var codeblock = codeblocks[j];
Kode lerroa:         if (codeblock.precinctNumber !== precinctNumber) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         precinctCodeblocks.push(codeblock);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       layerNumber: layerNumber,
Kode lerroa:       codeblocks: precinctCodeblocks
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function LayerResolutionComponentPositionIterator(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var layersCount = tile.codingStyleDefaultParameters.layersCount;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var maxDecompositionLevelsCount = 0;
Kode lerroa:     for (var q = 0; q < componentsCount; q++) {
Kode lerroa:       maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
Kode lerroa:     }
Kode lerroa:     var l = 0,
Kode lerroa:         r = 0,
Kode lerroa:         i = 0,
Kode lerroa:         k = 0;
Kode lerroa:     this.nextPacket = function JpxImage_nextPacket() {
Kode lerroa:       for (; l < layersCount; l++) {
Kode lerroa:         for (; r <= maxDecompositionLevelsCount; r++) {
Kode lerroa:           for (; i < componentsCount; i++) {
Kode lerroa:             var component = tile.components[i];
Kode lerroa:             if (r > component.codingStyleParameters.decompositionLevelsCount) {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             var resolution = component.resolutions[r];
Kode lerroa:             var numprecincts = resolution.precinctParameters.numprecincts;
Kode lerroa:             for (; k < numprecincts;) {
Kode lerroa:               var packet = createPacket(resolution, k, l);
Kode lerroa:               k++;
Kode lerroa:               return packet;
Kode lerroa:             }
Kode lerroa:             k = 0;
Kode lerroa:           }
Kode lerroa:           i = 0;
Kode lerroa:         }
Kode lerroa:         r = 0;
Kode lerroa:       }
Kode lerroa:       throw new JpxError('Out of packets');
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function ResolutionLayerComponentPositionIterator(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var layersCount = tile.codingStyleDefaultParameters.layersCount;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var maxDecompositionLevelsCount = 0;
Kode lerroa:     for (var q = 0; q < componentsCount; q++) {
Kode lerroa:       maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
Kode lerroa:     }
Kode lerroa:     var r = 0,
Kode lerroa:         l = 0,
Kode lerroa:         i = 0,
Kode lerroa:         k = 0;
Kode lerroa:     this.nextPacket = function JpxImage_nextPacket() {
Kode lerroa:       for (; r <= maxDecompositionLevelsCount; r++) {
Kode lerroa:         for (; l < layersCount; l++) {
Kode lerroa:           for (; i < componentsCount; i++) {
Kode lerroa:             var component = tile.components[i];
Kode lerroa:             if (r > component.codingStyleParameters.decompositionLevelsCount) {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             var resolution = component.resolutions[r];
Kode lerroa:             var numprecincts = resolution.precinctParameters.numprecincts;
Kode lerroa:             for (; k < numprecincts;) {
Kode lerroa:               var packet = createPacket(resolution, k, l);
Kode lerroa:               k++;
Kode lerroa:               return packet;
Kode lerroa:             }
Kode lerroa:             k = 0;
Kode lerroa:           }
Kode lerroa:           i = 0;
Kode lerroa:         }
Kode lerroa:         l = 0;
Kode lerroa:       }
Kode lerroa:       throw new JpxError('Out of packets');
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function ResolutionPositionComponentLayerIterator(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var layersCount = tile.codingStyleDefaultParameters.layersCount;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var l, r, c, p;
Kode lerroa:     var maxDecompositionLevelsCount = 0;
Kode lerroa:     for (c = 0; c < componentsCount; c++) {
Kode lerroa:       var component = tile.components[c];
Kode lerroa:       maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
Kode lerroa:     }
Kode lerroa:     var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
Kode lerroa:     for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
Kode lerroa:       var maxNumPrecincts = 0;
Kode lerroa:       for (c = 0; c < componentsCount; ++c) {
Kode lerroa:         var resolutions = tile.components[c].resolutions;
Kode lerroa:         if (r < resolutions.length) {
Kode lerroa:           maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       maxNumPrecinctsInLevel[r] = maxNumPrecincts;
Kode lerroa:     }
Kode lerroa:     l = 0;
Kode lerroa:     r = 0;
Kode lerroa:     c = 0;
Kode lerroa:     p = 0;
Kode lerroa:     this.nextPacket = function JpxImage_nextPacket() {
Kode lerroa:       for (; r <= maxDecompositionLevelsCount; r++) {
Kode lerroa:         for (; p < maxNumPrecinctsInLevel[r]; p++) {
Kode lerroa:           for (; c < componentsCount; c++) {
Kode lerroa:             var component = tile.components[c];
Kode lerroa:             if (r > component.codingStyleParameters.decompositionLevelsCount) {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             var resolution = component.resolutions[r];
Kode lerroa:             var numprecincts = resolution.precinctParameters.numprecincts;
Kode lerroa:             if (p >= numprecincts) {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             for (; l < layersCount;) {
Kode lerroa:               var packet = createPacket(resolution, p, l);
Kode lerroa:               l++;
Kode lerroa:               return packet;
Kode lerroa:             }
Kode lerroa:             l = 0;
Kode lerroa:           }
Kode lerroa:           c = 0;
Kode lerroa:         }
Kode lerroa:         p = 0;
Kode lerroa:       }
Kode lerroa:       throw new JpxError('Out of packets');
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function PositionComponentResolutionLayerIterator(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var layersCount = tile.codingStyleDefaultParameters.layersCount;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var precinctsSizes = getPrecinctSizesInImageScale(tile);
Kode lerroa:     var precinctsIterationSizes = precinctsSizes;
Kode lerroa:     var l = 0,
Kode lerroa:         r = 0,
Kode lerroa:         c = 0,
Kode lerroa:         px = 0,
Kode lerroa:         py = 0;
Kode lerroa:     this.nextPacket = function JpxImage_nextPacket() {
Kode lerroa:       for (; py < precinctsIterationSizes.maxNumHigh; py++) {
Kode lerroa:         for (; px < precinctsIterationSizes.maxNumWide; px++) {
Kode lerroa:           for (; c < componentsCount; c++) {
Kode lerroa:             var component = tile.components[c];
Kode lerroa:             var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
Kode lerroa:             for (; r <= decompositionLevelsCount; r++) {
Kode lerroa:               var resolution = component.resolutions[r];
Kode lerroa:               var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
Kode lerroa:               var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
Kode lerroa:               if (k === null) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               for (; l < layersCount;) {
Kode lerroa:                 var packet = createPacket(resolution, k, l);
Kode lerroa:                 l++;
Kode lerroa:                 return packet;
Kode lerroa:               }
Kode lerroa:               l = 0;
Kode lerroa:             }
Kode lerroa:             r = 0;
Kode lerroa:           }
Kode lerroa:           c = 0;
Kode lerroa:         }
Kode lerroa:         px = 0;
Kode lerroa:       }
Kode lerroa:       throw new JpxError('Out of packets');
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function ComponentPositionResolutionLayerIterator(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var layersCount = tile.codingStyleDefaultParameters.layersCount;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var precinctsSizes = getPrecinctSizesInImageScale(tile);
Kode lerroa:     var l = 0,
Kode lerroa:         r = 0,
Kode lerroa:         c = 0,
Kode lerroa:         px = 0,
Kode lerroa:         py = 0;
Kode lerroa:     this.nextPacket = function JpxImage_nextPacket() {
Kode lerroa:       for (; c < componentsCount; ++c) {
Kode lerroa:         var component = tile.components[c];
Kode lerroa:         var precinctsIterationSizes = precinctsSizes.components[c];
Kode lerroa:         var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
Kode lerroa:         for (; py < precinctsIterationSizes.maxNumHigh; py++) {
Kode lerroa:           for (; px < precinctsIterationSizes.maxNumWide; px++) {
Kode lerroa:             for (; r <= decompositionLevelsCount; r++) {
Kode lerroa:               var resolution = component.resolutions[r];
Kode lerroa:               var sizeInImageScale = precinctsIterationSizes.resolutions[r];
Kode lerroa:               var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
Kode lerroa:               if (k === null) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               for (; l < layersCount;) {
Kode lerroa:                 var packet = createPacket(resolution, k, l);
Kode lerroa:                 l++;
Kode lerroa:                 return packet;
Kode lerroa:               }
Kode lerroa:               l = 0;
Kode lerroa:             }
Kode lerroa:             r = 0;
Kode lerroa:           }
Kode lerroa:           px = 0;
Kode lerroa:         }
Kode lerroa:         py = 0;
Kode lerroa:       }
Kode lerroa:       throw new JpxError('Out of packets');
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
Kode lerroa:     var posX = pxIndex * precinctIterationSizes.minWidth;
Kode lerroa:     var posY = pyIndex * precinctIterationSizes.minHeight;
Kode lerroa:     if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:     var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
Kode lerroa:     return posX / sizeInImageScale.height + startPrecinctRowIndex;
Kode lerroa:   }
Kode lerroa:   function getPrecinctSizesInImageScale(tile) {
Kode lerroa:     var componentsCount = tile.components.length;
Kode lerroa:     var minWidth = Number.MAX_VALUE;
Kode lerroa:     var minHeight = Number.MAX_VALUE;
Kode lerroa:     var maxNumWide = 0;
Kode lerroa:     var maxNumHigh = 0;
Kode lerroa:     var sizePerComponent = new Array(componentsCount);
Kode lerroa:     for (var c = 0; c < componentsCount; c++) {
Kode lerroa:       var component = tile.components[c];
Kode lerroa:       var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
Kode lerroa:       var sizePerResolution = new Array(decompositionLevelsCount + 1);
Kode lerroa:       var minWidthCurrentComponent = Number.MAX_VALUE;
Kode lerroa:       var minHeightCurrentComponent = Number.MAX_VALUE;
Kode lerroa:       var maxNumWideCurrentComponent = 0;
Kode lerroa:       var maxNumHighCurrentComponent = 0;
Kode lerroa:       var scale = 1;
Kode lerroa:       for (var r = decompositionLevelsCount; r >= 0; --r) {
Kode lerroa:         var resolution = component.resolutions[r];
Kode lerroa:         var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
Kode lerroa:         var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
Kode lerroa:         minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
Kode lerroa:         minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
Kode lerroa:         maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
Kode lerroa:         maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
Kode lerroa:         sizePerResolution[r] = {
Kode lerroa:           width: widthCurrentResolution,
Kode lerroa:           height: heightCurrentResolution
Kode lerroa:         };
Kode lerroa:         scale <<= 1;
Kode lerroa:       }
Kode lerroa:       minWidth = Math.min(minWidth, minWidthCurrentComponent);
Kode lerroa:       minHeight = Math.min(minHeight, minHeightCurrentComponent);
Kode lerroa:       maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
Kode lerroa:       maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
Kode lerroa:       sizePerComponent[c] = {
Kode lerroa:         resolutions: sizePerResolution,
Kode lerroa:         minWidth: minWidthCurrentComponent,
Kode lerroa:         minHeight: minHeightCurrentComponent,
Kode lerroa:         maxNumWide: maxNumWideCurrentComponent,
Kode lerroa:         maxNumHigh: maxNumHighCurrentComponent
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       components: sizePerComponent,
Kode lerroa:       minWidth: minWidth,
Kode lerroa:       minHeight: minHeight,
Kode lerroa:       maxNumWide: maxNumWide,
Kode lerroa:       maxNumHigh: maxNumHigh
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function buildPackets(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     for (var c = 0; c < componentsCount; c++) {
Kode lerroa:       var component = tile.components[c];
Kode lerroa:       var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
Kode lerroa:       var resolutions = [];
Kode lerroa:       var subbands = [];
Kode lerroa:       for (var r = 0; r <= decompositionLevelsCount; r++) {
Kode lerroa:         var blocksDimensions = getBlocksDimensions(context, component, r);
Kode lerroa:         var resolution = {};
Kode lerroa:         var scale = 1 << decompositionLevelsCount - r;
Kode lerroa:         resolution.trx0 = Math.ceil(component.tcx0 / scale);
Kode lerroa:         resolution.try0 = Math.ceil(component.tcy0 / scale);
Kode lerroa:         resolution.trx1 = Math.ceil(component.tcx1 / scale);
Kode lerroa:         resolution.try1 = Math.ceil(component.tcy1 / scale);
Kode lerroa:         resolution.resLevel = r;
Kode lerroa:         buildPrecincts(context, resolution, blocksDimensions);
Kode lerroa:         resolutions.push(resolution);
Kode lerroa:         var subband;
Kode lerroa:         if (r === 0) {
Kode lerroa:           subband = {};
Kode lerroa:           subband.type = 'LL';
Kode lerroa:           subband.tbx0 = Math.ceil(component.tcx0 / scale);
Kode lerroa:           subband.tby0 = Math.ceil(component.tcy0 / scale);
Kode lerroa:           subband.tbx1 = Math.ceil(component.tcx1 / scale);
Kode lerroa:           subband.tby1 = Math.ceil(component.tcy1 / scale);
Kode lerroa:           subband.resolution = resolution;
Kode lerroa:           buildCodeblocks(context, subband, blocksDimensions);
Kode lerroa:           subbands.push(subband);
Kode lerroa:           resolution.subbands = [subband];
Kode lerroa:         } else {
Kode lerroa:           var bscale = 1 << decompositionLevelsCount - r + 1;
Kode lerroa:           var resolutionSubbands = [];
Kode lerroa:           subband = {};
Kode lerroa:           subband.type = 'HL';
Kode lerroa:           subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
Kode lerroa:           subband.tby0 = Math.ceil(component.tcy0 / bscale);
Kode lerroa:           subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
Kode lerroa:           subband.tby1 = Math.ceil(component.tcy1 / bscale);
Kode lerroa:           subband.resolution = resolution;
Kode lerroa:           buildCodeblocks(context, subband, blocksDimensions);
Kode lerroa:           subbands.push(subband);
Kode lerroa:           resolutionSubbands.push(subband);
Kode lerroa:           subband = {};
Kode lerroa:           subband.type = 'LH';
Kode lerroa:           subband.tbx0 = Math.ceil(component.tcx0 / bscale);
Kode lerroa:           subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
Kode lerroa:           subband.tbx1 = Math.ceil(component.tcx1 / bscale);
Kode lerroa:           subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
Kode lerroa:           subband.resolution = resolution;
Kode lerroa:           buildCodeblocks(context, subband, blocksDimensions);
Kode lerroa:           subbands.push(subband);
Kode lerroa:           resolutionSubbands.push(subband);
Kode lerroa:           subband = {};
Kode lerroa:           subband.type = 'HH';
Kode lerroa:           subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
Kode lerroa:           subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
Kode lerroa:           subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
Kode lerroa:           subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
Kode lerroa:           subband.resolution = resolution;
Kode lerroa:           buildCodeblocks(context, subband, blocksDimensions);
Kode lerroa:           subbands.push(subband);
Kode lerroa:           resolutionSubbands.push(subband);
Kode lerroa:           resolution.subbands = resolutionSubbands;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       component.resolutions = resolutions;
Kode lerroa:       component.subbands = subbands;
Kode lerroa:     }
Kode lerroa:     var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
Kode lerroa:     switch (progressionOrder) {
Kode lerroa:       case 0:
Kode lerroa:         tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
Kode lerroa:         break;
Kode lerroa:       case 1:
Kode lerroa:         tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
Kode lerroa:         break;
Kode lerroa:       case 2:
Kode lerroa:         tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
Kode lerroa:         break;
Kode lerroa:       case 3:
Kode lerroa:         tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
Kode lerroa:         break;
Kode lerroa:       case 4:
Kode lerroa:         tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
Kode lerroa:         break;
Kode lerroa:       default:
Kode lerroa:         throw new JpxError('Unsupported progression order ' + progressionOrder);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function parseTilePackets(context, data, offset, dataLength) {
Kode lerroa:     var position = 0;
Kode lerroa:     var buffer,
Kode lerroa:         bufferSize = 0,
Kode lerroa:         skipNextBit = false;
Kode lerroa:     function readBits(count) {
Kode lerroa:       while (bufferSize < count) {
Kode lerroa:         var b = data[offset + position];
Kode lerroa:         position++;
Kode lerroa:         if (skipNextBit) {
Kode lerroa:           buffer = buffer << 7 | b;
Kode lerroa:           bufferSize += 7;
Kode lerroa:           skipNextBit = false;
Kode lerroa:         } else {
Kode lerroa:           buffer = buffer << 8 | b;
Kode lerroa:           bufferSize += 8;
Kode lerroa:         }
Kode lerroa:         if (b === 0xFF) {
Kode lerroa:           skipNextBit = true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       bufferSize -= count;
Kode lerroa:       return buffer >>> bufferSize & (1 << count) - 1;
Kode lerroa:     }
Kode lerroa:     function skipMarkerIfEqual(value) {
Kode lerroa:       if (data[offset + position - 1] === 0xFF && data[offset + position] === value) {
Kode lerroa:         skipBytes(1);
Kode lerroa:         return true;
Kode lerroa:       } else if (data[offset + position] === 0xFF && data[offset + position + 1] === value) {
Kode lerroa:         skipBytes(2);
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     function skipBytes(count) {
Kode lerroa:       position += count;
Kode lerroa:     }
Kode lerroa:     function alignToByte() {
Kode lerroa:       bufferSize = 0;
Kode lerroa:       if (skipNextBit) {
Kode lerroa:         position++;
Kode lerroa:         skipNextBit = false;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     function readCodingpasses() {
Kode lerroa:       if (readBits(1) === 0) {
Kode lerroa:         return 1;
Kode lerroa:       }
Kode lerroa:       if (readBits(1) === 0) {
Kode lerroa:         return 2;
Kode lerroa:       }
Kode lerroa:       var value = readBits(2);
Kode lerroa:       if (value < 3) {
Kode lerroa:         return value + 3;
Kode lerroa:       }
Kode lerroa:       value = readBits(5);
Kode lerroa:       if (value < 31) {
Kode lerroa:         return value + 6;
Kode lerroa:       }
Kode lerroa:       value = readBits(7);
Kode lerroa:       return value + 37;
Kode lerroa:     }
Kode lerroa:     var tileIndex = context.currentTile.index;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     var sopMarkerUsed = context.COD.sopMarkerUsed;
Kode lerroa:     var ephMarkerUsed = context.COD.ephMarkerUsed;
Kode lerroa:     var packetsIterator = tile.packetsIterator;
Kode lerroa:     while (position < dataLength) {
Kode lerroa:       alignToByte();
Kode lerroa:       if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
Kode lerroa:         skipBytes(4);
Kode lerroa:       }
Kode lerroa:       var packet = packetsIterator.nextPacket();
Kode lerroa:       if (!readBits(1)) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       var layerNumber = packet.layerNumber;
Kode lerroa:       var queue = [],
Kode lerroa:           codeblock;
Kode lerroa:       for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
Kode lerroa:         codeblock = packet.codeblocks[i];
Kode lerroa:         var precinct = codeblock.precinct;
Kode lerroa:         var codeblockColumn = codeblock.cbx - precinct.cbxMin;
Kode lerroa:         var codeblockRow = codeblock.cby - precinct.cbyMin;
Kode lerroa:         var codeblockIncluded = false;
Kode lerroa:         var firstTimeInclusion = false;
Kode lerroa:         var valueReady;
Kode lerroa:         if (codeblock['included'] !== undefined) {
Kode lerroa:           codeblockIncluded = !!readBits(1);
Kode lerroa:         } else {
Kode lerroa:           precinct = codeblock.precinct;
Kode lerroa:           var inclusionTree, zeroBitPlanesTree;
Kode lerroa:           if (precinct['inclusionTree'] !== undefined) {
Kode lerroa:             inclusionTree = precinct.inclusionTree;
Kode lerroa:           } else {
Kode lerroa:             var width = precinct.cbxMax - precinct.cbxMin + 1;
Kode lerroa:             var height = precinct.cbyMax - precinct.cbyMin + 1;
Kode lerroa:             inclusionTree = new InclusionTree(width, height, layerNumber);
Kode lerroa:             zeroBitPlanesTree = new TagTree(width, height);
Kode lerroa:             precinct.inclusionTree = inclusionTree;
Kode lerroa:             precinct.zeroBitPlanesTree = zeroBitPlanesTree;
Kode lerroa:           }
Kode lerroa:           if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
Kode lerroa:             while (true) {
Kode lerroa:               if (readBits(1)) {
Kode lerroa:                 valueReady = !inclusionTree.nextLevel();
Kode lerroa:                 if (valueReady) {
Kode lerroa:                   codeblock.included = true;
Kode lerroa:                   codeblockIncluded = firstTimeInclusion = true;
Kode lerroa:                   break;
Kode lerroa:                 }
Kode lerroa:               } else {
Kode lerroa:                 inclusionTree.incrementValue(layerNumber);
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (!codeblockIncluded) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (firstTimeInclusion) {
Kode lerroa:           zeroBitPlanesTree = precinct.zeroBitPlanesTree;
Kode lerroa:           zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
Kode lerroa:           while (true) {
Kode lerroa:             if (readBits(1)) {
Kode lerroa:               valueReady = !zeroBitPlanesTree.nextLevel();
Kode lerroa:               if (valueReady) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               zeroBitPlanesTree.incrementValue();
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
Kode lerroa:         }
Kode lerroa:         var codingpasses = readCodingpasses();
Kode lerroa:         while (readBits(1)) {
Kode lerroa:           codeblock.Lblock++;
Kode lerroa:         }
Kode lerroa:         var codingpassesLog2 = (0, _util.log2)(codingpasses);
Kode lerroa:         var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
Kode lerroa:         var codedDataLength = readBits(bits);
Kode lerroa:         queue.push({
Kode lerroa:           codeblock: codeblock,
Kode lerroa:           codingpasses: codingpasses,
Kode lerroa:           dataLength: codedDataLength
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       alignToByte();
Kode lerroa:       if (ephMarkerUsed) {
Kode lerroa:         skipMarkerIfEqual(0x92);
Kode lerroa:       }
Kode lerroa:       while (queue.length > 0) {
Kode lerroa:         var packetItem = queue.shift();
Kode lerroa:         codeblock = packetItem.codeblock;
Kode lerroa:         if (codeblock['data'] === undefined) {
Kode lerroa:           codeblock.data = [];
Kode lerroa:         }
Kode lerroa:         codeblock.data.push({
Kode lerroa:           data: data,
Kode lerroa:           start: offset + position,
Kode lerroa:           end: offset + position + packetItem.dataLength,
Kode lerroa:           codingpasses: packetItem.codingpasses
Kode lerroa:         });
Kode lerroa:         position += packetItem.dataLength;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return position;
Kode lerroa:   }
Kode lerroa:   function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
Kode lerroa:     var x0 = subband.tbx0;
Kode lerroa:     var y0 = subband.tby0;
Kode lerroa:     var width = subband.tbx1 - subband.tbx0;
Kode lerroa:     var codeblocks = subband.codeblocks;
Kode lerroa:     var right = subband.type.charAt(0) === 'H' ? 1 : 0;
Kode lerroa:     var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;
Kode lerroa:     for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
Kode lerroa:       var codeblock = codeblocks[i];
Kode lerroa:       var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
Kode lerroa:       var blockHeight = codeblock.tby1_ - codeblock.tby0_;
Kode lerroa:       if (blockWidth === 0 || blockHeight === 0) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       if (codeblock['data'] === undefined) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       var bitModel, currentCodingpassType;
Kode lerroa:       bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
Kode lerroa:       currentCodingpassType = 2;
Kode lerroa:       var data = codeblock.data,
Kode lerroa:           totalLength = 0,
Kode lerroa:           codingpasses = 0;
Kode lerroa:       var j, jj, dataItem;
Kode lerroa:       for (j = 0, jj = data.length; j < jj; j++) {
Kode lerroa:         dataItem = data[j];
Kode lerroa:         totalLength += dataItem.end - dataItem.start;
Kode lerroa:         codingpasses += dataItem.codingpasses;
Kode lerroa:       }
Kode lerroa:       var encodedData = new Uint8Array(totalLength);
Kode lerroa:       var position = 0;
Kode lerroa:       for (j = 0, jj = data.length; j < jj; j++) {
Kode lerroa:         dataItem = data[j];
Kode lerroa:         var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
Kode lerroa:         encodedData.set(chunk, position);
Kode lerroa:         position += chunk.length;
Kode lerroa:       }
Kode lerroa:       var decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
Kode lerroa:       bitModel.setDecoder(decoder);
Kode lerroa:       for (j = 0; j < codingpasses; j++) {
Kode lerroa:         switch (currentCodingpassType) {
Kode lerroa:           case 0:
Kode lerroa:             bitModel.runSignificancePropagationPass();
Kode lerroa:             break;
Kode lerroa:           case 1:
Kode lerroa:             bitModel.runMagnitudeRefinementPass();
Kode lerroa:             break;
Kode lerroa:           case 2:
Kode lerroa:             bitModel.runCleanupPass();
Kode lerroa:             if (segmentationSymbolUsed) {
Kode lerroa:               bitModel.checkSegmentationSymbol();
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         currentCodingpassType = (currentCodingpassType + 1) % 3;
Kode lerroa:       }
Kode lerroa:       var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
Kode lerroa:       var sign = bitModel.coefficentsSign;
Kode lerroa:       var magnitude = bitModel.coefficentsMagnitude;
Kode lerroa:       var bitsDecoded = bitModel.bitsDecoded;
Kode lerroa:       var magnitudeCorrection = reversible ? 0 : 0.5;
Kode lerroa:       var k, n, nb;
Kode lerroa:       position = 0;
Kode lerroa:       var interleave = subband.type !== 'LL';
Kode lerroa:       for (j = 0; j < blockHeight; j++) {
Kode lerroa:         var row = offset / width | 0;
Kode lerroa:         var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
Kode lerroa:         for (k = 0; k < blockWidth; k++) {
Kode lerroa:           n = magnitude[position];
Kode lerroa:           if (n !== 0) {
Kode lerroa:             n = (n + magnitudeCorrection) * delta;
Kode lerroa:             if (sign[position] !== 0) {
Kode lerroa:               n = -n;
Kode lerroa:             }
Kode lerroa:             nb = bitsDecoded[position];
Kode lerroa:             var pos = interleave ? levelOffset + (offset << 1) : offset;
Kode lerroa:             if (reversible && nb >= mb) {
Kode lerroa:               coefficients[pos] = n;
Kode lerroa:             } else {
Kode lerroa:               coefficients[pos] = n * (1 << mb - nb);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           offset++;
Kode lerroa:           position++;
Kode lerroa:         }
Kode lerroa:         offset += width - blockWidth;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function transformTile(context, tile, c) {
Kode lerroa:     var component = tile.components[c];
Kode lerroa:     var codingStyleParameters = component.codingStyleParameters;
Kode lerroa:     var quantizationParameters = component.quantizationParameters;
Kode lerroa:     var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
Kode lerroa:     var spqcds = quantizationParameters.SPqcds;
Kode lerroa:     var scalarExpounded = quantizationParameters.scalarExpounded;
Kode lerroa:     var guardBits = quantizationParameters.guardBits;
Kode lerroa:     var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
Kode lerroa:     var precision = context.components[c].precision;
Kode lerroa:     var reversible = codingStyleParameters.reversibleTransformation;
Kode lerroa:     var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
Kode lerroa:     var subbandCoefficients = [];
Kode lerroa:     var b = 0;
Kode lerroa:     for (var i = 0; i <= decompositionLevelsCount; i++) {
Kode lerroa:       var resolution = component.resolutions[i];
Kode lerroa:       var width = resolution.trx1 - resolution.trx0;
Kode lerroa:       var height = resolution.try1 - resolution.try0;
Kode lerroa:       var coefficients = new Float32Array(width * height);
Kode lerroa:       for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
Kode lerroa:         var mu, epsilon;
Kode lerroa:         if (!scalarExpounded) {
Kode lerroa:           mu = spqcds[0].mu;
Kode lerroa:           epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
Kode lerroa:         } else {
Kode lerroa:           mu = spqcds[b].mu;
Kode lerroa:           epsilon = spqcds[b].epsilon;
Kode lerroa:           b++;
Kode lerroa:         }
Kode lerroa:         var subband = resolution.subbands[j];
Kode lerroa:         var gainLog2 = SubbandsGainLog2[subband.type];
Kode lerroa:         var delta = reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048);
Kode lerroa:         var mb = guardBits + epsilon - 1;
Kode lerroa:         copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
Kode lerroa:       }
Kode lerroa:       subbandCoefficients.push({
Kode lerroa:         width: width,
Kode lerroa:         height: height,
Kode lerroa:         items: coefficients
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
Kode lerroa:     return {
Kode lerroa:       left: component.tcx0,
Kode lerroa:       top: component.tcy0,
Kode lerroa:       width: result.width,
Kode lerroa:       height: result.height,
Kode lerroa:       items: result.items
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function transformComponents(context) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var components = context.components;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var resultImages = [];
Kode lerroa:     for (var i = 0, ii = context.tiles.length; i < ii; i++) {
Kode lerroa:       var tile = context.tiles[i];
Kode lerroa:       var transformedTiles = [];
Kode lerroa:       var c;
Kode lerroa:       for (c = 0; c < componentsCount; c++) {
Kode lerroa:         transformedTiles[c] = transformTile(context, tile, c);
Kode lerroa:       }
Kode lerroa:       var tile0 = transformedTiles[0];
Kode lerroa:       var out = new Uint8ClampedArray(tile0.items.length * componentsCount);
Kode lerroa:       var result = {
Kode lerroa:         left: tile0.left,
Kode lerroa:         top: tile0.top,
Kode lerroa:         width: tile0.width,
Kode lerroa:         height: tile0.height,
Kode lerroa:         items: out
Kode lerroa:       };
Kode lerroa:       var shift, offset;
Kode lerroa:       var pos = 0,
Kode lerroa:           j,
Kode lerroa:           jj,
Kode lerroa:           y0,
Kode lerroa:           y1,
Kode lerroa:           y2;
Kode lerroa:       if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
Kode lerroa:         var fourComponents = componentsCount === 4;
Kode lerroa:         var y0items = transformedTiles[0].items;
Kode lerroa:         var y1items = transformedTiles[1].items;
Kode lerroa:         var y2items = transformedTiles[2].items;
Kode lerroa:         var y3items = fourComponents ? transformedTiles[3].items : null;
Kode lerroa:         shift = components[0].precision - 8;
Kode lerroa:         offset = (128 << shift) + 0.5;
Kode lerroa:         var component0 = tile.components[0];
Kode lerroa:         var alpha01 = componentsCount - 3;
Kode lerroa:         jj = y0items.length;
Kode lerroa:         if (!component0.codingStyleParameters.reversibleTransformation) {
Kode lerroa:           for (j = 0; j < jj; j++, pos += alpha01) {
Kode lerroa:             y0 = y0items[j] + offset;
Kode lerroa:             y1 = y1items[j];
Kode lerroa:             y2 = y2items[j];
Kode lerroa:             out[pos++] = y0 + 1.402 * y2 >> shift;
Kode lerroa:             out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
Kode lerroa:             out[pos++] = y0 + 1.772 * y1 >> shift;
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           for (j = 0; j < jj; j++, pos += alpha01) {
Kode lerroa:             y0 = y0items[j] + offset;
Kode lerroa:             y1 = y1items[j];
Kode lerroa:             y2 = y2items[j];
Kode lerroa:             var g = y0 - (y2 + y1 >> 2);
Kode lerroa:             out[pos++] = g + y2 >> shift;
Kode lerroa:             out[pos++] = g >> shift;
Kode lerroa:             out[pos++] = g + y1 >> shift;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (fourComponents) {
Kode lerroa:           for (j = 0, pos = 3; j < jj; j++, pos += 4) {
Kode lerroa:             out[pos] = y3items[j] + offset >> shift;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         for (c = 0; c < componentsCount; c++) {
Kode lerroa:           var items = transformedTiles[c].items;
Kode lerroa:           shift = components[c].precision - 8;
Kode lerroa:           offset = (128 << shift) + 0.5;
Kode lerroa:           for (pos = c, j = 0, jj = items.length; j < jj; j++) {
Kode lerroa:             out[pos] = items[j] + offset >> shift;
Kode lerroa:             pos += componentsCount;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       resultImages.push(result);
Kode lerroa:     }
Kode lerroa:     return resultImages;
Kode lerroa:   }
Kode lerroa:   function initializeTile(context, tileIndex) {
Kode lerroa:     var siz = context.SIZ;
Kode lerroa:     var componentsCount = siz.Csiz;
Kode lerroa:     var tile = context.tiles[tileIndex];
Kode lerroa:     for (var c = 0; c < componentsCount; c++) {
Kode lerroa:       var component = tile.components[c];
Kode lerroa:       var qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD;
Kode lerroa:       component.quantizationParameters = qcdOrQcc;
Kode lerroa:       var codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD;
Kode lerroa:       component.codingStyleParameters = codOrCoc;
Kode lerroa:     }
Kode lerroa:     tile.codingStyleDefaultParameters = context.currentTile.COD;
Kode lerroa:   }
Kode lerroa:   var TagTree = function TagTreeClosure() {
Kode lerroa:     function TagTree(width, height) {
Kode lerroa:       var levelsLength = (0, _util.log2)(Math.max(width, height)) + 1;
Kode lerroa:       this.levels = [];
Kode lerroa:       for (var i = 0; i < levelsLength; i++) {
Kode lerroa:         var level = {
Kode lerroa:           width: width,
Kode lerroa:           height: height,
Kode lerroa:           items: []
Kode lerroa:         };
Kode lerroa:         this.levels.push(level);
Kode lerroa:         width = Math.ceil(width / 2);
Kode lerroa:         height = Math.ceil(height / 2);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     TagTree.prototype = {
Kode lerroa:       reset: function TagTree_reset(i, j) {
Kode lerroa:         var currentLevel = 0,
Kode lerroa:             value = 0,
Kode lerroa:             level;
Kode lerroa:         while (currentLevel < this.levels.length) {
Kode lerroa:           level = this.levels[currentLevel];
Kode lerroa:           var index = i + j * level.width;
Kode lerroa:           if (level.items[index] !== undefined) {
Kode lerroa:             value = level.items[index];
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           level.index = index;
Kode lerroa:           i >>= 1;
Kode lerroa:           j >>= 1;
Kode lerroa:           currentLevel++;
Kode lerroa:         }
Kode lerroa:         currentLevel--;
Kode lerroa:         level = this.levels[currentLevel];
Kode lerroa:         level.items[level.index] = value;
Kode lerroa:         this.currentLevel = currentLevel;
Kode lerroa:         delete this.value;
Kode lerroa:       },
Kode lerroa:       incrementValue: function TagTree_incrementValue() {
Kode lerroa:         var level = this.levels[this.currentLevel];
Kode lerroa:         level.items[level.index]++;
Kode lerroa:       },
Kode lerroa:       nextLevel: function TagTree_nextLevel() {
Kode lerroa:         var currentLevel = this.currentLevel;
Kode lerroa:         var level = this.levels[currentLevel];
Kode lerroa:         var value = level.items[level.index];
Kode lerroa:         currentLevel--;
Kode lerroa:         if (currentLevel < 0) {
Kode lerroa:           this.value = value;
Kode lerroa:           return false;
Kode lerroa:         }
Kode lerroa:         this.currentLevel = currentLevel;
Kode lerroa:         level = this.levels[currentLevel];
Kode lerroa:         level.items[level.index] = value;
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return TagTree;
Kode lerroa:   }();
Kode lerroa:   var InclusionTree = function InclusionTreeClosure() {
Kode lerroa:     function InclusionTree(width, height, defaultValue) {
Kode lerroa:       var levelsLength = (0, _util.log2)(Math.max(width, height)) + 1;
Kode lerroa:       this.levels = [];
Kode lerroa:       for (var i = 0; i < levelsLength; i++) {
Kode lerroa:         var items = new Uint8Array(width * height);
Kode lerroa:         for (var j = 0, jj = items.length; j < jj; j++) {
Kode lerroa:           items[j] = defaultValue;
Kode lerroa:         }
Kode lerroa:         var level = {
Kode lerroa:           width: width,
Kode lerroa:           height: height,
Kode lerroa:           items: items
Kode lerroa:         };
Kode lerroa:         this.levels.push(level);
Kode lerroa:         width = Math.ceil(width / 2);
Kode lerroa:         height = Math.ceil(height / 2);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     InclusionTree.prototype = {
Kode lerroa:       reset: function InclusionTree_reset(i, j, stopValue) {
Kode lerroa:         var currentLevel = 0;
Kode lerroa:         while (currentLevel < this.levels.length) {
Kode lerroa:           var level = this.levels[currentLevel];
Kode lerroa:           var index = i + j * level.width;
Kode lerroa:           level.index = index;
Kode lerroa:           var value = level.items[index];
Kode lerroa:           if (value === 0xFF) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           if (value > stopValue) {
Kode lerroa:             this.currentLevel = currentLevel;
Kode lerroa:             this.propagateValues();
Kode lerroa:             return false;
Kode lerroa:           }
Kode lerroa:           i >>= 1;
Kode lerroa:           j >>= 1;
Kode lerroa:           currentLevel++;
Kode lerroa:         }
Kode lerroa:         this.currentLevel = currentLevel - 1;
Kode lerroa:         return true;
Kode lerroa:       },
Kode lerroa:       incrementValue: function InclusionTree_incrementValue(stopValue) {
Kode lerroa:         var level = this.levels[this.currentLevel];
Kode lerroa:         level.items[level.index] = stopValue + 1;
Kode lerroa:         this.propagateValues();
Kode lerroa:       },
Kode lerroa:       propagateValues: function InclusionTree_propagateValues() {
Kode lerroa:         var levelIndex = this.currentLevel;
Kode lerroa:         var level = this.levels[levelIndex];
Kode lerroa:         var currentValue = level.items[level.index];
Kode lerroa:         while (--levelIndex >= 0) {
Kode lerroa:           level = this.levels[levelIndex];
Kode lerroa:           level.items[level.index] = currentValue;
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       nextLevel: function InclusionTree_nextLevel() {
Kode lerroa:         var currentLevel = this.currentLevel;
Kode lerroa:         var level = this.levels[currentLevel];
Kode lerroa:         var value = level.items[level.index];
Kode lerroa:         level.items[level.index] = 0xFF;
Kode lerroa:         currentLevel--;
Kode lerroa:         if (currentLevel < 0) {
Kode lerroa:           return false;
Kode lerroa:         }
Kode lerroa:         this.currentLevel = currentLevel;
Kode lerroa:         level = this.levels[currentLevel];
Kode lerroa:         level.items[level.index] = value;
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return InclusionTree;
Kode lerroa:   }();
Kode lerroa:   var BitModel = function BitModelClosure() {
Kode lerroa:     var UNIFORM_CONTEXT = 17;
Kode lerroa:     var RUNLENGTH_CONTEXT = 18;
Kode lerroa:     var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
Kode lerroa:     var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
Kode lerroa:     var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
Kode lerroa:     function BitModel(width, height, subband, zeroBitPlanes, mb) {
Kode lerroa:       this.width = width;
Kode lerroa:       this.height = height;
Kode lerroa:       this.contextLabelTable = subband === 'HH' ? HHContextLabel : subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel;
Kode lerroa:       var coefficientCount = width * height;
Kode lerroa:       this.neighborsSignificance = new Uint8Array(coefficientCount);
Kode lerroa:       this.coefficentsSign = new Uint8Array(coefficientCount);
Kode lerroa:       this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) : mb > 6 ? new Uint16Array(coefficientCount) : new Uint8Array(coefficientCount);
Kode lerroa:       this.processingFlags = new Uint8Array(coefficientCount);
Kode lerroa:       var bitsDecoded = new Uint8Array(coefficientCount);
Kode lerroa:       if (zeroBitPlanes !== 0) {
Kode lerroa:         for (var i = 0; i < coefficientCount; i++) {
Kode lerroa:           bitsDecoded[i] = zeroBitPlanes;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.bitsDecoded = bitsDecoded;
Kode lerroa:       this.reset();
Kode lerroa:     }
Kode lerroa:     BitModel.prototype = {
Kode lerroa:       setDecoder: function BitModel_setDecoder(decoder) {
Kode lerroa:         this.decoder = decoder;
Kode lerroa:       },
Kode lerroa:       reset: function BitModel_reset() {
Kode lerroa:         this.contexts = new Int8Array(19);
Kode lerroa:         this.contexts[0] = 4 << 1 | 0;
Kode lerroa:         this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
Kode lerroa:         this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
Kode lerroa:       },
Kode lerroa:       setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
Kode lerroa:         var neighborsSignificance = this.neighborsSignificance;
Kode lerroa:         var width = this.width,
Kode lerroa:             height = this.height;
Kode lerroa:         var left = column > 0;
Kode lerroa:         var right = column + 1 < width;
Kode lerroa:         var i;
Kode lerroa:         if (row > 0) {
Kode lerroa:           i = index - width;
Kode lerroa:           if (left) {
Kode lerroa:             neighborsSignificance[i - 1] += 0x10;
Kode lerroa:           }
Kode lerroa:           if (right) {
Kode lerroa:             neighborsSignificance[i + 1] += 0x10;
Kode lerroa:           }
Kode lerroa:           neighborsSignificance[i] += 0x04;
Kode lerroa:         }
Kode lerroa:         if (row + 1 < height) {
Kode lerroa:           i = index + width;
Kode lerroa:           if (left) {
Kode lerroa:             neighborsSignificance[i - 1] += 0x10;
Kode lerroa:           }
Kode lerroa:           if (right) {
Kode lerroa:             neighborsSignificance[i + 1] += 0x10;
Kode lerroa:           }
Kode lerroa:           neighborsSignificance[i] += 0x04;
Kode lerroa:         }
Kode lerroa:         if (left) {
Kode lerroa:           neighborsSignificance[index - 1] += 0x01;
Kode lerroa:         }
Kode lerroa:         if (right) {
Kode lerroa:           neighborsSignificance[index + 1] += 0x01;
Kode lerroa:         }
Kode lerroa:         neighborsSignificance[index] |= 0x80;
Kode lerroa:       },
Kode lerroa:       runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
Kode lerroa:         var decoder = this.decoder;
Kode lerroa:         var width = this.width,
Kode lerroa:             height = this.height;
Kode lerroa:         var coefficentsMagnitude = this.coefficentsMagnitude;
Kode lerroa:         var coefficentsSign = this.coefficentsSign;
Kode lerroa:         var neighborsSignificance = this.neighborsSignificance;
Kode lerroa:         var processingFlags = this.processingFlags;
Kode lerroa:         var contexts = this.contexts;
Kode lerroa:         var labels = this.contextLabelTable;
Kode lerroa:         var bitsDecoded = this.bitsDecoded;
Kode lerroa:         var processedInverseMask = ~1;
Kode lerroa:         var processedMask = 1;
Kode lerroa:         var firstMagnitudeBitMask = 2;
Kode lerroa:         for (var i0 = 0; i0 < height; i0 += 4) {
Kode lerroa:           for (var j = 0; j < width; j++) {
Kode lerroa:             var index = i0 * width + j;
Kode lerroa:             for (var i1 = 0; i1 < 4; i1++, index += width) {
Kode lerroa:               var i = i0 + i1;
Kode lerroa:               if (i >= height) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               processingFlags[index] &= processedInverseMask;
Kode lerroa:               if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               var contextLabel = labels[neighborsSignificance[index]];
Kode lerroa:               var decision = decoder.readBit(contexts, contextLabel);
Kode lerroa:               if (decision) {
Kode lerroa:                 var sign = this.decodeSignBit(i, j, index);
Kode lerroa:                 coefficentsSign[index] = sign;
Kode lerroa:                 coefficentsMagnitude[index] = 1;
Kode lerroa:                 this.setNeighborsSignificance(i, j, index);
Kode lerroa:                 processingFlags[index] |= firstMagnitudeBitMask;
Kode lerroa:               }
Kode lerroa:               bitsDecoded[index]++;
Kode lerroa:               processingFlags[index] |= processedMask;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
Kode lerroa:         var width = this.width,
Kode lerroa:             height = this.height;
Kode lerroa:         var coefficentsMagnitude = this.coefficentsMagnitude;
Kode lerroa:         var coefficentsSign = this.coefficentsSign;
Kode lerroa:         var contribution, sign0, sign1, significance1;
Kode lerroa:         var contextLabel, decoded;
Kode lerroa:         significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
Kode lerroa:         if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
Kode lerroa:           sign1 = coefficentsSign[index + 1];
Kode lerroa:           if (significance1) {
Kode lerroa:             sign0 = coefficentsSign[index - 1];
Kode lerroa:             contribution = 1 - sign1 - sign0;
Kode lerroa:           } else {
Kode lerroa:             contribution = 1 - sign1 - sign1;
Kode lerroa:           }
Kode lerroa:         } else if (significance1) {
Kode lerroa:           sign0 = coefficentsSign[index - 1];
Kode lerroa:           contribution = 1 - sign0 - sign0;
Kode lerroa:         } else {
Kode lerroa:           contribution = 0;
Kode lerroa:         }
Kode lerroa:         var horizontalContribution = 3 * contribution;
Kode lerroa:         significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
Kode lerroa:         if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
Kode lerroa:           sign1 = coefficentsSign[index + width];
Kode lerroa:           if (significance1) {
Kode lerroa:             sign0 = coefficentsSign[index - width];
Kode lerroa:             contribution = 1 - sign1 - sign0 + horizontalContribution;
Kode lerroa:           } else {
Kode lerroa:             contribution = 1 - sign1 - sign1 + horizontalContribution;
Kode lerroa:           }
Kode lerroa:         } else if (significance1) {
Kode lerroa:           sign0 = coefficentsSign[index - width];
Kode lerroa:           contribution = 1 - sign0 - sign0 + horizontalContribution;
Kode lerroa:         } else {
Kode lerroa:           contribution = horizontalContribution;
Kode lerroa:         }
Kode lerroa:         if (contribution >= 0) {
Kode lerroa:           contextLabel = 9 + contribution;
Kode lerroa:           decoded = this.decoder.readBit(this.contexts, contextLabel);
Kode lerroa:         } else {
Kode lerroa:           contextLabel = 9 - contribution;
Kode lerroa:           decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
Kode lerroa:         }
Kode lerroa:         return decoded;
Kode lerroa:       },
Kode lerroa:       runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
Kode lerroa:         var decoder = this.decoder;
Kode lerroa:         var width = this.width,
Kode lerroa:             height = this.height;
Kode lerroa:         var coefficentsMagnitude = this.coefficentsMagnitude;
Kode lerroa:         var neighborsSignificance = this.neighborsSignificance;
Kode lerroa:         var contexts = this.contexts;
Kode lerroa:         var bitsDecoded = this.bitsDecoded;
Kode lerroa:         var processingFlags = this.processingFlags;
Kode lerroa:         var processedMask = 1;
Kode lerroa:         var firstMagnitudeBitMask = 2;
Kode lerroa:         var length = width * height;
Kode lerroa:         var width4 = width * 4;
Kode lerroa:         for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
Kode lerroa:           indexNext = Math.min(length, index0 + width4);
Kode lerroa:           for (var j = 0; j < width; j++) {
Kode lerroa:             for (var index = index0 + j; index < indexNext; index += width) {
Kode lerroa:               if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               var contextLabel = 16;
Kode lerroa:               if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
Kode lerroa:                 processingFlags[index] ^= firstMagnitudeBitMask;
Kode lerroa:                 var significance = neighborsSignificance[index] & 127;
Kode lerroa:                 contextLabel = significance === 0 ? 15 : 14;
Kode lerroa:               }
Kode lerroa:               var bit = decoder.readBit(contexts, contextLabel);
Kode lerroa:               coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
Kode lerroa:               bitsDecoded[index]++;
Kode lerroa:               processingFlags[index] |= processedMask;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       runCleanupPass: function BitModel_runCleanupPass() {
Kode lerroa:         var decoder = this.decoder;
Kode lerroa:         var width = this.width,
Kode lerroa:             height = this.height;
Kode lerroa:         var neighborsSignificance = this.neighborsSignificance;
Kode lerroa:         var coefficentsMagnitude = this.coefficentsMagnitude;
Kode lerroa:         var coefficentsSign = this.coefficentsSign;
Kode lerroa:         var contexts = this.contexts;
Kode lerroa:         var labels = this.contextLabelTable;
Kode lerroa:         var bitsDecoded = this.bitsDecoded;
Kode lerroa:         var processingFlags = this.processingFlags;
Kode lerroa:         var processedMask = 1;
Kode lerroa:         var firstMagnitudeBitMask = 2;
Kode lerroa:         var oneRowDown = width;
Kode lerroa:         var twoRowsDown = width * 2;
Kode lerroa:         var threeRowsDown = width * 3;
Kode lerroa:         var iNext;
Kode lerroa:         for (var i0 = 0; i0 < height; i0 = iNext) {
Kode lerroa:           iNext = Math.min(i0 + 4, height);
Kode lerroa:           var indexBase = i0 * width;
Kode lerroa:           var checkAllEmpty = i0 + 3 < height;
Kode lerroa:           for (var j = 0; j < width; j++) {
Kode lerroa:             var index0 = indexBase + j;
Kode lerroa:             var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
Kode lerroa:             var i1 = 0,
Kode lerroa:                 index = index0;
Kode lerroa:             var i = i0,
Kode lerroa:                 sign;
Kode lerroa:             if (allEmpty) {
Kode lerroa:               var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
Kode lerroa:               if (!hasSignificantCoefficent) {
Kode lerroa:                 bitsDecoded[index0]++;
Kode lerroa:                 bitsDecoded[index0 + oneRowDown]++;
Kode lerroa:                 bitsDecoded[index0 + twoRowsDown]++;
Kode lerroa:                 bitsDecoded[index0 + threeRowsDown]++;
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
Kode lerroa:               if (i1 !== 0) {
Kode lerroa:                 i = i0 + i1;
Kode lerroa:                 index += i1 * width;
Kode lerroa:               }
Kode lerroa:               sign = this.decodeSignBit(i, j, index);
Kode lerroa:               coefficentsSign[index] = sign;
Kode lerroa:               coefficentsMagnitude[index] = 1;
Kode lerroa:               this.setNeighborsSignificance(i, j, index);
Kode lerroa:               processingFlags[index] |= firstMagnitudeBitMask;
Kode lerroa:               index = index0;
Kode lerroa:               for (var i2 = i0; i2 <= i; i2++, index += width) {
Kode lerroa:                 bitsDecoded[index]++;
Kode lerroa:               }
Kode lerroa:               i1++;
Kode lerroa:             }
Kode lerroa:             for (i = i0 + i1; i < iNext; i++, index += width) {
Kode lerroa:               if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               var contextLabel = labels[neighborsSignificance[index]];
Kode lerroa:               var decision = decoder.readBit(contexts, contextLabel);
Kode lerroa:               if (decision === 1) {
Kode lerroa:                 sign = this.decodeSignBit(i, j, index);
Kode lerroa:                 coefficentsSign[index] = sign;
Kode lerroa:                 coefficentsMagnitude[index] = 1;
Kode lerroa:                 this.setNeighborsSignificance(i, j, index);
Kode lerroa:                 processingFlags[index] |= firstMagnitudeBitMask;
Kode lerroa:               }
Kode lerroa:               bitsDecoded[index]++;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
Kode lerroa:         var decoder = this.decoder;
Kode lerroa:         var contexts = this.contexts;
Kode lerroa:         var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
Kode lerroa:         if (symbol !== 0xA) {
Kode lerroa:           throw new JpxError('Invalid segmentation symbol');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return BitModel;
Kode lerroa:   }();
Kode lerroa:   var Transform = function TransformClosure() {
Kode lerroa:     function Transform() {}
Kode lerroa:     Transform.prototype.calculate = function transformCalculate(subbands, u0, v0) {
Kode lerroa:       var ll = subbands[0];
Kode lerroa:       for (var i = 1, ii = subbands.length; i < ii; i++) {
Kode lerroa:         ll = this.iterate(ll, subbands[i], u0, v0);
Kode lerroa:       }
Kode lerroa:       return ll;
Kode lerroa:     };
Kode lerroa:     Transform.prototype.extend = function extend(buffer, offset, size) {
Kode lerroa:       var i1 = offset - 1,
Kode lerroa:           j1 = offset + 1;
Kode lerroa:       var i2 = offset + size - 2,
Kode lerroa:           j2 = offset + size;
Kode lerroa:       buffer[i1--] = buffer[j1++];
Kode lerroa:       buffer[j2++] = buffer[i2--];
Kode lerroa:       buffer[i1--] = buffer[j1++];
Kode lerroa:       buffer[j2++] = buffer[i2--];
Kode lerroa:       buffer[i1--] = buffer[j1++];
Kode lerroa:       buffer[j2++] = buffer[i2--];
Kode lerroa:       buffer[i1] = buffer[j1];
Kode lerroa:       buffer[j2] = buffer[i2];
Kode lerroa:     };
Kode lerroa:     Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
Kode lerroa:       var llWidth = ll.width,
Kode lerroa:           llHeight = ll.height,
Kode lerroa:           llItems = ll.items;
Kode lerroa:       var width = hl_lh_hh.width;
Kode lerroa:       var height = hl_lh_hh.height;
Kode lerroa:       var items = hl_lh_hh.items;
Kode lerroa:       var i, j, k, l, u, v;
Kode lerroa:       for (k = 0, i = 0; i < llHeight; i++) {
Kode lerroa:         l = i * 2 * width;
Kode lerroa:         for (j = 0; j < llWidth; j++, k++, l += 2) {
Kode lerroa:           items[l] = llItems[k];
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       llItems = ll.items = null;
Kode lerroa:       var bufferPadding = 4;
Kode lerroa:       var rowBuffer = new Float32Array(width + 2 * bufferPadding);
Kode lerroa:       if (width === 1) {
Kode lerroa:         if ((u0 & 1) !== 0) {
Kode lerroa:           for (v = 0, k = 0; v < height; v++, k += width) {
Kode lerroa:             items[k] *= 0.5;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         for (v = 0, k = 0; v < height; v++, k += width) {
Kode lerroa:           rowBuffer.set(items.subarray(k, k + width), bufferPadding);
Kode lerroa:           this.extend(rowBuffer, bufferPadding, width);
Kode lerroa:           this.filter(rowBuffer, bufferPadding, width);
Kode lerroa:           items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var numBuffers = 16;
Kode lerroa:       var colBuffers = [];
Kode lerroa:       for (i = 0; i < numBuffers; i++) {
Kode lerroa:         colBuffers.push(new Float32Array(height + 2 * bufferPadding));
Kode lerroa:       }
Kode lerroa:       var b,
Kode lerroa:           currentBuffer = 0;
Kode lerroa:       ll = bufferPadding + height;
Kode lerroa:       if (height === 1) {
Kode lerroa:         if ((v0 & 1) !== 0) {
Kode lerroa:           for (u = 0; u < width; u++) {
Kode lerroa:             items[u] *= 0.5;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         for (u = 0; u < width; u++) {
Kode lerroa:           if (currentBuffer === 0) {
Kode lerroa:             numBuffers = Math.min(width - u, numBuffers);
Kode lerroa:             for (k = u, l = bufferPadding; l < ll; k += width, l++) {
Kode lerroa:               for (b = 0; b < numBuffers; b++) {
Kode lerroa:                 colBuffers[b][l] = items[k + b];
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             currentBuffer = numBuffers;
Kode lerroa:           }
Kode lerroa:           currentBuffer--;
Kode lerroa:           var buffer = colBuffers[currentBuffer];
Kode lerroa:           this.extend(buffer, bufferPadding, height);
Kode lerroa:           this.filter(buffer, bufferPadding, height);
Kode lerroa:           if (currentBuffer === 0) {
Kode lerroa:             k = u - numBuffers + 1;
Kode lerroa:             for (l = bufferPadding; l < ll; k += width, l++) {
Kode lerroa:               for (b = 0; b < numBuffers; b++) {
Kode lerroa:                 items[k + b] = colBuffers[b][l];
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         width: width,
Kode lerroa:         height: height,
Kode lerroa:         items: items
Kode lerroa:       };
Kode lerroa:     };
Kode lerroa:     return Transform;
Kode lerroa:   }();
Kode lerroa:   var IrreversibleTransform = function IrreversibleTransformClosure() {
Kode lerroa:     function IrreversibleTransform() {
Kode lerroa:       Transform.call(this);
Kode lerroa:     }
Kode lerroa:     IrreversibleTransform.prototype = Object.create(Transform.prototype);
Kode lerroa:     IrreversibleTransform.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
Kode lerroa:       var len = length >> 1;
Kode lerroa:       offset = offset | 0;
Kode lerroa:       var j, n, current, next;
Kode lerroa:       var alpha = -1.586134342059924;
Kode lerroa:       var beta = -0.052980118572961;
Kode lerroa:       var gamma = 0.882911075530934;
Kode lerroa:       var delta = 0.443506852043971;
Kode lerroa:       var K = 1.230174104914001;
Kode lerroa:       var K_ = 1 / K;
Kode lerroa:       j = offset - 3;
Kode lerroa:       for (n = len + 4; n--; j += 2) {
Kode lerroa:         x[j] *= K_;
Kode lerroa:       }
Kode lerroa:       j = offset - 2;
Kode lerroa:       current = delta * x[j - 1];
Kode lerroa:       for (n = len + 3; n--; j += 2) {
Kode lerroa:         next = delta * x[j + 1];
Kode lerroa:         x[j] = K * x[j] - current - next;
Kode lerroa:         if (n--) {
Kode lerroa:           j += 2;
Kode lerroa:           current = delta * x[j + 1];
Kode lerroa:           x[j] = K * x[j] - current - next;
Kode lerroa:         } else {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       j = offset - 1;
Kode lerroa:       current = gamma * x[j - 1];
Kode lerroa:       for (n = len + 2; n--; j += 2) {
Kode lerroa:         next = gamma * x[j + 1];
Kode lerroa:         x[j] -= current + next;
Kode lerroa:         if (n--) {
Kode lerroa:           j += 2;
Kode lerroa:           current = gamma * x[j + 1];
Kode lerroa:           x[j] -= current + next;
Kode lerroa:         } else {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       j = offset;
Kode lerroa:       current = beta * x[j - 1];
Kode lerroa:       for (n = len + 1; n--; j += 2) {
Kode lerroa:         next = beta * x[j + 1];
Kode lerroa:         x[j] -= current + next;
Kode lerroa:         if (n--) {
Kode lerroa:           j += 2;
Kode lerroa:           current = beta * x[j + 1];
Kode lerroa:           x[j] -= current + next;
Kode lerroa:         } else {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (len !== 0) {
Kode lerroa:         j = offset + 1;
Kode lerroa:         current = alpha * x[j - 1];
Kode lerroa:         for (n = len; n--; j += 2) {
Kode lerroa:           next = alpha * x[j + 1];
Kode lerroa:           x[j] -= current + next;
Kode lerroa:           if (n--) {
Kode lerroa:             j += 2;
Kode lerroa:             current = alpha * x[j + 1];
Kode lerroa:             x[j] -= current + next;
Kode lerroa:           } else {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return IrreversibleTransform;
Kode lerroa:   }();
Kode lerroa:   var ReversibleTransform = function ReversibleTransformClosure() {
Kode lerroa:     function ReversibleTransform() {
Kode lerroa:       Transform.call(this);
Kode lerroa:     }
Kode lerroa:     ReversibleTransform.prototype = Object.create(Transform.prototype);
Kode lerroa:     ReversibleTransform.prototype.filter = function reversibleTransformFilter(x, offset, length) {
Kode lerroa:       var len = length >> 1;
Kode lerroa:       offset = offset | 0;
Kode lerroa:       var j, n;
Kode lerroa:       for (j = offset, n = len + 1; n--; j += 2) {
Kode lerroa:         x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
Kode lerroa:       }
Kode lerroa:       for (j = offset + 1, n = len; n--; j += 2) {
Kode lerroa:         x[j] += x[j - 1] + x[j + 1] >> 1;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     return ReversibleTransform;
Kode lerroa:   }();
Kode lerroa:   return JpxImage;
Kode lerroa: }();
Kode lerroa: exports.JpxImage = JpxImage;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 75 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: var ArithmeticDecoder = function ArithmeticDecoderClosure() {
Kode lerroa:   var QeTable = [{
Kode lerroa:     qe: 0x5601,
Kode lerroa:     nmps: 1,
Kode lerroa:     nlps: 1,
Kode lerroa:     switchFlag: 1
Kode lerroa:   }, {
Kode lerroa:     qe: 0x3401,
Kode lerroa:     nmps: 2,
Kode lerroa:     nlps: 6,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1801,
Kode lerroa:     nmps: 3,
Kode lerroa:     nlps: 9,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0AC1,
Kode lerroa:     nmps: 4,
Kode lerroa:     nlps: 12,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0521,
Kode lerroa:     nmps: 5,
Kode lerroa:     nlps: 29,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0221,
Kode lerroa:     nmps: 38,
Kode lerroa:     nlps: 33,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x5601,
Kode lerroa:     nmps: 7,
Kode lerroa:     nlps: 6,
Kode lerroa:     switchFlag: 1
Kode lerroa:   }, {
Kode lerroa:     qe: 0x5401,
Kode lerroa:     nmps: 8,
Kode lerroa:     nlps: 14,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x4801,
Kode lerroa:     nmps: 9,
Kode lerroa:     nlps: 14,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x3801,
Kode lerroa:     nmps: 10,
Kode lerroa:     nlps: 14,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x3001,
Kode lerroa:     nmps: 11,
Kode lerroa:     nlps: 17,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x2401,
Kode lerroa:     nmps: 12,
Kode lerroa:     nlps: 18,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1C01,
Kode lerroa:     nmps: 13,
Kode lerroa:     nlps: 20,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1601,
Kode lerroa:     nmps: 29,
Kode lerroa:     nlps: 21,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x5601,
Kode lerroa:     nmps: 15,
Kode lerroa:     nlps: 14,
Kode lerroa:     switchFlag: 1
Kode lerroa:   }, {
Kode lerroa:     qe: 0x5401,
Kode lerroa:     nmps: 16,
Kode lerroa:     nlps: 14,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x5101,
Kode lerroa:     nmps: 17,
Kode lerroa:     nlps: 15,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x4801,
Kode lerroa:     nmps: 18,
Kode lerroa:     nlps: 16,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x3801,
Kode lerroa:     nmps: 19,
Kode lerroa:     nlps: 17,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x3401,
Kode lerroa:     nmps: 20,
Kode lerroa:     nlps: 18,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x3001,
Kode lerroa:     nmps: 21,
Kode lerroa:     nlps: 19,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x2801,
Kode lerroa:     nmps: 22,
Kode lerroa:     nlps: 19,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x2401,
Kode lerroa:     nmps: 23,
Kode lerroa:     nlps: 20,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x2201,
Kode lerroa:     nmps: 24,
Kode lerroa:     nlps: 21,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1C01,
Kode lerroa:     nmps: 25,
Kode lerroa:     nlps: 22,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1801,
Kode lerroa:     nmps: 26,
Kode lerroa:     nlps: 23,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1601,
Kode lerroa:     nmps: 27,
Kode lerroa:     nlps: 24,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1401,
Kode lerroa:     nmps: 28,
Kode lerroa:     nlps: 25,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1201,
Kode lerroa:     nmps: 29,
Kode lerroa:     nlps: 26,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x1101,
Kode lerroa:     nmps: 30,
Kode lerroa:     nlps: 27,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0AC1,
Kode lerroa:     nmps: 31,
Kode lerroa:     nlps: 28,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x09C1,
Kode lerroa:     nmps: 32,
Kode lerroa:     nlps: 29,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x08A1,
Kode lerroa:     nmps: 33,
Kode lerroa:     nlps: 30,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0521,
Kode lerroa:     nmps: 34,
Kode lerroa:     nlps: 31,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0441,
Kode lerroa:     nmps: 35,
Kode lerroa:     nlps: 32,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x02A1,
Kode lerroa:     nmps: 36,
Kode lerroa:     nlps: 33,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0221,
Kode lerroa:     nmps: 37,
Kode lerroa:     nlps: 34,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0141,
Kode lerroa:     nmps: 38,
Kode lerroa:     nlps: 35,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0111,
Kode lerroa:     nmps: 39,
Kode lerroa:     nlps: 36,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0085,
Kode lerroa:     nmps: 40,
Kode lerroa:     nlps: 37,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0049,
Kode lerroa:     nmps: 41,
Kode lerroa:     nlps: 38,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0025,
Kode lerroa:     nmps: 42,
Kode lerroa:     nlps: 39,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0015,
Kode lerroa:     nmps: 43,
Kode lerroa:     nlps: 40,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0009,
Kode lerroa:     nmps: 44,
Kode lerroa:     nlps: 41,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0005,
Kode lerroa:     nmps: 45,
Kode lerroa:     nlps: 42,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x0001,
Kode lerroa:     nmps: 45,
Kode lerroa:     nlps: 43,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }, {
Kode lerroa:     qe: 0x5601,
Kode lerroa:     nmps: 46,
Kode lerroa:     nlps: 46,
Kode lerroa:     switchFlag: 0
Kode lerroa:   }];
Kode lerroa:   function ArithmeticDecoder(data, start, end) {
Kode lerroa:     this.data = data;
Kode lerroa:     this.bp = start;
Kode lerroa:     this.dataEnd = end;
Kode lerroa:     this.chigh = data[start];
Kode lerroa:     this.clow = 0;
Kode lerroa:     this.byteIn();
Kode lerroa:     this.chigh = this.chigh << 7 & 0xFFFF | this.clow >> 9 & 0x7F;
Kode lerroa:     this.clow = this.clow << 7 & 0xFFFF;
Kode lerroa:     this.ct -= 7;
Kode lerroa:     this.a = 0x8000;
Kode lerroa:   }
Kode lerroa:   ArithmeticDecoder.prototype = {
Kode lerroa:     byteIn: function ArithmeticDecoder_byteIn() {
Kode lerroa:       var data = this.data;
Kode lerroa:       var bp = this.bp;
Kode lerroa:       if (data[bp] === 0xFF) {
Kode lerroa:         var b1 = data[bp + 1];
Kode lerroa:         if (b1 > 0x8F) {
Kode lerroa:           this.clow += 0xFF00;
Kode lerroa:           this.ct = 8;
Kode lerroa:         } else {
Kode lerroa:           bp++;
Kode lerroa:           this.clow += data[bp] << 9;
Kode lerroa:           this.ct = 7;
Kode lerroa:           this.bp = bp;
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         bp++;
Kode lerroa:         this.clow += bp < this.dataEnd ? data[bp] << 8 : 0xFF00;
Kode lerroa:         this.ct = 8;
Kode lerroa:         this.bp = bp;
Kode lerroa:       }
Kode lerroa:       if (this.clow > 0xFFFF) {
Kode lerroa:         this.chigh += this.clow >> 16;
Kode lerroa:         this.clow &= 0xFFFF;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     readBit: function ArithmeticDecoder_readBit(contexts, pos) {
Kode lerroa:       var cx_index = contexts[pos] >> 1,
Kode lerroa:           cx_mps = contexts[pos] & 1;
Kode lerroa:       var qeTableIcx = QeTable[cx_index];
Kode lerroa:       var qeIcx = qeTableIcx.qe;
Kode lerroa:       var d;
Kode lerroa:       var a = this.a - qeIcx;
Kode lerroa:       if (this.chigh < qeIcx) {
Kode lerroa:         if (a < qeIcx) {
Kode lerroa:           a = qeIcx;
Kode lerroa:           d = cx_mps;
Kode lerroa:           cx_index = qeTableIcx.nmps;
Kode lerroa:         } else {
Kode lerroa:           a = qeIcx;
Kode lerroa:           d = 1 ^ cx_mps;
Kode lerroa:           if (qeTableIcx.switchFlag === 1) {
Kode lerroa:             cx_mps = d;
Kode lerroa:           }
Kode lerroa:           cx_index = qeTableIcx.nlps;
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.chigh -= qeIcx;
Kode lerroa:         if ((a & 0x8000) !== 0) {
Kode lerroa:           this.a = a;
Kode lerroa:           return cx_mps;
Kode lerroa:         }
Kode lerroa:         if (a < qeIcx) {
Kode lerroa:           d = 1 ^ cx_mps;
Kode lerroa:           if (qeTableIcx.switchFlag === 1) {
Kode lerroa:             cx_mps = d;
Kode lerroa:           }
Kode lerroa:           cx_index = qeTableIcx.nlps;
Kode lerroa:         } else {
Kode lerroa:           d = cx_mps;
Kode lerroa:           cx_index = qeTableIcx.nmps;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       do {
Kode lerroa:         if (this.ct === 0) {
Kode lerroa:           this.byteIn();
Kode lerroa:         }
Kode lerroa:         a <<= 1;
Kode lerroa:         this.chigh = this.chigh << 1 & 0xFFFF | this.clow >> 15 & 1;
Kode lerroa:         this.clow = this.clow << 1 & 0xFFFF;
Kode lerroa:         this.ct--;
Kode lerroa:       } while ((a & 0x8000) === 0);
Kode lerroa:       this.a = a;
Kode lerroa:       contexts[pos] = cx_index << 1 | cx_mps;
Kode lerroa:       return d;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return ArithmeticDecoder;
Kode lerroa: }();
Kode lerroa: exports.ArithmeticDecoder = ArithmeticDecoder;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 76 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.calculateSHA512 = exports.calculateSHA384 = exports.calculateSHA256 = exports.calculateMD5 = exports.PDF20 = exports.PDF17 = exports.CipherTransformFactory = exports.ARCFourCipher = exports.AES256Cipher = exports.AES128Cipher = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var _stream = __w_pdfjs_require__(5);
Kode lerroa: 
Kode lerroa: var ARCFourCipher = function ARCFourCipherClosure() {
Kode lerroa:   function ARCFourCipher(key) {
Kode lerroa:     this.a = 0;
Kode lerroa:     this.b = 0;
Kode lerroa:     var s = new Uint8Array(256);
Kode lerroa:     var i,
Kode lerroa:         j = 0,
Kode lerroa:         tmp,
Kode lerroa:         keyLength = key.length;
Kode lerroa:     for (i = 0; i < 256; ++i) {
Kode lerroa:       s[i] = i;
Kode lerroa:     }
Kode lerroa:     for (i = 0; i < 256; ++i) {
Kode lerroa:       tmp = s[i];
Kode lerroa:       j = j + tmp + key[i % keyLength] & 0xFF;
Kode lerroa:       s[i] = s[j];
Kode lerroa:       s[j] = tmp;
Kode lerroa:     }
Kode lerroa:     this.s = s;
Kode lerroa:   }
Kode lerroa:   ARCFourCipher.prototype = {
Kode lerroa:     encryptBlock: function ARCFourCipher_encryptBlock(data) {
Kode lerroa:       var i,
Kode lerroa:           n = data.length,
Kode lerroa:           tmp,
Kode lerroa:           tmp2;
Kode lerroa:       var a = this.a,
Kode lerroa:           b = this.b,
Kode lerroa:           s = this.s;
Kode lerroa:       var output = new Uint8Array(n);
Kode lerroa:       for (i = 0; i < n; ++i) {
Kode lerroa:         a = a + 1 & 0xFF;
Kode lerroa:         tmp = s[a];
Kode lerroa:         b = b + tmp & 0xFF;
Kode lerroa:         tmp2 = s[b];
Kode lerroa:         s[a] = tmp2;
Kode lerroa:         s[b] = tmp;
Kode lerroa:         output[i] = data[i] ^ s[tmp + tmp2 & 0xFF];
Kode lerroa:       }
Kode lerroa:       this.a = a;
Kode lerroa:       this.b = b;
Kode lerroa:       return output;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   ARCFourCipher.prototype.decryptBlock = ARCFourCipher.prototype.encryptBlock;
Kode lerroa:   return ARCFourCipher;
Kode lerroa: }();
Kode lerroa: var calculateMD5 = function calculateMD5Closure() {
Kode lerroa:   var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
Kode lerroa:   var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
Kode lerroa:   function hash(data, offset, length) {
Kode lerroa:     var h0 = 1732584193,
Kode lerroa:         h1 = -271733879,
Kode lerroa:         h2 = -1732584194,
Kode lerroa:         h3 = 271733878;
Kode lerroa:     var paddedLength = length + 72 & ~63;
Kode lerroa:     var padded = new Uint8Array(paddedLength);
Kode lerroa:     var i, j, n;
Kode lerroa:     for (i = 0; i < length; ++i) {
Kode lerroa:       padded[i] = data[offset++];
Kode lerroa:     }
Kode lerroa:     padded[i++] = 0x80;
Kode lerroa:     n = paddedLength - 8;
Kode lerroa:     while (i < n) {
Kode lerroa:       padded[i++] = 0;
Kode lerroa:     }
Kode lerroa:     padded[i++] = length << 3 & 0xFF;
Kode lerroa:     padded[i++] = length >> 5 & 0xFF;
Kode lerroa:     padded[i++] = length >> 13 & 0xFF;
Kode lerroa:     padded[i++] = length >> 21 & 0xFF;
Kode lerroa:     padded[i++] = length >>> 29 & 0xFF;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     var w = new Int32Array(16);
Kode lerroa:     for (i = 0; i < paddedLength;) {
Kode lerroa:       for (j = 0; j < 16; ++j, i += 4) {
Kode lerroa:         w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
Kode lerroa:       }
Kode lerroa:       var a = h0,
Kode lerroa:           b = h1,
Kode lerroa:           c = h2,
Kode lerroa:           d = h3,
Kode lerroa:           f,
Kode lerroa:           g;
Kode lerroa:       for (j = 0; j < 64; ++j) {
Kode lerroa:         if (j < 16) {
Kode lerroa:           f = b & c | ~b & d;
Kode lerroa:           g = j;
Kode lerroa:         } else if (j < 32) {
Kode lerroa:           f = d & b | ~d & c;
Kode lerroa:           g = 5 * j + 1 & 15;
Kode lerroa:         } else if (j < 48) {
Kode lerroa:           f = b ^ c ^ d;
Kode lerroa:           g = 3 * j + 5 & 15;
Kode lerroa:         } else {
Kode lerroa:           f = c ^ (b | ~d);
Kode lerroa:           g = 7 * j & 15;
Kode lerroa:         }
Kode lerroa:         var tmp = d,
Kode lerroa:             rotateArg = a + f + k[j] + w[g] | 0,
Kode lerroa:             rotate = r[j];
Kode lerroa:         d = c;
Kode lerroa:         c = b;
Kode lerroa:         b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
Kode lerroa:         a = tmp;
Kode lerroa:       }
Kode lerroa:       h0 = h0 + a | 0;
Kode lerroa:       h1 = h1 + b | 0;
Kode lerroa:       h2 = h2 + c | 0;
Kode lerroa:       h3 = h3 + d | 0;
Kode lerroa:     }
Kode lerroa:     return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);
Kode lerroa:   }
Kode lerroa:   return hash;
Kode lerroa: }();
Kode lerroa: var Word64 = function Word64Closure() {
Kode lerroa:   function Word64(highInteger, lowInteger) {
Kode lerroa:     this.high = highInteger | 0;
Kode lerroa:     this.low = lowInteger | 0;
Kode lerroa:   }
Kode lerroa:   Word64.prototype = {
Kode lerroa:     and: function Word64_and(word) {
Kode lerroa:       this.high &= word.high;
Kode lerroa:       this.low &= word.low;
Kode lerroa:     },
Kode lerroa:     xor: function Word64_xor(word) {
Kode lerroa:       this.high ^= word.high;
Kode lerroa:       this.low ^= word.low;
Kode lerroa:     },
Kode lerroa:     or: function Word64_or(word) {
Kode lerroa:       this.high |= word.high;
Kode lerroa:       this.low |= word.low;
Kode lerroa:     },
Kode lerroa:     shiftRight: function Word64_shiftRight(places) {
Kode lerroa:       if (places >= 32) {
Kode lerroa:         this.low = this.high >>> places - 32 | 0;
Kode lerroa:         this.high = 0;
Kode lerroa:       } else {
Kode lerroa:         this.low = this.low >>> places | this.high << 32 - places;
Kode lerroa:         this.high = this.high >>> places | 0;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     shiftLeft: function Word64_shiftLeft(places) {
Kode lerroa:       if (places >= 32) {
Kode lerroa:         this.high = this.low << places - 32;
Kode lerroa:         this.low = 0;
Kode lerroa:       } else {
Kode lerroa:         this.high = this.high << places | this.low >>> 32 - places;
Kode lerroa:         this.low = this.low << places;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     rotateRight: function Word64_rotateRight(places) {
Kode lerroa:       var low, high;
Kode lerroa:       if (places & 32) {
Kode lerroa:         high = this.low;
Kode lerroa:         low = this.high;
Kode lerroa:       } else {
Kode lerroa:         low = this.low;
Kode lerroa:         high = this.high;
Kode lerroa:       }
Kode lerroa:       places &= 31;
Kode lerroa:       this.low = low >>> places | high << 32 - places;
Kode lerroa:       this.high = high >>> places | low << 32 - places;
Kode lerroa:     },
Kode lerroa:     not: function Word64_not() {
Kode lerroa:       this.high = ~this.high;
Kode lerroa:       this.low = ~this.low;
Kode lerroa:     },
Kode lerroa:     add: function Word64_add(word) {
Kode lerroa:       var lowAdd = (this.low >>> 0) + (word.low >>> 0);
Kode lerroa:       var highAdd = (this.high >>> 0) + (word.high >>> 0);
Kode lerroa:       if (lowAdd > 0xFFFFFFFF) {
Kode lerroa:         highAdd += 1;
Kode lerroa:       }
Kode lerroa:       this.low = lowAdd | 0;
Kode lerroa:       this.high = highAdd | 0;
Kode lerroa:     },
Kode lerroa:     copyTo: function Word64_copyTo(bytes, offset) {
Kode lerroa:       bytes[offset] = this.high >>> 24 & 0xFF;
Kode lerroa:       bytes[offset + 1] = this.high >> 16 & 0xFF;
Kode lerroa:       bytes[offset + 2] = this.high >> 8 & 0xFF;
Kode lerroa:       bytes[offset + 3] = this.high & 0xFF;
Kode lerroa:       bytes[offset + 4] = this.low >>> 24 & 0xFF;
Kode lerroa:       bytes[offset + 5] = this.low >> 16 & 0xFF;
Kode lerroa:       bytes[offset + 6] = this.low >> 8 & 0xFF;
Kode lerroa:       bytes[offset + 7] = this.low & 0xFF;
Kode lerroa:     },
Kode lerroa:     assign: function Word64_assign(word) {
Kode lerroa:       this.high = word.high;
Kode lerroa:       this.low = word.low;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return Word64;
Kode lerroa: }();
Kode lerroa: var calculateSHA256 = function calculateSHA256Closure() {
Kode lerroa:   function rotr(x, n) {
Kode lerroa:     return x >>> n | x << 32 - n;
Kode lerroa:   }
Kode lerroa:   function ch(x, y, z) {
Kode lerroa:     return x & y ^ ~x & z;
Kode lerroa:   }
Kode lerroa:   function maj(x, y, z) {
Kode lerroa:     return x & y ^ x & z ^ y & z;
Kode lerroa:   }
Kode lerroa:   function sigma(x) {
Kode lerroa:     return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
Kode lerroa:   }
Kode lerroa:   function sigmaPrime(x) {
Kode lerroa:     return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
Kode lerroa:   }
Kode lerroa:   function littleSigma(x) {
Kode lerroa:     return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
Kode lerroa:   }
Kode lerroa:   function littleSigmaPrime(x) {
Kode lerroa:     return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
Kode lerroa:   }
Kode lerroa:   var k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
Kode lerroa:   function hash(data, offset, length) {
Kode lerroa:     var h0 = 0x6a09e667,
Kode lerroa:         h1 = 0xbb67ae85,
Kode lerroa:         h2 = 0x3c6ef372,
Kode lerroa:         h3 = 0xa54ff53a,
Kode lerroa:         h4 = 0x510e527f,
Kode lerroa:         h5 = 0x9b05688c,
Kode lerroa:         h6 = 0x1f83d9ab,
Kode lerroa:         h7 = 0x5be0cd19;
Kode lerroa:     var paddedLength = Math.ceil((length + 9) / 64) * 64;
Kode lerroa:     var padded = new Uint8Array(paddedLength);
Kode lerroa:     var i, j, n;
Kode lerroa:     for (i = 0; i < length; ++i) {
Kode lerroa:       padded[i] = data[offset++];
Kode lerroa:     }
Kode lerroa:     padded[i++] = 0x80;
Kode lerroa:     n = paddedLength - 8;
Kode lerroa:     while (i < n) {
Kode lerroa:       padded[i++] = 0;
Kode lerroa:     }
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = length >>> 29 & 0xFF;
Kode lerroa:     padded[i++] = length >> 21 & 0xFF;
Kode lerroa:     padded[i++] = length >> 13 & 0xFF;
Kode lerroa:     padded[i++] = length >> 5 & 0xFF;
Kode lerroa:     padded[i++] = length << 3 & 0xFF;
Kode lerroa:     var w = new Uint32Array(64);
Kode lerroa:     for (i = 0; i < paddedLength;) {
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
Kode lerroa:         i += 4;
Kode lerroa:       }
Kode lerroa:       for (j = 16; j < 64; ++j) {
Kode lerroa:         w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
Kode lerroa:       }
Kode lerroa:       var a = h0,
Kode lerroa:           b = h1,
Kode lerroa:           c = h2,
Kode lerroa:           d = h3,
Kode lerroa:           e = h4,
Kode lerroa:           f = h5,
Kode lerroa:           g = h6,
Kode lerroa:           h = h7,
Kode lerroa:           t1,
Kode lerroa:           t2;
Kode lerroa:       for (j = 0; j < 64; ++j) {
Kode lerroa:         t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
Kode lerroa:         t2 = sigma(a) + maj(a, b, c);
Kode lerroa:         h = g;
Kode lerroa:         g = f;
Kode lerroa:         f = e;
Kode lerroa:         e = d + t1 | 0;
Kode lerroa:         d = c;
Kode lerroa:         c = b;
Kode lerroa:         b = a;
Kode lerroa:         a = t1 + t2 | 0;
Kode lerroa:       }
Kode lerroa:       h0 = h0 + a | 0;
Kode lerroa:       h1 = h1 + b | 0;
Kode lerroa:       h2 = h2 + c | 0;
Kode lerroa:       h3 = h3 + d | 0;
Kode lerroa:       h4 = h4 + e | 0;
Kode lerroa:       h5 = h5 + f | 0;
Kode lerroa:       h6 = h6 + g | 0;
Kode lerroa:       h7 = h7 + h | 0;
Kode lerroa:     }
Kode lerroa:     return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);
Kode lerroa:   }
Kode lerroa:   return hash;
Kode lerroa: }();
Kode lerroa: var calculateSHA512 = function calculateSHA512Closure() {
Kode lerroa:   function ch(result, x, y, z, tmp) {
Kode lerroa:     result.assign(x);
Kode lerroa:     result.and(y);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.not();
Kode lerroa:     tmp.and(z);
Kode lerroa:     result.xor(tmp);
Kode lerroa:   }
Kode lerroa:   function maj(result, x, y, z, tmp) {
Kode lerroa:     result.assign(x);
Kode lerroa:     result.and(y);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.and(z);
Kode lerroa:     result.xor(tmp);
Kode lerroa:     tmp.assign(y);
Kode lerroa:     tmp.and(z);
Kode lerroa:     result.xor(tmp);
Kode lerroa:   }
Kode lerroa:   function sigma(result, x, tmp) {
Kode lerroa:     result.assign(x);
Kode lerroa:     result.rotateRight(28);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.rotateRight(34);
Kode lerroa:     result.xor(tmp);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.rotateRight(39);
Kode lerroa:     result.xor(tmp);
Kode lerroa:   }
Kode lerroa:   function sigmaPrime(result, x, tmp) {
Kode lerroa:     result.assign(x);
Kode lerroa:     result.rotateRight(14);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.rotateRight(18);
Kode lerroa:     result.xor(tmp);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.rotateRight(41);
Kode lerroa:     result.xor(tmp);
Kode lerroa:   }
Kode lerroa:   function littleSigma(result, x, tmp) {
Kode lerroa:     result.assign(x);
Kode lerroa:     result.rotateRight(1);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.rotateRight(8);
Kode lerroa:     result.xor(tmp);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.shiftRight(7);
Kode lerroa:     result.xor(tmp);
Kode lerroa:   }
Kode lerroa:   function littleSigmaPrime(result, x, tmp) {
Kode lerroa:     result.assign(x);
Kode lerroa:     result.rotateRight(19);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.rotateRight(61);
Kode lerroa:     result.xor(tmp);
Kode lerroa:     tmp.assign(x);
Kode lerroa:     tmp.shiftRight(6);
Kode lerroa:     result.xor(tmp);
Kode lerroa:   }
Kode lerroa:   var k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];
Kode lerroa:   function hash(data, offset, length, mode384) {
Kode lerroa:     mode384 = !!mode384;
Kode lerroa:     var h0, h1, h2, h3, h4, h5, h6, h7;
Kode lerroa:     if (!mode384) {
Kode lerroa:       h0 = new Word64(0x6a09e667, 0xf3bcc908);
Kode lerroa:       h1 = new Word64(0xbb67ae85, 0x84caa73b);
Kode lerroa:       h2 = new Word64(0x3c6ef372, 0xfe94f82b);
Kode lerroa:       h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
Kode lerroa:       h4 = new Word64(0x510e527f, 0xade682d1);
Kode lerroa:       h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
Kode lerroa:       h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
Kode lerroa:       h7 = new Word64(0x5be0cd19, 0x137e2179);
Kode lerroa:     } else {
Kode lerroa:       h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
Kode lerroa:       h1 = new Word64(0x629a292a, 0x367cd507);
Kode lerroa:       h2 = new Word64(0x9159015a, 0x3070dd17);
Kode lerroa:       h3 = new Word64(0x152fecd8, 0xf70e5939);
Kode lerroa:       h4 = new Word64(0x67332667, 0xffc00b31);
Kode lerroa:       h5 = new Word64(0x8eb44a87, 0x68581511);
Kode lerroa:       h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
Kode lerroa:       h7 = new Word64(0x47b5481d, 0xbefa4fa4);
Kode lerroa:     }
Kode lerroa:     var paddedLength = Math.ceil((length + 17) / 128) * 128;
Kode lerroa:     var padded = new Uint8Array(paddedLength);
Kode lerroa:     var i, j, n;
Kode lerroa:     for (i = 0; i < length; ++i) {
Kode lerroa:       padded[i] = data[offset++];
Kode lerroa:     }
Kode lerroa:     padded[i++] = 0x80;
Kode lerroa:     n = paddedLength - 16;
Kode lerroa:     while (i < n) {
Kode lerroa:       padded[i++] = 0;
Kode lerroa:     }
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = 0;
Kode lerroa:     padded[i++] = length >>> 29 & 0xFF;
Kode lerroa:     padded[i++] = length >> 21 & 0xFF;
Kode lerroa:     padded[i++] = length >> 13 & 0xFF;
Kode lerroa:     padded[i++] = length >> 5 & 0xFF;
Kode lerroa:     padded[i++] = length << 3 & 0xFF;
Kode lerroa:     var w = new Array(80);
Kode lerroa:     for (i = 0; i < 80; i++) {
Kode lerroa:       w[i] = new Word64(0, 0);
Kode lerroa:     }
Kode lerroa:     var a = new Word64(0, 0),
Kode lerroa:         b = new Word64(0, 0),
Kode lerroa:         c = new Word64(0, 0);
Kode lerroa:     var d = new Word64(0, 0),
Kode lerroa:         e = new Word64(0, 0),
Kode lerroa:         f = new Word64(0, 0);
Kode lerroa:     var g = new Word64(0, 0),
Kode lerroa:         h = new Word64(0, 0);
Kode lerroa:     var t1 = new Word64(0, 0),
Kode lerroa:         t2 = new Word64(0, 0);
Kode lerroa:     var tmp1 = new Word64(0, 0),
Kode lerroa:         tmp2 = new Word64(0, 0),
Kode lerroa:         tmp3;
Kode lerroa:     for (i = 0; i < paddedLength;) {
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
Kode lerroa:         w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
Kode lerroa:         i += 8;
Kode lerroa:       }
Kode lerroa:       for (j = 16; j < 80; ++j) {
Kode lerroa:         tmp3 = w[j];
Kode lerroa:         littleSigmaPrime(tmp3, w[j - 2], tmp2);
Kode lerroa:         tmp3.add(w[j - 7]);
Kode lerroa:         littleSigma(tmp1, w[j - 15], tmp2);
Kode lerroa:         tmp3.add(tmp1);
Kode lerroa:         tmp3.add(w[j - 16]);
Kode lerroa:       }
Kode lerroa:       a.assign(h0);
Kode lerroa:       b.assign(h1);
Kode lerroa:       c.assign(h2);
Kode lerroa:       d.assign(h3);
Kode lerroa:       e.assign(h4);
Kode lerroa:       f.assign(h5);
Kode lerroa:       g.assign(h6);
Kode lerroa:       h.assign(h7);
Kode lerroa:       for (j = 0; j < 80; ++j) {
Kode lerroa:         t1.assign(h);
Kode lerroa:         sigmaPrime(tmp1, e, tmp2);
Kode lerroa:         t1.add(tmp1);
Kode lerroa:         ch(tmp1, e, f, g, tmp2);
Kode lerroa:         t1.add(tmp1);
Kode lerroa:         t1.add(k[j]);
Kode lerroa:         t1.add(w[j]);
Kode lerroa:         sigma(t2, a, tmp2);
Kode lerroa:         maj(tmp1, a, b, c, tmp2);
Kode lerroa:         t2.add(tmp1);
Kode lerroa:         tmp3 = h;
Kode lerroa:         h = g;
Kode lerroa:         g = f;
Kode lerroa:         f = e;
Kode lerroa:         d.add(t1);
Kode lerroa:         e = d;
Kode lerroa:         d = c;
Kode lerroa:         c = b;
Kode lerroa:         b = a;
Kode lerroa:         tmp3.assign(t1);
Kode lerroa:         tmp3.add(t2);
Kode lerroa:         a = tmp3;
Kode lerroa:       }
Kode lerroa:       h0.add(a);
Kode lerroa:       h1.add(b);
Kode lerroa:       h2.add(c);
Kode lerroa:       h3.add(d);
Kode lerroa:       h4.add(e);
Kode lerroa:       h5.add(f);
Kode lerroa:       h6.add(g);
Kode lerroa:       h7.add(h);
Kode lerroa:     }
Kode lerroa:     var result;
Kode lerroa:     if (!mode384) {
Kode lerroa:       result = new Uint8Array(64);
Kode lerroa:       h0.copyTo(result, 0);
Kode lerroa:       h1.copyTo(result, 8);
Kode lerroa:       h2.copyTo(result, 16);
Kode lerroa:       h3.copyTo(result, 24);
Kode lerroa:       h4.copyTo(result, 32);
Kode lerroa:       h5.copyTo(result, 40);
Kode lerroa:       h6.copyTo(result, 48);
Kode lerroa:       h7.copyTo(result, 56);
Kode lerroa:     } else {
Kode lerroa:       result = new Uint8Array(48);
Kode lerroa:       h0.copyTo(result, 0);
Kode lerroa:       h1.copyTo(result, 8);
Kode lerroa:       h2.copyTo(result, 16);
Kode lerroa:       h3.copyTo(result, 24);
Kode lerroa:       h4.copyTo(result, 32);
Kode lerroa:       h5.copyTo(result, 40);
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   }
Kode lerroa:   return hash;
Kode lerroa: }();
Kode lerroa: var calculateSHA384 = function calculateSHA384Closure() {
Kode lerroa:   function hash(data, offset, length) {
Kode lerroa:     return calculateSHA512(data, offset, length, true);
Kode lerroa:   }
Kode lerroa:   return hash;
Kode lerroa: }();
Kode lerroa: var NullCipher = function NullCipherClosure() {
Kode lerroa:   function NullCipher() {}
Kode lerroa:   NullCipher.prototype = {
Kode lerroa:     decryptBlock: function NullCipher_decryptBlock(data) {
Kode lerroa:       return data;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return NullCipher;
Kode lerroa: }();
Kode lerroa: var AES128Cipher = function AES128CipherClosure() {
Kode lerroa:   var rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
Kode lerroa:   var s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
Kode lerroa:   var inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
Kode lerroa:   var mixCol = new Uint8Array(256);
Kode lerroa:   for (var i = 0; i < 256; i++) {
Kode lerroa:     if (i < 128) {
Kode lerroa:       mixCol[i] = i << 1;
Kode lerroa:     } else {
Kode lerroa:       mixCol[i] = i << 1 ^ 0x1b;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
Kode lerroa:   function expandKey128(cipherKey) {
Kode lerroa:     var b = 176,
Kode lerroa:         result = new Uint8Array(b);
Kode lerroa:     result.set(cipherKey);
Kode lerroa:     for (var j = 16, i = 1; j < b; ++i) {
Kode lerroa:       var t1 = result[j - 3],
Kode lerroa:           t2 = result[j - 2],
Kode lerroa:           t3 = result[j - 1],
Kode lerroa:           t4 = result[j - 4];
Kode lerroa:       t1 = s[t1];
Kode lerroa:       t2 = s[t2];
Kode lerroa:       t3 = s[t3];
Kode lerroa:       t4 = s[t4];
Kode lerroa:       t1 = t1 ^ rcon[i];
Kode lerroa:       for (var n = 0; n < 4; ++n) {
Kode lerroa:         result[j] = t1 ^= result[j - 16];
Kode lerroa:         j++;
Kode lerroa:         result[j] = t2 ^= result[j - 16];
Kode lerroa:         j++;
Kode lerroa:         result[j] = t3 ^= result[j - 16];
Kode lerroa:         j++;
Kode lerroa:         result[j] = t4 ^= result[j - 16];
Kode lerroa:         j++;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   }
Kode lerroa:   function decrypt128(input, key) {
Kode lerroa:     var state = new Uint8Array(16);
Kode lerroa:     state.set(input);
Kode lerroa:     var i, j, k;
Kode lerroa:     var t, u, v;
Kode lerroa:     for (j = 0, k = 160; j < 16; ++j, ++k) {
Kode lerroa:       state[j] ^= key[k];
Kode lerroa:     }
Kode lerroa:     for (i = 9; i >= 1; --i) {
Kode lerroa:       t = state[13];
Kode lerroa:       state[13] = state[9];
Kode lerroa:       state[9] = state[5];
Kode lerroa:       state[5] = state[1];
Kode lerroa:       state[1] = t;
Kode lerroa:       t = state[14];
Kode lerroa:       u = state[10];
Kode lerroa:       state[14] = state[6];
Kode lerroa:       state[10] = state[2];
Kode lerroa:       state[6] = t;
Kode lerroa:       state[2] = u;
Kode lerroa:       t = state[15];
Kode lerroa:       u = state[11];
Kode lerroa:       v = state[7];
Kode lerroa:       state[15] = state[3];
Kode lerroa:       state[11] = t;
Kode lerroa:       state[7] = u;
Kode lerroa:       state[3] = v;
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         state[j] = inv_s[state[j]];
Kode lerroa:       }
Kode lerroa:       for (j = 0, k = i * 16; j < 16; ++j, ++k) {
Kode lerroa:         state[j] ^= key[k];
Kode lerroa:       }
Kode lerroa:       for (j = 0; j < 16; j += 4) {
Kode lerroa:         var s0 = mix[state[j]],
Kode lerroa:             s1 = mix[state[j + 1]],
Kode lerroa:             s2 = mix[state[j + 2]],
Kode lerroa:             s3 = mix[state[j + 3]];
Kode lerroa:         t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
Kode lerroa:         state[j] = t >>> 24 & 0xFF;
Kode lerroa:         state[j + 1] = t >> 16 & 0xFF;
Kode lerroa:         state[j + 2] = t >> 8 & 0xFF;
Kode lerroa:         state[j + 3] = t & 0xFF;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     t = state[13];
Kode lerroa:     state[13] = state[9];
Kode lerroa:     state[9] = state[5];
Kode lerroa:     state[5] = state[1];
Kode lerroa:     state[1] = t;
Kode lerroa:     t = state[14];
Kode lerroa:     u = state[10];
Kode lerroa:     state[14] = state[6];
Kode lerroa:     state[10] = state[2];
Kode lerroa:     state[6] = t;
Kode lerroa:     state[2] = u;
Kode lerroa:     t = state[15];
Kode lerroa:     u = state[11];
Kode lerroa:     v = state[7];
Kode lerroa:     state[15] = state[3];
Kode lerroa:     state[11] = t;
Kode lerroa:     state[7] = u;
Kode lerroa:     state[3] = v;
Kode lerroa:     for (j = 0; j < 16; ++j) {
Kode lerroa:       state[j] = inv_s[state[j]];
Kode lerroa:       state[j] ^= key[j];
Kode lerroa:     }
Kode lerroa:     return state;
Kode lerroa:   }
Kode lerroa:   function encrypt128(input, key) {
Kode lerroa:     var t, u, v, k;
Kode lerroa:     var state = new Uint8Array(16);
Kode lerroa:     state.set(input);
Kode lerroa:     for (j = 0; j < 16; ++j) {
Kode lerroa:       state[j] ^= key[j];
Kode lerroa:     }
Kode lerroa:     for (i = 1; i < 10; i++) {
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         state[j] = s[state[j]];
Kode lerroa:       }
Kode lerroa:       v = state[1];
Kode lerroa:       state[1] = state[5];
Kode lerroa:       state[5] = state[9];
Kode lerroa:       state[9] = state[13];
Kode lerroa:       state[13] = v;
Kode lerroa:       v = state[2];
Kode lerroa:       u = state[6];
Kode lerroa:       state[2] = state[10];
Kode lerroa:       state[6] = state[14];
Kode lerroa:       state[10] = v;
Kode lerroa:       state[14] = u;
Kode lerroa:       v = state[3];
Kode lerroa:       u = state[7];
Kode lerroa:       t = state[11];
Kode lerroa:       state[3] = state[15];
Kode lerroa:       state[7] = v;
Kode lerroa:       state[11] = u;
Kode lerroa:       state[15] = t;
Kode lerroa:       for (var j = 0; j < 16; j += 4) {
Kode lerroa:         var s0 = state[j + 0],
Kode lerroa:             s1 = state[j + 1];
Kode lerroa:         var s2 = state[j + 2],
Kode lerroa:             s3 = state[j + 3];
Kode lerroa:         t = s0 ^ s1 ^ s2 ^ s3;
Kode lerroa:         state[j + 0] ^= t ^ mixCol[s0 ^ s1];
Kode lerroa:         state[j + 1] ^= t ^ mixCol[s1 ^ s2];
Kode lerroa:         state[j + 2] ^= t ^ mixCol[s2 ^ s3];
Kode lerroa:         state[j + 3] ^= t ^ mixCol[s3 ^ s0];
Kode lerroa:       }
Kode lerroa:       for (j = 0, k = i * 16; j < 16; ++j, ++k) {
Kode lerroa:         state[j] ^= key[k];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     for (j = 0; j < 16; ++j) {
Kode lerroa:       state[j] = s[state[j]];
Kode lerroa:     }
Kode lerroa:     v = state[1];
Kode lerroa:     state[1] = state[5];
Kode lerroa:     state[5] = state[9];
Kode lerroa:     state[9] = state[13];
Kode lerroa:     state[13] = v;
Kode lerroa:     v = state[2];
Kode lerroa:     u = state[6];
Kode lerroa:     state[2] = state[10];
Kode lerroa:     state[6] = state[14];
Kode lerroa:     state[10] = v;
Kode lerroa:     state[14] = u;
Kode lerroa:     v = state[3];
Kode lerroa:     u = state[7];
Kode lerroa:     t = state[11];
Kode lerroa:     state[3] = state[15];
Kode lerroa:     state[7] = v;
Kode lerroa:     state[11] = u;
Kode lerroa:     state[15] = t;
Kode lerroa:     for (j = 0, k = 160; j < 16; ++j, ++k) {
Kode lerroa:       state[j] ^= key[k];
Kode lerroa:     }
Kode lerroa:     return state;
Kode lerroa:   }
Kode lerroa:   function AES128Cipher(key) {
Kode lerroa:     this.key = expandKey128(key);
Kode lerroa:     this.buffer = new Uint8Array(16);
Kode lerroa:     this.bufferPosition = 0;
Kode lerroa:   }
Kode lerroa:   function decryptBlock2(data, finalize) {
Kode lerroa:     var i,
Kode lerroa:         j,
Kode lerroa:         ii,
Kode lerroa:         sourceLength = data.length,
Kode lerroa:         buffer = this.buffer,
Kode lerroa:         bufferLength = this.bufferPosition,
Kode lerroa:         result = [],
Kode lerroa:         iv = this.iv;
Kode lerroa:     for (i = 0; i < sourceLength; ++i) {
Kode lerroa:       buffer[bufferLength] = data[i];
Kode lerroa:       ++bufferLength;
Kode lerroa:       if (bufferLength < 16) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       var plain = decrypt128(buffer, this.key);
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         plain[j] ^= iv[j];
Kode lerroa:       }
Kode lerroa:       iv = buffer;
Kode lerroa:       result.push(plain);
Kode lerroa:       buffer = new Uint8Array(16);
Kode lerroa:       bufferLength = 0;
Kode lerroa:     }
Kode lerroa:     this.buffer = buffer;
Kode lerroa:     this.bufferLength = bufferLength;
Kode lerroa:     this.iv = iv;
Kode lerroa:     if (result.length === 0) {
Kode lerroa:       return new Uint8Array([]);
Kode lerroa:     }
Kode lerroa:     var outputLength = 16 * result.length;
Kode lerroa:     if (finalize) {
Kode lerroa:       var lastBlock = result[result.length - 1];
Kode lerroa:       var psLen = lastBlock[15];
Kode lerroa:       if (psLen <= 16) {
Kode lerroa:         for (i = 15, ii = 16 - psLen; i >= ii; --i) {
Kode lerroa:           if (lastBlock[i] !== psLen) {
Kode lerroa:             psLen = 0;
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         outputLength -= psLen;
Kode lerroa:         result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var output = new Uint8Array(outputLength);
Kode lerroa:     for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
Kode lerroa:       output.set(result[i], j);
Kode lerroa:     }
Kode lerroa:     return output;
Kode lerroa:   }
Kode lerroa:   AES128Cipher.prototype = {
Kode lerroa:     decryptBlock: function AES128Cipher_decryptBlock(data, finalize) {
Kode lerroa:       var i,
Kode lerroa:           sourceLength = data.length;
Kode lerroa:       var buffer = this.buffer,
Kode lerroa:           bufferLength = this.bufferPosition;
Kode lerroa:       for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
Kode lerroa:         buffer[bufferLength] = data[i];
Kode lerroa:       }
Kode lerroa:       if (bufferLength < 16) {
Kode lerroa:         this.bufferLength = bufferLength;
Kode lerroa:         return new Uint8Array([]);
Kode lerroa:       }
Kode lerroa:       this.iv = buffer;
Kode lerroa:       this.buffer = new Uint8Array(16);
Kode lerroa:       this.bufferLength = 0;
Kode lerroa:       this.decryptBlock = decryptBlock2;
Kode lerroa:       return this.decryptBlock(data.subarray(16), finalize);
Kode lerroa:     },
Kode lerroa:     encrypt: function AES128Cipher_encrypt(data, iv) {
Kode lerroa:       var i,
Kode lerroa:           j,
Kode lerroa:           ii,
Kode lerroa:           sourceLength = data.length,
Kode lerroa:           buffer = this.buffer,
Kode lerroa:           bufferLength = this.bufferPosition,
Kode lerroa:           result = [];
Kode lerroa:       if (!iv) {
Kode lerroa:         iv = new Uint8Array(16);
Kode lerroa:       }
Kode lerroa:       for (i = 0; i < sourceLength; ++i) {
Kode lerroa:         buffer[bufferLength] = data[i];
Kode lerroa:         ++bufferLength;
Kode lerroa:         if (bufferLength < 16) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         for (j = 0; j < 16; ++j) {
Kode lerroa:           buffer[j] ^= iv[j];
Kode lerroa:         }
Kode lerroa:         var cipher = encrypt128(buffer, this.key);
Kode lerroa:         iv = cipher;
Kode lerroa:         result.push(cipher);
Kode lerroa:         buffer = new Uint8Array(16);
Kode lerroa:         bufferLength = 0;
Kode lerroa:       }
Kode lerroa:       this.buffer = buffer;
Kode lerroa:       this.bufferLength = bufferLength;
Kode lerroa:       this.iv = iv;
Kode lerroa:       if (result.length === 0) {
Kode lerroa:         return new Uint8Array([]);
Kode lerroa:       }
Kode lerroa:       var outputLength = 16 * result.length;
Kode lerroa:       var output = new Uint8Array(outputLength);
Kode lerroa:       for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
Kode lerroa:         output.set(result[i], j);
Kode lerroa:       }
Kode lerroa:       return output;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return AES128Cipher;
Kode lerroa: }();
Kode lerroa: var AES256Cipher = function AES256CipherClosure() {
Kode lerroa:   var s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
Kode lerroa:   var inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
Kode lerroa:   var mixCol = new Uint8Array(256);
Kode lerroa:   for (var i = 0; i < 256; i++) {
Kode lerroa:     if (i < 128) {
Kode lerroa:       mixCol[i] = i << 1;
Kode lerroa:     } else {
Kode lerroa:       mixCol[i] = i << 1 ^ 0x1b;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
Kode lerroa:   function expandKey256(cipherKey) {
Kode lerroa:     var b = 240,
Kode lerroa:         result = new Uint8Array(b);
Kode lerroa:     var r = 1;
Kode lerroa:     result.set(cipherKey);
Kode lerroa:     for (var j = 32, i = 1; j < b; ++i) {
Kode lerroa:       if (j % 32 === 16) {
Kode lerroa:         t1 = s[t1];
Kode lerroa:         t2 = s[t2];
Kode lerroa:         t3 = s[t3];
Kode lerroa:         t4 = s[t4];
Kode lerroa:       } else if (j % 32 === 0) {
Kode lerroa:         var t1 = result[j - 3],
Kode lerroa:             t2 = result[j - 2],
Kode lerroa:             t3 = result[j - 1],
Kode lerroa:             t4 = result[j - 4];
Kode lerroa:         t1 = s[t1];
Kode lerroa:         t2 = s[t2];
Kode lerroa:         t3 = s[t3];
Kode lerroa:         t4 = s[t4];
Kode lerroa:         t1 = t1 ^ r;
Kode lerroa:         if ((r <<= 1) >= 256) {
Kode lerroa:           r = (r ^ 0x1b) & 0xFF;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (var n = 0; n < 4; ++n) {
Kode lerroa:         result[j] = t1 ^= result[j - 32];
Kode lerroa:         j++;
Kode lerroa:         result[j] = t2 ^= result[j - 32];
Kode lerroa:         j++;
Kode lerroa:         result[j] = t3 ^= result[j - 32];
Kode lerroa:         j++;
Kode lerroa:         result[j] = t4 ^= result[j - 32];
Kode lerroa:         j++;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return result;
Kode lerroa:   }
Kode lerroa:   function decrypt256(input, key) {
Kode lerroa:     var state = new Uint8Array(16);
Kode lerroa:     state.set(input);
Kode lerroa:     var i, j, k;
Kode lerroa:     var t, u, v;
Kode lerroa:     for (j = 0, k = 224; j < 16; ++j, ++k) {
Kode lerroa:       state[j] ^= key[k];
Kode lerroa:     }
Kode lerroa:     for (i = 13; i >= 1; --i) {
Kode lerroa:       t = state[13];
Kode lerroa:       state[13] = state[9];
Kode lerroa:       state[9] = state[5];
Kode lerroa:       state[5] = state[1];
Kode lerroa:       state[1] = t;
Kode lerroa:       t = state[14];
Kode lerroa:       u = state[10];
Kode lerroa:       state[14] = state[6];
Kode lerroa:       state[10] = state[2];
Kode lerroa:       state[6] = t;
Kode lerroa:       state[2] = u;
Kode lerroa:       t = state[15];
Kode lerroa:       u = state[11];
Kode lerroa:       v = state[7];
Kode lerroa:       state[15] = state[3];
Kode lerroa:       state[11] = t;
Kode lerroa:       state[7] = u;
Kode lerroa:       state[3] = v;
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         state[j] = inv_s[state[j]];
Kode lerroa:       }
Kode lerroa:       for (j = 0, k = i * 16; j < 16; ++j, ++k) {
Kode lerroa:         state[j] ^= key[k];
Kode lerroa:       }
Kode lerroa:       for (j = 0; j < 16; j += 4) {
Kode lerroa:         var s0 = mix[state[j]],
Kode lerroa:             s1 = mix[state[j + 1]],
Kode lerroa:             s2 = mix[state[j + 2]],
Kode lerroa:             s3 = mix[state[j + 3]];
Kode lerroa:         t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
Kode lerroa:         state[j] = t >>> 24 & 0xFF;
Kode lerroa:         state[j + 1] = t >> 16 & 0xFF;
Kode lerroa:         state[j + 2] = t >> 8 & 0xFF;
Kode lerroa:         state[j + 3] = t & 0xFF;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     t = state[13];
Kode lerroa:     state[13] = state[9];
Kode lerroa:     state[9] = state[5];
Kode lerroa:     state[5] = state[1];
Kode lerroa:     state[1] = t;
Kode lerroa:     t = state[14];
Kode lerroa:     u = state[10];
Kode lerroa:     state[14] = state[6];
Kode lerroa:     state[10] = state[2];
Kode lerroa:     state[6] = t;
Kode lerroa:     state[2] = u;
Kode lerroa:     t = state[15];
Kode lerroa:     u = state[11];
Kode lerroa:     v = state[7];
Kode lerroa:     state[15] = state[3];
Kode lerroa:     state[11] = t;
Kode lerroa:     state[7] = u;
Kode lerroa:     state[3] = v;
Kode lerroa:     for (j = 0; j < 16; ++j) {
Kode lerroa:       state[j] = inv_s[state[j]];
Kode lerroa:       state[j] ^= key[j];
Kode lerroa:     }
Kode lerroa:     return state;
Kode lerroa:   }
Kode lerroa:   function encrypt256(input, key) {
Kode lerroa:     var t, u, v, k;
Kode lerroa:     var state = new Uint8Array(16);
Kode lerroa:     state.set(input);
Kode lerroa:     for (j = 0; j < 16; ++j) {
Kode lerroa:       state[j] ^= key[j];
Kode lerroa:     }
Kode lerroa:     for (i = 1; i < 14; i++) {
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         state[j] = s[state[j]];
Kode lerroa:       }
Kode lerroa:       v = state[1];
Kode lerroa:       state[1] = state[5];
Kode lerroa:       state[5] = state[9];
Kode lerroa:       state[9] = state[13];
Kode lerroa:       state[13] = v;
Kode lerroa:       v = state[2];
Kode lerroa:       u = state[6];
Kode lerroa:       state[2] = state[10];
Kode lerroa:       state[6] = state[14];
Kode lerroa:       state[10] = v;
Kode lerroa:       state[14] = u;
Kode lerroa:       v = state[3];
Kode lerroa:       u = state[7];
Kode lerroa:       t = state[11];
Kode lerroa:       state[3] = state[15];
Kode lerroa:       state[7] = v;
Kode lerroa:       state[11] = u;
Kode lerroa:       state[15] = t;
Kode lerroa:       for (var j = 0; j < 16; j += 4) {
Kode lerroa:         var s0 = state[j + 0],
Kode lerroa:             s1 = state[j + 1];
Kode lerroa:         var s2 = state[j + 2],
Kode lerroa:             s3 = state[j + 3];
Kode lerroa:         t = s0 ^ s1 ^ s2 ^ s3;
Kode lerroa:         state[j + 0] ^= t ^ mixCol[s0 ^ s1];
Kode lerroa:         state[j + 1] ^= t ^ mixCol[s1 ^ s2];
Kode lerroa:         state[j + 2] ^= t ^ mixCol[s2 ^ s3];
Kode lerroa:         state[j + 3] ^= t ^ mixCol[s3 ^ s0];
Kode lerroa:       }
Kode lerroa:       for (j = 0, k = i * 16; j < 16; ++j, ++k) {
Kode lerroa:         state[j] ^= key[k];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     for (j = 0; j < 16; ++j) {
Kode lerroa:       state[j] = s[state[j]];
Kode lerroa:     }
Kode lerroa:     v = state[1];
Kode lerroa:     state[1] = state[5];
Kode lerroa:     state[5] = state[9];
Kode lerroa:     state[9] = state[13];
Kode lerroa:     state[13] = v;
Kode lerroa:     v = state[2];
Kode lerroa:     u = state[6];
Kode lerroa:     state[2] = state[10];
Kode lerroa:     state[6] = state[14];
Kode lerroa:     state[10] = v;
Kode lerroa:     state[14] = u;
Kode lerroa:     v = state[3];
Kode lerroa:     u = state[7];
Kode lerroa:     t = state[11];
Kode lerroa:     state[3] = state[15];
Kode lerroa:     state[7] = v;
Kode lerroa:     state[11] = u;
Kode lerroa:     state[15] = t;
Kode lerroa:     for (j = 0, k = 224; j < 16; ++j, ++k) {
Kode lerroa:       state[j] ^= key[k];
Kode lerroa:     }
Kode lerroa:     return state;
Kode lerroa:   }
Kode lerroa:   function AES256Cipher(key) {
Kode lerroa:     this.key = expandKey256(key);
Kode lerroa:     this.buffer = new Uint8Array(16);
Kode lerroa:     this.bufferPosition = 0;
Kode lerroa:   }
Kode lerroa:   function decryptBlock2(data, finalize) {
Kode lerroa:     var i,
Kode lerroa:         j,
Kode lerroa:         ii,
Kode lerroa:         sourceLength = data.length,
Kode lerroa:         buffer = this.buffer,
Kode lerroa:         bufferLength = this.bufferPosition,
Kode lerroa:         result = [],
Kode lerroa:         iv = this.iv;
Kode lerroa:     for (i = 0; i < sourceLength; ++i) {
Kode lerroa:       buffer[bufferLength] = data[i];
Kode lerroa:       ++bufferLength;
Kode lerroa:       if (bufferLength < 16) {
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       var plain = decrypt256(buffer, this.key);
Kode lerroa:       for (j = 0; j < 16; ++j) {
Kode lerroa:         plain[j] ^= iv[j];
Kode lerroa:       }
Kode lerroa:       iv = buffer;
Kode lerroa:       result.push(plain);
Kode lerroa:       buffer = new Uint8Array(16);
Kode lerroa:       bufferLength = 0;
Kode lerroa:     }
Kode lerroa:     this.buffer = buffer;
Kode lerroa:     this.bufferLength = bufferLength;
Kode lerroa:     this.iv = iv;
Kode lerroa:     if (result.length === 0) {
Kode lerroa:       return new Uint8Array([]);
Kode lerroa:     }
Kode lerroa:     var outputLength = 16 * result.length;
Kode lerroa:     if (finalize) {
Kode lerroa:       var lastBlock = result[result.length - 1];
Kode lerroa:       var psLen = lastBlock[15];
Kode lerroa:       if (psLen <= 16) {
Kode lerroa:         for (i = 15, ii = 16 - psLen; i >= ii; --i) {
Kode lerroa:           if (lastBlock[i] !== psLen) {
Kode lerroa:             psLen = 0;
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         outputLength -= psLen;
Kode lerroa:         result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var output = new Uint8Array(outputLength);
Kode lerroa:     for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
Kode lerroa:       output.set(result[i], j);
Kode lerroa:     }
Kode lerroa:     return output;
Kode lerroa:   }
Kode lerroa:   AES256Cipher.prototype = {
Kode lerroa:     decryptBlock: function AES256Cipher_decryptBlock(data, finalize, iv) {
Kode lerroa:       var i,
Kode lerroa:           sourceLength = data.length;
Kode lerroa:       var buffer = this.buffer,
Kode lerroa:           bufferLength = this.bufferPosition;
Kode lerroa:       if (iv) {
Kode lerroa:         this.iv = iv;
Kode lerroa:       } else {
Kode lerroa:         for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
Kode lerroa:           buffer[bufferLength] = data[i];
Kode lerroa:         }
Kode lerroa:         if (bufferLength < 16) {
Kode lerroa:           this.bufferLength = bufferLength;
Kode lerroa:           return new Uint8Array([]);
Kode lerroa:         }
Kode lerroa:         this.iv = buffer;
Kode lerroa:         data = data.subarray(16);
Kode lerroa:       }
Kode lerroa:       this.buffer = new Uint8Array(16);
Kode lerroa:       this.bufferLength = 0;
Kode lerroa:       this.decryptBlock = decryptBlock2;
Kode lerroa:       return this.decryptBlock(data, finalize);
Kode lerroa:     },
Kode lerroa:     encrypt: function AES256Cipher_encrypt(data, iv) {
Kode lerroa:       var i,
Kode lerroa:           j,
Kode lerroa:           ii,
Kode lerroa:           sourceLength = data.length,
Kode lerroa:           buffer = this.buffer,
Kode lerroa:           bufferLength = this.bufferPosition,
Kode lerroa:           result = [];
Kode lerroa:       if (!iv) {
Kode lerroa:         iv = new Uint8Array(16);
Kode lerroa:       }
Kode lerroa:       for (i = 0; i < sourceLength; ++i) {
Kode lerroa:         buffer[bufferLength] = data[i];
Kode lerroa:         ++bufferLength;
Kode lerroa:         if (bufferLength < 16) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         for (j = 0; j < 16; ++j) {
Kode lerroa:           buffer[j] ^= iv[j];
Kode lerroa:         }
Kode lerroa:         var cipher = encrypt256(buffer, this.key);
Kode lerroa:         this.iv = cipher;
Kode lerroa:         result.push(cipher);
Kode lerroa:         buffer = new Uint8Array(16);
Kode lerroa:         bufferLength = 0;
Kode lerroa:       }
Kode lerroa:       this.buffer = buffer;
Kode lerroa:       this.bufferLength = bufferLength;
Kode lerroa:       this.iv = iv;
Kode lerroa:       if (result.length === 0) {
Kode lerroa:         return new Uint8Array([]);
Kode lerroa:       }
Kode lerroa:       var outputLength = 16 * result.length;
Kode lerroa:       var output = new Uint8Array(outputLength);
Kode lerroa:       for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
Kode lerroa:         output.set(result[i], j);
Kode lerroa:       }
Kode lerroa:       return output;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return AES256Cipher;
Kode lerroa: }();
Kode lerroa: var PDF17 = function PDF17Closure() {
Kode lerroa:   function compareByteArrays(array1, array2) {
Kode lerroa:     if (array1.length !== array2.length) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     for (var i = 0; i < array1.length; i++) {
Kode lerroa:       if (array1[i] !== array2[i]) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   function PDF17() {}
Kode lerroa:   PDF17.prototype = {
Kode lerroa:     checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 56);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(ownerValidationSalt, password.length);
Kode lerroa:       hashData.set(userBytes, password.length + ownerValidationSalt.length);
Kode lerroa:       var result = calculateSHA256(hashData, 0, hashData.length);
Kode lerroa:       return compareByteArrays(result, ownerPassword);
Kode lerroa:     },
Kode lerroa:     checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 8);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(userValidationSalt, password.length);
Kode lerroa:       var result = calculateSHA256(hashData, 0, hashData.length);
Kode lerroa:       return compareByteArrays(result, userPassword);
Kode lerroa:     },
Kode lerroa:     getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 56);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(ownerKeySalt, password.length);
Kode lerroa:       hashData.set(userBytes, password.length + ownerKeySalt.length);
Kode lerroa:       var key = calculateSHA256(hashData, 0, hashData.length);
Kode lerroa:       var cipher = new AES256Cipher(key);
Kode lerroa:       return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
Kode lerroa:     },
Kode lerroa:     getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 8);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(userKeySalt, password.length);
Kode lerroa:       var key = calculateSHA256(hashData, 0, hashData.length);
Kode lerroa:       var cipher = new AES256Cipher(key);
Kode lerroa:       return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDF17;
Kode lerroa: }();
Kode lerroa: var PDF20 = function PDF20Closure() {
Kode lerroa:   function concatArrays(array1, array2) {
Kode lerroa:     var t = new Uint8Array(array1.length + array2.length);
Kode lerroa:     t.set(array1, 0);
Kode lerroa:     t.set(array2, array1.length);
Kode lerroa:     return t;
Kode lerroa:   }
Kode lerroa:   function calculatePDF20Hash(password, input, userBytes) {
Kode lerroa:     var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
Kode lerroa:     var e = [0];
Kode lerroa:     var i = 0;
Kode lerroa:     while (i < 64 || e[e.length - 1] > i - 32) {
Kode lerroa:       var arrayLength = password.length + k.length + userBytes.length;
Kode lerroa:       var k1 = new Uint8Array(arrayLength * 64);
Kode lerroa:       var array = concatArrays(password, k);
Kode lerroa:       array = concatArrays(array, userBytes);
Kode lerroa:       for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
Kode lerroa:         k1.set(array, pos);
Kode lerroa:       }
Kode lerroa:       var cipher = new AES128Cipher(k.subarray(0, 16));
Kode lerroa:       e = cipher.encrypt(k1, k.subarray(16, 32));
Kode lerroa:       var remainder = 0;
Kode lerroa:       for (var z = 0; z < 16; z++) {
Kode lerroa:         remainder *= 256 % 3;
Kode lerroa:         remainder %= 3;
Kode lerroa:         remainder += (e[z] >>> 0) % 3;
Kode lerroa:         remainder %= 3;
Kode lerroa:       }
Kode lerroa:       if (remainder === 0) {
Kode lerroa:         k = calculateSHA256(e, 0, e.length);
Kode lerroa:       } else if (remainder === 1) {
Kode lerroa:         k = calculateSHA384(e, 0, e.length);
Kode lerroa:       } else if (remainder === 2) {
Kode lerroa:         k = calculateSHA512(e, 0, e.length);
Kode lerroa:       }
Kode lerroa:       i++;
Kode lerroa:     }
Kode lerroa:     return k.subarray(0, 32);
Kode lerroa:   }
Kode lerroa:   function PDF20() {}
Kode lerroa:   function compareByteArrays(array1, array2) {
Kode lerroa:     if (array1.length !== array2.length) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     for (var i = 0; i < array1.length; i++) {
Kode lerroa:       if (array1[i] !== array2[i]) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   PDF20.prototype = {
Kode lerroa:     hash: function PDF20_hash(password, concatBytes, userBytes) {
Kode lerroa:       return calculatePDF20Hash(password, concatBytes, userBytes);
Kode lerroa:     },
Kode lerroa:     checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 56);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(ownerValidationSalt, password.length);
Kode lerroa:       hashData.set(userBytes, password.length + ownerValidationSalt.length);
Kode lerroa:       var result = calculatePDF20Hash(password, hashData, userBytes);
Kode lerroa:       return compareByteArrays(result, ownerPassword);
Kode lerroa:     },
Kode lerroa:     checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 8);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(userValidationSalt, password.length);
Kode lerroa:       var result = calculatePDF20Hash(password, hashData, []);
Kode lerroa:       return compareByteArrays(result, userPassword);
Kode lerroa:     },
Kode lerroa:     getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 56);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(ownerKeySalt, password.length);
Kode lerroa:       hashData.set(userBytes, password.length + ownerKeySalt.length);
Kode lerroa:       var key = calculatePDF20Hash(password, hashData, userBytes);
Kode lerroa:       var cipher = new AES256Cipher(key);
Kode lerroa:       return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
Kode lerroa:     },
Kode lerroa:     getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
Kode lerroa:       var hashData = new Uint8Array(password.length + 8);
Kode lerroa:       hashData.set(password, 0);
Kode lerroa:       hashData.set(userKeySalt, password.length);
Kode lerroa:       var key = calculatePDF20Hash(password, hashData, []);
Kode lerroa:       var cipher = new AES256Cipher(key);
Kode lerroa:       return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PDF20;
Kode lerroa: }();
Kode lerroa: var CipherTransform = function CipherTransformClosure() {
Kode lerroa:   function CipherTransform(stringCipherConstructor, streamCipherConstructor) {
Kode lerroa:     this.StringCipherConstructor = stringCipherConstructor;
Kode lerroa:     this.StreamCipherConstructor = streamCipherConstructor;
Kode lerroa:   }
Kode lerroa:   CipherTransform.prototype = {
Kode lerroa:     createStream: function CipherTransform_createStream(stream, length) {
Kode lerroa:       var cipher = new this.StreamCipherConstructor();
Kode lerroa:       return new _stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
Kode lerroa:         return cipher.decryptBlock(data, finalize);
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     decryptString: function CipherTransform_decryptString(s) {
Kode lerroa:       var cipher = new this.StringCipherConstructor();
Kode lerroa:       var data = (0, _util.stringToBytes)(s);
Kode lerroa:       data = cipher.decryptBlock(data, true);
Kode lerroa:       return (0, _util.bytesToString)(data);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CipherTransform;
Kode lerroa: }();
Kode lerroa: var CipherTransformFactory = function CipherTransformFactoryClosure() {
Kode lerroa:   var defaultPasswordBytes = new Uint8Array([0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08, 0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A]);
Kode lerroa:   function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
Kode lerroa:     if (password) {
Kode lerroa:       var passwordLength = Math.min(127, password.length);
Kode lerroa:       password = password.subarray(0, passwordLength);
Kode lerroa:     } else {
Kode lerroa:       password = [];
Kode lerroa:     }
Kode lerroa:     var pdfAlgorithm;
Kode lerroa:     if (revision === 6) {
Kode lerroa:       pdfAlgorithm = new PDF20();
Kode lerroa:     } else {
Kode lerroa:       pdfAlgorithm = new PDF17();
Kode lerroa:     }
Kode lerroa:     if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
Kode lerroa:       return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
Kode lerroa:     } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
Kode lerroa:       return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
Kode lerroa:     }
Kode lerroa:     return null;
Kode lerroa:   }
Kode lerroa:   function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
Kode lerroa:     var hashDataSize = 40 + ownerPassword.length + fileId.length;
Kode lerroa:     var hashData = new Uint8Array(hashDataSize),
Kode lerroa:         i = 0,
Kode lerroa:         j,
Kode lerroa:         n;
Kode lerroa:     if (password) {
Kode lerroa:       n = Math.min(32, password.length);
Kode lerroa:       for (; i < n; ++i) {
Kode lerroa:         hashData[i] = password[i];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     j = 0;
Kode lerroa:     while (i < 32) {
Kode lerroa:       hashData[i++] = defaultPasswordBytes[j++];
Kode lerroa:     }
Kode lerroa:     for (j = 0, n = ownerPassword.length; j < n; ++j) {
Kode lerroa:       hashData[i++] = ownerPassword[j];
Kode lerroa:     }
Kode lerroa:     hashData[i++] = flags & 0xFF;
Kode lerroa:     hashData[i++] = flags >> 8 & 0xFF;
Kode lerroa:     hashData[i++] = flags >> 16 & 0xFF;
Kode lerroa:     hashData[i++] = flags >>> 24 & 0xFF;
Kode lerroa:     for (j = 0, n = fileId.length; j < n; ++j) {
Kode lerroa:       hashData[i++] = fileId[j];
Kode lerroa:     }
Kode lerroa:     if (revision >= 4 && !encryptMetadata) {
Kode lerroa:       hashData[i++] = 0xFF;
Kode lerroa:       hashData[i++] = 0xFF;
Kode lerroa:       hashData[i++] = 0xFF;
Kode lerroa:       hashData[i++] = 0xFF;
Kode lerroa:     }
Kode lerroa:     var hash = calculateMD5(hashData, 0, i);
Kode lerroa:     var keyLengthInBytes = keyLength >> 3;
Kode lerroa:     if (revision >= 3) {
Kode lerroa:       for (j = 0; j < 50; ++j) {
Kode lerroa:         hash = calculateMD5(hash, 0, keyLengthInBytes);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var encryptionKey = hash.subarray(0, keyLengthInBytes);
Kode lerroa:     var cipher, checkData;
Kode lerroa:     if (revision >= 3) {
Kode lerroa:       for (i = 0; i < 32; ++i) {
Kode lerroa:         hashData[i] = defaultPasswordBytes[i];
Kode lerroa:       }
Kode lerroa:       for (j = 0, n = fileId.length; j < n; ++j) {
Kode lerroa:         hashData[i++] = fileId[j];
Kode lerroa:       }
Kode lerroa:       cipher = new ARCFourCipher(encryptionKey);
Kode lerroa:       checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
Kode lerroa:       n = encryptionKey.length;
Kode lerroa:       var derivedKey = new Uint8Array(n),
Kode lerroa:           k;
Kode lerroa:       for (j = 1; j <= 19; ++j) {
Kode lerroa:         for (k = 0; k < n; ++k) {
Kode lerroa:           derivedKey[k] = encryptionKey[k] ^ j;
Kode lerroa:         }
Kode lerroa:         cipher = new ARCFourCipher(derivedKey);
Kode lerroa:         checkData = cipher.encryptBlock(checkData);
Kode lerroa:       }
Kode lerroa:       for (j = 0, n = checkData.length; j < n; ++j) {
Kode lerroa:         if (userPassword[j] !== checkData[j]) {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       cipher = new ARCFourCipher(encryptionKey);
Kode lerroa:       checkData = cipher.encryptBlock(defaultPasswordBytes);
Kode lerroa:       for (j = 0, n = checkData.length; j < n; ++j) {
Kode lerroa:         if (userPassword[j] !== checkData[j]) {
Kode lerroa:           return null;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return encryptionKey;
Kode lerroa:   }
Kode lerroa:   function decodeUserPassword(password, ownerPassword, revision, keyLength) {
Kode lerroa:     var hashData = new Uint8Array(32),
Kode lerroa:         i = 0,
Kode lerroa:         j,
Kode lerroa:         n;
Kode lerroa:     n = Math.min(32, password.length);
Kode lerroa:     for (; i < n; ++i) {
Kode lerroa:       hashData[i] = password[i];
Kode lerroa:     }
Kode lerroa:     j = 0;
Kode lerroa:     while (i < 32) {
Kode lerroa:       hashData[i++] = defaultPasswordBytes[j++];
Kode lerroa:     }
Kode lerroa:     var hash = calculateMD5(hashData, 0, i);
Kode lerroa:     var keyLengthInBytes = keyLength >> 3;
Kode lerroa:     if (revision >= 3) {
Kode lerroa:       for (j = 0; j < 50; ++j) {
Kode lerroa:         hash = calculateMD5(hash, 0, hash.length);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var cipher, userPassword;
Kode lerroa:     if (revision >= 3) {
Kode lerroa:       userPassword = ownerPassword;
Kode lerroa:       var derivedKey = new Uint8Array(keyLengthInBytes),
Kode lerroa:           k;
Kode lerroa:       for (j = 19; j >= 0; j--) {
Kode lerroa:         for (k = 0; k < keyLengthInBytes; ++k) {
Kode lerroa:           derivedKey[k] = hash[k] ^ j;
Kode lerroa:         }
Kode lerroa:         cipher = new ARCFourCipher(derivedKey);
Kode lerroa:         userPassword = cipher.encryptBlock(userPassword);
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
Kode lerroa:       userPassword = cipher.encryptBlock(ownerPassword);
Kode lerroa:     }
Kode lerroa:     return userPassword;
Kode lerroa:   }
Kode lerroa:   var identityName = _primitives.Name.get('Identity');
Kode lerroa:   function CipherTransformFactory(dict, fileId, password) {
Kode lerroa:     var filter = dict.get('Filter');
Kode lerroa:     if (!(0, _primitives.isName)(filter, 'Standard')) {
Kode lerroa:       throw new _util.FormatError('unknown encryption method');
Kode lerroa:     }
Kode lerroa:     this.dict = dict;
Kode lerroa:     var algorithm = dict.get('V');
Kode lerroa:     if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
Kode lerroa:       throw new _util.FormatError('unsupported encryption algorithm');
Kode lerroa:     }
Kode lerroa:     this.algorithm = algorithm;
Kode lerroa:     var keyLength = dict.get('Length');
Kode lerroa:     if (!keyLength) {
Kode lerroa:       if (algorithm <= 3) {
Kode lerroa:         keyLength = 40;
Kode lerroa:       } else {
Kode lerroa:         var cfDict = dict.get('CF');
Kode lerroa:         var streamCryptoName = dict.get('StmF');
Kode lerroa:         if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
Kode lerroa:           cfDict.suppressEncryption = true;
Kode lerroa:           var handlerDict = cfDict.get(streamCryptoName.name);
Kode lerroa:           keyLength = handlerDict && handlerDict.get('Length') || 128;
Kode lerroa:           if (keyLength < 40) {
Kode lerroa:             keyLength <<= 3;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
Kode lerroa:       throw new _util.FormatError('invalid key length');
Kode lerroa:     }
Kode lerroa:     var ownerPassword = (0, _util.stringToBytes)(dict.get('O')).subarray(0, 32);
Kode lerroa:     var userPassword = (0, _util.stringToBytes)(dict.get('U')).subarray(0, 32);
Kode lerroa:     var flags = dict.get('P');
Kode lerroa:     var revision = dict.get('R');
Kode lerroa:     var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get('EncryptMetadata') !== false;
Kode lerroa:     this.encryptMetadata = encryptMetadata;
Kode lerroa:     var fileIdBytes = (0, _util.stringToBytes)(fileId);
Kode lerroa:     var passwordBytes;
Kode lerroa:     if (password) {
Kode lerroa:       if (revision === 6) {
Kode lerroa:         try {
Kode lerroa:           password = (0, _util.utf8StringToString)(password);
Kode lerroa:         } catch (ex) {
Kode lerroa:           (0, _util.warn)('CipherTransformFactory: ' + 'Unable to convert UTF8 encoded password.');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       passwordBytes = (0, _util.stringToBytes)(password);
Kode lerroa:     }
Kode lerroa:     var encryptionKey;
Kode lerroa:     if (algorithm !== 5) {
Kode lerroa:       encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
Kode lerroa:     } else {
Kode lerroa:       var ownerValidationSalt = (0, _util.stringToBytes)(dict.get('O')).subarray(32, 40);
Kode lerroa:       var ownerKeySalt = (0, _util.stringToBytes)(dict.get('O')).subarray(40, 48);
Kode lerroa:       var uBytes = (0, _util.stringToBytes)(dict.get('U')).subarray(0, 48);
Kode lerroa:       var userValidationSalt = (0, _util.stringToBytes)(dict.get('U')).subarray(32, 40);
Kode lerroa:       var userKeySalt = (0, _util.stringToBytes)(dict.get('U')).subarray(40, 48);
Kode lerroa:       var ownerEncryption = (0, _util.stringToBytes)(dict.get('OE'));
Kode lerroa:       var userEncryption = (0, _util.stringToBytes)(dict.get('UE'));
Kode lerroa:       var perms = (0, _util.stringToBytes)(dict.get('Perms'));
Kode lerroa:       encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
Kode lerroa:     }
Kode lerroa:     if (!encryptionKey && !password) {
Kode lerroa:       throw new _util.PasswordException('No password given', _util.PasswordResponses.NEED_PASSWORD);
Kode lerroa:     } else if (!encryptionKey && password) {
Kode lerroa:       var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
Kode lerroa:       encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
Kode lerroa:     }
Kode lerroa:     if (!encryptionKey) {
Kode lerroa:       throw new _util.PasswordException('Incorrect Password', _util.PasswordResponses.INCORRECT_PASSWORD);
Kode lerroa:     }
Kode lerroa:     this.encryptionKey = encryptionKey;
Kode lerroa:     if (algorithm >= 4) {
Kode lerroa:       var cf = dict.get('CF');
Kode lerroa:       if ((0, _primitives.isDict)(cf)) {
Kode lerroa:         cf.suppressEncryption = true;
Kode lerroa:       }
Kode lerroa:       this.cf = cf;
Kode lerroa:       this.stmf = dict.get('StmF') || identityName;
Kode lerroa:       this.strf = dict.get('StrF') || identityName;
Kode lerroa:       this.eff = dict.get('EFF') || this.stmf;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function buildObjectKey(num, gen, encryptionKey, isAes) {
Kode lerroa:     var key = new Uint8Array(encryptionKey.length + 9),
Kode lerroa:         i,
Kode lerroa:         n;
Kode lerroa:     for (i = 0, n = encryptionKey.length; i < n; ++i) {
Kode lerroa:       key[i] = encryptionKey[i];
Kode lerroa:     }
Kode lerroa:     key[i++] = num & 0xFF;
Kode lerroa:     key[i++] = num >> 8 & 0xFF;
Kode lerroa:     key[i++] = num >> 16 & 0xFF;
Kode lerroa:     key[i++] = gen & 0xFF;
Kode lerroa:     key[i++] = gen >> 8 & 0xFF;
Kode lerroa:     if (isAes) {
Kode lerroa:       key[i++] = 0x73;
Kode lerroa:       key[i++] = 0x41;
Kode lerroa:       key[i++] = 0x6C;
Kode lerroa:       key[i++] = 0x54;
Kode lerroa:     }
Kode lerroa:     var hash = calculateMD5(key, 0, i);
Kode lerroa:     return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
Kode lerroa:   }
Kode lerroa:   function buildCipherConstructor(cf, name, num, gen, key) {
Kode lerroa:     if (!(0, _primitives.isName)(name)) {
Kode lerroa:       throw new _util.FormatError('Invalid crypt filter name.');
Kode lerroa:     }
Kode lerroa:     var cryptFilter = cf.get(name.name);
Kode lerroa:     var cfm;
Kode lerroa:     if (cryptFilter !== null && cryptFilter !== undefined) {
Kode lerroa:       cfm = cryptFilter.get('CFM');
Kode lerroa:     }
Kode lerroa:     if (!cfm || cfm.name === 'None') {
Kode lerroa:       return function cipherTransformFactoryBuildCipherConstructorNone() {
Kode lerroa:         return new NullCipher();
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     if (cfm.name === 'V2') {
Kode lerroa:       return function cipherTransformFactoryBuildCipherConstructorV2() {
Kode lerroa:         return new ARCFourCipher(buildObjectKey(num, gen, key, false));
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     if (cfm.name === 'AESV2') {
Kode lerroa:       return function cipherTransformFactoryBuildCipherConstructorAESV2() {
Kode lerroa:         return new AES128Cipher(buildObjectKey(num, gen, key, true));
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     if (cfm.name === 'AESV3') {
Kode lerroa:       return function cipherTransformFactoryBuildCipherConstructorAESV3() {
Kode lerroa:         return new AES256Cipher(key);
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     throw new _util.FormatError('Unknown crypto method');
Kode lerroa:   }
Kode lerroa:   CipherTransformFactory.prototype = {
Kode lerroa:     createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
Kode lerroa:       if (this.algorithm === 4 || this.algorithm === 5) {
Kode lerroa:         return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
Kode lerroa:       }
Kode lerroa:       var key = buildObjectKey(num, gen, this.encryptionKey, false);
Kode lerroa:       var cipherConstructor = function buildCipherCipherConstructor() {
Kode lerroa:         return new ARCFourCipher(key);
Kode lerroa:       };
Kode lerroa:       return new CipherTransform(cipherConstructor, cipherConstructor);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CipherTransformFactory;
Kode lerroa: }();
Kode lerroa: exports.AES128Cipher = AES128Cipher;
Kode lerroa: exports.AES256Cipher = AES256Cipher;
Kode lerroa: exports.ARCFourCipher = ARCFourCipher;
Kode lerroa: exports.CipherTransformFactory = CipherTransformFactory;
Kode lerroa: exports.PDF17 = PDF17;
Kode lerroa: exports.PDF20 = PDF20;
Kode lerroa: exports.calculateMD5 = calculateMD5;
Kode lerroa: exports.calculateSHA256 = calculateSHA256;
Kode lerroa: exports.calculateSHA384 = calculateSHA384;
Kode lerroa: exports.calculateSHA512 = calculateSHA512;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 77 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PartialEvaluator = exports.OperatorList = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _cmap = __w_pdfjs_require__(134);
Kode lerroa: 
Kode lerroa: var _stream = __w_pdfjs_require__(5);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var _fonts = __w_pdfjs_require__(135);
Kode lerroa: 
Kode lerroa: var _encodings = __w_pdfjs_require__(28);
Kode lerroa: 
Kode lerroa: var _unicode = __w_pdfjs_require__(80);
Kode lerroa: 
Kode lerroa: var _standard_fonts = __w_pdfjs_require__(79);
Kode lerroa: 
Kode lerroa: var _pattern = __w_pdfjs_require__(139);
Kode lerroa: 
Kode lerroa: var _parser = __w_pdfjs_require__(34);
Kode lerroa: 
Kode lerroa: var _bidi = __w_pdfjs_require__(140);
Kode lerroa: 
Kode lerroa: var _colorspace = __w_pdfjs_require__(27);
Kode lerroa: 
Kode lerroa: var _glyphlist = __w_pdfjs_require__(47);
Kode lerroa: 
Kode lerroa: var _metrics = __w_pdfjs_require__(141);
Kode lerroa: 
Kode lerroa: var _function = __w_pdfjs_require__(81);
Kode lerroa: 
Kode lerroa: var _murmurhash = __w_pdfjs_require__(143);
Kode lerroa: 
Kode lerroa: var _image = __w_pdfjs_require__(144);
Kode lerroa: 
Kode lerroa: var PartialEvaluator = function PartialEvaluatorClosure() {
Kode lerroa:   var DefaultPartialEvaluatorOptions = {
Kode lerroa:     forceDataSchema: false,
Kode lerroa:     maxImageSize: -1,
Kode lerroa:     disableFontFace: false,
Kode lerroa:     nativeImageDecoderSupport: _util.NativeImageDecoding.DECODE,
Kode lerroa:     ignoreErrors: false,
Kode lerroa:     isEvalSupported: true
Kode lerroa:   };
Kode lerroa:   function NativeImageDecoder(_ref) {
Kode lerroa:     var xref = _ref.xref,
Kode lerroa:         resources = _ref.resources,
Kode lerroa:         handler = _ref.handler,
Kode lerroa:         _ref$forceDataSchema = _ref.forceDataSchema,
Kode lerroa:         forceDataSchema = _ref$forceDataSchema === undefined ? false : _ref$forceDataSchema,
Kode lerroa:         pdfFunctionFactory = _ref.pdfFunctionFactory;
Kode lerroa: 
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.resources = resources;
Kode lerroa:     this.handler = handler;
Kode lerroa:     this.forceDataSchema = forceDataSchema;
Kode lerroa:     this.pdfFunctionFactory = pdfFunctionFactory;
Kode lerroa:   }
Kode lerroa:   NativeImageDecoder.prototype = {
Kode lerroa:     canDecode: function canDecode(image) {
Kode lerroa:       return image instanceof _stream.JpegStream && NativeImageDecoder.isDecodable(image, this.xref, this.resources, this.pdfFunctionFactory);
Kode lerroa:     },
Kode lerroa:     decode: function decode(image) {
Kode lerroa:       var dict = image.dict;
Kode lerroa:       var colorSpace = dict.get('ColorSpace', 'CS');
Kode lerroa:       colorSpace = _colorspace.ColorSpace.parse(colorSpace, this.xref, this.resources, this.pdfFunctionFactory);
Kode lerroa:       var numComps = colorSpace.numComps;
Kode lerroa:       var decodePromise = this.handler.sendWithPromise('JpegDecode', [image.getIR(this.forceDataSchema), numComps]);
Kode lerroa:       return decodePromise.then(function (message) {
Kode lerroa:         var data = message.data;
Kode lerroa:         return new _stream.Stream(data, 0, data.length, image.dict);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   NativeImageDecoder.isSupported = function (image, xref, res, pdfFunctionFactory) {
Kode lerroa:     var dict = image.dict;
Kode lerroa:     if (dict.has('DecodeParms') || dict.has('DP')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     var cs = _colorspace.ColorSpace.parse(dict.get('ColorSpace', 'CS'), xref, res, pdfFunctionFactory);
Kode lerroa:     return (cs.name === 'DeviceGray' || cs.name === 'DeviceRGB') && cs.isDefaultDecode(dict.getArray('Decode', 'D'));
Kode lerroa:   };
Kode lerroa:   NativeImageDecoder.isDecodable = function (image, xref, res, pdfFunctionFactory) {
Kode lerroa:     var dict = image.dict;
Kode lerroa:     if (dict.has('DecodeParms') || dict.has('DP')) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     var cs = _colorspace.ColorSpace.parse(dict.get('ColorSpace', 'CS'), xref, res, pdfFunctionFactory);
Kode lerroa:     return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(dict.getArray('Decode', 'D'));
Kode lerroa:   };
Kode lerroa:   function PartialEvaluator(_ref2) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var pdfManager = _ref2.pdfManager,
Kode lerroa:         xref = _ref2.xref,
Kode lerroa:         handler = _ref2.handler,
Kode lerroa:         pageIndex = _ref2.pageIndex,
Kode lerroa:         idFactory = _ref2.idFactory,
Kode lerroa:         fontCache = _ref2.fontCache,
Kode lerroa:         builtInCMapCache = _ref2.builtInCMapCache,
Kode lerroa:         _ref2$options = _ref2.options,
Kode lerroa:         options = _ref2$options === undefined ? null : _ref2$options,
Kode lerroa:         pdfFunctionFactory = _ref2.pdfFunctionFactory;
Kode lerroa: 
Kode lerroa:     this.pdfManager = pdfManager;
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.handler = handler;
Kode lerroa:     this.pageIndex = pageIndex;
Kode lerroa:     this.idFactory = idFactory;
Kode lerroa:     this.fontCache = fontCache;
Kode lerroa:     this.builtInCMapCache = builtInCMapCache;
Kode lerroa:     this.options = options || DefaultPartialEvaluatorOptions;
Kode lerroa:     this.pdfFunctionFactory = pdfFunctionFactory;
Kode lerroa:     this.fetchBuiltInCMap = function (name) {
Kode lerroa:       var cachedCMap = _this.builtInCMapCache[name];
Kode lerroa:       if (cachedCMap) {
Kode lerroa:         return Promise.resolve(cachedCMap);
Kode lerroa:       }
Kode lerroa:       return _this.handler.sendWithPromise('FetchBuiltInCMap', { name: name }).then(function (data) {
Kode lerroa:         if (data.compressionType !== _util.CMapCompressionType.NONE) {
Kode lerroa:           _this.builtInCMapCache[name] = data;
Kode lerroa:         }
Kode lerroa:         return data;
Kode lerroa:       });
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   var TIME_SLOT_DURATION_MS = 20;
Kode lerroa:   var CHECK_TIME_EVERY = 100;
Kode lerroa:   function TimeSlotManager() {
Kode lerroa:     this.reset();
Kode lerroa:   }
Kode lerroa:   TimeSlotManager.prototype = {
Kode lerroa:     check: function TimeSlotManager_check() {
Kode lerroa:       if (++this.checked < CHECK_TIME_EVERY) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       this.checked = 0;
Kode lerroa:       return this.endTime <= Date.now();
Kode lerroa:     },
Kode lerroa:     reset: function TimeSlotManager_reset() {
Kode lerroa:       this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
Kode lerroa:       this.checked = 0;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   function normalizeBlendMode(value) {
Kode lerroa:     if (!(0, _primitives.isName)(value)) {
Kode lerroa:       return 'source-over';
Kode lerroa:     }
Kode lerroa:     switch (value.name) {
Kode lerroa:       case 'Normal':
Kode lerroa:       case 'Compatible':
Kode lerroa:         return 'source-over';
Kode lerroa:       case 'Multiply':
Kode lerroa:         return 'multiply';
Kode lerroa:       case 'Screen':
Kode lerroa:         return 'screen';
Kode lerroa:       case 'Overlay':
Kode lerroa:         return 'overlay';
Kode lerroa:       case 'Darken':
Kode lerroa:         return 'darken';
Kode lerroa:       case 'Lighten':
Kode lerroa:         return 'lighten';
Kode lerroa:       case 'ColorDodge':
Kode lerroa:         return 'color-dodge';
Kode lerroa:       case 'ColorBurn':
Kode lerroa:         return 'color-burn';
Kode lerroa:       case 'HardLight':
Kode lerroa:         return 'hard-light';
Kode lerroa:       case 'SoftLight':
Kode lerroa:         return 'soft-light';
Kode lerroa:       case 'Difference':
Kode lerroa:         return 'difference';
Kode lerroa:       case 'Exclusion':
Kode lerroa:         return 'exclusion';
Kode lerroa:       case 'Hue':
Kode lerroa:         return 'hue';
Kode lerroa:       case 'Saturation':
Kode lerroa:         return 'saturation';
Kode lerroa:       case 'Color':
Kode lerroa:         return 'color';
Kode lerroa:       case 'Luminosity':
Kode lerroa:         return 'luminosity';
Kode lerroa:     }
Kode lerroa:     (0, _util.warn)('Unsupported blend mode: ' + value.name);
Kode lerroa:     return 'source-over';
Kode lerroa:   }
Kode lerroa:   var deferred = Promise.resolve();
Kode lerroa:   var TILING_PATTERN = 1,
Kode lerroa:       SHADING_PATTERN = 2;
Kode lerroa:   PartialEvaluator.prototype = {
Kode lerroa:     clone: function clone() {
Kode lerroa:       var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultPartialEvaluatorOptions;
Kode lerroa: 
Kode lerroa:       var newEvaluator = Object.create(this);
Kode lerroa:       newEvaluator.options = newOptions;
Kode lerroa:       return newEvaluator;
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
Kode lerroa:       if (!(0, _primitives.isDict)(resources)) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       var processed = Object.create(null);
Kode lerroa:       if (resources.objId) {
Kode lerroa:         processed[resources.objId] = true;
Kode lerroa:       }
Kode lerroa:       var nodes = [resources],
Kode lerroa:           xref = this.xref;
Kode lerroa:       while (nodes.length) {
Kode lerroa:         var key, i, ii;
Kode lerroa:         var node = nodes.shift();
Kode lerroa:         var graphicStates = node.get('ExtGState');
Kode lerroa:         if ((0, _primitives.isDict)(graphicStates)) {
Kode lerroa:           var graphicStatesKeys = graphicStates.getKeys();
Kode lerroa:           for (i = 0, ii = graphicStatesKeys.length; i < ii; i++) {
Kode lerroa:             key = graphicStatesKeys[i];
Kode lerroa:             var graphicState = graphicStates.get(key);
Kode lerroa:             var bm = graphicState.get('BM');
Kode lerroa:             if ((0, _primitives.isName)(bm) && bm.name !== 'Normal') {
Kode lerroa:               return true;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         var xObjects = node.get('XObject');
Kode lerroa:         if (!(0, _primitives.isDict)(xObjects)) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var xObjectsKeys = xObjects.getKeys();
Kode lerroa:         for (i = 0, ii = xObjectsKeys.length; i < ii; i++) {
Kode lerroa:           key = xObjectsKeys[i];
Kode lerroa:           var xObject = xObjects.getRaw(key);
Kode lerroa:           if ((0, _primitives.isRef)(xObject)) {
Kode lerroa:             if (processed[xObject.toString()]) {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             xObject = xref.fetch(xObject);
Kode lerroa:           }
Kode lerroa:           if (!(0, _primitives.isStream)(xObject)) {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           if (xObject.dict.objId) {
Kode lerroa:             if (processed[xObject.dict.objId]) {
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:             processed[xObject.dict.objId] = true;
Kode lerroa:           }
Kode lerroa:           var xResources = xObject.dict.get('Resources');
Kode lerroa:           if ((0, _primitives.isDict)(xResources) && (!xResources.objId || !processed[xResources.objId])) {
Kode lerroa:             nodes.push(xResources);
Kode lerroa:             if (xResources.objId) {
Kode lerroa:               processed[xResources.objId] = true;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return false;
Kode lerroa:     },
Kode lerroa:     buildFormXObject: function PartialEvaluator_buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
Kode lerroa:       var dict = xobj.dict;
Kode lerroa:       var matrix = dict.getArray('Matrix');
Kode lerroa:       var bbox = dict.getArray('BBox');
Kode lerroa:       var group = dict.get('Group');
Kode lerroa:       if (group) {
Kode lerroa:         var groupOptions = {
Kode lerroa:           matrix: matrix,
Kode lerroa:           bbox: bbox,
Kode lerroa:           smask: smask,
Kode lerroa:           isolated: false,
Kode lerroa:           knockout: false
Kode lerroa:         };
Kode lerroa:         var groupSubtype = group.get('S');
Kode lerroa:         var colorSpace = null;
Kode lerroa:         if ((0, _primitives.isName)(groupSubtype, 'Transparency')) {
Kode lerroa:           groupOptions.isolated = group.get('I') || false;
Kode lerroa:           groupOptions.knockout = group.get('K') || false;
Kode lerroa:           if (group.has('CS')) {
Kode lerroa:             colorSpace = _colorspace.ColorSpace.parse(group.get('CS'), this.xref, resources, this.pdfFunctionFactory);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (smask && smask.backdrop) {
Kode lerroa:           colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
Kode lerroa:           smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
Kode lerroa:         }
Kode lerroa:         operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
Kode lerroa:       }
Kode lerroa:       operatorList.addOp(_util.OPS.paintFormXObjectBegin, [matrix, bbox]);
Kode lerroa:       return this.getOperatorList({
Kode lerroa:         stream: xobj,
Kode lerroa:         task: task,
Kode lerroa:         resources: dict.get('Resources') || resources,
Kode lerroa:         operatorList: operatorList,
Kode lerroa:         initialState: initialState
Kode lerroa:       }).then(function () {
Kode lerroa:         operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
Kode lerroa:         if (group) {
Kode lerroa:           operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     buildPaintImageXObject: function PartialEvaluator_buildPaintImageXObject(resources, image, inline, operatorList, cacheKey, imageCache) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var dict = image.dict;
Kode lerroa:       var w = dict.get('Width', 'W');
Kode lerroa:       var h = dict.get('Height', 'H');
Kode lerroa:       if (!(w && (0, _util.isNum)(w)) || !(h && (0, _util.isNum)(h))) {
Kode lerroa:         (0, _util.warn)('Image dimensions are missing, or not numbers.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var maxImageSize = this.options.maxImageSize;
Kode lerroa:       if (maxImageSize !== -1 && w * h > maxImageSize) {
Kode lerroa:         (0, _util.warn)('Image exceeded maximum allowed size and was removed.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var imageMask = dict.get('ImageMask', 'IM') || false;
Kode lerroa:       var imgData, args;
Kode lerroa:       if (imageMask) {
Kode lerroa:         var width = dict.get('Width', 'W');
Kode lerroa:         var height = dict.get('Height', 'H');
Kode lerroa:         var bitStrideLength = width + 7 >> 3;
Kode lerroa:         var imgArray = image.getBytes(bitStrideLength * height);
Kode lerroa:         var decode = dict.getArray('Decode', 'D');
Kode lerroa:         imgData = _image.PDFImage.createMask({
Kode lerroa:           imgArray: imgArray,
Kode lerroa:           width: width,
Kode lerroa:           height: height,
Kode lerroa:           imageIsFromDecodeStream: image instanceof _stream.DecodeStream,
Kode lerroa:           inverseDecode: !!decode && decode[0] > 0
Kode lerroa:         });
Kode lerroa:         imgData.cached = true;
Kode lerroa:         args = [imgData];
Kode lerroa:         operatorList.addOp(_util.OPS.paintImageMaskXObject, args);
Kode lerroa:         if (cacheKey) {
Kode lerroa:           imageCache[cacheKey] = {
Kode lerroa:             fn: _util.OPS.paintImageMaskXObject,
Kode lerroa:             args: args
Kode lerroa:           };
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var softMask = dict.get('SMask', 'SM') || false;
Kode lerroa:       var mask = dict.get('Mask') || false;
Kode lerroa:       var SMALL_IMAGE_DIMENSIONS = 200;
Kode lerroa:       if (inline && !softMask && !mask && !(image instanceof _stream.JpegStream) && w + h < SMALL_IMAGE_DIMENSIONS) {
Kode lerroa:         var imageObj = new _image.PDFImage({
Kode lerroa:           xref: this.xref,
Kode lerroa:           res: resources,
Kode lerroa:           image: image,
Kode lerroa:           pdfFunctionFactory: this.pdfFunctionFactory
Kode lerroa:         });
Kode lerroa:         imgData = imageObj.createImageData(true);
Kode lerroa:         operatorList.addOp(_util.OPS.paintInlineImageXObject, [imgData]);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var nativeImageDecoderSupport = this.options.nativeImageDecoderSupport;
Kode lerroa:       var objId = 'img_' + this.idFactory.createObjId();
Kode lerroa:       operatorList.addDependency(objId);
Kode lerroa:       args = [objId, w, h];
Kode lerroa:       if (nativeImageDecoderSupport !== _util.NativeImageDecoding.NONE && !softMask && !mask && image instanceof _stream.JpegStream && NativeImageDecoder.isSupported(image, this.xref, resources, this.pdfFunctionFactory)) {
Kode lerroa:         operatorList.addOp(_util.OPS.paintJpegXObject, args);
Kode lerroa:         this.handler.send('obj', [objId, this.pageIndex, 'JpegStream', image.getIR(this.options.forceDataSchema)]);
Kode lerroa:         if (cacheKey) {
Kode lerroa:           imageCache[cacheKey] = {
Kode lerroa:             fn: _util.OPS.paintJpegXObject,
Kode lerroa:             args: args
Kode lerroa:           };
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var nativeImageDecoder = null;
Kode lerroa:       if (nativeImageDecoderSupport === _util.NativeImageDecoding.DECODE && (image instanceof _stream.JpegStream || mask instanceof _stream.JpegStream || softMask instanceof _stream.JpegStream)) {
Kode lerroa:         nativeImageDecoder = new NativeImageDecoder({
Kode lerroa:           xref: this.xref,
Kode lerroa:           resources: resources,
Kode lerroa:           handler: this.handler,
Kode lerroa:           forceDataSchema: this.options.forceDataSchema,
Kode lerroa:           pdfFunctionFactory: this.pdfFunctionFactory
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       _image.PDFImage.buildImage({
Kode lerroa:         handler: this.handler,
Kode lerroa:         xref: this.xref,
Kode lerroa:         res: resources,
Kode lerroa:         image: image,
Kode lerroa:         nativeDecoder: nativeImageDecoder,
Kode lerroa:         pdfFunctionFactory: this.pdfFunctionFactory
Kode lerroa:       }).then(function (imageObj) {
Kode lerroa:         var imgData = imageObj.createImageData(false);
Kode lerroa:         _this2.handler.send('obj', [objId, _this2.pageIndex, 'Image', imgData], [imgData.data.buffer]);
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         (0, _util.warn)('Unable to decode image: ' + reason);
Kode lerroa:         _this2.handler.send('obj', [objId, _this2.pageIndex, 'Image', null]);
Kode lerroa:       });
Kode lerroa:       operatorList.addOp(_util.OPS.paintImageXObject, args);
Kode lerroa:       if (cacheKey) {
Kode lerroa:         imageCache[cacheKey] = {
Kode lerroa:           fn: _util.OPS.paintImageXObject,
Kode lerroa:           args: args
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
Kode lerroa:       var smaskContent = smask.get('G');
Kode lerroa:       var smaskOptions = {
Kode lerroa:         subtype: smask.get('S').name,
Kode lerroa:         backdrop: smask.get('BC')
Kode lerroa:       };
Kode lerroa:       var transferObj = smask.get('TR');
Kode lerroa:       if ((0, _function.isPDFFunction)(transferObj)) {
Kode lerroa:         var transferFn = this.pdfFunctionFactory.create(transferObj);
Kode lerroa:         var transferMap = new Uint8Array(256);
Kode lerroa:         var tmp = new Float32Array(1);
Kode lerroa:         for (var i = 0; i < 256; i++) {
Kode lerroa:           tmp[0] = i / 255;
Kode lerroa:           transferFn(tmp, 0, tmp, 0);
Kode lerroa:           transferMap[i] = tmp[0] * 255 | 0;
Kode lerroa:         }
Kode lerroa:         smaskOptions.transferMap = transferMap;
Kode lerroa:       }
Kode lerroa:       return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
Kode lerroa:     },
Kode lerroa:     handleTilingType: function handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       var tilingOpList = new OperatorList();
Kode lerroa:       var resourcesArray = [patternDict.get('Resources'), resources];
Kode lerroa:       var patternResources = _primitives.Dict.merge(this.xref, resourcesArray);
Kode lerroa:       return this.getOperatorList({
Kode lerroa:         stream: pattern,
Kode lerroa:         task: task,
Kode lerroa:         resources: patternResources,
Kode lerroa:         operatorList: tilingOpList
Kode lerroa:       }).then(function () {
Kode lerroa:         return (0, _pattern.getTilingPatternIR)({
Kode lerroa:           fnArray: tilingOpList.fnArray,
Kode lerroa:           argsArray: tilingOpList.argsArray
Kode lerroa:         }, patternDict, args);
Kode lerroa:       }).then(function (tilingPatternIR) {
Kode lerroa:         operatorList.addDependencies(tilingOpList.dependencies);
Kode lerroa:         operatorList.addOp(fn, tilingPatternIR);
Kode lerroa:       }, function (reason) {
Kode lerroa:         if (_this3.options.ignoreErrors) {
Kode lerroa:           _this3.handler.send('UnsupportedFeature', { featureId: _util.UNSUPPORTED_FEATURES.unknown });
Kode lerroa:           (0, _util.warn)('handleTilingType - ignoring pattern: "' + reason + '".');
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         throw reason;
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       var fontName;
Kode lerroa:       if (fontArgs) {
Kode lerroa:         fontArgs = fontArgs.slice();
Kode lerroa:         fontName = fontArgs[0].name;
Kode lerroa:       }
Kode lerroa:       return this.loadFont(fontName, fontRef, resources).then(function (translated) {
Kode lerroa:         if (!translated.font.isType3Font) {
Kode lerroa:           return translated;
Kode lerroa:         }
Kode lerroa:         return translated.loadType3Data(_this4, resources, operatorList, task).then(function () {
Kode lerroa:           return translated;
Kode lerroa:         }).catch(function (reason) {
Kode lerroa:           _this4.handler.send('UnsupportedFeature', { featureId: _util.UNSUPPORTED_FEATURES.font });
Kode lerroa:           return new TranslatedFont('g_font_error', new _fonts.ErrorFont('Type3 font load error: ' + reason), translated.font);
Kode lerroa:         });
Kode lerroa:       }).then(function (translated) {
Kode lerroa:         state.font = translated.font;
Kode lerroa:         translated.send(_this4.handler);
Kode lerroa:         return translated.loadedName;
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     handleText: function PartialEvaluator_handleText(chars, state) {
Kode lerroa:       var _this5 = this;
Kode lerroa: 
Kode lerroa:       var font = state.font;
Kode lerroa:       var glyphs = font.charsToGlyphs(chars);
Kode lerroa:       var isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
Kode lerroa:       if (font.data && (isAddToPathSet || this.options.disableFontFace)) {
Kode lerroa:         var buildPath = function buildPath(fontChar) {
Kode lerroa:           if (!font.renderer.hasBuiltPath(fontChar)) {
Kode lerroa:             var path = font.renderer.getPathJs(fontChar);
Kode lerroa:             _this5.handler.send('commonobj', [font.loadedName + '_path_' + fontChar, 'FontPath', path]);
Kode lerroa:           }
Kode lerroa:         };
Kode lerroa:         for (var i = 0, ii = glyphs.length; i < ii; i++) {
Kode lerroa:           var glyph = glyphs[i];
Kode lerroa:           buildPath(glyph.fontChar);
Kode lerroa:           var accent = glyph.accent;
Kode lerroa:           if (accent && accent.fontChar) {
Kode lerroa:             buildPath(accent.fontChar);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return glyphs;
Kode lerroa:     },
Kode lerroa:     setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, stateManager) {
Kode lerroa:       var _this6 = this;
Kode lerroa: 
Kode lerroa:       var gStateObj = [];
Kode lerroa:       var gStateKeys = gState.getKeys();
Kode lerroa:       var promise = Promise.resolve();
Kode lerroa: 
Kode lerroa:       var _loop = function _loop() {
Kode lerroa:         var key = gStateKeys[i];
Kode lerroa:         var value = gState.get(key);
Kode lerroa:         switch (key) {
Kode lerroa:           case 'Type':
Kode lerroa:             break;
Kode lerroa:           case 'LW':
Kode lerroa:           case 'LC':
Kode lerroa:           case 'LJ':
Kode lerroa:           case 'ML':
Kode lerroa:           case 'D':
Kode lerroa:           case 'RI':
Kode lerroa:           case 'FL':
Kode lerroa:           case 'CA':
Kode lerroa:           case 'ca':
Kode lerroa:             gStateObj.push([key, value]);
Kode lerroa:             break;
Kode lerroa:           case 'Font':
Kode lerroa:             promise = promise.then(function () {
Kode lerroa:               return _this6.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) {
Kode lerroa:                 operatorList.addDependency(loadedName);
Kode lerroa:                 gStateObj.push([key, [loadedName, value[1]]]);
Kode lerroa:               });
Kode lerroa:             });
Kode lerroa:             break;
Kode lerroa:           case 'BM':
Kode lerroa:             gStateObj.push([key, normalizeBlendMode(value)]);
Kode lerroa:             break;
Kode lerroa:           case 'SMask':
Kode lerroa:             if ((0, _primitives.isName)(value, 'None')) {
Kode lerroa:               gStateObj.push([key, false]);
Kode lerroa:               break;
Kode lerroa:             }
Kode lerroa:             if ((0, _primitives.isDict)(value)) {
Kode lerroa:               promise = promise.then(function () {
Kode lerroa:                 return _this6.handleSMask(value, resources, operatorList, task, stateManager);
Kode lerroa:               });
Kode lerroa:               gStateObj.push([key, true]);
Kode lerroa:             } else {
Kode lerroa:               (0, _util.warn)('Unsupported SMask type');
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'OP':
Kode lerroa:           case 'op':
Kode lerroa:           case 'OPM':
Kode lerroa:           case 'BG':
Kode lerroa:           case 'BG2':
Kode lerroa:           case 'UCR':
Kode lerroa:           case 'UCR2':
Kode lerroa:           case 'TR':
Kode lerroa:           case 'TR2':
Kode lerroa:           case 'HT':
Kode lerroa:           case 'SM':
Kode lerroa:           case 'SA':
Kode lerroa:           case 'AIS':
Kode lerroa:           case 'TK':
Kode lerroa:             (0, _util.info)('graphic state operator ' + key);
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             (0, _util.info)('Unknown graphic state operator ' + key);
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa: 
Kode lerroa:       for (var i = 0, ii = gStateKeys.length; i < ii; i++) {
Kode lerroa:         _loop();
Kode lerroa:       }
Kode lerroa:       return promise.then(function () {
Kode lerroa:         if (gStateObj.length > 0) {
Kode lerroa:           operatorList.addOp(_util.OPS.setGState, [gStateObj]);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     loadFont: function PartialEvaluator_loadFont(fontName, font, resources) {
Kode lerroa:       var _this7 = this;
Kode lerroa: 
Kode lerroa:       function errorFont() {
Kode lerroa:         return Promise.resolve(new TranslatedFont('g_font_error', new _fonts.ErrorFont('Font ' + fontName + ' is not available'), font));
Kode lerroa:       }
Kode lerroa:       var fontRef,
Kode lerroa:           xref = this.xref;
Kode lerroa:       if (font) {
Kode lerroa:         if (!(0, _primitives.isRef)(font)) {
Kode lerroa:           throw new Error('The "font" object should be a reference.');
Kode lerroa:         }
Kode lerroa:         fontRef = font;
Kode lerroa:       } else {
Kode lerroa:         var fontRes = resources.get('Font');
Kode lerroa:         if (fontRes) {
Kode lerroa:           fontRef = fontRes.getRaw(fontName);
Kode lerroa:         } else {
Kode lerroa:           (0, _util.warn)('fontRes not available');
Kode lerroa:           return errorFont();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (!fontRef) {
Kode lerroa:         (0, _util.warn)('fontRef not available');
Kode lerroa:         return errorFont();
Kode lerroa:       }
Kode lerroa:       if (this.fontCache.has(fontRef)) {
Kode lerroa:         return this.fontCache.get(fontRef);
Kode lerroa:       }
Kode lerroa:       font = xref.fetchIfRef(fontRef);
Kode lerroa:       if (!(0, _primitives.isDict)(font)) {
Kode lerroa:         return errorFont();
Kode lerroa:       }
Kode lerroa:       if (font.translated) {
Kode lerroa:         return font.translated;
Kode lerroa:       }
Kode lerroa:       var fontCapability = (0, _util.createPromiseCapability)();
Kode lerroa:       var preEvaluatedFont = this.preEvaluateFont(font);
Kode lerroa:       var descriptor = preEvaluatedFont.descriptor;
Kode lerroa:       var fontRefIsRef = (0, _primitives.isRef)(fontRef),
Kode lerroa:           fontID;
Kode lerroa:       if (fontRefIsRef) {
Kode lerroa:         fontID = fontRef.toString();
Kode lerroa:       }
Kode lerroa:       if ((0, _primitives.isDict)(descriptor)) {
Kode lerroa:         if (!descriptor.fontAliases) {
Kode lerroa:           descriptor.fontAliases = Object.create(null);
Kode lerroa:         }
Kode lerroa:         var fontAliases = descriptor.fontAliases;
Kode lerroa:         var hash = preEvaluatedFont.hash;
Kode lerroa:         if (fontAliases[hash]) {
Kode lerroa:           var aliasFontRef = fontAliases[hash].aliasRef;
Kode lerroa:           if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
Kode lerroa:             this.fontCache.putAlias(fontRef, aliasFontRef);
Kode lerroa:             return this.fontCache.get(fontRef);
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           fontAliases[hash] = { fontID: _fonts.Font.getFontID() };
Kode lerroa:         }
Kode lerroa:         if (fontRefIsRef) {
Kode lerroa:           fontAliases[hash].aliasRef = fontRef;
Kode lerroa:         }
Kode lerroa:         fontID = fontAliases[hash].fontID;
Kode lerroa:       }
Kode lerroa:       if (fontRefIsRef) {
Kode lerroa:         this.fontCache.put(fontRef, fontCapability.promise);
Kode lerroa:       } else {
Kode lerroa:         if (!fontID) {
Kode lerroa:           fontID = this.idFactory.createObjId();
Kode lerroa:         }
Kode lerroa:         this.fontCache.put('id_' + fontID, fontCapability.promise);
Kode lerroa:       }
Kode lerroa:       (0, _util.assert)(fontID, 'The "fontID" must be defined.');
Kode lerroa:       font.loadedName = 'g_' + this.pdfManager.docId + '_f' + fontID;
Kode lerroa:       font.translated = fontCapability.promise;
Kode lerroa:       var translatedPromise;
Kode lerroa:       try {
Kode lerroa:         translatedPromise = this.translateFont(preEvaluatedFont);
Kode lerroa:       } catch (e) {
Kode lerroa:         translatedPromise = Promise.reject(e);
Kode lerroa:       }
Kode lerroa:       translatedPromise.then(function (translatedFont) {
Kode lerroa:         if (translatedFont.fontType !== undefined) {
Kode lerroa:           var xrefFontStats = xref.stats.fontTypes;
Kode lerroa:           xrefFontStats[translatedFont.fontType] = true;
Kode lerroa:         }
Kode lerroa:         fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         _this7.handler.send('UnsupportedFeature', { featureId: _util.UNSUPPORTED_FEATURES.font });
Kode lerroa:         try {
Kode lerroa:           var descriptor = preEvaluatedFont.descriptor;
Kode lerroa:           var fontFile3 = descriptor && descriptor.get('FontFile3');
Kode lerroa:           var subtype = fontFile3 && fontFile3.get('Subtype');
Kode lerroa:           var fontType = (0, _fonts.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
Kode lerroa:           var xrefFontStats = xref.stats.fontTypes;
Kode lerroa:           xrefFontStats[fontType] = true;
Kode lerroa:         } catch (ex) {}
Kode lerroa:         fontCapability.resolve(new TranslatedFont(font.loadedName, new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason), font));
Kode lerroa:       });
Kode lerroa:       return fontCapability.promise;
Kode lerroa:     },
Kode lerroa:     buildPath: function PartialEvaluator_buildPath(operatorList, fn, args) {
Kode lerroa:       var lastIndex = operatorList.length - 1;
Kode lerroa:       if (!args) {
Kode lerroa:         args = [];
Kode lerroa:       }
Kode lerroa:       if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
Kode lerroa:         operatorList.addOp(_util.OPS.constructPath, [[fn], args]);
Kode lerroa:       } else {
Kode lerroa:         var opArgs = operatorList.argsArray[lastIndex];
Kode lerroa:         opArgs[0].push(fn);
Kode lerroa:         Array.prototype.push.apply(opArgs[1], args);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     handleColorN: function PartialEvaluator_handleColorN(operatorList, fn, args, cs, patterns, resources, task) {
Kode lerroa:       var patternName = args[args.length - 1];
Kode lerroa:       var pattern;
Kode lerroa:       if ((0, _primitives.isName)(patternName) && (pattern = patterns.get(patternName.name))) {
Kode lerroa:         var dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
Kode lerroa:         var typeNum = dict.get('PatternType');
Kode lerroa:         if (typeNum === TILING_PATTERN) {
Kode lerroa:           var color = cs.base ? cs.base.getRgb(args, 0) : null;
Kode lerroa:           return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
Kode lerroa:         } else if (typeNum === SHADING_PATTERN) {
Kode lerroa:           var shading = dict.get('Shading');
Kode lerroa:           var matrix = dict.getArray('Matrix');
Kode lerroa:           pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this.pdfFunctionFactory);
Kode lerroa:           operatorList.addOp(fn, pattern.getIR());
Kode lerroa:           return Promise.resolve();
Kode lerroa:         }
Kode lerroa:         return Promise.reject(new Error('Unknown PatternType: ' + typeNum));
Kode lerroa:       }
Kode lerroa:       operatorList.addOp(fn, args);
Kode lerroa:       return Promise.resolve();
Kode lerroa:     },
Kode lerroa:     getOperatorList: function getOperatorList(_ref3) {
Kode lerroa:       var _this8 = this;
Kode lerroa: 
Kode lerroa:       var stream = _ref3.stream,
Kode lerroa:           task = _ref3.task,
Kode lerroa:           resources = _ref3.resources,
Kode lerroa:           operatorList = _ref3.operatorList,
Kode lerroa:           _ref3$initialState = _ref3.initialState,
Kode lerroa:           initialState = _ref3$initialState === undefined ? null : _ref3$initialState;
Kode lerroa: 
Kode lerroa:       resources = resources || _primitives.Dict.empty;
Kode lerroa:       initialState = initialState || new EvalState();
Kode lerroa:       if (!operatorList) {
Kode lerroa:         throw new Error('getOperatorList: missing "operatorList" parameter');
Kode lerroa:       }
Kode lerroa:       var self = this;
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var imageCache = Object.create(null);
Kode lerroa:       var xobjs = resources.get('XObject') || _primitives.Dict.empty;
Kode lerroa:       var patterns = resources.get('Pattern') || _primitives.Dict.empty;
Kode lerroa:       var stateManager = new StateManager(initialState);
Kode lerroa:       var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
Kode lerroa:       var timeSlotManager = new TimeSlotManager();
Kode lerroa:       function closePendingRestoreOPS(argument) {
Kode lerroa:         for (var i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
Kode lerroa:           operatorList.addOp(_util.OPS.restore, []);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return new Promise(function promiseBody(resolve, reject) {
Kode lerroa:         var next = function next(promise) {
Kode lerroa:           promise.then(function () {
Kode lerroa:             try {
Kode lerroa:               promiseBody(resolve, reject);
Kode lerroa:             } catch (ex) {
Kode lerroa:               reject(ex);
Kode lerroa:             }
Kode lerroa:           }, reject);
Kode lerroa:         };
Kode lerroa:         task.ensureNotTerminated();
Kode lerroa:         timeSlotManager.reset();
Kode lerroa:         var stop,
Kode lerroa:             operation = {},
Kode lerroa:             i,
Kode lerroa:             ii,
Kode lerroa:             cs;
Kode lerroa:         while (!(stop = timeSlotManager.check())) {
Kode lerroa:           operation.args = null;
Kode lerroa:           if (!preprocessor.read(operation)) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           var args = operation.args;
Kode lerroa:           var fn = operation.fn;
Kode lerroa:           switch (fn | 0) {
Kode lerroa:             case _util.OPS.paintXObject:
Kode lerroa:               var name = args[0].name;
Kode lerroa:               if (name && imageCache[name] !== undefined) {
Kode lerroa:                 operatorList.addOp(imageCache[name].fn, imageCache[name].args);
Kode lerroa:                 args = null;
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               next(new Promise(function (resolveXObject, rejectXObject) {
Kode lerroa:                 if (!name) {
Kode lerroa:                   throw new _util.FormatError('XObject must be referred to by name.');
Kode lerroa:                 }
Kode lerroa:                 var xobj = xobjs.get(name);
Kode lerroa:                 if (!xobj) {
Kode lerroa:                   operatorList.addOp(fn, args);
Kode lerroa:                   resolveXObject();
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 if (!(0, _primitives.isStream)(xobj)) {
Kode lerroa:                   throw new _util.FormatError('XObject should be a stream');
Kode lerroa:                 }
Kode lerroa:                 var type = xobj.dict.get('Subtype');
Kode lerroa:                 if (!(0, _primitives.isName)(type)) {
Kode lerroa:                   throw new _util.FormatError('XObject should have a Name subtype');
Kode lerroa:                 }
Kode lerroa:                 if (type.name === 'Form') {
Kode lerroa:                   stateManager.save();
Kode lerroa:                   self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function () {
Kode lerroa:                     stateManager.restore();
Kode lerroa:                     resolveXObject();
Kode lerroa:                   }, rejectXObject);
Kode lerroa:                   return;
Kode lerroa:                 } else if (type.name === 'Image') {
Kode lerroa:                   self.buildPaintImageXObject(resources, xobj, false, operatorList, name, imageCache);
Kode lerroa:                 } else if (type.name === 'PS') {
Kode lerroa:                   (0, _util.info)('Ignored XObject subtype PS');
Kode lerroa:                 } else {
Kode lerroa:                   throw new _util.FormatError('Unhandled XObject subtype ' + type.name);
Kode lerroa:                 }
Kode lerroa:                 resolveXObject();
Kode lerroa:               }).catch(function (reason) {
Kode lerroa:                 if (self.options.ignoreErrors) {
Kode lerroa:                   self.handler.send('UnsupportedFeature', { featureId: _util.UNSUPPORTED_FEATURES.unknown });
Kode lerroa:                   (0, _util.warn)('getOperatorList - ignoring XObject: "' + reason + '".');
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 throw reason;
Kode lerroa:               }));
Kode lerroa:               return;
Kode lerroa:             case _util.OPS.setFont:
Kode lerroa:               var fontSize = args[1];
Kode lerroa:               next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function (loadedName) {
Kode lerroa:                 operatorList.addDependency(loadedName);
Kode lerroa:                 operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
Kode lerroa:               }));
Kode lerroa:               return;
Kode lerroa:             case _util.OPS.endInlineImage:
Kode lerroa:               var cacheKey = args[0].cacheKey;
Kode lerroa:               if (cacheKey) {
Kode lerroa:                 var cacheEntry = imageCache[cacheKey];
Kode lerroa:                 if (cacheEntry !== undefined) {
Kode lerroa:                   operatorList.addOp(cacheEntry.fn, cacheEntry.args);
Kode lerroa:                   args = null;
Kode lerroa:                   continue;
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:               self.buildPaintImageXObject(resources, args[0], true, operatorList, cacheKey, imageCache);
Kode lerroa:               args = null;
Kode lerroa:               continue;
Kode lerroa:             case _util.OPS.showText:
Kode lerroa:               args[0] = self.handleText(args[0], stateManager.state);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.showSpacedText:
Kode lerroa:               var arr = args[0];
Kode lerroa:               var combinedGlyphs = [];
Kode lerroa:               var arrLength = arr.length;
Kode lerroa:               var state = stateManager.state;
Kode lerroa:               for (i = 0; i < arrLength; ++i) {
Kode lerroa:                 var arrItem = arr[i];
Kode lerroa:                 if ((0, _util.isString)(arrItem)) {
Kode lerroa:                   Array.prototype.push.apply(combinedGlyphs, self.handleText(arrItem, state));
Kode lerroa:                 } else if ((0, _util.isNum)(arrItem)) {
Kode lerroa:                   combinedGlyphs.push(arrItem);
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:               args[0] = combinedGlyphs;
Kode lerroa:               fn = _util.OPS.showText;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.nextLineShowText:
Kode lerroa:               operatorList.addOp(_util.OPS.nextLine);
Kode lerroa:               args[0] = self.handleText(args[0], stateManager.state);
Kode lerroa:               fn = _util.OPS.showText;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.nextLineSetSpacingShowText:
Kode lerroa:               operatorList.addOp(_util.OPS.nextLine);
Kode lerroa:               operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
Kode lerroa:               operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
Kode lerroa:               args[0] = self.handleText(args[0], stateManager.state);
Kode lerroa:               fn = _util.OPS.showText;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setTextRenderingMode:
Kode lerroa:               stateManager.state.textRenderingMode = args[0];
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFillColorSpace:
Kode lerroa:               stateManager.state.fillColorSpace = _colorspace.ColorSpace.parse(args[0], xref, resources, self.pdfFunctionFactory);
Kode lerroa:               continue;
Kode lerroa:             case _util.OPS.setStrokeColorSpace:
Kode lerroa:               stateManager.state.strokeColorSpace = _colorspace.ColorSpace.parse(args[0], xref, resources, self.pdfFunctionFactory);
Kode lerroa:               continue;
Kode lerroa:             case _util.OPS.setFillColor:
Kode lerroa:               cs = stateManager.state.fillColorSpace;
Kode lerroa:               args = cs.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setFillRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setStrokeColor:
Kode lerroa:               cs = stateManager.state.strokeColorSpace;
Kode lerroa:               args = cs.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setStrokeRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFillGray:
Kode lerroa:               stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
Kode lerroa:               args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setFillRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setStrokeGray:
Kode lerroa:               stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
Kode lerroa:               args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setStrokeRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFillCMYKColor:
Kode lerroa:               stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
Kode lerroa:               args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setFillRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setStrokeCMYKColor:
Kode lerroa:               stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
Kode lerroa:               args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setStrokeRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFillRGBColor:
Kode lerroa:               stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
Kode lerroa:               args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setStrokeRGBColor:
Kode lerroa:               stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
Kode lerroa:               args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setFillColorN:
Kode lerroa:               cs = stateManager.state.fillColorSpace;
Kode lerroa:               if (cs.name === 'Pattern') {
Kode lerroa:                 next(self.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task));
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               args = cs.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setFillRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setStrokeColorN:
Kode lerroa:               cs = stateManager.state.strokeColorSpace;
Kode lerroa:               if (cs.name === 'Pattern') {
Kode lerroa:                 next(self.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task));
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               args = cs.getRgb(args, 0);
Kode lerroa:               fn = _util.OPS.setStrokeRGBColor;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.shadingFill:
Kode lerroa:               var shadingRes = resources.get('Shading');
Kode lerroa:               if (!shadingRes) {
Kode lerroa:                 throw new _util.FormatError('No shading resource found');
Kode lerroa:               }
Kode lerroa:               var shading = shadingRes.get(args[0].name);
Kode lerroa:               if (!shading) {
Kode lerroa:                 throw new _util.FormatError('No shading object found');
Kode lerroa:               }
Kode lerroa:               var shadingFill = _pattern.Pattern.parseShading(shading, null, xref, resources, self.handler, self.pdfFunctionFactory);
Kode lerroa:               var patternIR = shadingFill.getIR();
Kode lerroa:               args = [patternIR];
Kode lerroa:               fn = _util.OPS.shadingFill;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setGState:
Kode lerroa:               var dictName = args[0];
Kode lerroa:               var extGState = resources.get('ExtGState');
Kode lerroa:               if (!(0, _primitives.isDict)(extGState) || !extGState.has(dictName.name)) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               var gState = extGState.get(dictName.name);
Kode lerroa:               next(self.setGState(resources, gState, operatorList, task, stateManager));
Kode lerroa:               return;
Kode lerroa:             case _util.OPS.moveTo:
Kode lerroa:             case _util.OPS.lineTo:
Kode lerroa:             case _util.OPS.curveTo:
Kode lerroa:             case _util.OPS.curveTo2:
Kode lerroa:             case _util.OPS.curveTo3:
Kode lerroa:             case _util.OPS.closePath:
Kode lerroa:               self.buildPath(operatorList, fn, args);
Kode lerroa:               continue;
Kode lerroa:             case _util.OPS.rectangle:
Kode lerroa:               self.buildPath(operatorList, fn, args);
Kode lerroa:               continue;
Kode lerroa:             case _util.OPS.markPoint:
Kode lerroa:             case _util.OPS.markPointProps:
Kode lerroa:             case _util.OPS.beginMarkedContent:
Kode lerroa:             case _util.OPS.beginMarkedContentProps:
Kode lerroa:             case _util.OPS.endMarkedContent:
Kode lerroa:             case _util.OPS.beginCompat:
Kode lerroa:             case _util.OPS.endCompat:
Kode lerroa:               continue;
Kode lerroa:             default:
Kode lerroa:               if (args !== null) {
Kode lerroa:                 for (i = 0, ii = args.length; i < ii; i++) {
Kode lerroa:                   if (args[i] instanceof _primitives.Dict) {
Kode lerroa:                     break;
Kode lerroa:                   }
Kode lerroa:                 }
Kode lerroa:                 if (i < ii) {
Kode lerroa:                   (0, _util.warn)('getOperatorList - ignoring operator: ' + fn);
Kode lerroa:                   continue;
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:           }
Kode lerroa:           operatorList.addOp(fn, args);
Kode lerroa:         }
Kode lerroa:         if (stop) {
Kode lerroa:           next(deferred);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         closePendingRestoreOPS();
Kode lerroa:         resolve();
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         if (_this8.options.ignoreErrors) {
Kode lerroa:           _this8.handler.send('UnsupportedFeature', { featureId: _util.UNSUPPORTED_FEATURES.unknown });
Kode lerroa:           (0, _util.warn)('getOperatorList - ignoring errors during task: ' + task.name);
Kode lerroa:           closePendingRestoreOPS();
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         throw reason;
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getTextContent: function getTextContent(_ref4) {
Kode lerroa:       var _this9 = this;
Kode lerroa: 
Kode lerroa:       var stream = _ref4.stream,
Kode lerroa:           task = _ref4.task,
Kode lerroa:           resources = _ref4.resources,
Kode lerroa:           _ref4$stateManager = _ref4.stateManager,
Kode lerroa:           stateManager = _ref4$stateManager === undefined ? null : _ref4$stateManager,
Kode lerroa:           _ref4$normalizeWhites = _ref4.normalizeWhitespace,
Kode lerroa:           normalizeWhitespace = _ref4$normalizeWhites === undefined ? false : _ref4$normalizeWhites,
Kode lerroa:           _ref4$combineTextItem = _ref4.combineTextItems,
Kode lerroa:           combineTextItems = _ref4$combineTextItem === undefined ? false : _ref4$combineTextItem,
Kode lerroa:           sink = _ref4.sink,
Kode lerroa:           _ref4$seenStyles = _ref4.seenStyles,
Kode lerroa:           seenStyles = _ref4$seenStyles === undefined ? Object.create(null) : _ref4$seenStyles;
Kode lerroa: 
Kode lerroa:       resources = resources || _primitives.Dict.empty;
Kode lerroa:       stateManager = stateManager || new StateManager(new TextState());
Kode lerroa:       var WhitespaceRegexp = /\s/g;
Kode lerroa:       var textContent = {
Kode lerroa:         items: [],
Kode lerroa:         styles: Object.create(null)
Kode lerroa:       };
Kode lerroa:       var textContentItem = {
Kode lerroa:         initialized: false,
Kode lerroa:         str: [],
Kode lerroa:         width: 0,
Kode lerroa:         height: 0,
Kode lerroa:         vertical: false,
Kode lerroa:         lastAdvanceWidth: 0,
Kode lerroa:         lastAdvanceHeight: 0,
Kode lerroa:         textAdvanceScale: 0,
Kode lerroa:         spaceWidth: 0,
Kode lerroa:         fakeSpaceMin: Infinity,
Kode lerroa:         fakeMultiSpaceMin: Infinity,
Kode lerroa:         fakeMultiSpaceMax: -0,
Kode lerroa:         textRunBreakAllowed: false,
Kode lerroa:         transform: null,
Kode lerroa:         fontName: null
Kode lerroa:       };
Kode lerroa:       var SPACE_FACTOR = 0.3;
Kode lerroa:       var MULTI_SPACE_FACTOR = 1.5;
Kode lerroa:       var MULTI_SPACE_FACTOR_MAX = 4;
Kode lerroa:       var self = this;
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var xobjs = null;
Kode lerroa:       var skipEmptyXObjs = Object.create(null);
Kode lerroa:       var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
Kode lerroa:       var textState;
Kode lerroa:       function ensureTextContentItem() {
Kode lerroa:         if (textContentItem.initialized) {
Kode lerroa:           return textContentItem;
Kode lerroa:         }
Kode lerroa:         var font = textState.font;
Kode lerroa:         if (!(font.loadedName in seenStyles)) {
Kode lerroa:           seenStyles[font.loadedName] = true;
Kode lerroa:           textContent.styles[font.loadedName] = {
Kode lerroa:             fontFamily: font.fallbackName,
Kode lerroa:             ascent: font.ascent,
Kode lerroa:             descent: font.descent,
Kode lerroa:             vertical: font.vertical
Kode lerroa:           };
Kode lerroa:         }
Kode lerroa:         textContentItem.fontName = font.loadedName;
Kode lerroa:         var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
Kode lerroa:         if (font.isType3Font && textState.fontMatrix !== _util.FONT_IDENTITY_MATRIX && textState.fontSize === 1) {
Kode lerroa:           var glyphHeight = font.bbox[3] - font.bbox[1];
Kode lerroa:           if (glyphHeight > 0) {
Kode lerroa:             glyphHeight = glyphHeight * textState.fontMatrix[3];
Kode lerroa:             tsm[3] *= glyphHeight;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         var trm = _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
Kode lerroa:         textContentItem.transform = trm;
Kode lerroa:         if (!font.vertical) {
Kode lerroa:           textContentItem.width = 0;
Kode lerroa:           textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
Kode lerroa:           textContentItem.vertical = false;
Kode lerroa:         } else {
Kode lerroa:           textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
Kode lerroa:           textContentItem.height = 0;
Kode lerroa:           textContentItem.vertical = true;
Kode lerroa:         }
Kode lerroa:         var a = textState.textLineMatrix[0];
Kode lerroa:         var b = textState.textLineMatrix[1];
Kode lerroa:         var scaleLineX = Math.sqrt(a * a + b * b);
Kode lerroa:         a = textState.ctm[0];
Kode lerroa:         b = textState.ctm[1];
Kode lerroa:         var scaleCtmX = Math.sqrt(a * a + b * b);
Kode lerroa:         textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
Kode lerroa:         textContentItem.lastAdvanceWidth = 0;
Kode lerroa:         textContentItem.lastAdvanceHeight = 0;
Kode lerroa:         var spaceWidth = font.spaceWidth / 1000 * textState.fontSize;
Kode lerroa:         if (spaceWidth) {
Kode lerroa:           textContentItem.spaceWidth = spaceWidth;
Kode lerroa:           textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
Kode lerroa:           textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
Kode lerroa:           textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
Kode lerroa:           textContentItem.textRunBreakAllowed = !font.isMonospace;
Kode lerroa:         } else {
Kode lerroa:           textContentItem.spaceWidth = 0;
Kode lerroa:           textContentItem.fakeSpaceMin = Infinity;
Kode lerroa:           textContentItem.fakeMultiSpaceMin = Infinity;
Kode lerroa:           textContentItem.fakeMultiSpaceMax = 0;
Kode lerroa:           textContentItem.textRunBreakAllowed = false;
Kode lerroa:         }
Kode lerroa:         textContentItem.initialized = true;
Kode lerroa:         return textContentItem;
Kode lerroa:       }
Kode lerroa:       function replaceWhitespace(str) {
Kode lerroa:         var i = 0,
Kode lerroa:             ii = str.length,
Kode lerroa:             code;
Kode lerroa:         while (i < ii && (code = str.charCodeAt(i)) >= 0x20 && code <= 0x7F) {
Kode lerroa:           i++;
Kode lerroa:         }
Kode lerroa:         return i < ii ? str.replace(WhitespaceRegexp, ' ') : str;
Kode lerroa:       }
Kode lerroa:       function runBidiTransform(textChunk) {
Kode lerroa:         var str = textChunk.str.join('');
Kode lerroa:         var bidiResult = (0, _bidi.bidi)(str, -1, textChunk.vertical);
Kode lerroa:         return {
Kode lerroa:           str: normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str,
Kode lerroa:           dir: bidiResult.dir,
Kode lerroa:           width: textChunk.width,
Kode lerroa:           height: textChunk.height,
Kode lerroa:           transform: textChunk.transform,
Kode lerroa:           fontName: textChunk.fontName
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:       function handleSetFont(fontName, fontRef) {
Kode lerroa:         return self.loadFont(fontName, fontRef, resources).then(function (translated) {
Kode lerroa:           textState.font = translated.font;
Kode lerroa:           textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       function buildTextContentItem(chars) {
Kode lerroa:         var font = textState.font;
Kode lerroa:         var textChunk = ensureTextContentItem();
Kode lerroa:         var width = 0;
Kode lerroa:         var height = 0;
Kode lerroa:         var glyphs = font.charsToGlyphs(chars);
Kode lerroa:         for (var i = 0; i < glyphs.length; i++) {
Kode lerroa:           var glyph = glyphs[i];
Kode lerroa:           var glyphWidth = null;
Kode lerroa:           if (font.vertical && glyph.vmetric) {
Kode lerroa:             glyphWidth = glyph.vmetric[0];
Kode lerroa:           } else {
Kode lerroa:             glyphWidth = glyph.width;
Kode lerroa:           }
Kode lerroa:           var glyphUnicode = glyph.unicode;
Kode lerroa:           var NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();
Kode lerroa:           if (NormalizedUnicodes[glyphUnicode] !== undefined) {
Kode lerroa:             glyphUnicode = NormalizedUnicodes[glyphUnicode];
Kode lerroa:           }
Kode lerroa:           glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
Kode lerroa:           var charSpacing = textState.charSpacing;
Kode lerroa:           if (glyph.isSpace) {
Kode lerroa:             var wordSpacing = textState.wordSpacing;
Kode lerroa:             charSpacing += wordSpacing;
Kode lerroa:             if (wordSpacing > 0) {
Kode lerroa:               addFakeSpaces(wordSpacing, textChunk.str);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           var tx = 0;
Kode lerroa:           var ty = 0;
Kode lerroa:           if (!font.vertical) {
Kode lerroa:             var w0 = glyphWidth * textState.fontMatrix[0];
Kode lerroa:             tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
Kode lerroa:             width += tx;
Kode lerroa:           } else {
Kode lerroa:             var w1 = glyphWidth * textState.fontMatrix[0];
Kode lerroa:             ty = w1 * textState.fontSize + charSpacing;
Kode lerroa:             height += ty;
Kode lerroa:           }
Kode lerroa:           textState.translateTextMatrix(tx, ty);
Kode lerroa:           textChunk.str.push(glyphUnicode);
Kode lerroa:         }
Kode lerroa:         if (!font.vertical) {
Kode lerroa:           textChunk.lastAdvanceWidth = width;
Kode lerroa:           textChunk.width += width;
Kode lerroa:         } else {
Kode lerroa:           textChunk.lastAdvanceHeight = height;
Kode lerroa:           textChunk.height += Math.abs(height);
Kode lerroa:         }
Kode lerroa:         return textChunk;
Kode lerroa:       }
Kode lerroa:       function addFakeSpaces(width, strBuf) {
Kode lerroa:         if (width < textContentItem.fakeSpaceMin) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (width < textContentItem.fakeMultiSpaceMin) {
Kode lerroa:           strBuf.push(' ');
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var fakeSpaces = Math.round(width / textContentItem.spaceWidth);
Kode lerroa:         while (fakeSpaces-- > 0) {
Kode lerroa:           strBuf.push(' ');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       function flushTextContentItem() {
Kode lerroa:         if (!textContentItem.initialized) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         textContentItem.width *= textContentItem.textAdvanceScale;
Kode lerroa:         textContentItem.height *= textContentItem.textAdvanceScale;
Kode lerroa:         textContent.items.push(runBidiTransform(textContentItem));
Kode lerroa:         textContentItem.initialized = false;
Kode lerroa:         textContentItem.str.length = 0;
Kode lerroa:       }
Kode lerroa:       function enqueueChunk() {
Kode lerroa:         var length = textContent.items.length;
Kode lerroa:         if (length > 0) {
Kode lerroa:           sink.enqueue(textContent, length);
Kode lerroa:           textContent.items = [];
Kode lerroa:           textContent.styles = Object.create(null);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var timeSlotManager = new TimeSlotManager();
Kode lerroa:       return new Promise(function promiseBody(resolve, reject) {
Kode lerroa:         var next = function next(promise) {
Kode lerroa:           enqueueChunk();
Kode lerroa:           Promise.all([promise, sink.ready]).then(function () {
Kode lerroa:             try {
Kode lerroa:               promiseBody(resolve, reject);
Kode lerroa:             } catch (ex) {
Kode lerroa:               reject(ex);
Kode lerroa:             }
Kode lerroa:           }, reject);
Kode lerroa:         };
Kode lerroa:         task.ensureNotTerminated();
Kode lerroa:         timeSlotManager.reset();
Kode lerroa:         var stop,
Kode lerroa:             operation = {},
Kode lerroa:             args = [];
Kode lerroa:         while (!(stop = timeSlotManager.check())) {
Kode lerroa:           args.length = 0;
Kode lerroa:           operation.args = args;
Kode lerroa:           if (!preprocessor.read(operation)) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           textState = stateManager.state;
Kode lerroa:           var fn = operation.fn;
Kode lerroa:           args = operation.args;
Kode lerroa:           var advance, diff;
Kode lerroa:           switch (fn | 0) {
Kode lerroa:             case _util.OPS.setFont:
Kode lerroa:               var fontNameArg = args[0].name,
Kode lerroa:                   fontSizeArg = args[1];
Kode lerroa:               if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.fontName = fontNameArg;
Kode lerroa:               textState.fontSize = fontSizeArg;
Kode lerroa:               next(handleSetFont(fontNameArg, null));
Kode lerroa:               return;
Kode lerroa:             case _util.OPS.setTextRise:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.textRise = args[0];
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setHScale:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.textHScale = args[0] / 100;
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLeading:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.leading = args[0];
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.moveText:
Kode lerroa:               var isSameTextLine = !textState.font ? false : (textState.font.vertical ? args[0] : args[1]) === 0;
Kode lerroa:               advance = args[0] - args[1];
Kode lerroa:               if (combineTextItems && isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
Kode lerroa:                 textState.translateTextLineMatrix(args[0], args[1]);
Kode lerroa:                 textContentItem.width += args[0] - textContentItem.lastAdvanceWidth;
Kode lerroa:                 textContentItem.height += args[1] - textContentItem.lastAdvanceHeight;
Kode lerroa:                 diff = args[0] - textContentItem.lastAdvanceWidth - (args[1] - textContentItem.lastAdvanceHeight);
Kode lerroa:                 addFakeSpaces(diff, textContentItem.str);
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.translateTextLineMatrix(args[0], args[1]);
Kode lerroa:               textState.textMatrix = textState.textLineMatrix.slice();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setLeadingMoveText:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.leading = -args[1];
Kode lerroa:               textState.translateTextLineMatrix(args[0], args[1]);
Kode lerroa:               textState.textMatrix = textState.textLineMatrix.slice();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.nextLine:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.carriageReturn();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setTextMatrix:
Kode lerroa:               advance = textState.calcTextLineMatrixAdvance(args[0], args[1], args[2], args[3], args[4], args[5]);
Kode lerroa:               if (combineTextItems && advance !== null && textContentItem.initialized && advance.value > 0 && advance.value <= textContentItem.fakeMultiSpaceMax) {
Kode lerroa:                 textState.translateTextLineMatrix(advance.width, advance.height);
Kode lerroa:                 textContentItem.width += advance.width - textContentItem.lastAdvanceWidth;
Kode lerroa:                 textContentItem.height += advance.height - textContentItem.lastAdvanceHeight;
Kode lerroa:                 diff = advance.width - textContentItem.lastAdvanceWidth - (advance.height - textContentItem.lastAdvanceHeight);
Kode lerroa:                 addFakeSpaces(diff, textContentItem.str);
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
Kode lerroa:               textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setCharSpacing:
Kode lerroa:               textState.charSpacing = args[0];
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.setWordSpacing:
Kode lerroa:               textState.wordSpacing = args[0];
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.beginText:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.textMatrix = _util.IDENTITY_MATRIX.slice();
Kode lerroa:               textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.showSpacedText:
Kode lerroa:               var items = args[0];
Kode lerroa:               var offset;
Kode lerroa:               for (var j = 0, jj = items.length; j < jj; j++) {
Kode lerroa:                 if (typeof items[j] === 'string') {
Kode lerroa:                   buildTextContentItem(items[j]);
Kode lerroa:                 } else if ((0, _util.isNum)(items[j])) {
Kode lerroa:                   ensureTextContentItem();
Kode lerroa:                   advance = items[j] * textState.fontSize / 1000;
Kode lerroa:                   var breakTextRun = false;
Kode lerroa:                   if (textState.font.vertical) {
Kode lerroa:                     offset = advance;
Kode lerroa:                     textState.translateTextMatrix(0, offset);
Kode lerroa:                     breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
Kode lerroa:                     if (!breakTextRun) {
Kode lerroa:                       textContentItem.height += offset;
Kode lerroa:                     }
Kode lerroa:                   } else {
Kode lerroa:                     advance = -advance;
Kode lerroa:                     offset = advance * textState.textHScale;
Kode lerroa:                     textState.translateTextMatrix(offset, 0);
Kode lerroa:                     breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
Kode lerroa:                     if (!breakTextRun) {
Kode lerroa:                       textContentItem.width += offset;
Kode lerroa:                     }
Kode lerroa:                   }
Kode lerroa:                   if (breakTextRun) {
Kode lerroa:                     flushTextContentItem();
Kode lerroa:                   } else if (advance > 0) {
Kode lerroa:                     addFakeSpaces(advance, textContentItem.str);
Kode lerroa:                   }
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.showText:
Kode lerroa:               buildTextContentItem(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.nextLineShowText:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.carriageReturn();
Kode lerroa:               buildTextContentItem(args[0]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.nextLineSetSpacingShowText:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               textState.wordSpacing = args[0];
Kode lerroa:               textState.charSpacing = args[1];
Kode lerroa:               textState.carriageReturn();
Kode lerroa:               buildTextContentItem(args[2]);
Kode lerroa:               break;
Kode lerroa:             case _util.OPS.paintXObject:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               if (!xobjs) {
Kode lerroa:                 xobjs = resources.get('XObject') || _primitives.Dict.empty;
Kode lerroa:               }
Kode lerroa:               var name = args[0].name;
Kode lerroa:               if (name && skipEmptyXObjs[name] !== undefined) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               next(new Promise(function (resolveXObject, rejectXObject) {
Kode lerroa:                 if (!name) {
Kode lerroa:                   throw new _util.FormatError('XObject must be referred to by name.');
Kode lerroa:                 }
Kode lerroa:                 var xobj = xobjs.get(name);
Kode lerroa:                 if (!xobj) {
Kode lerroa:                   resolveXObject();
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 if (!(0, _primitives.isStream)(xobj)) {
Kode lerroa:                   throw new _util.FormatError('XObject should be a stream');
Kode lerroa:                 }
Kode lerroa:                 var type = xobj.dict.get('Subtype');
Kode lerroa:                 if (!(0, _primitives.isName)(type)) {
Kode lerroa:                   throw new _util.FormatError('XObject should have a Name subtype');
Kode lerroa:                 }
Kode lerroa:                 if (type.name !== 'Form') {
Kode lerroa:                   skipEmptyXObjs[name] = true;
Kode lerroa:                   resolveXObject();
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 var currentState = stateManager.state.clone();
Kode lerroa:                 var xObjStateManager = new StateManager(currentState);
Kode lerroa:                 var matrix = xobj.dict.getArray('Matrix');
Kode lerroa:                 if (Array.isArray(matrix) && matrix.length === 6) {
Kode lerroa:                   xObjStateManager.transform(matrix);
Kode lerroa:                 }
Kode lerroa:                 enqueueChunk();
Kode lerroa:                 var sinkWrapper = {
Kode lerroa:                   enqueueInvoked: false,
Kode lerroa:                   enqueue: function enqueue(chunk, size) {
Kode lerroa:                     this.enqueueInvoked = true;
Kode lerroa:                     sink.enqueue(chunk, size);
Kode lerroa:                   },
Kode lerroa: 
Kode lerroa:                   get desiredSize() {
Kode lerroa:                     return sink.desiredSize;
Kode lerroa:                   },
Kode lerroa:                   get ready() {
Kode lerroa:                     return sink.ready;
Kode lerroa:                   }
Kode lerroa:                 };
Kode lerroa:                 self.getTextContent({
Kode lerroa:                   stream: xobj,
Kode lerroa:                   task: task,
Kode lerroa:                   resources: xobj.dict.get('Resources') || resources,
Kode lerroa:                   stateManager: xObjStateManager,
Kode lerroa:                   normalizeWhitespace: normalizeWhitespace,
Kode lerroa:                   combineTextItems: combineTextItems,
Kode lerroa:                   sink: sinkWrapper,
Kode lerroa:                   seenStyles: seenStyles
Kode lerroa:                 }).then(function () {
Kode lerroa:                   if (!sinkWrapper.enqueueInvoked) {
Kode lerroa:                     skipEmptyXObjs[name] = true;
Kode lerroa:                   }
Kode lerroa:                   resolveXObject();
Kode lerroa:                 }, rejectXObject);
Kode lerroa:               }).catch(function (reason) {
Kode lerroa:                 if (reason instanceof _util.AbortException) {
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 if (self.options.ignoreErrors) {
Kode lerroa:                   (0, _util.warn)('getTextContent - ignoring XObject: "' + reason + '".');
Kode lerroa:                   return;
Kode lerroa:                 }
Kode lerroa:                 throw reason;
Kode lerroa:               }));
Kode lerroa:               return;
Kode lerroa:             case _util.OPS.setGState:
Kode lerroa:               flushTextContentItem();
Kode lerroa:               var dictName = args[0];
Kode lerroa:               var extGState = resources.get('ExtGState');
Kode lerroa:               if (!(0, _primitives.isDict)(extGState) || !(0, _primitives.isName)(dictName)) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               var gState = extGState.get(dictName.name);
Kode lerroa:               if (!(0, _primitives.isDict)(gState)) {
Kode lerroa:                 break;
Kode lerroa:               }
Kode lerroa:               var gStateFont = gState.get('Font');
Kode lerroa:               if (gStateFont) {
Kode lerroa:                 textState.fontName = null;
Kode lerroa:                 textState.fontSize = gStateFont[1];
Kode lerroa:                 next(handleSetFont(null, gStateFont[0]));
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:           }
Kode lerroa:           if (textContent.items.length >= sink.desiredSize) {
Kode lerroa:             stop = true;
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (stop) {
Kode lerroa:           next(deferred);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         flushTextContentItem();
Kode lerroa:         enqueueChunk();
Kode lerroa:         resolve();
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         if (reason instanceof _util.AbortException) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (_this9.options.ignoreErrors) {
Kode lerroa:           (0, _util.warn)('getTextContent - ignoring errors during task: ' + task.name);
Kode lerroa:           flushTextContentItem();
Kode lerroa:           enqueueChunk();
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         throw reason;
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     extractDataStructures: function PartialEvaluator_extractDataStructures(dict, baseDict, properties) {
Kode lerroa:       var _this10 = this;
Kode lerroa: 
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var toUnicode = dict.get('ToUnicode') || baseDict.get('ToUnicode');
Kode lerroa:       var toUnicodePromise = toUnicode ? this.readToUnicode(toUnicode) : Promise.resolve(undefined);
Kode lerroa:       if (properties.composite) {
Kode lerroa:         var cidSystemInfo = dict.get('CIDSystemInfo');
Kode lerroa:         if ((0, _primitives.isDict)(cidSystemInfo)) {
Kode lerroa:           properties.cidSystemInfo = {
Kode lerroa:             registry: cidSystemInfo.get('Registry'),
Kode lerroa:             ordering: cidSystemInfo.get('Ordering'),
Kode lerroa:             supplement: cidSystemInfo.get('Supplement')
Kode lerroa:           };
Kode lerroa:         }
Kode lerroa:         var cidToGidMap = dict.get('CIDToGIDMap');
Kode lerroa:         if ((0, _primitives.isStream)(cidToGidMap)) {
Kode lerroa:           properties.cidToGidMap = this.readCidToGidMap(cidToGidMap);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var differences = [];
Kode lerroa:       var baseEncodingName = null;
Kode lerroa:       var encoding;
Kode lerroa:       if (dict.has('Encoding')) {
Kode lerroa:         encoding = dict.get('Encoding');
Kode lerroa:         if ((0, _primitives.isDict)(encoding)) {
Kode lerroa:           baseEncodingName = encoding.get('BaseEncoding');
Kode lerroa:           baseEncodingName = (0, _primitives.isName)(baseEncodingName) ? baseEncodingName.name : null;
Kode lerroa:           if (encoding.has('Differences')) {
Kode lerroa:             var diffEncoding = encoding.get('Differences');
Kode lerroa:             var index = 0;
Kode lerroa:             for (var j = 0, jj = diffEncoding.length; j < jj; j++) {
Kode lerroa:               var data = xref.fetchIfRef(diffEncoding[j]);
Kode lerroa:               if ((0, _util.isNum)(data)) {
Kode lerroa:                 index = data;
Kode lerroa:               } else if ((0, _primitives.isName)(data)) {
Kode lerroa:                 differences[index++] = data.name;
Kode lerroa:               } else {
Kode lerroa:                 throw new _util.FormatError('Invalid entry in \'Differences\' array: ' + data);
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         } else if ((0, _primitives.isName)(encoding)) {
Kode lerroa:           baseEncodingName = encoding.name;
Kode lerroa:         } else {
Kode lerroa:           throw new _util.FormatError('Encoding is not a Name nor a Dict');
Kode lerroa:         }
Kode lerroa:         if (baseEncodingName !== 'MacRomanEncoding' && baseEncodingName !== 'MacExpertEncoding' && baseEncodingName !== 'WinAnsiEncoding') {
Kode lerroa:           baseEncodingName = null;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (baseEncodingName) {
Kode lerroa:         properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName).slice();
Kode lerroa:       } else {
Kode lerroa:         var isSymbolicFont = !!(properties.flags & _fonts.FontFlags.Symbolic);
Kode lerroa:         var isNonsymbolicFont = !!(properties.flags & _fonts.FontFlags.Nonsymbolic);
Kode lerroa:         encoding = _encodings.StandardEncoding;
Kode lerroa:         if (properties.type === 'TrueType' && !isNonsymbolicFont) {
Kode lerroa:           encoding = _encodings.WinAnsiEncoding;
Kode lerroa:         }
Kode lerroa:         if (isSymbolicFont) {
Kode lerroa:           encoding = _encodings.MacRomanEncoding;
Kode lerroa:           if (!properties.file) {
Kode lerroa:             if (/Symbol/i.test(properties.name)) {
Kode lerroa:               encoding = _encodings.SymbolSetEncoding;
Kode lerroa:             } else if (/Dingbats/i.test(properties.name)) {
Kode lerroa:               encoding = _encodings.ZapfDingbatsEncoding;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         properties.defaultEncoding = encoding;
Kode lerroa:       }
Kode lerroa:       properties.differences = differences;
Kode lerroa:       properties.baseEncodingName = baseEncodingName;
Kode lerroa:       properties.hasEncoding = !!baseEncodingName || differences.length > 0;
Kode lerroa:       properties.dict = dict;
Kode lerroa:       return toUnicodePromise.then(function (toUnicode) {
Kode lerroa:         properties.toUnicode = toUnicode;
Kode lerroa:         return _this10.buildToUnicode(properties);
Kode lerroa:       }).then(function (toUnicode) {
Kode lerroa:         properties.toUnicode = toUnicode;
Kode lerroa:         return properties;
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     buildToUnicode: function PartialEvaluator_buildToUnicode(properties) {
Kode lerroa:       properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
Kode lerroa:       if (properties.hasIncludedToUnicodeMap) {
Kode lerroa:         return Promise.resolve(properties.toUnicode);
Kode lerroa:       }
Kode lerroa:       var toUnicode, charcode, glyphName;
Kode lerroa:       if (!properties.composite) {
Kode lerroa:         toUnicode = [];
Kode lerroa:         var encoding = properties.defaultEncoding.slice();
Kode lerroa:         var baseEncodingName = properties.baseEncodingName;
Kode lerroa:         var differences = properties.differences;
Kode lerroa:         for (charcode in differences) {
Kode lerroa:           glyphName = differences[charcode];
Kode lerroa:           if (glyphName === '.notdef') {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           encoding[charcode] = glyphName;
Kode lerroa:         }
Kode lerroa:         var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
Kode lerroa:         for (charcode in encoding) {
Kode lerroa:           glyphName = encoding[charcode];
Kode lerroa:           if (glyphName === '') {
Kode lerroa:             continue;
Kode lerroa:           } else if (glyphsUnicodeMap[glyphName] === undefined) {
Kode lerroa:             var code = 0;
Kode lerroa:             switch (glyphName[0]) {
Kode lerroa:               case 'G':
Kode lerroa:                 if (glyphName.length === 3) {
Kode lerroa:                   code = parseInt(glyphName.substr(1), 16);
Kode lerroa:                 }
Kode lerroa:                 break;
Kode lerroa:               case 'g':
Kode lerroa:                 if (glyphName.length === 5) {
Kode lerroa:                   code = parseInt(glyphName.substr(1), 16);
Kode lerroa:                 }
Kode lerroa:                 break;
Kode lerroa:               case 'C':
Kode lerroa:               case 'c':
Kode lerroa:                 if (glyphName.length >= 3) {
Kode lerroa:                   code = +glyphName.substr(1);
Kode lerroa:                 }
Kode lerroa:                 break;
Kode lerroa:               default:
Kode lerroa:                 var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
Kode lerroa:                 if (unicode !== -1) {
Kode lerroa:                   code = unicode;
Kode lerroa:                 }
Kode lerroa:             }
Kode lerroa:             if (code) {
Kode lerroa:               if (baseEncodingName && code === +charcode) {
Kode lerroa:                 var baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
Kode lerroa:                 if (baseEncoding && (glyphName = baseEncoding[charcode])) {
Kode lerroa:                   toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
Kode lerroa:                   continue;
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:               toUnicode[charcode] = String.fromCharCode(code);
Kode lerroa:             }
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
Kode lerroa:         }
Kode lerroa:         return Promise.resolve(new _fonts.ToUnicodeMap(toUnicode));
Kode lerroa:       }
Kode lerroa:       if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === 'Adobe' && (properties.cidSystemInfo.ordering === 'GB1' || properties.cidSystemInfo.ordering === 'CNS1' || properties.cidSystemInfo.ordering === 'Japan1' || properties.cidSystemInfo.ordering === 'Korea1'))) {
Kode lerroa:         var registry = properties.cidSystemInfo.registry;
Kode lerroa:         var ordering = properties.cidSystemInfo.ordering;
Kode lerroa:         var ucs2CMapName = _primitives.Name.get(registry + '-' + ordering + '-UCS2');
Kode lerroa:         return _cmap.CMapFactory.create({
Kode lerroa:           encoding: ucs2CMapName,
Kode lerroa:           fetchBuiltInCMap: this.fetchBuiltInCMap,
Kode lerroa:           useCMap: null
Kode lerroa:         }).then(function (ucs2CMap) {
Kode lerroa:           var cMap = properties.cMap;
Kode lerroa:           toUnicode = [];
Kode lerroa:           cMap.forEach(function (charcode, cid) {
Kode lerroa:             if (cid > 0xffff) {
Kode lerroa:               throw new _util.FormatError('Max size of CID is 65,535');
Kode lerroa:             }
Kode lerroa:             var ucs2 = ucs2CMap.lookup(cid);
Kode lerroa:             if (ucs2) {
Kode lerroa:               toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
Kode lerroa:             }
Kode lerroa:           });
Kode lerroa:           return new _fonts.ToUnicodeMap(toUnicode);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       return Promise.resolve(new _fonts.IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
Kode lerroa:     },
Kode lerroa:     readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
Kode lerroa:       var cmapObj = toUnicode;
Kode lerroa:       if ((0, _primitives.isName)(cmapObj)) {
Kode lerroa:         return _cmap.CMapFactory.create({
Kode lerroa:           encoding: cmapObj,
Kode lerroa:           fetchBuiltInCMap: this.fetchBuiltInCMap,
Kode lerroa:           useCMap: null
Kode lerroa:         }).then(function (cmap) {
Kode lerroa:           if (cmap instanceof _cmap.IdentityCMap) {
Kode lerroa:             return new _fonts.IdentityToUnicodeMap(0, 0xFFFF);
Kode lerroa:           }
Kode lerroa:           return new _fonts.ToUnicodeMap(cmap.getMap());
Kode lerroa:         });
Kode lerroa:       } else if ((0, _primitives.isStream)(cmapObj)) {
Kode lerroa:         return _cmap.CMapFactory.create({
Kode lerroa:           encoding: cmapObj,
Kode lerroa:           fetchBuiltInCMap: this.fetchBuiltInCMap,
Kode lerroa:           useCMap: null
Kode lerroa:         }).then(function (cmap) {
Kode lerroa:           if (cmap instanceof _cmap.IdentityCMap) {
Kode lerroa:             return new _fonts.IdentityToUnicodeMap(0, 0xFFFF);
Kode lerroa:           }
Kode lerroa:           var map = new Array(cmap.length);
Kode lerroa:           cmap.forEach(function (charCode, token) {
Kode lerroa:             var str = [];
Kode lerroa:             for (var k = 0; k < token.length; k += 2) {
Kode lerroa:               var w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
Kode lerroa:               if ((w1 & 0xF800) !== 0xD800) {
Kode lerroa:                 str.push(w1);
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               k += 2;
Kode lerroa:               var w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
Kode lerroa:               str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
Kode lerroa:             }
Kode lerroa:             map[charCode] = String.fromCharCode.apply(String, str);
Kode lerroa:           });
Kode lerroa:           return new _fonts.ToUnicodeMap(map);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       return Promise.resolve(null);
Kode lerroa:     },
Kode lerroa:     readCidToGidMap: function PartialEvaluator_readCidToGidMap(cidToGidStream) {
Kode lerroa:       var glyphsData = cidToGidStream.getBytes();
Kode lerroa:       var result = [];
Kode lerroa:       for (var j = 0, jj = glyphsData.length; j < jj; j++) {
Kode lerroa:         var glyphID = glyphsData[j++] << 8 | glyphsData[j];
Kode lerroa:         if (glyphID === 0) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var code = j >> 1;
Kode lerroa:         result[code] = glyphID;
Kode lerroa:       }
Kode lerroa:       return result;
Kode lerroa:     },
Kode lerroa:     extractWidths: function PartialEvaluator_extractWidths(dict, descriptor, properties) {
Kode lerroa:       var xref = this.xref;
Kode lerroa:       var glyphsWidths = [];
Kode lerroa:       var defaultWidth = 0;
Kode lerroa:       var glyphsVMetrics = [];
Kode lerroa:       var defaultVMetrics;
Kode lerroa:       var i, ii, j, jj, start, code, widths;
Kode lerroa:       if (properties.composite) {
Kode lerroa:         defaultWidth = dict.has('DW') ? dict.get('DW') : 1000;
Kode lerroa:         widths = dict.get('W');
Kode lerroa:         if (widths) {
Kode lerroa:           for (i = 0, ii = widths.length; i < ii; i++) {
Kode lerroa:             start = xref.fetchIfRef(widths[i++]);
Kode lerroa:             code = xref.fetchIfRef(widths[i]);
Kode lerroa:             if (Array.isArray(code)) {
Kode lerroa:               for (j = 0, jj = code.length; j < jj; j++) {
Kode lerroa:                 glyphsWidths[start++] = xref.fetchIfRef(code[j]);
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               var width = xref.fetchIfRef(widths[++i]);
Kode lerroa:               for (j = start; j <= code; j++) {
Kode lerroa:                 glyphsWidths[j] = width;
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (properties.vertical) {
Kode lerroa:           var vmetrics = dict.getArray('DW2') || [880, -1000];
Kode lerroa:           defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
Kode lerroa:           vmetrics = dict.get('W2');
Kode lerroa:           if (vmetrics) {
Kode lerroa:             for (i = 0, ii = vmetrics.length; i < ii; i++) {
Kode lerroa:               start = xref.fetchIfRef(vmetrics[i++]);
Kode lerroa:               code = xref.fetchIfRef(vmetrics[i]);
Kode lerroa:               if (Array.isArray(code)) {
Kode lerroa:                 for (j = 0, jj = code.length; j < jj; j++) {
Kode lerroa:                   glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
Kode lerroa:                 }
Kode lerroa:               } else {
Kode lerroa:                 var vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
Kode lerroa:                 for (j = start; j <= code; j++) {
Kode lerroa:                   glyphsVMetrics[j] = vmetric;
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         var firstChar = properties.firstChar;
Kode lerroa:         widths = dict.get('Widths');
Kode lerroa:         if (widths) {
Kode lerroa:           j = firstChar;
Kode lerroa:           for (i = 0, ii = widths.length; i < ii; i++) {
Kode lerroa:             glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
Kode lerroa:           }
Kode lerroa:           defaultWidth = parseFloat(descriptor.get('MissingWidth')) || 0;
Kode lerroa:         } else {
Kode lerroa:           var baseFontName = dict.get('BaseFont');
Kode lerroa:           if ((0, _primitives.isName)(baseFontName)) {
Kode lerroa:             var metrics = this.getBaseFontMetrics(baseFontName.name);
Kode lerroa:             glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
Kode lerroa:             defaultWidth = metrics.defaultWidth;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var isMonospace = true;
Kode lerroa:       var firstWidth = defaultWidth;
Kode lerroa:       for (var glyph in glyphsWidths) {
Kode lerroa:         var glyphWidth = glyphsWidths[glyph];
Kode lerroa:         if (!glyphWidth) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (!firstWidth) {
Kode lerroa:           firstWidth = glyphWidth;
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (firstWidth !== glyphWidth) {
Kode lerroa:           isMonospace = false;
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (isMonospace) {
Kode lerroa:         properties.flags |= _fonts.FontFlags.FixedPitch;
Kode lerroa:       }
Kode lerroa:       properties.defaultWidth = defaultWidth;
Kode lerroa:       properties.widths = glyphsWidths;
Kode lerroa:       properties.defaultVMetrics = defaultVMetrics;
Kode lerroa:       properties.vmetrics = glyphsVMetrics;
Kode lerroa:     },
Kode lerroa:     isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
Kode lerroa:       var fontNameWoStyle = baseFontName.split('-')[0];
Kode lerroa:       return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
Kode lerroa:     },
Kode lerroa:     getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
Kode lerroa:       var defaultWidth = 0;
Kode lerroa:       var widths = [];
Kode lerroa:       var monospace = false;
Kode lerroa:       var stdFontMap = (0, _standard_fonts.getStdFontMap)();
Kode lerroa:       var lookupName = stdFontMap[name] || name;
Kode lerroa:       var Metrics = (0, _metrics.getMetrics)();
Kode lerroa:       if (!(lookupName in Metrics)) {
Kode lerroa:         if (this.isSerifFont(name)) {
Kode lerroa:           lookupName = 'Times-Roman';
Kode lerroa:         } else {
Kode lerroa:           lookupName = 'Helvetica';
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var glyphWidths = Metrics[lookupName];
Kode lerroa:       if ((0, _util.isNum)(glyphWidths)) {
Kode lerroa:         defaultWidth = glyphWidths;
Kode lerroa:         monospace = true;
Kode lerroa:       } else {
Kode lerroa:         widths = glyphWidths();
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         defaultWidth: defaultWidth,
Kode lerroa:         monospace: monospace,
Kode lerroa:         widths: widths
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     buildCharCodeToWidth: function PartialEvaluator_bulildCharCodeToWidth(widthsByGlyphName, properties) {
Kode lerroa:       var widths = Object.create(null);
Kode lerroa:       var differences = properties.differences;
Kode lerroa:       var encoding = properties.defaultEncoding;
Kode lerroa:       for (var charCode = 0; charCode < 256; charCode++) {
Kode lerroa:         if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
Kode lerroa:           widths[charCode] = widthsByGlyphName[differences[charCode]];
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
Kode lerroa:           widths[charCode] = widthsByGlyphName[encoding[charCode]];
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return widths;
Kode lerroa:     },
Kode lerroa:     preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict) {
Kode lerroa:       var baseDict = dict;
Kode lerroa:       var type = dict.get('Subtype');
Kode lerroa:       if (!(0, _primitives.isName)(type)) {
Kode lerroa:         throw new _util.FormatError('invalid font Subtype');
Kode lerroa:       }
Kode lerroa:       var composite = false;
Kode lerroa:       var uint8array;
Kode lerroa:       if (type.name === 'Type0') {
Kode lerroa:         var df = dict.get('DescendantFonts');
Kode lerroa:         if (!df) {
Kode lerroa:           throw new _util.FormatError('Descendant fonts are not specified');
Kode lerroa:         }
Kode lerroa:         dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
Kode lerroa:         type = dict.get('Subtype');
Kode lerroa:         if (!(0, _primitives.isName)(type)) {
Kode lerroa:           throw new _util.FormatError('invalid font Subtype');
Kode lerroa:         }
Kode lerroa:         composite = true;
Kode lerroa:       }
Kode lerroa:       var descriptor = dict.get('FontDescriptor');
Kode lerroa:       if (descriptor) {
Kode lerroa:         var hash = new _murmurhash.MurmurHash3_64();
Kode lerroa:         var encoding = baseDict.getRaw('Encoding');
Kode lerroa:         if ((0, _primitives.isName)(encoding)) {
Kode lerroa:           hash.update(encoding.name);
Kode lerroa:         } else if ((0, _primitives.isRef)(encoding)) {
Kode lerroa:           hash.update(encoding.toString());
Kode lerroa:         } else if ((0, _primitives.isDict)(encoding)) {
Kode lerroa:           var keys = encoding.getKeys();
Kode lerroa:           for (var i = 0, ii = keys.length; i < ii; i++) {
Kode lerroa:             var entry = encoding.getRaw(keys[i]);
Kode lerroa:             if ((0, _primitives.isName)(entry)) {
Kode lerroa:               hash.update(entry.name);
Kode lerroa:             } else if ((0, _primitives.isRef)(entry)) {
Kode lerroa:               hash.update(entry.toString());
Kode lerroa:             } else if (Array.isArray(entry)) {
Kode lerroa:               var diffLength = entry.length,
Kode lerroa:                   diffBuf = new Array(diffLength);
Kode lerroa:               for (var j = 0; j < diffLength; j++) {
Kode lerroa:                 var diffEntry = entry[j];
Kode lerroa:                 if ((0, _primitives.isName)(diffEntry)) {
Kode lerroa:                   diffBuf[j] = diffEntry.name;
Kode lerroa:                 } else if ((0, _util.isNum)(diffEntry) || (0, _primitives.isRef)(diffEntry)) {
Kode lerroa:                   diffBuf[j] = diffEntry.toString();
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:               hash.update(diffBuf.join());
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         var toUnicode = dict.get('ToUnicode') || baseDict.get('ToUnicode');
Kode lerroa:         if ((0, _primitives.isStream)(toUnicode)) {
Kode lerroa:           var stream = toUnicode.str || toUnicode;
Kode lerroa:           uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
Kode lerroa:           hash.update(uint8array);
Kode lerroa:         } else if ((0, _primitives.isName)(toUnicode)) {
Kode lerroa:           hash.update(toUnicode.name);
Kode lerroa:         }
Kode lerroa:         var widths = dict.get('Widths') || baseDict.get('Widths');
Kode lerroa:         if (widths) {
Kode lerroa:           uint8array = new Uint8Array(new Uint32Array(widths).buffer);
Kode lerroa:           hash.update(uint8array);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         descriptor: descriptor,
Kode lerroa:         dict: dict,
Kode lerroa:         baseDict: baseDict,
Kode lerroa:         composite: composite,
Kode lerroa:         type: type.name,
Kode lerroa:         hash: hash ? hash.hexdigest() : ''
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     translateFont: function PartialEvaluator_translateFont(preEvaluatedFont) {
Kode lerroa:       var _this11 = this;
Kode lerroa: 
Kode lerroa:       var baseDict = preEvaluatedFont.baseDict;
Kode lerroa:       var dict = preEvaluatedFont.dict;
Kode lerroa:       var composite = preEvaluatedFont.composite;
Kode lerroa:       var descriptor = preEvaluatedFont.descriptor;
Kode lerroa:       var type = preEvaluatedFont.type;
Kode lerroa:       var maxCharIndex = composite ? 0xFFFF : 0xFF;
Kode lerroa:       var properties;
Kode lerroa:       if (!descriptor) {
Kode lerroa:         if (type === 'Type3') {
Kode lerroa:           descriptor = new _primitives.Dict(null);
Kode lerroa:           descriptor.set('FontName', _primitives.Name.get(type));
Kode lerroa:           descriptor.set('FontBBox', dict.getArray('FontBBox'));
Kode lerroa:         } else {
Kode lerroa:           var baseFontName = dict.get('BaseFont');
Kode lerroa:           if (!(0, _primitives.isName)(baseFontName)) {
Kode lerroa:             throw new _util.FormatError('Base font is not specified');
Kode lerroa:           }
Kode lerroa:           baseFontName = baseFontName.name.replace(/[,_]/g, '-');
Kode lerroa:           var metrics = this.getBaseFontMetrics(baseFontName);
Kode lerroa:           var fontNameWoStyle = baseFontName.split('-')[0];
Kode lerroa:           var flags = (this.isSerifFont(fontNameWoStyle) ? _fonts.FontFlags.Serif : 0) | (metrics.monospace ? _fonts.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts.FontFlags.Symbolic : _fonts.FontFlags.Nonsymbolic);
Kode lerroa:           properties = {
Kode lerroa:             type: type,
Kode lerroa:             name: baseFontName,
Kode lerroa:             widths: metrics.widths,
Kode lerroa:             defaultWidth: metrics.defaultWidth,
Kode lerroa:             flags: flags,
Kode lerroa:             firstChar: 0,
Kode lerroa:             lastChar: maxCharIndex
Kode lerroa:           };
Kode lerroa:           return this.extractDataStructures(dict, dict, properties).then(function (properties) {
Kode lerroa:             properties.widths = _this11.buildCharCodeToWidth(metrics.widths, properties);
Kode lerroa:             return new _fonts.Font(baseFontName, null, properties);
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var firstChar = dict.get('FirstChar') || 0;
Kode lerroa:       var lastChar = dict.get('LastChar') || maxCharIndex;
Kode lerroa:       var fontName = descriptor.get('FontName');
Kode lerroa:       var baseFont = dict.get('BaseFont');
Kode lerroa:       if ((0, _util.isString)(fontName)) {
Kode lerroa:         fontName = _primitives.Name.get(fontName);
Kode lerroa:       }
Kode lerroa:       if ((0, _util.isString)(baseFont)) {
Kode lerroa:         baseFont = _primitives.Name.get(baseFont);
Kode lerroa:       }
Kode lerroa:       if (type !== 'Type3') {
Kode lerroa:         var fontNameStr = fontName && fontName.name;
Kode lerroa:         var baseFontStr = baseFont && baseFont.name;
Kode lerroa:         if (fontNameStr !== baseFontStr) {
Kode lerroa:           (0, _util.info)('The FontDescriptor\'s FontName is "' + fontNameStr + '" but should be the same as the Font\'s BaseFont "' + baseFontStr + '"');
Kode lerroa:           if (fontNameStr && baseFontStr && baseFontStr.indexOf(fontNameStr) === 0) {
Kode lerroa:             fontName = baseFont;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       fontName = fontName || baseFont;
Kode lerroa:       if (!(0, _primitives.isName)(fontName)) {
Kode lerroa:         throw new _util.FormatError('invalid font name');
Kode lerroa:       }
Kode lerroa:       var fontFile = descriptor.get('FontFile', 'FontFile2', 'FontFile3');
Kode lerroa:       if (fontFile) {
Kode lerroa:         if (fontFile.dict) {
Kode lerroa:           var subtype = fontFile.dict.get('Subtype');
Kode lerroa:           if (subtype) {
Kode lerroa:             subtype = subtype.name;
Kode lerroa:           }
Kode lerroa:           var length1 = fontFile.dict.get('Length1');
Kode lerroa:           var length2 = fontFile.dict.get('Length2');
Kode lerroa:           var length3 = fontFile.dict.get('Length3');
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       properties = {
Kode lerroa:         type: type,
Kode lerroa:         name: fontName.name,
Kode lerroa:         subtype: subtype,
Kode lerroa:         file: fontFile,
Kode lerroa:         length1: length1,
Kode lerroa:         length2: length2,
Kode lerroa:         length3: length3,
Kode lerroa:         loadedName: baseDict.loadedName,
Kode lerroa:         composite: composite,
Kode lerroa:         wideChars: composite,
Kode lerroa:         fixedPitch: false,
Kode lerroa:         fontMatrix: dict.getArray('FontMatrix') || _util.FONT_IDENTITY_MATRIX,
Kode lerroa:         firstChar: firstChar || 0,
Kode lerroa:         lastChar: lastChar || maxCharIndex,
Kode lerroa:         bbox: descriptor.getArray('FontBBox'),
Kode lerroa:         ascent: descriptor.get('Ascent'),
Kode lerroa:         descent: descriptor.get('Descent'),
Kode lerroa:         xHeight: descriptor.get('XHeight'),
Kode lerroa:         capHeight: descriptor.get('CapHeight'),
Kode lerroa:         flags: descriptor.get('Flags'),
Kode lerroa:         italicAngle: descriptor.get('ItalicAngle'),
Kode lerroa:         isType3Font: false
Kode lerroa:       };
Kode lerroa:       var cMapPromise;
Kode lerroa:       if (composite) {
Kode lerroa:         var cidEncoding = baseDict.get('Encoding');
Kode lerroa:         if ((0, _primitives.isName)(cidEncoding)) {
Kode lerroa:           properties.cidEncoding = cidEncoding.name;
Kode lerroa:         }
Kode lerroa:         cMapPromise = _cmap.CMapFactory.create({
Kode lerroa:           encoding: cidEncoding,
Kode lerroa:           fetchBuiltInCMap: this.fetchBuiltInCMap,
Kode lerroa:           useCMap: null
Kode lerroa:         }).then(function (cMap) {
Kode lerroa:           properties.cMap = cMap;
Kode lerroa:           properties.vertical = properties.cMap.vertical;
Kode lerroa:         });
Kode lerroa:       } else {
Kode lerroa:         cMapPromise = Promise.resolve(undefined);
Kode lerroa:       }
Kode lerroa:       return cMapPromise.then(function () {
Kode lerroa:         return _this11.extractDataStructures(dict, baseDict, properties);
Kode lerroa:       }).then(function (properties) {
Kode lerroa:         _this11.extractWidths(dict, descriptor, properties);
Kode lerroa:         if (type === 'Type3') {
Kode lerroa:           properties.isType3Font = true;
Kode lerroa:         }
Kode lerroa:         return new _fonts.Font(fontName.name, fontFile, properties);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PartialEvaluator;
Kode lerroa: }();
Kode lerroa: var TranslatedFont = function TranslatedFontClosure() {
Kode lerroa:   function TranslatedFont(loadedName, font, dict) {
Kode lerroa:     this.loadedName = loadedName;
Kode lerroa:     this.font = font;
Kode lerroa:     this.dict = dict;
Kode lerroa:     this.type3Loaded = null;
Kode lerroa:     this.sent = false;
Kode lerroa:   }
Kode lerroa:   TranslatedFont.prototype = {
Kode lerroa:     send: function send(handler) {
Kode lerroa:       if (this.sent) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var fontData = this.font.exportData();
Kode lerroa:       handler.send('commonobj', [this.loadedName, 'Font', fontData]);
Kode lerroa:       this.sent = true;
Kode lerroa:     },
Kode lerroa:     loadType3Data: function loadType3Data(evaluator, resources, parentOperatorList, task) {
Kode lerroa:       if (!this.font.isType3Font) {
Kode lerroa:         throw new Error('Must be a Type3 font.');
Kode lerroa:       }
Kode lerroa:       if (this.type3Loaded) {
Kode lerroa:         return this.type3Loaded;
Kode lerroa:       }
Kode lerroa:       var type3Options = Object.create(evaluator.options);
Kode lerroa:       type3Options.ignoreErrors = false;
Kode lerroa:       var type3Evaluator = evaluator.clone(type3Options);
Kode lerroa:       var translatedFont = this.font;
Kode lerroa:       var loadCharProcsPromise = Promise.resolve();
Kode lerroa:       var charProcs = this.dict.get('CharProcs');
Kode lerroa:       var fontResources = this.dict.get('Resources') || resources;
Kode lerroa:       var charProcKeys = charProcs.getKeys();
Kode lerroa:       var charProcOperatorList = Object.create(null);
Kode lerroa: 
Kode lerroa:       var _loop2 = function _loop2() {
Kode lerroa:         var key = charProcKeys[i];
Kode lerroa:         loadCharProcsPromise = loadCharProcsPromise.then(function () {
Kode lerroa:           var glyphStream = charProcs.get(key);
Kode lerroa:           var operatorList = new OperatorList();
Kode lerroa:           return type3Evaluator.getOperatorList({
Kode lerroa:             stream: glyphStream,
Kode lerroa:             task: task,
Kode lerroa:             resources: fontResources,
Kode lerroa:             operatorList: operatorList
Kode lerroa:           }).then(function () {
Kode lerroa:             charProcOperatorList[key] = operatorList.getIR();
Kode lerroa:             parentOperatorList.addDependencies(operatorList.dependencies);
Kode lerroa:           }).catch(function (reason) {
Kode lerroa:             (0, _util.warn)('Type3 font resource "' + key + '" is not available.');
Kode lerroa:             var operatorList = new OperatorList();
Kode lerroa:             charProcOperatorList[key] = operatorList.getIR();
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       };
Kode lerroa: 
Kode lerroa:       for (var i = 0, n = charProcKeys.length; i < n; ++i) {
Kode lerroa:         _loop2();
Kode lerroa:       }
Kode lerroa:       this.type3Loaded = loadCharProcsPromise.then(function () {
Kode lerroa:         translatedFont.charProcOperatorList = charProcOperatorList;
Kode lerroa:       });
Kode lerroa:       return this.type3Loaded;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return TranslatedFont;
Kode lerroa: }();
Kode lerroa: var OperatorList = function OperatorListClosure() {
Kode lerroa:   var CHUNK_SIZE = 1000;
Kode lerroa:   var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;
Kode lerroa:   function getTransfers(queue) {
Kode lerroa:     var transfers = [];
Kode lerroa:     var fnArray = queue.fnArray,
Kode lerroa:         argsArray = queue.argsArray;
Kode lerroa:     for (var i = 0, ii = queue.length; i < ii; i++) {
Kode lerroa:       switch (fnArray[i]) {
Kode lerroa:         case _util.OPS.paintInlineImageXObject:
Kode lerroa:         case _util.OPS.paintInlineImageXObjectGroup:
Kode lerroa:         case _util.OPS.paintImageMaskXObject:
Kode lerroa:           var arg = argsArray[i][0];
Kode lerroa:           if (!arg.cached) {
Kode lerroa:             transfers.push(arg.data.buffer);
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return transfers;
Kode lerroa:   }
Kode lerroa:   function OperatorList(intent, messageHandler, pageIndex) {
Kode lerroa:     this.messageHandler = messageHandler;
Kode lerroa:     this.fnArray = [];
Kode lerroa:     this.argsArray = [];
Kode lerroa:     this.dependencies = Object.create(null);
Kode lerroa:     this._totalLength = 0;
Kode lerroa:     this.pageIndex = pageIndex;
Kode lerroa:     this.intent = intent;
Kode lerroa:   }
Kode lerroa:   OperatorList.prototype = {
Kode lerroa:     get length() {
Kode lerroa:       return this.argsArray.length;
Kode lerroa:     },
Kode lerroa:     get totalLength() {
Kode lerroa:       return this._totalLength + this.length;
Kode lerroa:     },
Kode lerroa:     addOp: function addOp(fn, args) {
Kode lerroa:       this.fnArray.push(fn);
Kode lerroa:       this.argsArray.push(args);
Kode lerroa:       if (this.messageHandler) {
Kode lerroa:         if (this.fnArray.length >= CHUNK_SIZE) {
Kode lerroa:           this.flush();
Kode lerroa:         } else if (this.fnArray.length >= CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
Kode lerroa:           this.flush();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     addDependency: function addDependency(dependency) {
Kode lerroa:       if (dependency in this.dependencies) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.dependencies[dependency] = true;
Kode lerroa:       this.addOp(_util.OPS.dependency, [dependency]);
Kode lerroa:     },
Kode lerroa:     addDependencies: function addDependencies(dependencies) {
Kode lerroa:       for (var key in dependencies) {
Kode lerroa:         this.addDependency(key);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     addOpList: function addOpList(opList) {
Kode lerroa:       _util.Util.extendObj(this.dependencies, opList.dependencies);
Kode lerroa:       for (var i = 0, ii = opList.length; i < ii; i++) {
Kode lerroa:         this.addOp(opList.fnArray[i], opList.argsArray[i]);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     getIR: function getIR() {
Kode lerroa:       return {
Kode lerroa:         fnArray: this.fnArray,
Kode lerroa:         argsArray: this.argsArray,
Kode lerroa:         length: this.length
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     flush: function flush(lastChunk) {
Kode lerroa:       if (this.intent !== 'oplist') {
Kode lerroa:         new QueueOptimizer().optimize(this);
Kode lerroa:       }
Kode lerroa:       var transfers = getTransfers(this);
Kode lerroa:       var length = this.length;
Kode lerroa:       this._totalLength += length;
Kode lerroa:       this.messageHandler.send('RenderPageChunk', {
Kode lerroa:         operatorList: {
Kode lerroa:           fnArray: this.fnArray,
Kode lerroa:           argsArray: this.argsArray,
Kode lerroa:           lastChunk: lastChunk,
Kode lerroa:           length: length
Kode lerroa:         },
Kode lerroa:         pageIndex: this.pageIndex,
Kode lerroa:         intent: this.intent
Kode lerroa:       }, transfers);
Kode lerroa:       this.dependencies = Object.create(null);
Kode lerroa:       this.fnArray.length = 0;
Kode lerroa:       this.argsArray.length = 0;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return OperatorList;
Kode lerroa: }();
Kode lerroa: var StateManager = function StateManagerClosure() {
Kode lerroa:   function StateManager(initialState) {
Kode lerroa:     this.state = initialState;
Kode lerroa:     this.stateStack = [];
Kode lerroa:   }
Kode lerroa:   StateManager.prototype = {
Kode lerroa:     save: function save() {
Kode lerroa:       var old = this.state;
Kode lerroa:       this.stateStack.push(this.state);
Kode lerroa:       this.state = old.clone();
Kode lerroa:     },
Kode lerroa:     restore: function restore() {
Kode lerroa:       var prev = this.stateStack.pop();
Kode lerroa:       if (prev) {
Kode lerroa:         this.state = prev;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     transform: function transform(args) {
Kode lerroa:       this.state.ctm = _util.Util.transform(this.state.ctm, args);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return StateManager;
Kode lerroa: }();
Kode lerroa: var TextState = function TextStateClosure() {
Kode lerroa:   function TextState() {
Kode lerroa:     this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
Kode lerroa:     this.fontName = null;
Kode lerroa:     this.fontSize = 0;
Kode lerroa:     this.font = null;
Kode lerroa:     this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
Kode lerroa:     this.textMatrix = _util.IDENTITY_MATRIX.slice();
Kode lerroa:     this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
Kode lerroa:     this.charSpacing = 0;
Kode lerroa:     this.wordSpacing = 0;
Kode lerroa:     this.leading = 0;
Kode lerroa:     this.textHScale = 1;
Kode lerroa:     this.textRise = 0;
Kode lerroa:   }
Kode lerroa:   TextState.prototype = {
Kode lerroa:     setTextMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
Kode lerroa:       var m = this.textMatrix;
Kode lerroa:       m[0] = a;
Kode lerroa:       m[1] = b;
Kode lerroa:       m[2] = c;
Kode lerroa:       m[3] = d;
Kode lerroa:       m[4] = e;
Kode lerroa:       m[5] = f;
Kode lerroa:     },
Kode lerroa:     setTextLineMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
Kode lerroa:       var m = this.textLineMatrix;
Kode lerroa:       m[0] = a;
Kode lerroa:       m[1] = b;
Kode lerroa:       m[2] = c;
Kode lerroa:       m[3] = d;
Kode lerroa:       m[4] = e;
Kode lerroa:       m[5] = f;
Kode lerroa:     },
Kode lerroa:     translateTextMatrix: function TextState_translateTextMatrix(x, y) {
Kode lerroa:       var m = this.textMatrix;
Kode lerroa:       m[4] = m[0] * x + m[2] * y + m[4];
Kode lerroa:       m[5] = m[1] * x + m[3] * y + m[5];
Kode lerroa:     },
Kode lerroa:     translateTextLineMatrix: function TextState_translateTextMatrix(x, y) {
Kode lerroa:       var m = this.textLineMatrix;
Kode lerroa:       m[4] = m[0] * x + m[2] * y + m[4];
Kode lerroa:       m[5] = m[1] * x + m[3] * y + m[5];
Kode lerroa:     },
Kode lerroa:     calcTextLineMatrixAdvance: function TextState_calcTextLineMatrixAdvance(a, b, c, d, e, f) {
Kode lerroa:       var font = this.font;
Kode lerroa:       if (!font) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var m = this.textLineMatrix;
Kode lerroa:       if (!(a === m[0] && b === m[1] && c === m[2] && d === m[3])) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var txDiff = e - m[4],
Kode lerroa:           tyDiff = f - m[5];
Kode lerroa:       if (font.vertical && txDiff !== 0 || !font.vertical && tyDiff !== 0) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       var tx,
Kode lerroa:           ty,
Kode lerroa:           denominator = a * d - b * c;
Kode lerroa:       if (font.vertical) {
Kode lerroa:         tx = -tyDiff * c / denominator;
Kode lerroa:         ty = tyDiff * a / denominator;
Kode lerroa:       } else {
Kode lerroa:         tx = txDiff * d / denominator;
Kode lerroa:         ty = -txDiff * b / denominator;
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         width: tx,
Kode lerroa:         height: ty,
Kode lerroa:         value: font.vertical ? ty : tx
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
Kode lerroa:       var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
Kode lerroa:       return _util.Util.transform(ctm, _util.Util.transform(this.textMatrix, tsm));
Kode lerroa:     },
Kode lerroa:     carriageReturn: function TextState_carriageReturn() {
Kode lerroa:       this.translateTextLineMatrix(0, -this.leading);
Kode lerroa:       this.textMatrix = this.textLineMatrix.slice();
Kode lerroa:     },
Kode lerroa:     clone: function TextState_clone() {
Kode lerroa:       var clone = Object.create(this);
Kode lerroa:       clone.textMatrix = this.textMatrix.slice();
Kode lerroa:       clone.textLineMatrix = this.textLineMatrix.slice();
Kode lerroa:       clone.fontMatrix = this.fontMatrix.slice();
Kode lerroa:       return clone;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return TextState;
Kode lerroa: }();
Kode lerroa: var EvalState = function EvalStateClosure() {
Kode lerroa:   function EvalState() {
Kode lerroa:     this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
Kode lerroa:     this.font = null;
Kode lerroa:     this.textRenderingMode = _util.TextRenderingMode.FILL;
Kode lerroa:     this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
Kode lerroa:     this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
Kode lerroa:   }
Kode lerroa:   EvalState.prototype = {
Kode lerroa:     clone: function CanvasExtraState_clone() {
Kode lerroa:       return Object.create(this);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return EvalState;
Kode lerroa: }();
Kode lerroa: var EvaluatorPreprocessor = function EvaluatorPreprocessorClosure() {
Kode lerroa:   var getOPMap = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:     t['w'] = {
Kode lerroa:       id: _util.OPS.setLineWidth,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['J'] = {
Kode lerroa:       id: _util.OPS.setLineCap,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['j'] = {
Kode lerroa:       id: _util.OPS.setLineJoin,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['M'] = {
Kode lerroa:       id: _util.OPS.setMiterLimit,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['d'] = {
Kode lerroa:       id: _util.OPS.setDash,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['ri'] = {
Kode lerroa:       id: _util.OPS.setRenderingIntent,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['i'] = {
Kode lerroa:       id: _util.OPS.setFlatness,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['gs'] = {
Kode lerroa:       id: _util.OPS.setGState,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['q'] = {
Kode lerroa:       id: _util.OPS.save,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Q'] = {
Kode lerroa:       id: _util.OPS.restore,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['cm'] = {
Kode lerroa:       id: _util.OPS.transform,
Kode lerroa:       numArgs: 6,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['m'] = {
Kode lerroa:       id: _util.OPS.moveTo,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['l'] = {
Kode lerroa:       id: _util.OPS.lineTo,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['c'] = {
Kode lerroa:       id: _util.OPS.curveTo,
Kode lerroa:       numArgs: 6,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['v'] = {
Kode lerroa:       id: _util.OPS.curveTo2,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['y'] = {
Kode lerroa:       id: _util.OPS.curveTo3,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['h'] = {
Kode lerroa:       id: _util.OPS.closePath,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['re'] = {
Kode lerroa:       id: _util.OPS.rectangle,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['S'] = {
Kode lerroa:       id: _util.OPS.stroke,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['s'] = {
Kode lerroa:       id: _util.OPS.closeStroke,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['f'] = {
Kode lerroa:       id: _util.OPS.fill,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['F'] = {
Kode lerroa:       id: _util.OPS.fill,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['f*'] = {
Kode lerroa:       id: _util.OPS.eoFill,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['B'] = {
Kode lerroa:       id: _util.OPS.fillStroke,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['B*'] = {
Kode lerroa:       id: _util.OPS.eoFillStroke,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['b'] = {
Kode lerroa:       id: _util.OPS.closeFillStroke,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['b*'] = {
Kode lerroa:       id: _util.OPS.closeEOFillStroke,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['n'] = {
Kode lerroa:       id: _util.OPS.endPath,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['W'] = {
Kode lerroa:       id: _util.OPS.clip,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['W*'] = {
Kode lerroa:       id: _util.OPS.eoClip,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['BT'] = {
Kode lerroa:       id: _util.OPS.beginText,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['ET'] = {
Kode lerroa:       id: _util.OPS.endText,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tc'] = {
Kode lerroa:       id: _util.OPS.setCharSpacing,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tw'] = {
Kode lerroa:       id: _util.OPS.setWordSpacing,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tz'] = {
Kode lerroa:       id: _util.OPS.setHScale,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['TL'] = {
Kode lerroa:       id: _util.OPS.setLeading,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tf'] = {
Kode lerroa:       id: _util.OPS.setFont,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tr'] = {
Kode lerroa:       id: _util.OPS.setTextRenderingMode,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Ts'] = {
Kode lerroa:       id: _util.OPS.setTextRise,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Td'] = {
Kode lerroa:       id: _util.OPS.moveText,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['TD'] = {
Kode lerroa:       id: _util.OPS.setLeadingMoveText,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tm'] = {
Kode lerroa:       id: _util.OPS.setTextMatrix,
Kode lerroa:       numArgs: 6,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['T*'] = {
Kode lerroa:       id: _util.OPS.nextLine,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Tj'] = {
Kode lerroa:       id: _util.OPS.showText,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['TJ'] = {
Kode lerroa:       id: _util.OPS.showSpacedText,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['\''] = {
Kode lerroa:       id: _util.OPS.nextLineShowText,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['"'] = {
Kode lerroa:       id: _util.OPS.nextLineSetSpacingShowText,
Kode lerroa:       numArgs: 3,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['d0'] = {
Kode lerroa:       id: _util.OPS.setCharWidth,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['d1'] = {
Kode lerroa:       id: _util.OPS.setCharWidthAndBounds,
Kode lerroa:       numArgs: 6,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['CS'] = {
Kode lerroa:       id: _util.OPS.setStrokeColorSpace,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['cs'] = {
Kode lerroa:       id: _util.OPS.setFillColorSpace,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['SC'] = {
Kode lerroa:       id: _util.OPS.setStrokeColor,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: true
Kode lerroa:     };
Kode lerroa:     t['SCN'] = {
Kode lerroa:       id: _util.OPS.setStrokeColorN,
Kode lerroa:       numArgs: 33,
Kode lerroa:       variableArgs: true
Kode lerroa:     };
Kode lerroa:     t['sc'] = {
Kode lerroa:       id: _util.OPS.setFillColor,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: true
Kode lerroa:     };
Kode lerroa:     t['scn'] = {
Kode lerroa:       id: _util.OPS.setFillColorN,
Kode lerroa:       numArgs: 33,
Kode lerroa:       variableArgs: true
Kode lerroa:     };
Kode lerroa:     t['G'] = {
Kode lerroa:       id: _util.OPS.setStrokeGray,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['g'] = {
Kode lerroa:       id: _util.OPS.setFillGray,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['RG'] = {
Kode lerroa:       id: _util.OPS.setStrokeRGBColor,
Kode lerroa:       numArgs: 3,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['rg'] = {
Kode lerroa:       id: _util.OPS.setFillRGBColor,
Kode lerroa:       numArgs: 3,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['K'] = {
Kode lerroa:       id: _util.OPS.setStrokeCMYKColor,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['k'] = {
Kode lerroa:       id: _util.OPS.setFillCMYKColor,
Kode lerroa:       numArgs: 4,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['sh'] = {
Kode lerroa:       id: _util.OPS.shadingFill,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['BI'] = {
Kode lerroa:       id: _util.OPS.beginInlineImage,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['ID'] = {
Kode lerroa:       id: _util.OPS.beginImageData,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['EI'] = {
Kode lerroa:       id: _util.OPS.endInlineImage,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['Do'] = {
Kode lerroa:       id: _util.OPS.paintXObject,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['MP'] = {
Kode lerroa:       id: _util.OPS.markPoint,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['DP'] = {
Kode lerroa:       id: _util.OPS.markPointProps,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['BMC'] = {
Kode lerroa:       id: _util.OPS.beginMarkedContent,
Kode lerroa:       numArgs: 1,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['BDC'] = {
Kode lerroa:       id: _util.OPS.beginMarkedContentProps,
Kode lerroa:       numArgs: 2,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['EMC'] = {
Kode lerroa:       id: _util.OPS.endMarkedContent,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['BX'] = {
Kode lerroa:       id: _util.OPS.beginCompat,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['EX'] = {
Kode lerroa:       id: _util.OPS.endCompat,
Kode lerroa:       numArgs: 0,
Kode lerroa:       variableArgs: false
Kode lerroa:     };
Kode lerroa:     t['BM'] = null;
Kode lerroa:     t['BD'] = null;
Kode lerroa:     t['true'] = null;
Kode lerroa:     t['fa'] = null;
Kode lerroa:     t['fal'] = null;
Kode lerroa:     t['fals'] = null;
Kode lerroa:     t['false'] = null;
Kode lerroa:     t['nu'] = null;
Kode lerroa:     t['nul'] = null;
Kode lerroa:     t['null'] = null;
Kode lerroa:   });
Kode lerroa:   function EvaluatorPreprocessor(stream, xref, stateManager) {
Kode lerroa:     this.opMap = getOPMap();
Kode lerroa:     this.parser = new _parser.Parser(new _parser.Lexer(stream, this.opMap), false, xref);
Kode lerroa:     this.stateManager = stateManager;
Kode lerroa:     this.nonProcessedArgs = [];
Kode lerroa:   }
Kode lerroa:   EvaluatorPreprocessor.prototype = {
Kode lerroa:     get savedStatesDepth() {
Kode lerroa:       return this.stateManager.stateStack.length;
Kode lerroa:     },
Kode lerroa:     read: function EvaluatorPreprocessor_read(operation) {
Kode lerroa:       var args = operation.args;
Kode lerroa:       while (true) {
Kode lerroa:         var obj = this.parser.getObj();
Kode lerroa:         if ((0, _primitives.isCmd)(obj)) {
Kode lerroa:           var cmd = obj.cmd;
Kode lerroa:           var opSpec = this.opMap[cmd];
Kode lerroa:           if (!opSpec) {
Kode lerroa:             (0, _util.warn)('Unknown command "' + cmd + '"');
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           var fn = opSpec.id;
Kode lerroa:           var numArgs = opSpec.numArgs;
Kode lerroa:           var argsLength = args !== null ? args.length : 0;
Kode lerroa:           if (!opSpec.variableArgs) {
Kode lerroa:             if (argsLength !== numArgs) {
Kode lerroa:               var nonProcessedArgs = this.nonProcessedArgs;
Kode lerroa:               while (argsLength > numArgs) {
Kode lerroa:                 nonProcessedArgs.push(args.shift());
Kode lerroa:                 argsLength--;
Kode lerroa:               }
Kode lerroa:               while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
Kode lerroa:                 if (args === null) {
Kode lerroa:                   args = [];
Kode lerroa:                 }
Kode lerroa:                 args.unshift(nonProcessedArgs.pop());
Kode lerroa:                 argsLength++;
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             if (argsLength < numArgs) {
Kode lerroa:               (0, _util.warn)('Skipping command ' + fn + ': expected ' + numArgs + ' args, but received ' + argsLength + ' args.');
Kode lerroa:               if (args !== null) {
Kode lerroa:                 args.length = 0;
Kode lerroa:               }
Kode lerroa:               continue;
Kode lerroa:             }
Kode lerroa:           } else if (argsLength > numArgs) {
Kode lerroa:             (0, _util.info)('Command ' + fn + ': expected [0,' + numArgs + '] args, but received ' + argsLength + ' args.');
Kode lerroa:           }
Kode lerroa:           this.preprocessCommand(fn, args);
Kode lerroa:           operation.fn = fn;
Kode lerroa:           operation.args = args;
Kode lerroa:           return true;
Kode lerroa:         }
Kode lerroa:         if ((0, _primitives.isEOF)(obj)) {
Kode lerroa:           return false;
Kode lerroa:         }
Kode lerroa:         if (obj !== null) {
Kode lerroa:           if (args === null) {
Kode lerroa:             args = [];
Kode lerroa:           }
Kode lerroa:           args.push(obj);
Kode lerroa:           if (args.length > 33) {
Kode lerroa:             throw new _util.FormatError('Too many arguments');
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     preprocessCommand: function EvaluatorPreprocessor_preprocessCommand(fn, args) {
Kode lerroa:       switch (fn | 0) {
Kode lerroa:         case _util.OPS.save:
Kode lerroa:           this.stateManager.save();
Kode lerroa:           break;
Kode lerroa:         case _util.OPS.restore:
Kode lerroa:           this.stateManager.restore();
Kode lerroa:           break;
Kode lerroa:         case _util.OPS.transform:
Kode lerroa:           this.stateManager.transform(args);
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return EvaluatorPreprocessor;
Kode lerroa: }();
Kode lerroa: var QueueOptimizer = function QueueOptimizerClosure() {
Kode lerroa:   function addState(parentState, pattern, fn) {
Kode lerroa:     var state = parentState;
Kode lerroa:     for (var i = 0, ii = pattern.length - 1; i < ii; i++) {
Kode lerroa:       var item = pattern[i];
Kode lerroa:       state = state[item] || (state[item] = []);
Kode lerroa:     }
Kode lerroa:     state[pattern[pattern.length - 1]] = fn;
Kode lerroa:   }
Kode lerroa:   function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
Kode lerroa:     var iFirstPIMXO = iFirstSave + 2;
Kode lerroa:     for (var i = 0; i < count; i++) {
Kode lerroa:       var arg = argsArray[iFirstPIMXO + 4 * i];
Kode lerroa:       var imageMask = arg.length === 1 && arg[0];
Kode lerroa:       if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
Kode lerroa:         fnArray[iFirstPIMXO + 4 * i] = _util.OPS.paintSolidColorImageMask;
Kode lerroa:         continue;
Kode lerroa:       }
Kode lerroa:       break;
Kode lerroa:     }
Kode lerroa:     return count - i;
Kode lerroa:   }
Kode lerroa:   var InitialState = [];
Kode lerroa:   addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], function foundInlineImageGroup(context) {
Kode lerroa:     var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
Kode lerroa:     var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
Kode lerroa:     var MAX_WIDTH = 1000;
Kode lerroa:     var IMAGE_PADDING = 1;
Kode lerroa:     var fnArray = context.fnArray,
Kode lerroa:         argsArray = context.argsArray;
Kode lerroa:     var curr = context.iCurr;
Kode lerroa:     var iFirstSave = curr - 3;
Kode lerroa:     var iFirstTransform = curr - 2;
Kode lerroa:     var iFirstPIIXO = curr - 1;
Kode lerroa:     var i = iFirstSave + 4;
Kode lerroa:     var ii = fnArray.length;
Kode lerroa:     while (i + 3 < ii) {
Kode lerroa:       if (fnArray[i] !== _util.OPS.save || fnArray[i + 1] !== _util.OPS.transform || fnArray[i + 2] !== _util.OPS.paintInlineImageXObject || fnArray[i + 3] !== _util.OPS.restore) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       i += 4;
Kode lerroa:     }
Kode lerroa:     var count = Math.min((i - iFirstSave) / 4, MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
Kode lerroa:     if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
Kode lerroa:       return i;
Kode lerroa:     }
Kode lerroa:     var maxX = 0;
Kode lerroa:     var map = [],
Kode lerroa:         maxLineHeight = 0;
Kode lerroa:     var currentX = IMAGE_PADDING,
Kode lerroa:         currentY = IMAGE_PADDING;
Kode lerroa:     var q;
Kode lerroa:     for (q = 0; q < count; q++) {
Kode lerroa:       var transform = argsArray[iFirstTransform + (q << 2)];
Kode lerroa:       var img = argsArray[iFirstPIIXO + (q << 2)][0];
Kode lerroa:       if (currentX + img.width > MAX_WIDTH) {
Kode lerroa:         maxX = Math.max(maxX, currentX);
Kode lerroa:         currentY += maxLineHeight + 2 * IMAGE_PADDING;
Kode lerroa:         currentX = 0;
Kode lerroa:         maxLineHeight = 0;
Kode lerroa:       }
Kode lerroa:       map.push({
Kode lerroa:         transform: transform,
Kode lerroa:         x: currentX,
Kode lerroa:         y: currentY,
Kode lerroa:         w: img.width,
Kode lerroa:         h: img.height
Kode lerroa:       });
Kode lerroa:       currentX += img.width + 2 * IMAGE_PADDING;
Kode lerroa:       maxLineHeight = Math.max(maxLineHeight, img.height);
Kode lerroa:     }
Kode lerroa:     var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
Kode lerroa:     var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
Kode lerroa:     var imgData = new Uint8Array(imgWidth * imgHeight * 4);
Kode lerroa:     var imgRowSize = imgWidth << 2;
Kode lerroa:     for (q = 0; q < count; q++) {
Kode lerroa:       var data = argsArray[iFirstPIIXO + (q << 2)][0].data;
Kode lerroa:       var rowSize = map[q].w << 2;
Kode lerroa:       var dataOffset = 0;
Kode lerroa:       var offset = map[q].x + map[q].y * imgWidth << 2;
Kode lerroa:       imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
Kode lerroa:       for (var k = 0, kk = map[q].h; k < kk; k++) {
Kode lerroa:         imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
Kode lerroa:         dataOffset += rowSize;
Kode lerroa:         offset += imgRowSize;
Kode lerroa:       }
Kode lerroa:       imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
Kode lerroa:       while (offset >= 0) {
Kode lerroa:         data[offset - 4] = data[offset];
Kode lerroa:         data[offset - 3] = data[offset + 1];
Kode lerroa:         data[offset - 2] = data[offset + 2];
Kode lerroa:         data[offset - 1] = data[offset + 3];
Kode lerroa:         data[offset + rowSize] = data[offset + rowSize - 4];
Kode lerroa:         data[offset + rowSize + 1] = data[offset + rowSize - 3];
Kode lerroa:         data[offset + rowSize + 2] = data[offset + rowSize - 2];
Kode lerroa:         data[offset + rowSize + 3] = data[offset + rowSize - 1];
Kode lerroa:         offset -= imgRowSize;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
Kode lerroa:     argsArray.splice(iFirstSave, count * 4, [{
Kode lerroa:       width: imgWidth,
Kode lerroa:       height: imgHeight,
Kode lerroa:       kind: _util.ImageKind.RGBA_32BPP,
Kode lerroa:       data: imgData
Kode lerroa:     }, map]);
Kode lerroa:     return iFirstSave + 1;
Kode lerroa:   });
Kode lerroa:   addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], function foundImageMaskGroup(context) {
Kode lerroa:     var MIN_IMAGES_IN_MASKS_BLOCK = 10;
Kode lerroa:     var MAX_IMAGES_IN_MASKS_BLOCK = 100;
Kode lerroa:     var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
Kode lerroa:     var fnArray = context.fnArray,
Kode lerroa:         argsArray = context.argsArray;
Kode lerroa:     var curr = context.iCurr;
Kode lerroa:     var iFirstSave = curr - 3;
Kode lerroa:     var iFirstTransform = curr - 2;
Kode lerroa:     var iFirstPIMXO = curr - 1;
Kode lerroa:     var i = iFirstSave + 4;
Kode lerroa:     var ii = fnArray.length;
Kode lerroa:     while (i + 3 < ii) {
Kode lerroa:       if (fnArray[i] !== _util.OPS.save || fnArray[i + 1] !== _util.OPS.transform || fnArray[i + 2] !== _util.OPS.paintImageMaskXObject || fnArray[i + 3] !== _util.OPS.restore) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       i += 4;
Kode lerroa:     }
Kode lerroa:     var count = (i - iFirstSave) / 4;
Kode lerroa:     count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
Kode lerroa:     if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
Kode lerroa:       return i;
Kode lerroa:     }
Kode lerroa:     var q;
Kode lerroa:     var isSameImage = false;
Kode lerroa:     var iTransform, transformArgs;
Kode lerroa:     var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
Kode lerroa:     if (argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0) {
Kode lerroa:       isSameImage = true;
Kode lerroa:       var firstTransformArg0 = argsArray[iFirstTransform][0];
Kode lerroa:       var firstTransformArg3 = argsArray[iFirstTransform][3];
Kode lerroa:       iTransform = iFirstTransform + 4;
Kode lerroa:       var iPIMXO = iFirstPIMXO + 4;
Kode lerroa:       for (q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
Kode lerroa:         transformArgs = argsArray[iTransform];
Kode lerroa:         if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== 0 || transformArgs[2] !== 0 || transformArgs[3] !== firstTransformArg3) {
Kode lerroa:           if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
Kode lerroa:             isSameImage = false;
Kode lerroa:           } else {
Kode lerroa:             count = q;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (isSameImage) {
Kode lerroa:       count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
Kode lerroa:       var positions = new Float32Array(count * 2);
Kode lerroa:       iTransform = iFirstTransform;
Kode lerroa:       for (q = 0; q < count; q++, iTransform += 4) {
Kode lerroa:         transformArgs = argsArray[iTransform];
Kode lerroa:         positions[q << 1] = transformArgs[4];
Kode lerroa:         positions[(q << 1) + 1] = transformArgs[5];
Kode lerroa:       }
Kode lerroa:       fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
Kode lerroa:       argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg3, positions]);
Kode lerroa:     } else {
Kode lerroa:       count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
Kode lerroa:       var images = [];
Kode lerroa:       for (q = 0; q < count; q++) {
Kode lerroa:         transformArgs = argsArray[iFirstTransform + (q << 2)];
Kode lerroa:         var maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
Kode lerroa:         images.push({
Kode lerroa:           data: maskParams.data,
Kode lerroa:           width: maskParams.width,
Kode lerroa:           height: maskParams.height,
Kode lerroa:           transform: transformArgs
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
Kode lerroa:       argsArray.splice(iFirstSave, count * 4, [images]);
Kode lerroa:     }
Kode lerroa:     return iFirstSave + 1;
Kode lerroa:   });
Kode lerroa:   addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function (context) {
Kode lerroa:     var MIN_IMAGES_IN_BLOCK = 3;
Kode lerroa:     var MAX_IMAGES_IN_BLOCK = 1000;
Kode lerroa:     var fnArray = context.fnArray,
Kode lerroa:         argsArray = context.argsArray;
Kode lerroa:     var curr = context.iCurr;
Kode lerroa:     var iFirstSave = curr - 3;
Kode lerroa:     var iFirstTransform = curr - 2;
Kode lerroa:     var iFirstPIXO = curr - 1;
Kode lerroa:     var iFirstRestore = curr;
Kode lerroa:     if (argsArray[iFirstTransform][1] !== 0 || argsArray[iFirstTransform][2] !== 0) {
Kode lerroa:       return iFirstRestore + 1;
Kode lerroa:     }
Kode lerroa:     var firstPIXOArg0 = argsArray[iFirstPIXO][0];
Kode lerroa:     var firstTransformArg0 = argsArray[iFirstTransform][0];
Kode lerroa:     var firstTransformArg3 = argsArray[iFirstTransform][3];
Kode lerroa:     var i = iFirstSave + 4;
Kode lerroa:     var ii = fnArray.length;
Kode lerroa:     while (i + 3 < ii) {
Kode lerroa:       if (fnArray[i] !== _util.OPS.save || fnArray[i + 1] !== _util.OPS.transform || fnArray[i + 2] !== _util.OPS.paintImageXObject || fnArray[i + 3] !== _util.OPS.restore) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       if (argsArray[i + 1][0] !== firstTransformArg0 || argsArray[i + 1][1] !== 0 || argsArray[i + 1][2] !== 0 || argsArray[i + 1][3] !== firstTransformArg3) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       if (argsArray[i + 2][0] !== firstPIXOArg0) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       i += 4;
Kode lerroa:     }
Kode lerroa:     var count = Math.min((i - iFirstSave) / 4, MAX_IMAGES_IN_BLOCK);
Kode lerroa:     if (count < MIN_IMAGES_IN_BLOCK) {
Kode lerroa:       return i;
Kode lerroa:     }
Kode lerroa:     var positions = new Float32Array(count * 2);
Kode lerroa:     var iTransform = iFirstTransform;
Kode lerroa:     for (var q = 0; q < count; q++, iTransform += 4) {
Kode lerroa:       var transformArgs = argsArray[iTransform];
Kode lerroa:       positions[q << 1] = transformArgs[4];
Kode lerroa:       positions[(q << 1) + 1] = transformArgs[5];
Kode lerroa:     }
Kode lerroa:     var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
Kode lerroa:     fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
Kode lerroa:     argsArray.splice(iFirstSave, count * 4, args);
Kode lerroa:     return iFirstSave + 1;
Kode lerroa:   });
Kode lerroa:   addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], function (context) {
Kode lerroa:     var MIN_CHARS_IN_BLOCK = 3;
Kode lerroa:     var MAX_CHARS_IN_BLOCK = 1000;
Kode lerroa:     var fnArray = context.fnArray,
Kode lerroa:         argsArray = context.argsArray;
Kode lerroa:     var curr = context.iCurr;
Kode lerroa:     var iFirstBeginText = curr - 4;
Kode lerroa:     var iFirstSetFont = curr - 3;
Kode lerroa:     var iFirstSetTextMatrix = curr - 2;
Kode lerroa:     var iFirstShowText = curr - 1;
Kode lerroa:     var iFirstEndText = curr;
Kode lerroa:     var firstSetFontArg0 = argsArray[iFirstSetFont][0];
Kode lerroa:     var firstSetFontArg1 = argsArray[iFirstSetFont][1];
Kode lerroa:     var i = iFirstBeginText + 5;
Kode lerroa:     var ii = fnArray.length;
Kode lerroa:     while (i + 4 < ii) {
Kode lerroa:       if (fnArray[i] !== _util.OPS.beginText || fnArray[i + 1] !== _util.OPS.setFont || fnArray[i + 2] !== _util.OPS.setTextMatrix || fnArray[i + 3] !== _util.OPS.showText || fnArray[i + 4] !== _util.OPS.endText) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       if (argsArray[i + 1][0] !== firstSetFontArg0 || argsArray[i + 1][1] !== firstSetFontArg1) {
Kode lerroa:         break;
Kode lerroa:       }
Kode lerroa:       i += 5;
Kode lerroa:     }
Kode lerroa:     var count = Math.min((i - iFirstBeginText) / 5, MAX_CHARS_IN_BLOCK);
Kode lerroa:     if (count < MIN_CHARS_IN_BLOCK) {
Kode lerroa:       return i;
Kode lerroa:     }
Kode lerroa:     var iFirst = iFirstBeginText;
Kode lerroa:     if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
Kode lerroa:       count++;
Kode lerroa:       iFirst -= 5;
Kode lerroa:     }
Kode lerroa:     var iEndText = iFirst + 4;
Kode lerroa:     for (var q = 1; q < count; q++) {
Kode lerroa:       fnArray.splice(iEndText, 3);
Kode lerroa:       argsArray.splice(iEndText, 3);
Kode lerroa:       iEndText += 2;
Kode lerroa:     }
Kode lerroa:     return iEndText + 1;
Kode lerroa:   });
Kode lerroa:   function QueueOptimizer() {}
Kode lerroa:   QueueOptimizer.prototype = {
Kode lerroa:     optimize: function QueueOptimizer_optimize(queue) {
Kode lerroa:       var fnArray = queue.fnArray,
Kode lerroa:           argsArray = queue.argsArray;
Kode lerroa:       var context = {
Kode lerroa:         iCurr: 0,
Kode lerroa:         fnArray: fnArray,
Kode lerroa:         argsArray: argsArray
Kode lerroa:       };
Kode lerroa:       var state;
Kode lerroa:       var i = 0,
Kode lerroa:           ii = fnArray.length;
Kode lerroa:       while (i < ii) {
Kode lerroa:         state = (state || InitialState)[fnArray[i]];
Kode lerroa:         if (typeof state === 'function') {
Kode lerroa:           context.iCurr = i;
Kode lerroa:           i = state(context);
Kode lerroa:           state = undefined;
Kode lerroa:           ii = context.fnArray.length;
Kode lerroa:         } else {
Kode lerroa:           i++;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return QueueOptimizer;
Kode lerroa: }();
Kode lerroa: exports.OperatorList = OperatorList;
Kode lerroa: exports.PartialEvaluator = PartialEvaluator;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 78 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.CFFCompiler = exports.CFFPrivateDict = exports.CFFTopDict = exports.CFFCharset = exports.CFFIndex = exports.CFFStrings = exports.CFFHeader = exports.CFF = exports.CFFParser = exports.CFFStandardStrings = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _charsets = __w_pdfjs_require__(136);
Kode lerroa: 
Kode lerroa: var _encodings = __w_pdfjs_require__(28);
Kode lerroa: 
Kode lerroa: var MAX_SUBR_NESTING = 10;
Kode lerroa: var CFFStandardStrings = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000', '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];
Kode lerroa: var CFFParser = function CFFParserClosure() {
Kode lerroa:   var CharstringValidationData = [null, {
Kode lerroa:     id: 'hstem',
Kode lerroa:     min: 2,
Kode lerroa:     stackClearing: true,
Kode lerroa:     stem: true
Kode lerroa:   }, null, {
Kode lerroa:     id: 'vstem',
Kode lerroa:     min: 2,
Kode lerroa:     stackClearing: true,
Kode lerroa:     stem: true
Kode lerroa:   }, {
Kode lerroa:     id: 'vmoveto',
Kode lerroa:     min: 1,
Kode lerroa:     stackClearing: true
Kode lerroa:   }, {
Kode lerroa:     id: 'rlineto',
Kode lerroa:     min: 2,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'hlineto',
Kode lerroa:     min: 1,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'vlineto',
Kode lerroa:     min: 1,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'rrcurveto',
Kode lerroa:     min: 6,
Kode lerroa:     resetStack: true
Kode lerroa:   }, null, {
Kode lerroa:     id: 'callsubr',
Kode lerroa:     min: 1,
Kode lerroa:     undefStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'return',
Kode lerroa:     min: 0,
Kode lerroa:     undefStack: true
Kode lerroa:   }, null, null, {
Kode lerroa:     id: 'endchar',
Kode lerroa:     min: 0,
Kode lerroa:     stackClearing: true
Kode lerroa:   }, null, null, null, {
Kode lerroa:     id: 'hstemhm',
Kode lerroa:     min: 2,
Kode lerroa:     stackClearing: true,
Kode lerroa:     stem: true
Kode lerroa:   }, {
Kode lerroa:     id: 'hintmask',
Kode lerroa:     min: 0,
Kode lerroa:     stackClearing: true
Kode lerroa:   }, {
Kode lerroa:     id: 'cntrmask',
Kode lerroa:     min: 0,
Kode lerroa:     stackClearing: true
Kode lerroa:   }, {
Kode lerroa:     id: 'rmoveto',
Kode lerroa:     min: 2,
Kode lerroa:     stackClearing: true
Kode lerroa:   }, {
Kode lerroa:     id: 'hmoveto',
Kode lerroa:     min: 1,
Kode lerroa:     stackClearing: true
Kode lerroa:   }, {
Kode lerroa:     id: 'vstemhm',
Kode lerroa:     min: 2,
Kode lerroa:     stackClearing: true,
Kode lerroa:     stem: true
Kode lerroa:   }, {
Kode lerroa:     id: 'rcurveline',
Kode lerroa:     min: 8,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'rlinecurve',
Kode lerroa:     min: 8,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'vvcurveto',
Kode lerroa:     min: 4,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'hhcurveto',
Kode lerroa:     min: 4,
Kode lerroa:     resetStack: true
Kode lerroa:   }, null, {
Kode lerroa:     id: 'callgsubr',
Kode lerroa:     min: 1,
Kode lerroa:     undefStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'vhcurveto',
Kode lerroa:     min: 4,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'hvcurveto',
Kode lerroa:     min: 4,
Kode lerroa:     resetStack: true
Kode lerroa:   }];
Kode lerroa:   var CharstringValidationData12 = [null, null, null, {
Kode lerroa:     id: 'and',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1
Kode lerroa:   }, {
Kode lerroa:     id: 'or',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1
Kode lerroa:   }, {
Kode lerroa:     id: 'not',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: 0
Kode lerroa:   }, null, null, null, {
Kode lerroa:     id: 'abs',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: 0
Kode lerroa:   }, {
Kode lerroa:     id: 'add',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1,
Kode lerroa:     stackFn: function stack_div(stack, index) {
Kode lerroa:       stack[index - 2] = stack[index - 2] + stack[index - 1];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     id: 'sub',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1,
Kode lerroa:     stackFn: function stack_div(stack, index) {
Kode lerroa:       stack[index - 2] = stack[index - 2] - stack[index - 1];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     id: 'div',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1,
Kode lerroa:     stackFn: function stack_div(stack, index) {
Kode lerroa:       stack[index - 2] = stack[index - 2] / stack[index - 1];
Kode lerroa:     }
Kode lerroa:   }, null, {
Kode lerroa:     id: 'neg',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: 0,
Kode lerroa:     stackFn: function stack_div(stack, index) {
Kode lerroa:       stack[index - 1] = -stack[index - 1];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     id: 'eq',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1
Kode lerroa:   }, null, null, {
Kode lerroa:     id: 'drop',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: -1
Kode lerroa:   }, null, {
Kode lerroa:     id: 'put',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -2
Kode lerroa:   }, {
Kode lerroa:     id: 'get',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: 0
Kode lerroa:   }, {
Kode lerroa:     id: 'ifelse',
Kode lerroa:     min: 4,
Kode lerroa:     stackDelta: -3
Kode lerroa:   }, {
Kode lerroa:     id: 'random',
Kode lerroa:     min: 0,
Kode lerroa:     stackDelta: 1
Kode lerroa:   }, {
Kode lerroa:     id: 'mul',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: -1,
Kode lerroa:     stackFn: function stack_div(stack, index) {
Kode lerroa:       stack[index - 2] = stack[index - 2] * stack[index - 1];
Kode lerroa:     }
Kode lerroa:   }, null, {
Kode lerroa:     id: 'sqrt',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: 0
Kode lerroa:   }, {
Kode lerroa:     id: 'dup',
Kode lerroa:     min: 1,
Kode lerroa:     stackDelta: 1
Kode lerroa:   }, {
Kode lerroa:     id: 'exch',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: 0
Kode lerroa:   }, {
Kode lerroa:     id: 'index',
Kode lerroa:     min: 2,
Kode lerroa:     stackDelta: 0
Kode lerroa:   }, {
Kode lerroa:     id: 'roll',
Kode lerroa:     min: 3,
Kode lerroa:     stackDelta: -2
Kode lerroa:   }, null, null, null, {
Kode lerroa:     id: 'hflex',
Kode lerroa:     min: 7,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'flex',
Kode lerroa:     min: 13,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'hflex1',
Kode lerroa:     min: 9,
Kode lerroa:     resetStack: true
Kode lerroa:   }, {
Kode lerroa:     id: 'flex1',
Kode lerroa:     min: 11,
Kode lerroa:     resetStack: true
Kode lerroa:   }];
Kode lerroa:   function CFFParser(file, properties, seacAnalysisEnabled) {
Kode lerroa:     this.bytes = file.getBytes();
Kode lerroa:     this.properties = properties;
Kode lerroa:     this.seacAnalysisEnabled = !!seacAnalysisEnabled;
Kode lerroa:   }
Kode lerroa:   CFFParser.prototype = {
Kode lerroa:     parse: function CFFParser_parse() {
Kode lerroa:       var properties = this.properties;
Kode lerroa:       var cff = new CFF();
Kode lerroa:       this.cff = cff;
Kode lerroa:       var header = this.parseHeader();
Kode lerroa:       var nameIndex = this.parseIndex(header.endPos);
Kode lerroa:       var topDictIndex = this.parseIndex(nameIndex.endPos);
Kode lerroa:       var stringIndex = this.parseIndex(topDictIndex.endPos);
Kode lerroa:       var globalSubrIndex = this.parseIndex(stringIndex.endPos);
Kode lerroa:       var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
Kode lerroa:       var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
Kode lerroa:       cff.header = header.obj;
Kode lerroa:       cff.names = this.parseNameIndex(nameIndex.obj);
Kode lerroa:       cff.strings = this.parseStringIndex(stringIndex.obj);
Kode lerroa:       cff.topDict = topDict;
Kode lerroa:       cff.globalSubrIndex = globalSubrIndex.obj;
Kode lerroa:       this.parsePrivateDict(cff.topDict);
Kode lerroa:       cff.isCIDFont = topDict.hasName('ROS');
Kode lerroa:       var charStringOffset = topDict.getByName('CharStrings');
Kode lerroa:       var charStringIndex = this.parseIndex(charStringOffset).obj;
Kode lerroa:       var fontMatrix = topDict.getByName('FontMatrix');
Kode lerroa:       if (fontMatrix) {
Kode lerroa:         properties.fontMatrix = fontMatrix;
Kode lerroa:       }
Kode lerroa:       var fontBBox = topDict.getByName('FontBBox');
Kode lerroa:       if (fontBBox) {
Kode lerroa:         properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
Kode lerroa:         properties.descent = Math.min(fontBBox[1], fontBBox[3]);
Kode lerroa:         properties.ascentScaled = true;
Kode lerroa:       }
Kode lerroa:       var charset, encoding;
Kode lerroa:       if (cff.isCIDFont) {
Kode lerroa:         var fdArrayIndex = this.parseIndex(topDict.getByName('FDArray')).obj;
Kode lerroa:         for (var i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
Kode lerroa:           var dictRaw = fdArrayIndex.get(i);
Kode lerroa:           var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
Kode lerroa:           this.parsePrivateDict(fontDict);
Kode lerroa:           cff.fdArray.push(fontDict);
Kode lerroa:         }
Kode lerroa:         encoding = null;
Kode lerroa:         charset = this.parseCharsets(topDict.getByName('charset'), charStringIndex.count, cff.strings, true);
Kode lerroa:         cff.fdSelect = this.parseFDSelect(topDict.getByName('FDSelect'), charStringIndex.count);
Kode lerroa:       } else {
Kode lerroa:         charset = this.parseCharsets(topDict.getByName('charset'), charStringIndex.count, cff.strings, false);
Kode lerroa:         encoding = this.parseEncoding(topDict.getByName('Encoding'), properties, cff.strings, charset.charset);
Kode lerroa:       }
Kode lerroa:       cff.charset = charset;
Kode lerroa:       cff.encoding = encoding;
Kode lerroa:       var charStringsAndSeacs = this.parseCharStrings({
Kode lerroa:         charStrings: charStringIndex,
Kode lerroa:         localSubrIndex: topDict.privateDict.subrsIndex,
Kode lerroa:         globalSubrIndex: globalSubrIndex.obj,
Kode lerroa:         fdSelect: cff.fdSelect,
Kode lerroa:         fdArray: cff.fdArray,
Kode lerroa:         privateDict: topDict.privateDict
Kode lerroa:       });
Kode lerroa:       cff.charStrings = charStringsAndSeacs.charStrings;
Kode lerroa:       cff.seacs = charStringsAndSeacs.seacs;
Kode lerroa:       cff.widths = charStringsAndSeacs.widths;
Kode lerroa:       return cff;
Kode lerroa:     },
Kode lerroa:     parseHeader: function CFFParser_parseHeader() {
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var bytesLength = bytes.length;
Kode lerroa:       var offset = 0;
Kode lerroa:       while (offset < bytesLength && bytes[offset] !== 1) {
Kode lerroa:         ++offset;
Kode lerroa:       }
Kode lerroa:       if (offset >= bytesLength) {
Kode lerroa:         throw new _util.FormatError('Invalid CFF header');
Kode lerroa:       }
Kode lerroa:       if (offset !== 0) {
Kode lerroa:         (0, _util.info)('cff data is shifted');
Kode lerroa:         bytes = bytes.subarray(offset);
Kode lerroa:         this.bytes = bytes;
Kode lerroa:       }
Kode lerroa:       var major = bytes[0];
Kode lerroa:       var minor = bytes[1];
Kode lerroa:       var hdrSize = bytes[2];
Kode lerroa:       var offSize = bytes[3];
Kode lerroa:       var header = new CFFHeader(major, minor, hdrSize, offSize);
Kode lerroa:       return {
Kode lerroa:         obj: header,
Kode lerroa:         endPos: hdrSize
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     parseDict: function CFFParser_parseDict(dict) {
Kode lerroa:       var pos = 0;
Kode lerroa:       function parseOperand() {
Kode lerroa:         var value = dict[pos++];
Kode lerroa:         if (value === 30) {
Kode lerroa:           return parseFloatOperand();
Kode lerroa:         } else if (value === 28) {
Kode lerroa:           value = dict[pos++];
Kode lerroa:           value = (value << 24 | dict[pos++] << 16) >> 16;
Kode lerroa:           return value;
Kode lerroa:         } else if (value === 29) {
Kode lerroa:           value = dict[pos++];
Kode lerroa:           value = value << 8 | dict[pos++];
Kode lerroa:           value = value << 8 | dict[pos++];
Kode lerroa:           value = value << 8 | dict[pos++];
Kode lerroa:           return value;
Kode lerroa:         } else if (value >= 32 && value <= 246) {
Kode lerroa:           return value - 139;
Kode lerroa:         } else if (value >= 247 && value <= 250) {
Kode lerroa:           return (value - 247) * 256 + dict[pos++] + 108;
Kode lerroa:         } else if (value >= 251 && value <= 254) {
Kode lerroa:           return -((value - 251) * 256) - dict[pos++] - 108;
Kode lerroa:         }
Kode lerroa:         (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
Kode lerroa:         return NaN;
Kode lerroa:       }
Kode lerroa:       function parseFloatOperand() {
Kode lerroa:         var str = '';
Kode lerroa:         var eof = 15;
Kode lerroa:         var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
Kode lerroa:         var length = dict.length;
Kode lerroa:         while (pos < length) {
Kode lerroa:           var b = dict[pos++];
Kode lerroa:           var b1 = b >> 4;
Kode lerroa:           var b2 = b & 15;
Kode lerroa:           if (b1 === eof) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           str += lookup[b1];
Kode lerroa:           if (b2 === eof) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           str += lookup[b2];
Kode lerroa:         }
Kode lerroa:         return parseFloat(str);
Kode lerroa:       }
Kode lerroa:       var operands = [];
Kode lerroa:       var entries = [];
Kode lerroa:       pos = 0;
Kode lerroa:       var end = dict.length;
Kode lerroa:       while (pos < end) {
Kode lerroa:         var b = dict[pos];
Kode lerroa:         if (b <= 21) {
Kode lerroa:           if (b === 12) {
Kode lerroa:             b = b << 8 | dict[++pos];
Kode lerroa:           }
Kode lerroa:           entries.push([b, operands]);
Kode lerroa:           operands = [];
Kode lerroa:           ++pos;
Kode lerroa:         } else {
Kode lerroa:           operands.push(parseOperand());
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return entries;
Kode lerroa:     },
Kode lerroa:     parseIndex: function CFFParser_parseIndex(pos) {
Kode lerroa:       var cffIndex = new CFFIndex();
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var count = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:       var offsets = [];
Kode lerroa:       var end = pos;
Kode lerroa:       var i, ii;
Kode lerroa:       if (count !== 0) {
Kode lerroa:         var offsetSize = bytes[pos++];
Kode lerroa:         var startPos = pos + (count + 1) * offsetSize - 1;
Kode lerroa:         for (i = 0, ii = count + 1; i < ii; ++i) {
Kode lerroa:           var offset = 0;
Kode lerroa:           for (var j = 0; j < offsetSize; ++j) {
Kode lerroa:             offset <<= 8;
Kode lerroa:             offset += bytes[pos++];
Kode lerroa:           }
Kode lerroa:           offsets.push(startPos + offset);
Kode lerroa:         }
Kode lerroa:         end = offsets[count];
Kode lerroa:       }
Kode lerroa:       for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
Kode lerroa:         var offsetStart = offsets[i];
Kode lerroa:         var offsetEnd = offsets[i + 1];
Kode lerroa:         cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         obj: cffIndex,
Kode lerroa:         endPos: end
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     parseNameIndex: function CFFParser_parseNameIndex(index) {
Kode lerroa:       var names = [];
Kode lerroa:       for (var i = 0, ii = index.count; i < ii; ++i) {
Kode lerroa:         var name = index.get(i);
Kode lerroa:         names.push((0, _util.bytesToString)(name));
Kode lerroa:       }
Kode lerroa:       return names;
Kode lerroa:     },
Kode lerroa:     parseStringIndex: function CFFParser_parseStringIndex(index) {
Kode lerroa:       var strings = new CFFStrings();
Kode lerroa:       for (var i = 0, ii = index.count; i < ii; ++i) {
Kode lerroa:         var data = index.get(i);
Kode lerroa:         strings.add((0, _util.bytesToString)(data));
Kode lerroa:       }
Kode lerroa:       return strings;
Kode lerroa:     },
Kode lerroa:     createDict: function CFFParser_createDict(Type, dict, strings) {
Kode lerroa:       var cffDict = new Type(strings);
Kode lerroa:       for (var i = 0, ii = dict.length; i < ii; ++i) {
Kode lerroa:         var pair = dict[i];
Kode lerroa:         var key = pair[0];
Kode lerroa:         var value = pair[1];
Kode lerroa:         cffDict.setByKey(key, value);
Kode lerroa:       }
Kode lerroa:       return cffDict;
Kode lerroa:     },
Kode lerroa:     parseCharString: function CFFParser_parseCharString(state, data, localSubrIndex, globalSubrIndex) {
Kode lerroa:       if (!data || state.callDepth > MAX_SUBR_NESTING) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       var stackSize = state.stackSize;
Kode lerroa:       var stack = state.stack;
Kode lerroa:       var length = data.length;
Kode lerroa:       for (var j = 0; j < length;) {
Kode lerroa:         var value = data[j++];
Kode lerroa:         var validationCommand = null;
Kode lerroa:         if (value === 12) {
Kode lerroa:           var q = data[j++];
Kode lerroa:           if (q === 0) {
Kode lerroa:             data[j - 2] = 139;
Kode lerroa:             data[j - 1] = 22;
Kode lerroa:             stackSize = 0;
Kode lerroa:           } else {
Kode lerroa:             validationCommand = CharstringValidationData12[q];
Kode lerroa:           }
Kode lerroa:         } else if (value === 28) {
Kode lerroa:           stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
Kode lerroa:           j += 2;
Kode lerroa:           stackSize++;
Kode lerroa:         } else if (value === 14) {
Kode lerroa:           if (stackSize >= 4) {
Kode lerroa:             stackSize -= 4;
Kode lerroa:             if (this.seacAnalysisEnabled) {
Kode lerroa:               state.seac = stack.slice(stackSize, stackSize + 4);
Kode lerroa:               return false;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           validationCommand = CharstringValidationData[value];
Kode lerroa:         } else if (value >= 32 && value <= 246) {
Kode lerroa:           stack[stackSize] = value - 139;
Kode lerroa:           stackSize++;
Kode lerroa:         } else if (value >= 247 && value <= 254) {
Kode lerroa:           stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
Kode lerroa:           j++;
Kode lerroa:           stackSize++;
Kode lerroa:         } else if (value === 255) {
Kode lerroa:           stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
Kode lerroa:           j += 4;
Kode lerroa:           stackSize++;
Kode lerroa:         } else if (value === 19 || value === 20) {
Kode lerroa:           state.hints += stackSize >> 1;
Kode lerroa:           j += state.hints + 7 >> 3;
Kode lerroa:           stackSize %= 2;
Kode lerroa:           validationCommand = CharstringValidationData[value];
Kode lerroa:         } else if (value === 10 || value === 29) {
Kode lerroa:           var subrsIndex;
Kode lerroa:           if (value === 10) {
Kode lerroa:             subrsIndex = localSubrIndex;
Kode lerroa:           } else {
Kode lerroa:             subrsIndex = globalSubrIndex;
Kode lerroa:           }
Kode lerroa:           if (!subrsIndex) {
Kode lerroa:             validationCommand = CharstringValidationData[value];
Kode lerroa:             (0, _util.warn)('Missing subrsIndex for ' + validationCommand.id);
Kode lerroa:             return false;
Kode lerroa:           }
Kode lerroa:           var bias = 32768;
Kode lerroa:           if (subrsIndex.count < 1240) {
Kode lerroa:             bias = 107;
Kode lerroa:           } else if (subrsIndex.count < 33900) {
Kode lerroa:             bias = 1131;
Kode lerroa:           }
Kode lerroa:           var subrNumber = stack[--stackSize] + bias;
Kode lerroa:           if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
Kode lerroa:             validationCommand = CharstringValidationData[value];
Kode lerroa:             (0, _util.warn)('Out of bounds subrIndex for ' + validationCommand.id);
Kode lerroa:             return false;
Kode lerroa:           }
Kode lerroa:           state.stackSize = stackSize;
Kode lerroa:           state.callDepth++;
Kode lerroa:           var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
Kode lerroa:           if (!valid) {
Kode lerroa:             return false;
Kode lerroa:           }
Kode lerroa:           state.callDepth--;
Kode lerroa:           stackSize = state.stackSize;
Kode lerroa:           continue;
Kode lerroa:         } else if (value === 11) {
Kode lerroa:           state.stackSize = stackSize;
Kode lerroa:           return true;
Kode lerroa:         } else {
Kode lerroa:           validationCommand = CharstringValidationData[value];
Kode lerroa:         }
Kode lerroa:         if (validationCommand) {
Kode lerroa:           if (validationCommand.stem) {
Kode lerroa:             state.hints += stackSize >> 1;
Kode lerroa:           }
Kode lerroa:           if ('min' in validationCommand) {
Kode lerroa:             if (!state.undefStack && stackSize < validationCommand.min) {
Kode lerroa:               (0, _util.warn)('Not enough parameters for ' + validationCommand.id + '; actual: ' + stackSize + ', expected: ' + validationCommand.min);
Kode lerroa:               return false;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           if (state.firstStackClearing && validationCommand.stackClearing) {
Kode lerroa:             state.firstStackClearing = false;
Kode lerroa:             stackSize -= validationCommand.min;
Kode lerroa:             if (stackSize >= 2 && validationCommand.stem) {
Kode lerroa:               stackSize %= 2;
Kode lerroa:             } else if (stackSize > 1) {
Kode lerroa:               (0, _util.warn)('Found too many parameters for stack-clearing command');
Kode lerroa:             }
Kode lerroa:             if (stackSize > 0 && stack[stackSize - 1] >= 0) {
Kode lerroa:               state.width = stack[stackSize - 1];
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           if ('stackDelta' in validationCommand) {
Kode lerroa:             if ('stackFn' in validationCommand) {
Kode lerroa:               validationCommand.stackFn(stack, stackSize);
Kode lerroa:             }
Kode lerroa:             stackSize += validationCommand.stackDelta;
Kode lerroa:           } else if (validationCommand.stackClearing) {
Kode lerroa:             stackSize = 0;
Kode lerroa:           } else if (validationCommand.resetStack) {
Kode lerroa:             stackSize = 0;
Kode lerroa:             state.undefStack = false;
Kode lerroa:           } else if (validationCommand.undefStack) {
Kode lerroa:             stackSize = 0;
Kode lerroa:             state.undefStack = true;
Kode lerroa:             state.firstStackClearing = false;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       state.stackSize = stackSize;
Kode lerroa:       return true;
Kode lerroa:     },
Kode lerroa:     parseCharStrings: function parseCharStrings(_ref) {
Kode lerroa:       var charStrings = _ref.charStrings,
Kode lerroa:           localSubrIndex = _ref.localSubrIndex,
Kode lerroa:           globalSubrIndex = _ref.globalSubrIndex,
Kode lerroa:           fdSelect = _ref.fdSelect,
Kode lerroa:           fdArray = _ref.fdArray,
Kode lerroa:           privateDict = _ref.privateDict;
Kode lerroa: 
Kode lerroa:       var seacs = [];
Kode lerroa:       var widths = [];
Kode lerroa:       var count = charStrings.count;
Kode lerroa:       for (var i = 0; i < count; i++) {
Kode lerroa:         var charstring = charStrings.get(i);
Kode lerroa:         var state = {
Kode lerroa:           callDepth: 0,
Kode lerroa:           stackSize: 0,
Kode lerroa:           stack: [],
Kode lerroa:           undefStack: true,
Kode lerroa:           hints: 0,
Kode lerroa:           firstStackClearing: true,
Kode lerroa:           seac: null,
Kode lerroa:           width: null
Kode lerroa:         };
Kode lerroa:         var valid = true;
Kode lerroa:         var localSubrToUse = null;
Kode lerroa:         var privateDictToUse = privateDict;
Kode lerroa:         if (fdSelect && fdArray.length) {
Kode lerroa:           var fdIndex = fdSelect.getFDIndex(i);
Kode lerroa:           if (fdIndex === -1) {
Kode lerroa:             (0, _util.warn)('Glyph index is not in fd select.');
Kode lerroa:             valid = false;
Kode lerroa:           }
Kode lerroa:           if (fdIndex >= fdArray.length) {
Kode lerroa:             (0, _util.warn)('Invalid fd index for glyph index.');
Kode lerroa:             valid = false;
Kode lerroa:           }
Kode lerroa:           if (valid) {
Kode lerroa:             privateDictToUse = fdArray[fdIndex].privateDict;
Kode lerroa:             localSubrToUse = privateDictToUse.subrsIndex;
Kode lerroa:           }
Kode lerroa:         } else if (localSubrIndex) {
Kode lerroa:           localSubrToUse = localSubrIndex;
Kode lerroa:         }
Kode lerroa:         if (valid) {
Kode lerroa:           valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
Kode lerroa:         }
Kode lerroa:         if (state.width !== null) {
Kode lerroa:           var nominalWidth = privateDictToUse.getByName('nominalWidthX');
Kode lerroa:           widths[i] = nominalWidth + state.width;
Kode lerroa:         } else {
Kode lerroa:           var defaultWidth = privateDictToUse.getByName('defaultWidthX');
Kode lerroa:           widths[i] = defaultWidth;
Kode lerroa:         }
Kode lerroa:         if (state.seac !== null) {
Kode lerroa:           seacs[i] = state.seac;
Kode lerroa:         }
Kode lerroa:         if (!valid) {
Kode lerroa:           charStrings.set(i, new Uint8Array([14]));
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         charStrings: charStrings,
Kode lerroa:         seacs: seacs,
Kode lerroa:         widths: widths
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa: 
Kode lerroa:     emptyPrivateDictionary: function CFFParser_emptyPrivateDictionary(parentDict) {
Kode lerroa:       var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
Kode lerroa:       parentDict.setByKey(18, [0, 0]);
Kode lerroa:       parentDict.privateDict = privateDict;
Kode lerroa:     },
Kode lerroa:     parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
Kode lerroa:       if (!parentDict.hasName('Private')) {
Kode lerroa:         this.emptyPrivateDictionary(parentDict);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var privateOffset = parentDict.getByName('Private');
Kode lerroa:       if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
Kode lerroa:         parentDict.removeByName('Private');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var size = privateOffset[0];
Kode lerroa:       var offset = privateOffset[1];
Kode lerroa:       if (size === 0 || offset >= this.bytes.length) {
Kode lerroa:         this.emptyPrivateDictionary(parentDict);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var privateDictEnd = offset + size;
Kode lerroa:       var dictData = this.bytes.subarray(offset, privateDictEnd);
Kode lerroa:       var dict = this.parseDict(dictData);
Kode lerroa:       var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
Kode lerroa:       parentDict.privateDict = privateDict;
Kode lerroa:       if (!privateDict.getByName('Subrs')) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var subrsOffset = privateDict.getByName('Subrs');
Kode lerroa:       var relativeOffset = offset + subrsOffset;
Kode lerroa:       if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
Kode lerroa:         this.emptyPrivateDictionary(parentDict);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var subrsIndex = this.parseIndex(relativeOffset);
Kode lerroa:       privateDict.subrsIndex = subrsIndex.obj;
Kode lerroa:     },
Kode lerroa:     parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
Kode lerroa:       if (pos === 0) {
Kode lerroa:         return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
Kode lerroa:       } else if (pos === 1) {
Kode lerroa:         return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
Kode lerroa:       } else if (pos === 2) {
Kode lerroa:         return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
Kode lerroa:       }
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var start = pos;
Kode lerroa:       var format = bytes[pos++];
Kode lerroa:       var charset = ['.notdef'];
Kode lerroa:       var id, count, i;
Kode lerroa:       length -= 1;
Kode lerroa:       switch (format) {
Kode lerroa:         case 0:
Kode lerroa:           for (i = 0; i < length; i++) {
Kode lerroa:             id = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:             charset.push(cid ? id : strings.get(id));
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 1:
Kode lerroa:           while (charset.length <= length) {
Kode lerroa:             id = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:             count = bytes[pos++];
Kode lerroa:             for (i = 0; i <= count; i++) {
Kode lerroa:               charset.push(cid ? id++ : strings.get(id++));
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 2:
Kode lerroa:           while (charset.length <= length) {
Kode lerroa:             id = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:             count = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:             for (i = 0; i <= count; i++) {
Kode lerroa:               charset.push(cid ? id++ : strings.get(id++));
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           throw new _util.FormatError('Unknown charset format');
Kode lerroa:       }
Kode lerroa:       var end = pos;
Kode lerroa:       var raw = bytes.subarray(start, end);
Kode lerroa:       return new CFFCharset(false, format, charset, raw);
Kode lerroa:     },
Kode lerroa:     parseEncoding: function CFFParser_parseEncoding(pos, properties, strings, charset) {
Kode lerroa:       var encoding = Object.create(null);
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var predefined = false;
Kode lerroa:       var format, i, ii;
Kode lerroa:       var raw = null;
Kode lerroa:       function readSupplement() {
Kode lerroa:         var supplementsCount = bytes[pos++];
Kode lerroa:         for (i = 0; i < supplementsCount; i++) {
Kode lerroa:           var code = bytes[pos++];
Kode lerroa:           var sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);
Kode lerroa:           encoding[code] = charset.indexOf(strings.get(sid));
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (pos === 0 || pos === 1) {
Kode lerroa:         predefined = true;
Kode lerroa:         format = pos;
Kode lerroa:         var baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
Kode lerroa:         for (i = 0, ii = charset.length; i < ii; i++) {
Kode lerroa:           var index = baseEncoding.indexOf(charset[i]);
Kode lerroa:           if (index !== -1) {
Kode lerroa:             encoding[index] = i;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         var dataStart = pos;
Kode lerroa:         format = bytes[pos++];
Kode lerroa:         switch (format & 0x7f) {
Kode lerroa:           case 0:
Kode lerroa:             var glyphsCount = bytes[pos++];
Kode lerroa:             for (i = 1; i <= glyphsCount; i++) {
Kode lerroa:               encoding[bytes[pos++]] = i;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 1:
Kode lerroa:             var rangesCount = bytes[pos++];
Kode lerroa:             var gid = 1;
Kode lerroa:             for (i = 0; i < rangesCount; i++) {
Kode lerroa:               var start = bytes[pos++];
Kode lerroa:               var left = bytes[pos++];
Kode lerroa:               for (var j = start; j <= start + left; j++) {
Kode lerroa:                 encoding[j] = gid++;
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             throw new _util.FormatError('Unknown encoding format: ' + format + ' in CFF');
Kode lerroa:         }
Kode lerroa:         var dataEnd = pos;
Kode lerroa:         if (format & 0x80) {
Kode lerroa:           bytes[dataStart] &= 0x7f;
Kode lerroa:           readSupplement();
Kode lerroa:         }
Kode lerroa:         raw = bytes.subarray(dataStart, dataEnd);
Kode lerroa:       }
Kode lerroa:       format = format & 0x7f;
Kode lerroa:       return new CFFEncoding(predefined, format, encoding, raw);
Kode lerroa:     },
Kode lerroa:     parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
Kode lerroa:       var start = pos;
Kode lerroa:       var bytes = this.bytes;
Kode lerroa:       var format = bytes[pos++];
Kode lerroa:       var fdSelect = [],
Kode lerroa:           rawBytes;
Kode lerroa:       var i,
Kode lerroa:           invalidFirstGID = false;
Kode lerroa:       switch (format) {
Kode lerroa:         case 0:
Kode lerroa:           for (i = 0; i < length; ++i) {
Kode lerroa:             var id = bytes[pos++];
Kode lerroa:             fdSelect.push(id);
Kode lerroa:           }
Kode lerroa:           rawBytes = bytes.subarray(start, pos);
Kode lerroa:           break;
Kode lerroa:         case 3:
Kode lerroa:           var rangesCount = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:           for (i = 0; i < rangesCount; ++i) {
Kode lerroa:             var first = bytes[pos++] << 8 | bytes[pos++];
Kode lerroa:             if (i === 0 && first !== 0) {
Kode lerroa:               (0, _util.warn)('parseFDSelect: The first range must have a first GID of 0' + ' -- trying to recover.');
Kode lerroa:               invalidFirstGID = true;
Kode lerroa:               first = 0;
Kode lerroa:             }
Kode lerroa:             var fdIndex = bytes[pos++];
Kode lerroa:             var next = bytes[pos] << 8 | bytes[pos + 1];
Kode lerroa:             for (var j = first; j < next; ++j) {
Kode lerroa:               fdSelect.push(fdIndex);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           pos += 2;
Kode lerroa:           rawBytes = bytes.subarray(start, pos);
Kode lerroa:           if (invalidFirstGID) {
Kode lerroa:             rawBytes[3] = rawBytes[4] = 0;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           throw new _util.FormatError('parseFDSelect: Unknown format "' + format + '".');
Kode lerroa:       }
Kode lerroa:       if (fdSelect.length !== length) {
Kode lerroa:         throw new _util.FormatError('parseFDSelect: Invalid font data.');
Kode lerroa:       }
Kode lerroa:       return new CFFFDSelect(fdSelect, rawBytes);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CFFParser;
Kode lerroa: }();
Kode lerroa: var CFF = function CFFClosure() {
Kode lerroa:   function CFF() {
Kode lerroa:     this.header = null;
Kode lerroa:     this.names = [];
Kode lerroa:     this.topDict = null;
Kode lerroa:     this.strings = new CFFStrings();
Kode lerroa:     this.globalSubrIndex = null;
Kode lerroa:     this.encoding = null;
Kode lerroa:     this.charset = null;
Kode lerroa:     this.charStrings = null;
Kode lerroa:     this.fdArray = [];
Kode lerroa:     this.fdSelect = null;
Kode lerroa:     this.isCIDFont = false;
Kode lerroa:   }
Kode lerroa:   return CFF;
Kode lerroa: }();
Kode lerroa: var CFFHeader = function CFFHeaderClosure() {
Kode lerroa:   function CFFHeader(major, minor, hdrSize, offSize) {
Kode lerroa:     this.major = major;
Kode lerroa:     this.minor = minor;
Kode lerroa:     this.hdrSize = hdrSize;
Kode lerroa:     this.offSize = offSize;
Kode lerroa:   }
Kode lerroa:   return CFFHeader;
Kode lerroa: }();
Kode lerroa: var CFFStrings = function CFFStringsClosure() {
Kode lerroa:   function CFFStrings() {
Kode lerroa:     this.strings = [];
Kode lerroa:   }
Kode lerroa:   CFFStrings.prototype = {
Kode lerroa:     get: function CFFStrings_get(index) {
Kode lerroa:       if (index >= 0 && index <= 390) {
Kode lerroa:         return CFFStandardStrings[index];
Kode lerroa:       }
Kode lerroa:       if (index - 391 <= this.strings.length) {
Kode lerroa:         return this.strings[index - 391];
Kode lerroa:       }
Kode lerroa:       return CFFStandardStrings[0];
Kode lerroa:     },
Kode lerroa:     add: function CFFStrings_add(value) {
Kode lerroa:       this.strings.push(value);
Kode lerroa:     },
Kode lerroa:     get count() {
Kode lerroa:       return this.strings.length;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CFFStrings;
Kode lerroa: }();
Kode lerroa: var CFFIndex = function CFFIndexClosure() {
Kode lerroa:   function CFFIndex() {
Kode lerroa:     this.objects = [];
Kode lerroa:     this.length = 0;
Kode lerroa:   }
Kode lerroa:   CFFIndex.prototype = {
Kode lerroa:     add: function CFFIndex_add(data) {
Kode lerroa:       this.length += data.length;
Kode lerroa:       this.objects.push(data);
Kode lerroa:     },
Kode lerroa:     set: function CFFIndex_set(index, data) {
Kode lerroa:       this.length += data.length - this.objects[index].length;
Kode lerroa:       this.objects[index] = data;
Kode lerroa:     },
Kode lerroa:     get: function CFFIndex_get(index) {
Kode lerroa:       return this.objects[index];
Kode lerroa:     },
Kode lerroa:     get count() {
Kode lerroa:       return this.objects.length;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CFFIndex;
Kode lerroa: }();
Kode lerroa: var CFFDict = function CFFDictClosure() {
Kode lerroa:   function CFFDict(tables, strings) {
Kode lerroa:     this.keyToNameMap = tables.keyToNameMap;
Kode lerroa:     this.nameToKeyMap = tables.nameToKeyMap;
Kode lerroa:     this.defaults = tables.defaults;
Kode lerroa:     this.types = tables.types;
Kode lerroa:     this.opcodes = tables.opcodes;
Kode lerroa:     this.order = tables.order;
Kode lerroa:     this.strings = strings;
Kode lerroa:     this.values = Object.create(null);
Kode lerroa:   }
Kode lerroa:   CFFDict.prototype = {
Kode lerroa:     setByKey: function CFFDict_setByKey(key, value) {
Kode lerroa:       if (!(key in this.keyToNameMap)) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       var valueLength = value.length;
Kode lerroa:       if (valueLength === 0) {
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:       for (var i = 0; i < valueLength; i++) {
Kode lerroa:         if (isNaN(value[i])) {
Kode lerroa:           (0, _util.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
Kode lerroa:           return true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var type = this.types[key];
Kode lerroa:       if (type === 'num' || type === 'sid' || type === 'offset') {
Kode lerroa:         value = value[0];
Kode lerroa:       }
Kode lerroa:       this.values[key] = value;
Kode lerroa:       return true;
Kode lerroa:     },
Kode lerroa:     setByName: function CFFDict_setByName(name, value) {
Kode lerroa:       if (!(name in this.nameToKeyMap)) {
Kode lerroa:         throw new _util.FormatError('Invalid dictionary name "' + name + '"');
Kode lerroa:       }
Kode lerroa:       this.values[this.nameToKeyMap[name]] = value;
Kode lerroa:     },
Kode lerroa:     hasName: function CFFDict_hasName(name) {
Kode lerroa:       return this.nameToKeyMap[name] in this.values;
Kode lerroa:     },
Kode lerroa:     getByName: function CFFDict_getByName(name) {
Kode lerroa:       if (!(name in this.nameToKeyMap)) {
Kode lerroa:         throw new _util.FormatError('Invalid dictionary name ' + name + '"');
Kode lerroa:       }
Kode lerroa:       var key = this.nameToKeyMap[name];
Kode lerroa:       if (!(key in this.values)) {
Kode lerroa:         return this.defaults[key];
Kode lerroa:       }
Kode lerroa:       return this.values[key];
Kode lerroa:     },
Kode lerroa:     removeByName: function CFFDict_removeByName(name) {
Kode lerroa:       delete this.values[this.nameToKeyMap[name]];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   CFFDict.createTables = function CFFDict_createTables(layout) {
Kode lerroa:     var tables = {
Kode lerroa:       keyToNameMap: {},
Kode lerroa:       nameToKeyMap: {},
Kode lerroa:       defaults: {},
Kode lerroa:       types: {},
Kode lerroa:       opcodes: {},
Kode lerroa:       order: []
Kode lerroa:     };
Kode lerroa:     for (var i = 0, ii = layout.length; i < ii; ++i) {
Kode lerroa:       var entry = layout[i];
Kode lerroa:       var key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
Kode lerroa:       tables.keyToNameMap[key] = entry[1];
Kode lerroa:       tables.nameToKeyMap[entry[1]] = key;
Kode lerroa:       tables.types[key] = entry[2];
Kode lerroa:       tables.defaults[key] = entry[3];
Kode lerroa:       tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
Kode lerroa:       tables.order.push(key);
Kode lerroa:     }
Kode lerroa:     return tables;
Kode lerroa:   };
Kode lerroa:   return CFFDict;
Kode lerroa: }();
Kode lerroa: var CFFTopDict = function CFFTopDictClosure() {
Kode lerroa:   var layout = [[[12, 30], 'ROS', ['sid', 'sid', 'num'], null], [[12, 20], 'SyntheticBase', 'num', null], [0, 'version', 'sid', null], [1, 'Notice', 'sid', null], [[12, 0], 'Copyright', 'sid', null], [2, 'FullName', 'sid', null], [3, 'FamilyName', 'sid', null], [4, 'Weight', 'sid', null], [[12, 1], 'isFixedPitch', 'num', 0], [[12, 2], 'ItalicAngle', 'num', 0], [[12, 3], 'UnderlinePosition', 'num', -100], [[12, 4], 'UnderlineThickness', 'num', 50], [[12, 5], 'PaintType', 'num', 0], [[12, 6], 'CharstringType', 'num', 2], [[12, 7], 'FontMatrix', ['num', 'num', 'num', 'num', 'num', 'num'], [0.001, 0, 0, 0.001, 0, 0]], [13, 'UniqueID', 'num', null], [5, 'FontBBox', ['num', 'num', 'num', 'num'], [0, 0, 0, 0]], [[12, 8], 'StrokeWidth', 'num', 0], [14, 'XUID', 'array', null], [15, 'charset', 'offset', 0], [16, 'Encoding', 'offset', 0], [17, 'CharStrings', 'offset', 0], [18, 'Private', ['offset', 'offset'], null], [[12, 21], 'PostScript', 'sid', null], [[12, 22], 'BaseFontName', 'sid', null], [[12, 23], 'BaseFontBlend', 'delta', null], [[12, 31], 'CIDFontVersion', 'num', 0], [[12, 32], 'CIDFontRevision', 'num', 0], [[12, 33], 'CIDFontType', 'num', 0], [[12, 34], 'CIDCount', 'num', 8720], [[12, 35], 'UIDBase', 'num', null], [[12, 37], 'FDSelect', 'offset', null], [[12, 36], 'FDArray', 'offset', null], [[12, 38], 'FontName', 'sid', null]];
Kode lerroa:   var tables = null;
Kode lerroa:   function CFFTopDict(strings) {
Kode lerroa:     if (tables === null) {
Kode lerroa:       tables = CFFDict.createTables(layout);
Kode lerroa:     }
Kode lerroa:     CFFDict.call(this, tables, strings);
Kode lerroa:     this.privateDict = null;
Kode lerroa:   }
Kode lerroa:   CFFTopDict.prototype = Object.create(CFFDict.prototype);
Kode lerroa:   return CFFTopDict;
Kode lerroa: }();
Kode lerroa: var CFFPrivateDict = function CFFPrivateDictClosure() {
Kode lerroa:   var layout = [[6, 'BlueValues', 'delta', null], [7, 'OtherBlues', 'delta', null], [8, 'FamilyBlues', 'delta', null], [9, 'FamilyOtherBlues', 'delta', null], [[12, 9], 'BlueScale', 'num', 0.039625], [[12, 10], 'BlueShift', 'num', 7], [[12, 11], 'BlueFuzz', 'num', 1], [10, 'StdHW', 'num', null], [11, 'StdVW', 'num', null], [[12, 12], 'StemSnapH', 'delta', null], [[12, 13], 'StemSnapV', 'delta', null], [[12, 14], 'ForceBold', 'num', 0], [[12, 17], 'LanguageGroup', 'num', 0], [[12, 18], 'ExpansionFactor', 'num', 0.06], [[12, 19], 'initialRandomSeed', 'num', 0], [20, 'defaultWidthX', 'num', 0], [21, 'nominalWidthX', 'num', 0], [19, 'Subrs', 'offset', null]];
Kode lerroa:   var tables = null;
Kode lerroa:   function CFFPrivateDict(strings) {
Kode lerroa:     if (tables === null) {
Kode lerroa:       tables = CFFDict.createTables(layout);
Kode lerroa:     }
Kode lerroa:     CFFDict.call(this, tables, strings);
Kode lerroa:     this.subrsIndex = null;
Kode lerroa:   }
Kode lerroa:   CFFPrivateDict.prototype = Object.create(CFFDict.prototype);
Kode lerroa:   return CFFPrivateDict;
Kode lerroa: }();
Kode lerroa: var CFFCharsetPredefinedTypes = {
Kode lerroa:   ISO_ADOBE: 0,
Kode lerroa:   EXPERT: 1,
Kode lerroa:   EXPERT_SUBSET: 2
Kode lerroa: };
Kode lerroa: var CFFCharset = function CFFCharsetClosure() {
Kode lerroa:   function CFFCharset(predefined, format, charset, raw) {
Kode lerroa:     this.predefined = predefined;
Kode lerroa:     this.format = format;
Kode lerroa:     this.charset = charset;
Kode lerroa:     this.raw = raw;
Kode lerroa:   }
Kode lerroa:   return CFFCharset;
Kode lerroa: }();
Kode lerroa: var CFFEncoding = function CFFEncodingClosure() {
Kode lerroa:   function CFFEncoding(predefined, format, encoding, raw) {
Kode lerroa:     this.predefined = predefined;
Kode lerroa:     this.format = format;
Kode lerroa:     this.encoding = encoding;
Kode lerroa:     this.raw = raw;
Kode lerroa:   }
Kode lerroa:   return CFFEncoding;
Kode lerroa: }();
Kode lerroa: var CFFFDSelect = function CFFFDSelectClosure() {
Kode lerroa:   function CFFFDSelect(fdSelect, raw) {
Kode lerroa:     this.fdSelect = fdSelect;
Kode lerroa:     this.raw = raw;
Kode lerroa:   }
Kode lerroa:   CFFFDSelect.prototype = {
Kode lerroa:     getFDIndex: function CFFFDSelect_get(glyphIndex) {
Kode lerroa:       if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
Kode lerroa:         return -1;
Kode lerroa:       }
Kode lerroa:       return this.fdSelect[glyphIndex];
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CFFFDSelect;
Kode lerroa: }();
Kode lerroa: var CFFOffsetTracker = function CFFOffsetTrackerClosure() {
Kode lerroa:   function CFFOffsetTracker() {
Kode lerroa:     this.offsets = Object.create(null);
Kode lerroa:   }
Kode lerroa:   CFFOffsetTracker.prototype = {
Kode lerroa:     isTracking: function CFFOffsetTracker_isTracking(key) {
Kode lerroa:       return key in this.offsets;
Kode lerroa:     },
Kode lerroa:     track: function CFFOffsetTracker_track(key, location) {
Kode lerroa:       if (key in this.offsets) {
Kode lerroa:         throw new _util.FormatError('Already tracking location of ' + key);
Kode lerroa:       }
Kode lerroa:       this.offsets[key] = location;
Kode lerroa:     },
Kode lerroa:     offset: function CFFOffsetTracker_offset(value) {
Kode lerroa:       for (var key in this.offsets) {
Kode lerroa:         this.offsets[key] += value;
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     setEntryLocation: function CFFOffsetTracker_setEntryLocation(key, values, output) {
Kode lerroa:       if (!(key in this.offsets)) {
Kode lerroa:         throw new _util.FormatError('Not tracking location of ' + key);
Kode lerroa:       }
Kode lerroa:       var data = output.data;
Kode lerroa:       var dataOffset = this.offsets[key];
Kode lerroa:       var size = 5;
Kode lerroa:       for (var i = 0, ii = values.length; i < ii; ++i) {
Kode lerroa:         var offset0 = i * size + dataOffset;
Kode lerroa:         var offset1 = offset0 + 1;
Kode lerroa:         var offset2 = offset0 + 2;
Kode lerroa:         var offset3 = offset0 + 3;
Kode lerroa:         var offset4 = offset0 + 4;
Kode lerroa:         if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
Kode lerroa:           throw new _util.FormatError('writing to an offset that is not empty');
Kode lerroa:         }
Kode lerroa:         var value = values[i];
Kode lerroa:         data[offset0] = 0x1d;
Kode lerroa:         data[offset1] = value >> 24 & 0xFF;
Kode lerroa:         data[offset2] = value >> 16 & 0xFF;
Kode lerroa:         data[offset3] = value >> 8 & 0xFF;
Kode lerroa:         data[offset4] = value & 0xFF;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CFFOffsetTracker;
Kode lerroa: }();
Kode lerroa: var CFFCompiler = function CFFCompilerClosure() {
Kode lerroa:   function CFFCompiler(cff) {
Kode lerroa:     this.cff = cff;
Kode lerroa:   }
Kode lerroa:   CFFCompiler.prototype = {
Kode lerroa:     compile: function CFFCompiler_compile() {
Kode lerroa:       var cff = this.cff;
Kode lerroa:       var output = {
Kode lerroa:         data: [],
Kode lerroa:         length: 0,
Kode lerroa:         add: function CFFCompiler_add(data) {
Kode lerroa:           this.data = this.data.concat(data);
Kode lerroa:           this.length = this.data.length;
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       var header = this.compileHeader(cff.header);
Kode lerroa:       output.add(header);
Kode lerroa:       var nameIndex = this.compileNameIndex(cff.names);
Kode lerroa:       output.add(nameIndex);
Kode lerroa:       if (cff.isCIDFont) {
Kode lerroa:         if (cff.topDict.hasName('FontMatrix')) {
Kode lerroa:           var base = cff.topDict.getByName('FontMatrix');
Kode lerroa:           cff.topDict.removeByName('FontMatrix');
Kode lerroa:           for (var i = 0, ii = cff.fdArray.length; i < ii; i++) {
Kode lerroa:             var subDict = cff.fdArray[i];
Kode lerroa:             var matrix = base.slice(0);
Kode lerroa:             if (subDict.hasName('FontMatrix')) {
Kode lerroa:               matrix = _util.Util.transform(matrix, subDict.getByName('FontMatrix'));
Kode lerroa:             }
Kode lerroa:             subDict.setByName('FontMatrix', matrix);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
Kode lerroa:       output.add(compiled.output);
Kode lerroa:       var topDictTracker = compiled.trackers[0];
Kode lerroa:       var stringIndex = this.compileStringIndex(cff.strings.strings);
Kode lerroa:       output.add(stringIndex);
Kode lerroa:       var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
Kode lerroa:       output.add(globalSubrIndex);
Kode lerroa:       if (cff.encoding && cff.topDict.hasName('Encoding')) {
Kode lerroa:         if (cff.encoding.predefined) {
Kode lerroa:           topDictTracker.setEntryLocation('Encoding', [cff.encoding.format], output);
Kode lerroa:         } else {
Kode lerroa:           var encoding = this.compileEncoding(cff.encoding);
Kode lerroa:           topDictTracker.setEntryLocation('Encoding', [output.length], output);
Kode lerroa:           output.add(encoding);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (cff.charset && cff.topDict.hasName('charset')) {
Kode lerroa:         if (cff.charset.predefined) {
Kode lerroa:           topDictTracker.setEntryLocation('charset', [cff.charset.format], output);
Kode lerroa:         } else {
Kode lerroa:           var charset = this.compileCharset(cff.charset);
Kode lerroa:           topDictTracker.setEntryLocation('charset', [output.length], output);
Kode lerroa:           output.add(charset);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var charStrings = this.compileCharStrings(cff.charStrings);
Kode lerroa:       topDictTracker.setEntryLocation('CharStrings', [output.length], output);
Kode lerroa:       output.add(charStrings);
Kode lerroa:       if (cff.isCIDFont) {
Kode lerroa:         topDictTracker.setEntryLocation('FDSelect', [output.length], output);
Kode lerroa:         var fdSelect = this.compileFDSelect(cff.fdSelect.raw);
Kode lerroa:         output.add(fdSelect);
Kode lerroa:         compiled = this.compileTopDicts(cff.fdArray, output.length, true);
Kode lerroa:         topDictTracker.setEntryLocation('FDArray', [output.length], output);
Kode lerroa:         output.add(compiled.output);
Kode lerroa:         var fontDictTrackers = compiled.trackers;
Kode lerroa:         this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
Kode lerroa:       }
Kode lerroa:       this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
Kode lerroa:       output.add([0]);
Kode lerroa:       return output.data;
Kode lerroa:     },
Kode lerroa:     encodeNumber: function CFFCompiler_encodeNumber(value) {
Kode lerroa:       if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) {
Kode lerroa:         return this.encodeInteger(value);
Kode lerroa:       }
Kode lerroa:       return this.encodeFloat(value);
Kode lerroa:     },
Kode lerroa:     encodeFloat: function CFFCompiler_encodeFloat(num) {
Kode lerroa:       var value = num.toString();
Kode lerroa:       var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
Kode lerroa:       if (m) {
Kode lerroa:         var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
Kode lerroa:         value = (Math.round(num * epsilon) / epsilon).toString();
Kode lerroa:       }
Kode lerroa:       var nibbles = '';
Kode lerroa:       var i, ii;
Kode lerroa:       for (i = 0, ii = value.length; i < ii; ++i) {
Kode lerroa:         var a = value[i];
Kode lerroa:         if (a === 'e') {
Kode lerroa:           nibbles += value[++i] === '-' ? 'c' : 'b';
Kode lerroa:         } else if (a === '.') {
Kode lerroa:           nibbles += 'a';
Kode lerroa:         } else if (a === '-') {
Kode lerroa:           nibbles += 'e';
Kode lerroa:         } else {
Kode lerroa:           nibbles += a;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       nibbles += nibbles.length & 1 ? 'f' : 'ff';
Kode lerroa:       var out = [30];
Kode lerroa:       for (i = 0, ii = nibbles.length; i < ii; i += 2) {
Kode lerroa:         out.push(parseInt(nibbles.substr(i, 2), 16));
Kode lerroa:       }
Kode lerroa:       return out;
Kode lerroa:     },
Kode lerroa:     encodeInteger: function CFFCompiler_encodeInteger(value) {
Kode lerroa:       var code;
Kode lerroa:       if (value >= -107 && value <= 107) {
Kode lerroa:         code = [value + 139];
Kode lerroa:       } else if (value >= 108 && value <= 1131) {
Kode lerroa:         value = value - 108;
Kode lerroa:         code = [(value >> 8) + 247, value & 0xFF];
Kode lerroa:       } else if (value >= -1131 && value <= -108) {
Kode lerroa:         value = -value - 108;
Kode lerroa:         code = [(value >> 8) + 251, value & 0xFF];
Kode lerroa:       } else if (value >= -32768 && value <= 32767) {
Kode lerroa:         code = [0x1c, value >> 8 & 0xFF, value & 0xFF];
Kode lerroa:       } else {
Kode lerroa:         code = [0x1d, value >> 24 & 0xFF, value >> 16 & 0xFF, value >> 8 & 0xFF, value & 0xFF];
Kode lerroa:       }
Kode lerroa:       return code;
Kode lerroa:     },
Kode lerroa:     compileHeader: function CFFCompiler_compileHeader(header) {
Kode lerroa:       return [header.major, header.minor, header.hdrSize, header.offSize];
Kode lerroa:     },
Kode lerroa:     compileNameIndex: function CFFCompiler_compileNameIndex(names) {
Kode lerroa:       var nameIndex = new CFFIndex();
Kode lerroa:       for (var i = 0, ii = names.length; i < ii; ++i) {
Kode lerroa:         var name = names[i];
Kode lerroa:         var length = Math.min(name.length, 127);
Kode lerroa:         var sanitizedName = new Array(length);
Kode lerroa:         for (var j = 0; j < length; j++) {
Kode lerroa:           var char = name[j];
Kode lerroa:           if (char < '!' || char > '~' || char === '[' || char === ']' || char === '(' || char === ')' || char === '{' || char === '}' || char === '<' || char === '>' || char === '/' || char === '%') {
Kode lerroa:             char = '_';
Kode lerroa:           }
Kode lerroa:           sanitizedName[j] = char;
Kode lerroa:         }
Kode lerroa:         sanitizedName = sanitizedName.join('');
Kode lerroa:         if (sanitizedName === '') {
Kode lerroa:           sanitizedName = 'Bad_Font_Name';
Kode lerroa:         }
Kode lerroa:         nameIndex.add((0, _util.stringToBytes)(sanitizedName));
Kode lerroa:       }
Kode lerroa:       return this.compileIndex(nameIndex);
Kode lerroa:     },
Kode lerroa:     compileTopDicts: function CFFCompiler_compileTopDicts(dicts, length, removeCidKeys) {
Kode lerroa:       var fontDictTrackers = [];
Kode lerroa:       var fdArrayIndex = new CFFIndex();
Kode lerroa:       for (var i = 0, ii = dicts.length; i < ii; ++i) {
Kode lerroa:         var fontDict = dicts[i];
Kode lerroa:         if (removeCidKeys) {
Kode lerroa:           fontDict.removeByName('CIDFontVersion');
Kode lerroa:           fontDict.removeByName('CIDFontRevision');
Kode lerroa:           fontDict.removeByName('CIDFontType');
Kode lerroa:           fontDict.removeByName('CIDCount');
Kode lerroa:           fontDict.removeByName('UIDBase');
Kode lerroa:         }
Kode lerroa:         var fontDictTracker = new CFFOffsetTracker();
Kode lerroa:         var fontDictData = this.compileDict(fontDict, fontDictTracker);
Kode lerroa:         fontDictTrackers.push(fontDictTracker);
Kode lerroa:         fdArrayIndex.add(fontDictData);
Kode lerroa:         fontDictTracker.offset(length);
Kode lerroa:       }
Kode lerroa:       fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
Kode lerroa:       return {
Kode lerroa:         trackers: fontDictTrackers,
Kode lerroa:         output: fdArrayIndex
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts, trackers, output) {
Kode lerroa:       for (var i = 0, ii = dicts.length; i < ii; ++i) {
Kode lerroa:         var fontDict = dicts[i];
Kode lerroa:         var privateDict = fontDict.privateDict;
Kode lerroa:         if (!privateDict || !fontDict.hasName('Private')) {
Kode lerroa:           throw new _util.FormatError('There must be a private dictionary.');
Kode lerroa:         }
Kode lerroa:         var privateDictTracker = new CFFOffsetTracker();
Kode lerroa:         var privateDictData = this.compileDict(privateDict, privateDictTracker);
Kode lerroa:         var outputLength = output.length;
Kode lerroa:         privateDictTracker.offset(outputLength);
Kode lerroa:         if (!privateDictData.length) {
Kode lerroa:           outputLength = 0;
Kode lerroa:         }
Kode lerroa:         trackers[i].setEntryLocation('Private', [privateDictData.length, outputLength], output);
Kode lerroa:         output.add(privateDictData);
Kode lerroa:         if (privateDict.subrsIndex && privateDict.hasName('Subrs')) {
Kode lerroa:           var subrs = this.compileIndex(privateDict.subrsIndex);
Kode lerroa:           privateDictTracker.setEntryLocation('Subrs', [privateDictData.length], output);
Kode lerroa:           output.add(subrs);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
Kode lerroa:       var out = [];
Kode lerroa:       var order = dict.order;
Kode lerroa:       for (var i = 0; i < order.length; ++i) {
Kode lerroa:         var key = order[i];
Kode lerroa:         if (!(key in dict.values)) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         var values = dict.values[key];
Kode lerroa:         var types = dict.types[key];
Kode lerroa:         if (!Array.isArray(types)) {
Kode lerroa:           types = [types];
Kode lerroa:         }
Kode lerroa:         if (!Array.isArray(values)) {
Kode lerroa:           values = [values];
Kode lerroa:         }
Kode lerroa:         if (values.length === 0) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         for (var j = 0, jj = types.length; j < jj; ++j) {
Kode lerroa:           var type = types[j];
Kode lerroa:           var value = values[j];
Kode lerroa:           switch (type) {
Kode lerroa:             case 'num':
Kode lerroa:             case 'sid':
Kode lerroa:               out = out.concat(this.encodeNumber(value));
Kode lerroa:               break;
Kode lerroa:             case 'offset':
Kode lerroa:               var name = dict.keyToNameMap[key];
Kode lerroa:               if (!offsetTracker.isTracking(name)) {
Kode lerroa:                 offsetTracker.track(name, out.length);
Kode lerroa:               }
Kode lerroa:               out = out.concat([0x1d, 0, 0, 0, 0]);
Kode lerroa:               break;
Kode lerroa:             case 'array':
Kode lerroa:             case 'delta':
Kode lerroa:               out = out.concat(this.encodeNumber(value));
Kode lerroa:               for (var k = 1, kk = values.length; k < kk; ++k) {
Kode lerroa:                 out = out.concat(this.encodeNumber(values[k]));
Kode lerroa:               }
Kode lerroa:               break;
Kode lerroa:             default:
Kode lerroa:               throw new _util.FormatError('Unknown data type of ' + type);
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         out = out.concat(dict.opcodes[key]);
Kode lerroa:       }
Kode lerroa:       return out;
Kode lerroa:     },
Kode lerroa:     compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
Kode lerroa:       var stringIndex = new CFFIndex();
Kode lerroa:       for (var i = 0, ii = strings.length; i < ii; ++i) {
Kode lerroa:         stringIndex.add((0, _util.stringToBytes)(strings[i]));
Kode lerroa:       }
Kode lerroa:       return this.compileIndex(stringIndex);
Kode lerroa:     },
Kode lerroa:     compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
Kode lerroa:       var globalSubrIndex = this.cff.globalSubrIndex;
Kode lerroa:       this.out.writeByteArray(this.compileIndex(globalSubrIndex));
Kode lerroa:     },
Kode lerroa:     compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
Kode lerroa:       return this.compileIndex(charStrings);
Kode lerroa:     },
Kode lerroa:     compileCharset: function CFFCompiler_compileCharset(charset) {
Kode lerroa:       return this.compileTypedArray(charset.raw);
Kode lerroa:     },
Kode lerroa:     compileEncoding: function CFFCompiler_compileEncoding(encoding) {
Kode lerroa:       return this.compileTypedArray(encoding.raw);
Kode lerroa:     },
Kode lerroa:     compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
Kode lerroa:       return this.compileTypedArray(fdSelect);
Kode lerroa:     },
Kode lerroa:     compileTypedArray: function CFFCompiler_compileTypedArray(data) {
Kode lerroa:       var out = [];
Kode lerroa:       for (var i = 0, ii = data.length; i < ii; ++i) {
Kode lerroa:         out[i] = data[i];
Kode lerroa:       }
Kode lerroa:       return out;
Kode lerroa:     },
Kode lerroa:     compileIndex: function CFFCompiler_compileIndex(index, trackers) {
Kode lerroa:       trackers = trackers || [];
Kode lerroa:       var objects = index.objects;
Kode lerroa:       var count = objects.length;
Kode lerroa:       if (count === 0) {
Kode lerroa:         return [0, 0, 0];
Kode lerroa:       }
Kode lerroa:       var data = [count >> 8 & 0xFF, count & 0xff];
Kode lerroa:       var lastOffset = 1,
Kode lerroa:           i;
Kode lerroa:       for (i = 0; i < count; ++i) {
Kode lerroa:         lastOffset += objects[i].length;
Kode lerroa:       }
Kode lerroa:       var offsetSize;
Kode lerroa:       if (lastOffset < 0x100) {
Kode lerroa:         offsetSize = 1;
Kode lerroa:       } else if (lastOffset < 0x10000) {
Kode lerroa:         offsetSize = 2;
Kode lerroa:       } else if (lastOffset < 0x1000000) {
Kode lerroa:         offsetSize = 3;
Kode lerroa:       } else {
Kode lerroa:         offsetSize = 4;
Kode lerroa:       }
Kode lerroa:       data.push(offsetSize);
Kode lerroa:       var relativeOffset = 1;
Kode lerroa:       for (i = 0; i < count + 1; i++) {
Kode lerroa:         if (offsetSize === 1) {
Kode lerroa:           data.push(relativeOffset & 0xFF);
Kode lerroa:         } else if (offsetSize === 2) {
Kode lerroa:           data.push(relativeOffset >> 8 & 0xFF, relativeOffset & 0xFF);
Kode lerroa:         } else if (offsetSize === 3) {
Kode lerroa:           data.push(relativeOffset >> 16 & 0xFF, relativeOffset >> 8 & 0xFF, relativeOffset & 0xFF);
Kode lerroa:         } else {
Kode lerroa:           data.push(relativeOffset >>> 24 & 0xFF, relativeOffset >> 16 & 0xFF, relativeOffset >> 8 & 0xFF, relativeOffset & 0xFF);
Kode lerroa:         }
Kode lerroa:         if (objects[i]) {
Kode lerroa:           relativeOffset += objects[i].length;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       for (i = 0; i < count; i++) {
Kode lerroa:         if (trackers[i]) {
Kode lerroa:           trackers[i].offset(data.length);
Kode lerroa:         }
Kode lerroa:         for (var j = 0, jj = objects[i].length; j < jj; j++) {
Kode lerroa:           data.push(objects[i][j]);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return data;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return CFFCompiler;
Kode lerroa: }();
Kode lerroa: exports.CFFStandardStrings = CFFStandardStrings;
Kode lerroa: exports.CFFParser = CFFParser;
Kode lerroa: exports.CFF = CFF;
Kode lerroa: exports.CFFHeader = CFFHeader;
Kode lerroa: exports.CFFStrings = CFFStrings;
Kode lerroa: exports.CFFIndex = CFFIndex;
Kode lerroa: exports.CFFCharset = CFFCharset;
Kode lerroa: exports.CFFTopDict = CFFTopDict;
Kode lerroa: exports.CFFPrivateDict = CFFPrivateDict;
Kode lerroa: exports.CFFCompiler = CFFCompiler;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 79 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.getSupplementalGlyphMapForArialBlack = exports.getGlyphMapForStandardFonts = exports.getSymbolsFonts = exports.getSerifFonts = exports.getNonStdFontMap = exports.getStdFontMap = undefined;
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var getStdFontMap = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:   t['ArialNarrow'] = 'Helvetica';
Kode lerroa:   t['ArialNarrow-Bold'] = 'Helvetica-Bold';
Kode lerroa:   t['ArialNarrow-BoldItalic'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['ArialNarrow-Italic'] = 'Helvetica-Oblique';
Kode lerroa:   t['ArialBlack'] = 'Helvetica';
Kode lerroa:   t['ArialBlack-Bold'] = 'Helvetica-Bold';
Kode lerroa:   t['ArialBlack-BoldItalic'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['ArialBlack-Italic'] = 'Helvetica-Oblique';
Kode lerroa:   t['Arial-Black'] = 'Helvetica';
Kode lerroa:   t['Arial-Black-Bold'] = 'Helvetica-Bold';
Kode lerroa:   t['Arial-Black-BoldItalic'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['Arial-Black-Italic'] = 'Helvetica-Oblique';
Kode lerroa:   t['Arial'] = 'Helvetica';
Kode lerroa:   t['Arial-Bold'] = 'Helvetica-Bold';
Kode lerroa:   t['Arial-BoldItalic'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['Arial-Italic'] = 'Helvetica-Oblique';
Kode lerroa:   t['Arial-BoldItalicMT'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['Arial-BoldMT'] = 'Helvetica-Bold';
Kode lerroa:   t['Arial-ItalicMT'] = 'Helvetica-Oblique';
Kode lerroa:   t['ArialMT'] = 'Helvetica';
Kode lerroa:   t['Courier-Bold'] = 'Courier-Bold';
Kode lerroa:   t['Courier-BoldItalic'] = 'Courier-BoldOblique';
Kode lerroa:   t['Courier-Italic'] = 'Courier-Oblique';
Kode lerroa:   t['CourierNew'] = 'Courier';
Kode lerroa:   t['CourierNew-Bold'] = 'Courier-Bold';
Kode lerroa:   t['CourierNew-BoldItalic'] = 'Courier-BoldOblique';
Kode lerroa:   t['CourierNew-Italic'] = 'Courier-Oblique';
Kode lerroa:   t['CourierNewPS-BoldItalicMT'] = 'Courier-BoldOblique';
Kode lerroa:   t['CourierNewPS-BoldMT'] = 'Courier-Bold';
Kode lerroa:   t['CourierNewPS-ItalicMT'] = 'Courier-Oblique';
Kode lerroa:   t['CourierNewPSMT'] = 'Courier';
Kode lerroa:   t['Helvetica'] = 'Helvetica';
Kode lerroa:   t['Helvetica-Bold'] = 'Helvetica-Bold';
Kode lerroa:   t['Helvetica-BoldItalic'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['Helvetica-BoldOblique'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['Helvetica-Italic'] = 'Helvetica-Oblique';
Kode lerroa:   t['Helvetica-Oblique'] = 'Helvetica-Oblique';
Kode lerroa:   t['SegoeUISymbol'] = 'Helvetica';
Kode lerroa:   t['Symbol-Bold'] = 'Symbol';
Kode lerroa:   t['Symbol-BoldItalic'] = 'Symbol';
Kode lerroa:   t['Symbol-Italic'] = 'Symbol';
Kode lerroa:   t['TimesNewRoman'] = 'Times-Roman';
Kode lerroa:   t['TimesNewRoman-Bold'] = 'Times-Bold';
Kode lerroa:   t['TimesNewRoman-BoldItalic'] = 'Times-BoldItalic';
Kode lerroa:   t['TimesNewRoman-Italic'] = 'Times-Italic';
Kode lerroa:   t['TimesNewRomanPS'] = 'Times-Roman';
Kode lerroa:   t['TimesNewRomanPS-Bold'] = 'Times-Bold';
Kode lerroa:   t['TimesNewRomanPS-BoldItalic'] = 'Times-BoldItalic';
Kode lerroa:   t['TimesNewRomanPS-BoldItalicMT'] = 'Times-BoldItalic';
Kode lerroa:   t['TimesNewRomanPS-BoldMT'] = 'Times-Bold';
Kode lerroa:   t['TimesNewRomanPS-Italic'] = 'Times-Italic';
Kode lerroa:   t['TimesNewRomanPS-ItalicMT'] = 'Times-Italic';
Kode lerroa:   t['TimesNewRomanPSMT'] = 'Times-Roman';
Kode lerroa:   t['TimesNewRomanPSMT-Bold'] = 'Times-Bold';
Kode lerroa:   t['TimesNewRomanPSMT-BoldItalic'] = 'Times-BoldItalic';
Kode lerroa:   t['TimesNewRomanPSMT-Italic'] = 'Times-Italic';
Kode lerroa: });
Kode lerroa: var getNonStdFontMap = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:   t['CenturyGothic'] = 'Helvetica';
Kode lerroa:   t['CenturyGothic-Bold'] = 'Helvetica-Bold';
Kode lerroa:   t['CenturyGothic-BoldItalic'] = 'Helvetica-BoldOblique';
Kode lerroa:   t['CenturyGothic-Italic'] = 'Helvetica-Oblique';
Kode lerroa:   t['ComicSansMS'] = 'Comic Sans MS';
Kode lerroa:   t['ComicSansMS-Bold'] = 'Comic Sans MS-Bold';
Kode lerroa:   t['ComicSansMS-BoldItalic'] = 'Comic Sans MS-BoldItalic';
Kode lerroa:   t['ComicSansMS-Italic'] = 'Comic Sans MS-Italic';
Kode lerroa:   t['LucidaConsole'] = 'Courier';
Kode lerroa:   t['LucidaConsole-Bold'] = 'Courier-Bold';
Kode lerroa:   t['LucidaConsole-BoldItalic'] = 'Courier-BoldOblique';
Kode lerroa:   t['LucidaConsole-Italic'] = 'Courier-Oblique';
Kode lerroa:   t['MS-Gothic'] = 'MS Gothic';
Kode lerroa:   t['MS-Gothic-Bold'] = 'MS Gothic-Bold';
Kode lerroa:   t['MS-Gothic-BoldItalic'] = 'MS Gothic-BoldItalic';
Kode lerroa:   t['MS-Gothic-Italic'] = 'MS Gothic-Italic';
Kode lerroa:   t['MS-Mincho'] = 'MS Mincho';
Kode lerroa:   t['MS-Mincho-Bold'] = 'MS Mincho-Bold';
Kode lerroa:   t['MS-Mincho-BoldItalic'] = 'MS Mincho-BoldItalic';
Kode lerroa:   t['MS-Mincho-Italic'] = 'MS Mincho-Italic';
Kode lerroa:   t['MS-PGothic'] = 'MS PGothic';
Kode lerroa:   t['MS-PGothic-Bold'] = 'MS PGothic-Bold';
Kode lerroa:   t['MS-PGothic-BoldItalic'] = 'MS PGothic-BoldItalic';
Kode lerroa:   t['MS-PGothic-Italic'] = 'MS PGothic-Italic';
Kode lerroa:   t['MS-PMincho'] = 'MS PMincho';
Kode lerroa:   t['MS-PMincho-Bold'] = 'MS PMincho-Bold';
Kode lerroa:   t['MS-PMincho-BoldItalic'] = 'MS PMincho-BoldItalic';
Kode lerroa:   t['MS-PMincho-Italic'] = 'MS PMincho-Italic';
Kode lerroa:   t['NuptialScript'] = 'Times-Italic';
Kode lerroa:   t['Wingdings'] = 'ZapfDingbats';
Kode lerroa: });
Kode lerroa: var getSerifFonts = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:   t['Adobe Jenson'] = true;
Kode lerroa:   t['Adobe Text'] = true;
Kode lerroa:   t['Albertus'] = true;
Kode lerroa:   t['Aldus'] = true;
Kode lerroa:   t['Alexandria'] = true;
Kode lerroa:   t['Algerian'] = true;
Kode lerroa:   t['American Typewriter'] = true;
Kode lerroa:   t['Antiqua'] = true;
Kode lerroa:   t['Apex'] = true;
Kode lerroa:   t['Arno'] = true;
Kode lerroa:   t['Aster'] = true;
Kode lerroa:   t['Aurora'] = true;
Kode lerroa:   t['Baskerville'] = true;
Kode lerroa:   t['Bell'] = true;
Kode lerroa:   t['Bembo'] = true;
Kode lerroa:   t['Bembo Schoolbook'] = true;
Kode lerroa:   t['Benguiat'] = true;
Kode lerroa:   t['Berkeley Old Style'] = true;
Kode lerroa:   t['Bernhard Modern'] = true;
Kode lerroa:   t['Berthold City'] = true;
Kode lerroa:   t['Bodoni'] = true;
Kode lerroa:   t['Bauer Bodoni'] = true;
Kode lerroa:   t['Book Antiqua'] = true;
Kode lerroa:   t['Bookman'] = true;
Kode lerroa:   t['Bordeaux Roman'] = true;
Kode lerroa:   t['Californian FB'] = true;
Kode lerroa:   t['Calisto'] = true;
Kode lerroa:   t['Calvert'] = true;
Kode lerroa:   t['Capitals'] = true;
Kode lerroa:   t['Cambria'] = true;
Kode lerroa:   t['Cartier'] = true;
Kode lerroa:   t['Caslon'] = true;
Kode lerroa:   t['Catull'] = true;
Kode lerroa:   t['Centaur'] = true;
Kode lerroa:   t['Century Old Style'] = true;
Kode lerroa:   t['Century Schoolbook'] = true;
Kode lerroa:   t['Chaparral'] = true;
Kode lerroa:   t['Charis SIL'] = true;
Kode lerroa:   t['Cheltenham'] = true;
Kode lerroa:   t['Cholla Slab'] = true;
Kode lerroa:   t['Clarendon'] = true;
Kode lerroa:   t['Clearface'] = true;
Kode lerroa:   t['Cochin'] = true;
Kode lerroa:   t['Colonna'] = true;
Kode lerroa:   t['Computer Modern'] = true;
Kode lerroa:   t['Concrete Roman'] = true;
Kode lerroa:   t['Constantia'] = true;
Kode lerroa:   t['Cooper Black'] = true;
Kode lerroa:   t['Corona'] = true;
Kode lerroa:   t['Ecotype'] = true;
Kode lerroa:   t['Egyptienne'] = true;
Kode lerroa:   t['Elephant'] = true;
Kode lerroa:   t['Excelsior'] = true;
Kode lerroa:   t['Fairfield'] = true;
Kode lerroa:   t['FF Scala'] = true;
Kode lerroa:   t['Folkard'] = true;
Kode lerroa:   t['Footlight'] = true;
Kode lerroa:   t['FreeSerif'] = true;
Kode lerroa:   t['Friz Quadrata'] = true;
Kode lerroa:   t['Garamond'] = true;
Kode lerroa:   t['Gentium'] = true;
Kode lerroa:   t['Georgia'] = true;
Kode lerroa:   t['Gloucester'] = true;
Kode lerroa:   t['Goudy Old Style'] = true;
Kode lerroa:   t['Goudy Schoolbook'] = true;
Kode lerroa:   t['Goudy Pro Font'] = true;
Kode lerroa:   t['Granjon'] = true;
Kode lerroa:   t['Guardian Egyptian'] = true;
Kode lerroa:   t['Heather'] = true;
Kode lerroa:   t['Hercules'] = true;
Kode lerroa:   t['High Tower Text'] = true;
Kode lerroa:   t['Hiroshige'] = true;
Kode lerroa:   t['Hoefler Text'] = true;
Kode lerroa:   t['Humana Serif'] = true;
Kode lerroa:   t['Imprint'] = true;
Kode lerroa:   t['Ionic No. 5'] = true;
Kode lerroa:   t['Janson'] = true;
Kode lerroa:   t['Joanna'] = true;
Kode lerroa:   t['Korinna'] = true;
Kode lerroa:   t['Lexicon'] = true;
Kode lerroa:   t['Liberation Serif'] = true;
Kode lerroa:   t['Linux Libertine'] = true;
Kode lerroa:   t['Literaturnaya'] = true;
Kode lerroa:   t['Lucida'] = true;
Kode lerroa:   t['Lucida Bright'] = true;
Kode lerroa:   t['Melior'] = true;
Kode lerroa:   t['Memphis'] = true;
Kode lerroa:   t['Miller'] = true;
Kode lerroa:   t['Minion'] = true;
Kode lerroa:   t['Modern'] = true;
Kode lerroa:   t['Mona Lisa'] = true;
Kode lerroa:   t['Mrs Eaves'] = true;
Kode lerroa:   t['MS Serif'] = true;
Kode lerroa:   t['Museo Slab'] = true;
Kode lerroa:   t['New York'] = true;
Kode lerroa:   t['Nimbus Roman'] = true;
Kode lerroa:   t['NPS Rawlinson Roadway'] = true;
Kode lerroa:   t['NuptialScript'] = true;
Kode lerroa:   t['Palatino'] = true;
Kode lerroa:   t['Perpetua'] = true;
Kode lerroa:   t['Plantin'] = true;
Kode lerroa:   t['Plantin Schoolbook'] = true;
Kode lerroa:   t['Playbill'] = true;
Kode lerroa:   t['Poor Richard'] = true;
Kode lerroa:   t['Rawlinson Roadway'] = true;
Kode lerroa:   t['Renault'] = true;
Kode lerroa:   t['Requiem'] = true;
Kode lerroa:   t['Rockwell'] = true;
Kode lerroa:   t['Roman'] = true;
Kode lerroa:   t['Rotis Serif'] = true;
Kode lerroa:   t['Sabon'] = true;
Kode lerroa:   t['Scala'] = true;
Kode lerroa:   t['Seagull'] = true;
Kode lerroa:   t['Sistina'] = true;
Kode lerroa:   t['Souvenir'] = true;
Kode lerroa:   t['STIX'] = true;
Kode lerroa:   t['Stone Informal'] = true;
Kode lerroa:   t['Stone Serif'] = true;
Kode lerroa:   t['Sylfaen'] = true;
Kode lerroa:   t['Times'] = true;
Kode lerroa:   t['Trajan'] = true;
Kode lerroa:   t['Trinit'] = true;
Kode lerroa:   t['Trump Mediaeval'] = true;
Kode lerroa:   t['Utopia'] = true;
Kode lerroa:   t['Vale Type'] = true;
Kode lerroa:   t['Bitstream Vera'] = true;
Kode lerroa:   t['Vera Serif'] = true;
Kode lerroa:   t['Versailles'] = true;
Kode lerroa:   t['Wanted'] = true;
Kode lerroa:   t['Weiss'] = true;
Kode lerroa:   t['Wide Latin'] = true;
Kode lerroa:   t['Windsor'] = true;
Kode lerroa:   t['XITS'] = true;
Kode lerroa: });
Kode lerroa: var getSymbolsFonts = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:   t['Dingbats'] = true;
Kode lerroa:   t['Symbol'] = true;
Kode lerroa:   t['ZapfDingbats'] = true;
Kode lerroa: });
Kode lerroa: var getGlyphMapForStandardFonts = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:   t[2] = 10;
Kode lerroa:   t[3] = 32;
Kode lerroa:   t[4] = 33;
Kode lerroa:   t[5] = 34;
Kode lerroa:   t[6] = 35;
Kode lerroa:   t[7] = 36;
Kode lerroa:   t[8] = 37;
Kode lerroa:   t[9] = 38;
Kode lerroa:   t[10] = 39;
Kode lerroa:   t[11] = 40;
Kode lerroa:   t[12] = 41;
Kode lerroa:   t[13] = 42;
Kode lerroa:   t[14] = 43;
Kode lerroa:   t[15] = 44;
Kode lerroa:   t[16] = 45;
Kode lerroa:   t[17] = 46;
Kode lerroa:   t[18] = 47;
Kode lerroa:   t[19] = 48;
Kode lerroa:   t[20] = 49;
Kode lerroa:   t[21] = 50;
Kode lerroa:   t[22] = 51;
Kode lerroa:   t[23] = 52;
Kode lerroa:   t[24] = 53;
Kode lerroa:   t[25] = 54;
Kode lerroa:   t[26] = 55;
Kode lerroa:   t[27] = 56;
Kode lerroa:   t[28] = 57;
Kode lerroa:   t[29] = 58;
Kode lerroa:   t[30] = 894;
Kode lerroa:   t[31] = 60;
Kode lerroa:   t[32] = 61;
Kode lerroa:   t[33] = 62;
Kode lerroa:   t[34] = 63;
Kode lerroa:   t[35] = 64;
Kode lerroa:   t[36] = 65;
Kode lerroa:   t[37] = 66;
Kode lerroa:   t[38] = 67;
Kode lerroa:   t[39] = 68;
Kode lerroa:   t[40] = 69;
Kode lerroa:   t[41] = 70;
Kode lerroa:   t[42] = 71;
Kode lerroa:   t[43] = 72;
Kode lerroa:   t[44] = 73;
Kode lerroa:   t[45] = 74;
Kode lerroa:   t[46] = 75;
Kode lerroa:   t[47] = 76;
Kode lerroa:   t[48] = 77;
Kode lerroa:   t[49] = 78;
Kode lerroa:   t[50] = 79;
Kode lerroa:   t[51] = 80;
Kode lerroa:   t[52] = 81;
Kode lerroa:   t[53] = 82;
Kode lerroa:   t[54] = 83;
Kode lerroa:   t[55] = 84;
Kode lerroa:   t[56] = 85;
Kode lerroa:   t[57] = 86;
Kode lerroa:   t[58] = 87;
Kode lerroa:   t[59] = 88;
Kode lerroa:   t[60] = 89;
Kode lerroa:   t[61] = 90;
Kode lerroa:   t[62] = 91;
Kode lerroa:   t[63] = 92;
Kode lerroa:   t[64] = 93;
Kode lerroa:   t[65] = 94;
Kode lerroa:   t[66] = 95;
Kode lerroa:   t[67] = 96;
Kode lerroa:   t[68] = 97;
Kode lerroa:   t[69] = 98;
Kode lerroa:   t[70] = 99;
Kode lerroa:   t[71] = 100;
Kode lerroa:   t[72] = 101;
Kode lerroa:   t[73] = 102;
Kode lerroa:   t[74] = 103;
Kode lerroa:   t[75] = 104;
Kode lerroa:   t[76] = 105;
Kode lerroa:   t[77] = 106;
Kode lerroa:   t[78] = 107;
Kode lerroa:   t[79] = 108;
Kode lerroa:   t[80] = 109;
Kode lerroa:   t[81] = 110;
Kode lerroa:   t[82] = 111;
Kode lerroa:   t[83] = 112;
Kode lerroa:   t[84] = 113;
Kode lerroa:   t[85] = 114;
Kode lerroa:   t[86] = 115;
Kode lerroa:   t[87] = 116;
Kode lerroa:   t[88] = 117;
Kode lerroa:   t[89] = 118;
Kode lerroa:   t[90] = 119;
Kode lerroa:   t[91] = 120;
Kode lerroa:   t[92] = 121;
Kode lerroa:   t[93] = 122;
Kode lerroa:   t[94] = 123;
Kode lerroa:   t[95] = 124;
Kode lerroa:   t[96] = 125;
Kode lerroa:   t[97] = 126;
Kode lerroa:   t[98] = 196;
Kode lerroa:   t[99] = 197;
Kode lerroa:   t[100] = 199;
Kode lerroa:   t[101] = 201;
Kode lerroa:   t[102] = 209;
Kode lerroa:   t[103] = 214;
Kode lerroa:   t[104] = 220;
Kode lerroa:   t[105] = 225;
Kode lerroa:   t[106] = 224;
Kode lerroa:   t[107] = 226;
Kode lerroa:   t[108] = 228;
Kode lerroa:   t[109] = 227;
Kode lerroa:   t[110] = 229;
Kode lerroa:   t[111] = 231;
Kode lerroa:   t[112] = 233;
Kode lerroa:   t[113] = 232;
Kode lerroa:   t[114] = 234;
Kode lerroa:   t[115] = 235;
Kode lerroa:   t[116] = 237;
Kode lerroa:   t[117] = 236;
Kode lerroa:   t[118] = 238;
Kode lerroa:   t[119] = 239;
Kode lerroa:   t[120] = 241;
Kode lerroa:   t[121] = 243;
Kode lerroa:   t[122] = 242;
Kode lerroa:   t[123] = 244;
Kode lerroa:   t[124] = 246;
Kode lerroa:   t[125] = 245;
Kode lerroa:   t[126] = 250;
Kode lerroa:   t[127] = 249;
Kode lerroa:   t[128] = 251;
Kode lerroa:   t[129] = 252;
Kode lerroa:   t[130] = 8224;
Kode lerroa:   t[131] = 176;
Kode lerroa:   t[132] = 162;
Kode lerroa:   t[133] = 163;
Kode lerroa:   t[134] = 167;
Kode lerroa:   t[135] = 8226;
Kode lerroa:   t[136] = 182;
Kode lerroa:   t[137] = 223;
Kode lerroa:   t[138] = 174;
Kode lerroa:   t[139] = 169;
Kode lerroa:   t[140] = 8482;
Kode lerroa:   t[141] = 180;
Kode lerroa:   t[142] = 168;
Kode lerroa:   t[143] = 8800;
Kode lerroa:   t[144] = 198;
Kode lerroa:   t[145] = 216;
Kode lerroa:   t[146] = 8734;
Kode lerroa:   t[147] = 177;
Kode lerroa:   t[148] = 8804;
Kode lerroa:   t[149] = 8805;
Kode lerroa:   t[150] = 165;
Kode lerroa:   t[151] = 181;
Kode lerroa:   t[152] = 8706;
Kode lerroa:   t[153] = 8721;
Kode lerroa:   t[154] = 8719;
Kode lerroa:   t[156] = 8747;
Kode lerroa:   t[157] = 170;
Kode lerroa:   t[158] = 186;
Kode lerroa:   t[159] = 8486;
Kode lerroa:   t[160] = 230;
Kode lerroa:   t[161] = 248;
Kode lerroa:   t[162] = 191;
Kode lerroa:   t[163] = 161;
Kode lerroa:   t[164] = 172;
Kode lerroa:   t[165] = 8730;
Kode lerroa:   t[166] = 402;
Kode lerroa:   t[167] = 8776;
Kode lerroa:   t[168] = 8710;
Kode lerroa:   t[169] = 171;
Kode lerroa:   t[170] = 187;
Kode lerroa:   t[171] = 8230;
Kode lerroa:   t[210] = 218;
Kode lerroa:   t[223] = 711;
Kode lerroa:   t[224] = 321;
Kode lerroa:   t[225] = 322;
Kode lerroa:   t[227] = 353;
Kode lerroa:   t[229] = 382;
Kode lerroa:   t[234] = 253;
Kode lerroa:   t[252] = 263;
Kode lerroa:   t[253] = 268;
Kode lerroa:   t[254] = 269;
Kode lerroa:   t[258] = 258;
Kode lerroa:   t[260] = 260;
Kode lerroa:   t[261] = 261;
Kode lerroa:   t[265] = 280;
Kode lerroa:   t[266] = 281;
Kode lerroa:   t[268] = 283;
Kode lerroa:   t[269] = 313;
Kode lerroa:   t[275] = 323;
Kode lerroa:   t[276] = 324;
Kode lerroa:   t[278] = 328;
Kode lerroa:   t[284] = 345;
Kode lerroa:   t[285] = 346;
Kode lerroa:   t[286] = 347;
Kode lerroa:   t[292] = 367;
Kode lerroa:   t[295] = 377;
Kode lerroa:   t[296] = 378;
Kode lerroa:   t[298] = 380;
Kode lerroa:   t[305] = 963;
Kode lerroa:   t[306] = 964;
Kode lerroa:   t[307] = 966;
Kode lerroa:   t[308] = 8215;
Kode lerroa:   t[309] = 8252;
Kode lerroa:   t[310] = 8319;
Kode lerroa:   t[311] = 8359;
Kode lerroa:   t[312] = 8592;
Kode lerroa:   t[313] = 8593;
Kode lerroa:   t[337] = 9552;
Kode lerroa:   t[493] = 1039;
Kode lerroa:   t[494] = 1040;
Kode lerroa:   t[705] = 1524;
Kode lerroa:   t[706] = 8362;
Kode lerroa:   t[710] = 64288;
Kode lerroa:   t[711] = 64298;
Kode lerroa:   t[759] = 1617;
Kode lerroa:   t[761] = 1776;
Kode lerroa:   t[763] = 1778;
Kode lerroa:   t[775] = 1652;
Kode lerroa:   t[777] = 1764;
Kode lerroa:   t[778] = 1780;
Kode lerroa:   t[779] = 1781;
Kode lerroa:   t[780] = 1782;
Kode lerroa:   t[782] = 771;
Kode lerroa:   t[783] = 64726;
Kode lerroa:   t[786] = 8363;
Kode lerroa:   t[788] = 8532;
Kode lerroa:   t[790] = 768;
Kode lerroa:   t[791] = 769;
Kode lerroa:   t[792] = 768;
Kode lerroa:   t[795] = 803;
Kode lerroa:   t[797] = 64336;
Kode lerroa:   t[798] = 64337;
Kode lerroa:   t[799] = 64342;
Kode lerroa:   t[800] = 64343;
Kode lerroa:   t[801] = 64344;
Kode lerroa:   t[802] = 64345;
Kode lerroa:   t[803] = 64362;
Kode lerroa:   t[804] = 64363;
Kode lerroa:   t[805] = 64364;
Kode lerroa:   t[2424] = 7821;
Kode lerroa:   t[2425] = 7822;
Kode lerroa:   t[2426] = 7823;
Kode lerroa:   t[2427] = 7824;
Kode lerroa:   t[2428] = 7825;
Kode lerroa:   t[2429] = 7826;
Kode lerroa:   t[2430] = 7827;
Kode lerroa:   t[2433] = 7682;
Kode lerroa:   t[2678] = 8045;
Kode lerroa:   t[2679] = 8046;
Kode lerroa:   t[2830] = 1552;
Kode lerroa:   t[2838] = 686;
Kode lerroa:   t[2840] = 751;
Kode lerroa:   t[2842] = 753;
Kode lerroa:   t[2843] = 754;
Kode lerroa:   t[2844] = 755;
Kode lerroa:   t[2846] = 757;
Kode lerroa:   t[2856] = 767;
Kode lerroa:   t[2857] = 848;
Kode lerroa:   t[2858] = 849;
Kode lerroa:   t[2862] = 853;
Kode lerroa:   t[2863] = 854;
Kode lerroa:   t[2864] = 855;
Kode lerroa:   t[2865] = 861;
Kode lerroa:   t[2866] = 862;
Kode lerroa:   t[2906] = 7460;
Kode lerroa:   t[2908] = 7462;
Kode lerroa:   t[2909] = 7463;
Kode lerroa:   t[2910] = 7464;
Kode lerroa:   t[2912] = 7466;
Kode lerroa:   t[2913] = 7467;
Kode lerroa:   t[2914] = 7468;
Kode lerroa:   t[2916] = 7470;
Kode lerroa:   t[2917] = 7471;
Kode lerroa:   t[2918] = 7472;
Kode lerroa:   t[2920] = 7474;
Kode lerroa:   t[2921] = 7475;
Kode lerroa:   t[2922] = 7476;
Kode lerroa:   t[2924] = 7478;
Kode lerroa:   t[2925] = 7479;
Kode lerroa:   t[2926] = 7480;
Kode lerroa:   t[2928] = 7482;
Kode lerroa:   t[2929] = 7483;
Kode lerroa:   t[2930] = 7484;
Kode lerroa:   t[2932] = 7486;
Kode lerroa:   t[2933] = 7487;
Kode lerroa:   t[2934] = 7488;
Kode lerroa:   t[2936] = 7490;
Kode lerroa:   t[2937] = 7491;
Kode lerroa:   t[2938] = 7492;
Kode lerroa:   t[2940] = 7494;
Kode lerroa:   t[2941] = 7495;
Kode lerroa:   t[2942] = 7496;
Kode lerroa:   t[2944] = 7498;
Kode lerroa:   t[2946] = 7500;
Kode lerroa:   t[2948] = 7502;
Kode lerroa:   t[2950] = 7504;
Kode lerroa:   t[2951] = 7505;
Kode lerroa:   t[2952] = 7506;
Kode lerroa:   t[2954] = 7508;
Kode lerroa:   t[2955] = 7509;
Kode lerroa:   t[2956] = 7510;
Kode lerroa:   t[2958] = 7512;
Kode lerroa:   t[2959] = 7513;
Kode lerroa:   t[2960] = 7514;
Kode lerroa:   t[2962] = 7516;
Kode lerroa:   t[2963] = 7517;
Kode lerroa:   t[2964] = 7518;
Kode lerroa:   t[2966] = 7520;
Kode lerroa:   t[2967] = 7521;
Kode lerroa:   t[2968] = 7522;
Kode lerroa:   t[2970] = 7524;
Kode lerroa:   t[2971] = 7525;
Kode lerroa:   t[2972] = 7526;
Kode lerroa:   t[2974] = 7528;
Kode lerroa:   t[2975] = 7529;
Kode lerroa:   t[2976] = 7530;
Kode lerroa:   t[2978] = 1537;
Kode lerroa:   t[2979] = 1538;
Kode lerroa:   t[2980] = 1539;
Kode lerroa:   t[2982] = 1549;
Kode lerroa:   t[2983] = 1551;
Kode lerroa:   t[2984] = 1552;
Kode lerroa:   t[2986] = 1554;
Kode lerroa:   t[2987] = 1555;
Kode lerroa:   t[2988] = 1556;
Kode lerroa:   t[2990] = 1623;
Kode lerroa:   t[2991] = 1624;
Kode lerroa:   t[2995] = 1775;
Kode lerroa:   t[2999] = 1791;
Kode lerroa:   t[3002] = 64290;
Kode lerroa:   t[3003] = 64291;
Kode lerroa:   t[3004] = 64292;
Kode lerroa:   t[3006] = 64294;
Kode lerroa:   t[3007] = 64295;
Kode lerroa:   t[3008] = 64296;
Kode lerroa:   t[3011] = 1900;
Kode lerroa:   t[3014] = 8223;
Kode lerroa:   t[3015] = 8244;
Kode lerroa:   t[3017] = 7532;
Kode lerroa:   t[3018] = 7533;
Kode lerroa:   t[3019] = 7534;
Kode lerroa:   t[3075] = 7590;
Kode lerroa:   t[3076] = 7591;
Kode lerroa:   t[3079] = 7594;
Kode lerroa:   t[3080] = 7595;
Kode lerroa:   t[3083] = 7598;
Kode lerroa:   t[3084] = 7599;
Kode lerroa:   t[3087] = 7602;
Kode lerroa:   t[3088] = 7603;
Kode lerroa:   t[3091] = 7606;
Kode lerroa:   t[3092] = 7607;
Kode lerroa:   t[3095] = 7610;
Kode lerroa:   t[3096] = 7611;
Kode lerroa:   t[3099] = 7614;
Kode lerroa:   t[3100] = 7615;
Kode lerroa:   t[3103] = 7618;
Kode lerroa:   t[3104] = 7619;
Kode lerroa:   t[3107] = 8337;
Kode lerroa:   t[3108] = 8338;
Kode lerroa:   t[3116] = 1884;
Kode lerroa:   t[3119] = 1885;
Kode lerroa:   t[3120] = 1885;
Kode lerroa:   t[3123] = 1886;
Kode lerroa:   t[3124] = 1886;
Kode lerroa:   t[3127] = 1887;
Kode lerroa:   t[3128] = 1887;
Kode lerroa:   t[3131] = 1888;
Kode lerroa:   t[3132] = 1888;
Kode lerroa:   t[3135] = 1889;
Kode lerroa:   t[3136] = 1889;
Kode lerroa:   t[3139] = 1890;
Kode lerroa:   t[3140] = 1890;
Kode lerroa:   t[3143] = 1891;
Kode lerroa:   t[3144] = 1891;
Kode lerroa:   t[3147] = 1892;
Kode lerroa:   t[3148] = 1892;
Kode lerroa:   t[3153] = 580;
Kode lerroa:   t[3154] = 581;
Kode lerroa:   t[3157] = 584;
Kode lerroa:   t[3158] = 585;
Kode lerroa:   t[3161] = 588;
Kode lerroa:   t[3162] = 589;
Kode lerroa:   t[3165] = 891;
Kode lerroa:   t[3166] = 892;
Kode lerroa:   t[3169] = 1274;
Kode lerroa:   t[3170] = 1275;
Kode lerroa:   t[3173] = 1278;
Kode lerroa:   t[3174] = 1279;
Kode lerroa:   t[3181] = 7622;
Kode lerroa:   t[3182] = 7623;
Kode lerroa:   t[3282] = 11799;
Kode lerroa:   t[3316] = 578;
Kode lerroa:   t[3379] = 42785;
Kode lerroa:   t[3393] = 1159;
Kode lerroa:   t[3416] = 8377;
Kode lerroa: });
Kode lerroa: var getSupplementalGlyphMapForArialBlack = (0, _util.getLookupTableFactory)(function (t) {
Kode lerroa:   t[227] = 322;
Kode lerroa:   t[264] = 261;
Kode lerroa:   t[291] = 346;
Kode lerroa: });
Kode lerroa: exports.getStdFontMap = getStdFontMap;
Kode lerroa: exports.getNonStdFontMap = getNonStdFontMap;
Kode lerroa: exports.getSerifFonts = getSerifFonts;
Kode lerroa: exports.getSymbolsFonts = getSymbolsFonts;
Kode lerroa: exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
Kode lerroa: exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 80 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: var getLookupTableFactory = __w_pdfjs_require__(0).getLookupTableFactory;
Kode lerroa: var getSpecialPUASymbols = getLookupTableFactory(function (t) {
Kode lerroa:  t[63721] = 0x00A9;
Kode lerroa:  t[63193] = 0x00A9;
Kode lerroa:  t[63720] = 0x00AE;
Kode lerroa:  t[63194] = 0x00AE;
Kode lerroa:  t[63722] = 0x2122;
Kode lerroa:  t[63195] = 0x2122;
Kode lerroa:  t[63729] = 0x23A7;
Kode lerroa:  t[63730] = 0x23A8;
Kode lerroa:  t[63731] = 0x23A9;
Kode lerroa:  t[63740] = 0x23AB;
Kode lerroa:  t[63741] = 0x23AC;
Kode lerroa:  t[63742] = 0x23AD;
Kode lerroa:  t[63726] = 0x23A1;
Kode lerroa:  t[63727] = 0x23A2;
Kode lerroa:  t[63728] = 0x23A3;
Kode lerroa:  t[63737] = 0x23A4;
Kode lerroa:  t[63738] = 0x23A5;
Kode lerroa:  t[63739] = 0x23A6;
Kode lerroa:  t[63723] = 0x239B;
Kode lerroa:  t[63724] = 0x239C;
Kode lerroa:  t[63725] = 0x239D;
Kode lerroa:  t[63734] = 0x239E;
Kode lerroa:  t[63735] = 0x239F;
Kode lerroa:  t[63736] = 0x23A0;
Kode lerroa: });
Kode lerroa: function mapSpecialUnicodeValues(code) {
Kode lerroa:  if (code >= 0xFFF0 && code <= 0xFFFF) {
Kode lerroa:   return 0;
Kode lerroa:  } else if (code >= 0xF600 && code <= 0xF8FF) {
Kode lerroa:   return getSpecialPUASymbols()[code] || code;
Kode lerroa:  } else if (code === 0x00AD) {
Kode lerroa:   return 0x002D;
Kode lerroa:  }
Kode lerroa:  return code;
Kode lerroa: }
Kode lerroa: function getUnicodeForGlyph(name, glyphsUnicodeMap) {
Kode lerroa:  var unicode = glyphsUnicodeMap[name];
Kode lerroa:  if (unicode !== undefined) {
Kode lerroa:   return unicode;
Kode lerroa:  }
Kode lerroa:  if (!name) {
Kode lerroa:   return -1;
Kode lerroa:  }
Kode lerroa:  if (name[0] === 'u') {
Kode lerroa:   var nameLen = name.length, hexStr;
Kode lerroa:   if (nameLen === 7 && name[1] === 'n' && name[2] === 'i') {
Kode lerroa:    hexStr = name.substr(3);
Kode lerroa:   } else if (nameLen >= 5 && nameLen <= 7) {
Kode lerroa:    hexStr = name.substr(1);
Kode lerroa:   } else {
Kode lerroa:    return -1;
Kode lerroa:   }
Kode lerroa:   if (hexStr === hexStr.toUpperCase()) {
Kode lerroa:    unicode = parseInt(hexStr, 16);
Kode lerroa:    if (unicode >= 0) {
Kode lerroa:     return unicode;
Kode lerroa:    }
Kode lerroa:   }
Kode lerroa:  }
Kode lerroa:  return -1;
Kode lerroa: }
Kode lerroa: var UnicodeRanges = [
Kode lerroa:  {
Kode lerroa:   'begin': 0x0000,
Kode lerroa:   'end': 0x007F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0080,
Kode lerroa:   'end': 0x00FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0100,
Kode lerroa:   'end': 0x017F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0180,
Kode lerroa:   'end': 0x024F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0250,
Kode lerroa:   'end': 0x02AF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x02B0,
Kode lerroa:   'end': 0x02FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0300,
Kode lerroa:   'end': 0x036F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0370,
Kode lerroa:   'end': 0x03FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2C80,
Kode lerroa:   'end': 0x2CFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0400,
Kode lerroa:   'end': 0x04FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0530,
Kode lerroa:   'end': 0x058F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0590,
Kode lerroa:   'end': 0x05FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA500,
Kode lerroa:   'end': 0xA63F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0600,
Kode lerroa:   'end': 0x06FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x07C0,
Kode lerroa:   'end': 0x07FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0900,
Kode lerroa:   'end': 0x097F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0980,
Kode lerroa:   'end': 0x09FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0A00,
Kode lerroa:   'end': 0x0A7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0A80,
Kode lerroa:   'end': 0x0AFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0B00,
Kode lerroa:   'end': 0x0B7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0B80,
Kode lerroa:   'end': 0x0BFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0C00,
Kode lerroa:   'end': 0x0C7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0C80,
Kode lerroa:   'end': 0x0CFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0D00,
Kode lerroa:   'end': 0x0D7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0E00,
Kode lerroa:   'end': 0x0E7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0E80,
Kode lerroa:   'end': 0x0EFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10A0,
Kode lerroa:   'end': 0x10FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1B00,
Kode lerroa:   'end': 0x1B7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1100,
Kode lerroa:   'end': 0x11FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1E00,
Kode lerroa:   'end': 0x1EFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1F00,
Kode lerroa:   'end': 0x1FFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2000,
Kode lerroa:   'end': 0x206F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2070,
Kode lerroa:   'end': 0x209F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x20A0,
Kode lerroa:   'end': 0x20CF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x20D0,
Kode lerroa:   'end': 0x20FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2100,
Kode lerroa:   'end': 0x214F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2150,
Kode lerroa:   'end': 0x218F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2190,
Kode lerroa:   'end': 0x21FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2200,
Kode lerroa:   'end': 0x22FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2300,
Kode lerroa:   'end': 0x23FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2400,
Kode lerroa:   'end': 0x243F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2440,
Kode lerroa:   'end': 0x245F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2460,
Kode lerroa:   'end': 0x24FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2500,
Kode lerroa:   'end': 0x257F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2580,
Kode lerroa:   'end': 0x259F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x25A0,
Kode lerroa:   'end': 0x25FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2600,
Kode lerroa:   'end': 0x26FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2700,
Kode lerroa:   'end': 0x27BF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x3000,
Kode lerroa:   'end': 0x303F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x3040,
Kode lerroa:   'end': 0x309F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x30A0,
Kode lerroa:   'end': 0x30FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x3100,
Kode lerroa:   'end': 0x312F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x3130,
Kode lerroa:   'end': 0x318F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA840,
Kode lerroa:   'end': 0xA87F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x3200,
Kode lerroa:   'end': 0x32FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x3300,
Kode lerroa:   'end': 0x33FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xAC00,
Kode lerroa:   'end': 0xD7AF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xD800,
Kode lerroa:   'end': 0xDFFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10900,
Kode lerroa:   'end': 0x1091F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x4E00,
Kode lerroa:   'end': 0x9FFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xE000,
Kode lerroa:   'end': 0xF8FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x31C0,
Kode lerroa:   'end': 0x31EF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFB00,
Kode lerroa:   'end': 0xFB4F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFB50,
Kode lerroa:   'end': 0xFDFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFE20,
Kode lerroa:   'end': 0xFE2F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFE10,
Kode lerroa:   'end': 0xFE1F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFE50,
Kode lerroa:   'end': 0xFE6F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFE70,
Kode lerroa:   'end': 0xFEFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFF00,
Kode lerroa:   'end': 0xFFEF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFFF0,
Kode lerroa:   'end': 0xFFFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0F00,
Kode lerroa:   'end': 0x0FFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0700,
Kode lerroa:   'end': 0x074F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0780,
Kode lerroa:   'end': 0x07BF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x0D80,
Kode lerroa:   'end': 0x0DFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1000,
Kode lerroa:   'end': 0x109F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1200,
Kode lerroa:   'end': 0x137F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x13A0,
Kode lerroa:   'end': 0x13FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1400,
Kode lerroa:   'end': 0x167F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1680,
Kode lerroa:   'end': 0x169F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x16A0,
Kode lerroa:   'end': 0x16FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1780,
Kode lerroa:   'end': 0x17FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1800,
Kode lerroa:   'end': 0x18AF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2800,
Kode lerroa:   'end': 0x28FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA000,
Kode lerroa:   'end': 0xA48F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1700,
Kode lerroa:   'end': 0x171F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10300,
Kode lerroa:   'end': 0x1032F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10330,
Kode lerroa:   'end': 0x1034F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10400,
Kode lerroa:   'end': 0x1044F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1D000,
Kode lerroa:   'end': 0x1D0FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1D400,
Kode lerroa:   'end': 0x1D7FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFF000,
Kode lerroa:   'end': 0xFFFFD
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xFE00,
Kode lerroa:   'end': 0xFE0F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xE0000,
Kode lerroa:   'end': 0xE007F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1900,
Kode lerroa:   'end': 0x194F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1950,
Kode lerroa:   'end': 0x197F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1980,
Kode lerroa:   'end': 0x19DF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1A00,
Kode lerroa:   'end': 0x1A1F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2C00,
Kode lerroa:   'end': 0x2C5F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x2D30,
Kode lerroa:   'end': 0x2D7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x4DC0,
Kode lerroa:   'end': 0x4DFF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA800,
Kode lerroa:   'end': 0xA82F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10000,
Kode lerroa:   'end': 0x1007F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10140,
Kode lerroa:   'end': 0x1018F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10380,
Kode lerroa:   'end': 0x1039F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x103A0,
Kode lerroa:   'end': 0x103DF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10450,
Kode lerroa:   'end': 0x1047F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10480,
Kode lerroa:   'end': 0x104AF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10800,
Kode lerroa:   'end': 0x1083F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10A00,
Kode lerroa:   'end': 0x10A5F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1D300,
Kode lerroa:   'end': 0x1D35F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x12000,
Kode lerroa:   'end': 0x123FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1D360,
Kode lerroa:   'end': 0x1D37F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1B80,
Kode lerroa:   'end': 0x1BBF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1C00,
Kode lerroa:   'end': 0x1C4F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1C50,
Kode lerroa:   'end': 0x1C7F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA880,
Kode lerroa:   'end': 0xA8DF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA900,
Kode lerroa:   'end': 0xA92F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xA930,
Kode lerroa:   'end': 0xA95F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0xAA00,
Kode lerroa:   'end': 0xAA5F
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x10190,
Kode lerroa:   'end': 0x101CF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x101D0,
Kode lerroa:   'end': 0x101FF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x102A0,
Kode lerroa:   'end': 0x102DF
Kode lerroa:  },
Kode lerroa:  {
Kode lerroa:   'begin': 0x1F030,
Kode lerroa:   'end': 0x1F09F
Kode lerroa:  }
Kode lerroa: ];
Kode lerroa: function getUnicodeRangeFor(value) {
Kode lerroa:  for (var i = 0, ii = UnicodeRanges.length; i < ii; i++) {
Kode lerroa:   var range = UnicodeRanges[i];
Kode lerroa:   if (value >= range.begin && value < range.end) {
Kode lerroa:    return i;
Kode lerroa:   }
Kode lerroa:  }
Kode lerroa:  return -1;
Kode lerroa: }
Kode lerroa: function isRTLRangeFor(value) {
Kode lerroa:  var range = UnicodeRanges[13];
Kode lerroa:  if (value >= range.begin && value < range.end) {
Kode lerroa:   return true;
Kode lerroa:  }
Kode lerroa:  range = UnicodeRanges[11];
Kode lerroa:  if (value >= range.begin && value < range.end) {
Kode lerroa:   return true;
Kode lerroa:  }
Kode lerroa:  return false;
Kode lerroa: }
Kode lerroa: var getNormalizedUnicodes = getLookupTableFactory(function (t) {
Kode lerroa:  t['\u00A8'] = '\u0020\u0308';
Kode lerroa:  t['\u00AF'] = '\u0020\u0304';
Kode lerroa:  t['\u00B4'] = '\u0020\u0301';
Kode lerroa:  t['\u00B5'] = '\u03BC';
Kode lerroa:  t['\u00B8'] = '\u0020\u0327';
Kode lerroa:  t['\u0132'] = '\u0049\u004A';
Kode lerroa:  t['\u0133'] = '\u0069\u006A';
Kode lerroa:  t['\u013F'] = '\u004C\u00B7';
Kode lerroa:  t['\u0140'] = '\u006C\u00B7';
Kode lerroa:  t['\u0149'] = '\u02BC\u006E';
Kode lerroa:  t['\u017F'] = '\u0073';
Kode lerroa:  t['\u01C4'] = '\u0044\u017D';
Kode lerroa:  t['\u01C5'] = '\u0044\u017E';
Kode lerroa:  t['\u01C6'] = '\u0064\u017E';
Kode lerroa:  t['\u01C7'] = '\u004C\u004A';
Kode lerroa:  t['\u01C8'] = '\u004C\u006A';
Kode lerroa:  t['\u01C9'] = '\u006C\u006A';
Kode lerroa:  t['\u01CA'] = '\u004E\u004A';
Kode lerroa:  t['\u01CB'] = '\u004E\u006A';
Kode lerroa:  t['\u01CC'] = '\u006E\u006A';
Kode lerroa:  t['\u01F1'] = '\u0044\u005A';
Kode lerroa:  t['\u01F2'] = '\u0044\u007A';
Kode lerroa:  t['\u01F3'] = '\u0064\u007A';
Kode lerroa:  t['\u02D8'] = '\u0020\u0306';
Kode lerroa:  t['\u02D9'] = '\u0020\u0307';
Kode lerroa:  t['\u02DA'] = '\u0020\u030A';
Kode lerroa:  t['\u02DB'] = '\u0020\u0328';
Kode lerroa:  t['\u02DC'] = '\u0020\u0303';
Kode lerroa:  t['\u02DD'] = '\u0020\u030B';
Kode lerroa:  t['\u037A'] = '\u0020\u0345';
Kode lerroa:  t['\u0384'] = '\u0020\u0301';
Kode lerroa:  t['\u03D0'] = '\u03B2';
Kode lerroa:  t['\u03D1'] = '\u03B8';
Kode lerroa:  t['\u03D2'] = '\u03A5';
Kode lerroa:  t['\u03D5'] = '\u03C6';
Kode lerroa:  t['\u03D6'] = '\u03C0';
Kode lerroa:  t['\u03F0'] = '\u03BA';
Kode lerroa:  t['\u03F1'] = '\u03C1';
Kode lerroa:  t['\u03F2'] = '\u03C2';
Kode lerroa:  t['\u03F4'] = '\u0398';
Kode lerroa:  t['\u03F5'] = '\u03B5';
Kode lerroa:  t['\u03F9'] = '\u03A3';
Kode lerroa:  t['\u0587'] = '\u0565\u0582';
Kode lerroa:  t['\u0675'] = '\u0627\u0674';
Kode lerroa:  t['\u0676'] = '\u0648\u0674';
Kode lerroa:  t['\u0677'] = '\u06C7\u0674';
Kode lerroa:  t['\u0678'] = '\u064A\u0674';
Kode lerroa:  t['\u0E33'] = '\u0E4D\u0E32';
Kode lerroa:  t['\u0EB3'] = '\u0ECD\u0EB2';
Kode lerroa:  t['\u0EDC'] = '\u0EAB\u0E99';
Kode lerroa:  t['\u0EDD'] = '\u0EAB\u0EA1';
Kode lerroa:  t['\u0F77'] = '\u0FB2\u0F81';
Kode lerroa:  t['\u0F79'] = '\u0FB3\u0F81';
Kode lerroa:  t['\u1E9A'] = '\u0061\u02BE';
Kode lerroa:  t['\u1FBD'] = '\u0020\u0313';
Kode lerroa:  t['\u1FBF'] = '\u0020\u0313';
Kode lerroa:  t['\u1FC0'] = '\u0020\u0342';
Kode lerroa:  t['\u1FFE'] = '\u0020\u0314';
Kode lerroa:  t['\u2002'] = '\u0020';
Kode lerroa:  t['\u2003'] = '\u0020';
Kode lerroa:  t['\u2004'] = '\u0020';
Kode lerroa:  t['\u2005'] = '\u0020';
Kode lerroa:  t['\u2006'] = '\u0020';
Kode lerroa:  t['\u2008'] = '\u0020';
Kode lerroa:  t['\u2009'] = '\u0020';
Kode lerroa:  t['\u200A'] = '\u0020';
Kode lerroa:  t['\u2017'] = '\u0020\u0333';
Kode lerroa:  t['\u2024'] = '\u002E';
Kode lerroa:  t['\u2025'] = '\u002E\u002E';
Kode lerroa:  t['\u2026'] = '\u002E\u002E\u002E';
Kode lerroa:  t['\u2033'] = '\u2032\u2032';
Kode lerroa:  t['\u2034'] = '\u2032\u2032\u2032';
Kode lerroa:  t['\u2036'] = '\u2035\u2035';
Kode lerroa:  t['\u2037'] = '\u2035\u2035\u2035';
Kode lerroa:  t['\u203C'] = '\u0021\u0021';
Kode lerroa:  t['\u203E'] = '\u0020\u0305';
Kode lerroa:  t['\u2047'] = '\u003F\u003F';
Kode lerroa:  t['\u2048'] = '\u003F\u0021';
Kode lerroa:  t['\u2049'] = '\u0021\u003F';
Kode lerroa:  t['\u2057'] = '\u2032\u2032\u2032\u2032';
Kode lerroa:  t['\u205F'] = '\u0020';
Kode lerroa:  t['\u20A8'] = '\u0052\u0073';
Kode lerroa:  t['\u2100'] = '\u0061\u002F\u0063';
Kode lerroa:  t['\u2101'] = '\u0061\u002F\u0073';
Kode lerroa:  t['\u2103'] = '\u00B0\u0043';
Kode lerroa:  t['\u2105'] = '\u0063\u002F\u006F';
Kode lerroa:  t['\u2106'] = '\u0063\u002F\u0075';
Kode lerroa:  t['\u2107'] = '\u0190';
Kode lerroa:  t['\u2109'] = '\u00B0\u0046';
Kode lerroa:  t['\u2116'] = '\u004E\u006F';
Kode lerroa:  t['\u2121'] = '\u0054\u0045\u004C';
Kode lerroa:  t['\u2135'] = '\u05D0';
Kode lerroa:  t['\u2136'] = '\u05D1';
Kode lerroa:  t['\u2137'] = '\u05D2';
Kode lerroa:  t['\u2138'] = '\u05D3';
Kode lerroa:  t['\u213B'] = '\u0046\u0041\u0058';
Kode lerroa:  t['\u2160'] = '\u0049';
Kode lerroa:  t['\u2161'] = '\u0049\u0049';
Kode lerroa:  t['\u2162'] = '\u0049\u0049\u0049';
Kode lerroa:  t['\u2163'] = '\u0049\u0056';
Kode lerroa:  t['\u2164'] = '\u0056';
Kode lerroa:  t['\u2165'] = '\u0056\u0049';
Kode lerroa:  t['\u2166'] = '\u0056\u0049\u0049';
Kode lerroa:  t['\u2167'] = '\u0056\u0049\u0049\u0049';
Kode lerroa:  t['\u2168'] = '\u0049\u0058';
Kode lerroa:  t['\u2169'] = '\u0058';
Kode lerroa:  t['\u216A'] = '\u0058\u0049';
Kode lerroa:  t['\u216B'] = '\u0058\u0049\u0049';
Kode lerroa:  t['\u216C'] = '\u004C';
Kode lerroa:  t['\u216D'] = '\u0043';
Kode lerroa:  t['\u216E'] = '\u0044';
Kode lerroa:  t['\u216F'] = '\u004D';
Kode lerroa:  t['\u2170'] = '\u0069';
Kode lerroa:  t['\u2171'] = '\u0069\u0069';
Kode lerroa:  t['\u2172'] = '\u0069\u0069\u0069';
Kode lerroa:  t['\u2173'] = '\u0069\u0076';
Kode lerroa:  t['\u2174'] = '\u0076';
Kode lerroa:  t['\u2175'] = '\u0076\u0069';
Kode lerroa:  t['\u2176'] = '\u0076\u0069\u0069';
Kode lerroa:  t['\u2177'] = '\u0076\u0069\u0069\u0069';
Kode lerroa:  t['\u2178'] = '\u0069\u0078';
Kode lerroa:  t['\u2179'] = '\u0078';
Kode lerroa:  t['\u217A'] = '\u0078\u0069';
Kode lerroa:  t['\u217B'] = '\u0078\u0069\u0069';
Kode lerroa:  t['\u217C'] = '\u006C';
Kode lerroa:  t['\u217D'] = '\u0063';
Kode lerroa:  t['\u217E'] = '\u0064';
Kode lerroa:  t['\u217F'] = '\u006D';
Kode lerroa:  t['\u222C'] = '\u222B\u222B';
Kode lerroa:  t['\u222D'] = '\u222B\u222B\u222B';
Kode lerroa:  t['\u222F'] = '\u222E\u222E';
Kode lerroa:  t['\u2230'] = '\u222E\u222E\u222E';
Kode lerroa:  t['\u2474'] = '\u0028\u0031\u0029';
Kode lerroa:  t['\u2475'] = '\u0028\u0032\u0029';
Kode lerroa:  t['\u2476'] = '\u0028\u0033\u0029';
Kode lerroa:  t['\u2477'] = '\u0028\u0034\u0029';
Kode lerroa:  t['\u2478'] = '\u0028\u0035\u0029';
Kode lerroa:  t['\u2479'] = '\u0028\u0036\u0029';
Kode lerroa:  t['\u247A'] = '\u0028\u0037\u0029';
Kode lerroa:  t['\u247B'] = '\u0028\u0038\u0029';
Kode lerroa:  t['\u247C'] = '\u0028\u0039\u0029';
Kode lerroa:  t['\u247D'] = '\u0028\u0031\u0030\u0029';
Kode lerroa:  t['\u247E'] = '\u0028\u0031\u0031\u0029';
Kode lerroa:  t['\u247F'] = '\u0028\u0031\u0032\u0029';
Kode lerroa:  t['\u2480'] = '\u0028\u0031\u0033\u0029';
Kode lerroa:  t['\u2481'] = '\u0028\u0031\u0034\u0029';
Kode lerroa:  t['\u2482'] = '\u0028\u0031\u0035\u0029';
Kode lerroa:  t['\u2483'] = '\u0028\u0031\u0036\u0029';
Kode lerroa:  t['\u2484'] = '\u0028\u0031\u0037\u0029';
Kode lerroa:  t['\u2485'] = '\u0028\u0031\u0038\u0029';
Kode lerroa:  t['\u2486'] = '\u0028\u0031\u0039\u0029';
Kode lerroa:  t['\u2487'] = '\u0028\u0032\u0030\u0029';
Kode lerroa:  t['\u2488'] = '\u0031\u002E';
Kode lerroa:  t['\u2489'] = '\u0032\u002E';
Kode lerroa:  t['\u248A'] = '\u0033\u002E';
Kode lerroa:  t['\u248B'] = '\u0034\u002E';
Kode lerroa:  t['\u248C'] = '\u0035\u002E';
Kode lerroa:  t['\u248D'] = '\u0036\u002E';
Kode lerroa:  t['\u248E'] = '\u0037\u002E';
Kode lerroa:  t['\u248F'] = '\u0038\u002E';
Kode lerroa:  t['\u2490'] = '\u0039\u002E';
Kode lerroa:  t['\u2491'] = '\u0031\u0030\u002E';
Kode lerroa:  t['\u2492'] = '\u0031\u0031\u002E';
Kode lerroa:  t['\u2493'] = '\u0031\u0032\u002E';
Kode lerroa:  t['\u2494'] = '\u0031\u0033\u002E';
Kode lerroa:  t['\u2495'] = '\u0031\u0034\u002E';
Kode lerroa:  t['\u2496'] = '\u0031\u0035\u002E';
Kode lerroa:  t['\u2497'] = '\u0031\u0036\u002E';
Kode lerroa:  t['\u2498'] = '\u0031\u0037\u002E';
Kode lerroa:  t['\u2499'] = '\u0031\u0038\u002E';
Kode lerroa:  t['\u249A'] = '\u0031\u0039\u002E';
Kode lerroa:  t['\u249B'] = '\u0032\u0030\u002E';
Kode lerroa:  t['\u249C'] = '\u0028\u0061\u0029';
Kode lerroa:  t['\u249D'] = '\u0028\u0062\u0029';
Kode lerroa:  t['\u249E'] = '\u0028\u0063\u0029';
Kode lerroa:  t['\u249F'] = '\u0028\u0064\u0029';
Kode lerroa:  t['\u24A0'] = '\u0028\u0065\u0029';
Kode lerroa:  t['\u24A1'] = '\u0028\u0066\u0029';
Kode lerroa:  t['\u24A2'] = '\u0028\u0067\u0029';
Kode lerroa:  t['\u24A3'] = '\u0028\u0068\u0029';
Kode lerroa:  t['\u24A4'] = '\u0028\u0069\u0029';
Kode lerroa:  t['\u24A5'] = '\u0028\u006A\u0029';
Kode lerroa:  t['\u24A6'] = '\u0028\u006B\u0029';
Kode lerroa:  t['\u24A7'] = '\u0028\u006C\u0029';
Kode lerroa:  t['\u24A8'] = '\u0028\u006D\u0029';
Kode lerroa:  t['\u24A9'] = '\u0028\u006E\u0029';
Kode lerroa:  t['\u24AA'] = '\u0028\u006F\u0029';
Kode lerroa:  t['\u24AB'] = '\u0028\u0070\u0029';
Kode lerroa:  t['\u24AC'] = '\u0028\u0071\u0029';
Kode lerroa:  t['\u24AD'] = '\u0028\u0072\u0029';
Kode lerroa:  t['\u24AE'] = '\u0028\u0073\u0029';
Kode lerroa:  t['\u24AF'] = '\u0028\u0074\u0029';
Kode lerroa:  t['\u24B0'] = '\u0028\u0075\u0029';
Kode lerroa:  t['\u24B1'] = '\u0028\u0076\u0029';
Kode lerroa:  t['\u24B2'] = '\u0028\u0077\u0029';
Kode lerroa:  t['\u24B3'] = '\u0028\u0078\u0029';
Kode lerroa:  t['\u24B4'] = '\u0028\u0079\u0029';
Kode lerroa:  t['\u24B5'] = '\u0028\u007A\u0029';
Kode lerroa:  t['\u2A0C'] = '\u222B\u222B\u222B\u222B';
Kode lerroa:  t['\u2A74'] = '\u003A\u003A\u003D';
Kode lerroa:  t['\u2A75'] = '\u003D\u003D';
Kode lerroa:  t['\u2A76'] = '\u003D\u003D\u003D';
Kode lerroa:  t['\u2E9F'] = '\u6BCD';
Kode lerroa:  t['\u2EF3'] = '\u9F9F';
Kode lerroa:  t['\u2F00'] = '\u4E00';
Kode lerroa:  t['\u2F01'] = '\u4E28';
Kode lerroa:  t['\u2F02'] = '\u4E36';
Kode lerroa:  t['\u2F03'] = '\u4E3F';
Kode lerroa:  t['\u2F04'] = '\u4E59';
Kode lerroa:  t['\u2F05'] = '\u4E85';
Kode lerroa:  t['\u2F06'] = '\u4E8C';
Kode lerroa:  t['\u2F07'] = '\u4EA0';
Kode lerroa:  t['\u2F08'] = '\u4EBA';
Kode lerroa:  t['\u2F09'] = '\u513F';
Kode lerroa:  t['\u2F0A'] = '\u5165';
Kode lerroa:  t['\u2F0B'] = '\u516B';
Kode lerroa:  t['\u2F0C'] = '\u5182';
Kode lerroa:  t['\u2F0D'] = '\u5196';
Kode lerroa:  t['\u2F0E'] = '\u51AB';
Kode lerroa:  t['\u2F0F'] = '\u51E0';
Kode lerroa:  t['\u2F10'] = '\u51F5';
Kode lerroa:  t['\u2F11'] = '\u5200';
Kode lerroa:  t['\u2F12'] = '\u529B';
Kode lerroa:  t['\u2F13'] = '\u52F9';
Kode lerroa:  t['\u2F14'] = '\u5315';
Kode lerroa:  t['\u2F15'] = '\u531A';
Kode lerroa:  t['\u2F16'] = '\u5338';
Kode lerroa:  t['\u2F17'] = '\u5341';
Kode lerroa:  t['\u2F18'] = '\u535C';
Kode lerroa:  t['\u2F19'] = '\u5369';
Kode lerroa:  t['\u2F1A'] = '\u5382';
Kode lerroa:  t['\u2F1B'] = '\u53B6';
Kode lerroa:  t['\u2F1C'] = '\u53C8';
Kode lerroa:  t['\u2F1D'] = '\u53E3';
Kode lerroa:  t['\u2F1E'] = '\u56D7';
Kode lerroa:  t['\u2F1F'] = '\u571F';
Kode lerroa:  t['\u2F20'] = '\u58EB';
Kode lerroa:  t['\u2F21'] = '\u5902';
Kode lerroa:  t['\u2F22'] = '\u590A';
Kode lerroa:  t['\u2F23'] = '\u5915';
Kode lerroa:  t['\u2F24'] = '\u5927';
Kode lerroa:  t['\u2F25'] = '\u5973';
Kode lerroa:  t['\u2F26'] = '\u5B50';
Kode lerroa:  t['\u2F27'] = '\u5B80';
Kode lerroa:  t['\u2F28'] = '\u5BF8';
Kode lerroa:  t['\u2F29'] = '\u5C0F';
Kode lerroa:  t['\u2F2A'] = '\u5C22';
Kode lerroa:  t['\u2F2B'] = '\u5C38';
Kode lerroa:  t['\u2F2C'] = '\u5C6E';
Kode lerroa:  t['\u2F2D'] = '\u5C71';
Kode lerroa:  t['\u2F2E'] = '\u5DDB';
Kode lerroa:  t['\u2F2F'] = '\u5DE5';
Kode lerroa:  t['\u2F30'] = '\u5DF1';
Kode lerroa:  t['\u2F31'] = '\u5DFE';
Kode lerroa:  t['\u2F32'] = '\u5E72';
Kode lerroa:  t['\u2F33'] = '\u5E7A';
Kode lerroa:  t['\u2F34'] = '\u5E7F';
Kode lerroa:  t['\u2F35'] = '\u5EF4';
Kode lerroa:  t['\u2F36'] = '\u5EFE';
Kode lerroa:  t['\u2F37'] = '\u5F0B';
Kode lerroa:  t['\u2F38'] = '\u5F13';
Kode lerroa:  t['\u2F39'] = '\u5F50';
Kode lerroa:  t['\u2F3A'] = '\u5F61';
Kode lerroa:  t['\u2F3B'] = '\u5F73';
Kode lerroa:  t['\u2F3C'] = '\u5FC3';
Kode lerroa:  t['\u2F3D'] = '\u6208';
Kode lerroa:  t['\u2F3E'] = '\u6236';
Kode lerroa:  t['\u2F3F'] = '\u624B';
Kode lerroa:  t['\u2F40'] = '\u652F';
Kode lerroa:  t['\u2F41'] = '\u6534';
Kode lerroa:  t['\u2F42'] = '\u6587';
Kode lerroa:  t['\u2F43'] = '\u6597';
Kode lerroa:  t['\u2F44'] = '\u65A4';
Kode lerroa:  t['\u2F45'] = '\u65B9';
Kode lerroa:  t['\u2F46'] = '\u65E0';
Kode lerroa:  t['\u2F47'] = '\u65E5';
Kode lerroa:  t['\u2F48'] = '\u66F0';
Kode lerroa:  t['\u2F49'] = '\u6708';
Kode lerroa:  t['\u2F4A'] = '\u6728';
Kode lerroa:  t['\u2F4B'] = '\u6B20';
Kode lerroa:  t['\u2F4C'] = '\u6B62';
Kode lerroa:  t['\u2F4D'] = '\u6B79';
Kode lerroa:  t['\u2F4E'] = '\u6BB3';
Kode lerroa:  t['\u2F4F'] = '\u6BCB';
Kode lerroa:  t['\u2F50'] = '\u6BD4';
Kode lerroa:  t['\u2F51'] = '\u6BDB';
Kode lerroa:  t['\u2F52'] = '\u6C0F';
Kode lerroa:  t['\u2F53'] = '\u6C14';
Kode lerroa:  t['\u2F54'] = '\u6C34';
Kode lerroa:  t['\u2F55'] = '\u706B';
Kode lerroa:  t['\u2F56'] = '\u722A';
Kode lerroa:  t['\u2F57'] = '\u7236';
Kode lerroa:  t['\u2F58'] = '\u723B';
Kode lerroa:  t['\u2F59'] = '\u723F';
Kode lerroa:  t['\u2F5A'] = '\u7247';
Kode lerroa:  t['\u2F5B'] = '\u7259';
Kode lerroa:  t['\u2F5C'] = '\u725B';
Kode lerroa:  t['\u2F5D'] = '\u72AC';
Kode lerroa:  t['\u2F5E'] = '\u7384';
Kode lerroa:  t['\u2F5F'] = '\u7389';
Kode lerroa:  t['\u2F60'] = '\u74DC';
Kode lerroa:  t['\u2F61'] = '\u74E6';
Kode lerroa:  t['\u2F62'] = '\u7518';
Kode lerroa:  t['\u2F63'] = '\u751F';
Kode lerroa:  t['\u2F64'] = '\u7528';
Kode lerroa:  t['\u2F65'] = '\u7530';
Kode lerroa:  t['\u2F66'] = '\u758B';
Kode lerroa:  t['\u2F67'] = '\u7592';
Kode lerroa:  t['\u2F68'] = '\u7676';
Kode lerroa:  t['\u2F69'] = '\u767D';
Kode lerroa:  t['\u2F6A'] = '\u76AE';
Kode lerroa:  t['\u2F6B'] = '\u76BF';
Kode lerroa:  t['\u2F6C'] = '\u76EE';
Kode lerroa:  t['\u2F6D'] = '\u77DB';
Kode lerroa:  t['\u2F6E'] = '\u77E2';
Kode lerroa:  t['\u2F6F'] = '\u77F3';
Kode lerroa:  t['\u2F70'] = '\u793A';
Kode lerroa:  t['\u2F71'] = '\u79B8';
Kode lerroa:  t['\u2F72'] = '\u79BE';
Kode lerroa:  t['\u2F73'] = '\u7A74';
Kode lerroa:  t['\u2F74'] = '\u7ACB';
Kode lerroa:  t['\u2F75'] = '\u7AF9';
Kode lerroa:  t['\u2F76'] = '\u7C73';
Kode lerroa:  t['\u2F77'] = '\u7CF8';
Kode lerroa:  t['\u2F78'] = '\u7F36';
Kode lerroa:  t['\u2F79'] = '\u7F51';
Kode lerroa:  t['\u2F7A'] = '\u7F8A';
Kode lerroa:  t['\u2F7B'] = '\u7FBD';
Kode lerroa:  t['\u2F7C'] = '\u8001';
Kode lerroa:  t['\u2F7D'] = '\u800C';
Kode lerroa:  t['\u2F7E'] = '\u8012';
Kode lerroa:  t['\u2F7F'] = '\u8033';
Kode lerroa:  t['\u2F80'] = '\u807F';
Kode lerroa:  t['\u2F81'] = '\u8089';
Kode lerroa:  t['\u2F82'] = '\u81E3';
Kode lerroa:  t['\u2F83'] = '\u81EA';
Kode lerroa:  t['\u2F84'] = '\u81F3';
Kode lerroa:  t['\u2F85'] = '\u81FC';
Kode lerroa:  t['\u2F86'] = '\u820C';
Kode lerroa:  t['\u2F87'] = '\u821B';
Kode lerroa:  t['\u2F88'] = '\u821F';
Kode lerroa:  t['\u2F89'] = '\u826E';
Kode lerroa:  t['\u2F8A'] = '\u8272';
Kode lerroa:  t['\u2F8B'] = '\u8278';
Kode lerroa:  t['\u2F8C'] = '\u864D';
Kode lerroa:  t['\u2F8D'] = '\u866B';
Kode lerroa:  t['\u2F8E'] = '\u8840';
Kode lerroa:  t['\u2F8F'] = '\u884C';
Kode lerroa:  t['\u2F90'] = '\u8863';
Kode lerroa:  t['\u2F91'] = '\u897E';
Kode lerroa:  t['\u2F92'] = '\u898B';
Kode lerroa:  t['\u2F93'] = '\u89D2';
Kode lerroa:  t['\u2F94'] = '\u8A00';
Kode lerroa:  t['\u2F95'] = '\u8C37';
Kode lerroa:  t['\u2F96'] = '\u8C46';
Kode lerroa:  t['\u2F97'] = '\u8C55';
Kode lerroa:  t['\u2F98'] = '\u8C78';
Kode lerroa:  t['\u2F99'] = '\u8C9D';
Kode lerroa:  t['\u2F9A'] = '\u8D64';
Kode lerroa:  t['\u2F9B'] = '\u8D70';
Kode lerroa:  t['\u2F9C'] = '\u8DB3';
Kode lerroa:  t['\u2F9D'] = '\u8EAB';
Kode lerroa:  t['\u2F9E'] = '\u8ECA';
Kode lerroa:  t['\u2F9F'] = '\u8F9B';
Kode lerroa:  t['\u2FA0'] = '\u8FB0';
Kode lerroa:  t['\u2FA1'] = '\u8FB5';
Kode lerroa:  t['\u2FA2'] = '\u9091';
Kode lerroa:  t['\u2FA3'] = '\u9149';
Kode lerroa:  t['\u2FA4'] = '\u91C6';
Kode lerroa:  t['\u2FA5'] = '\u91CC';
Kode lerroa:  t['\u2FA6'] = '\u91D1';
Kode lerroa:  t['\u2FA7'] = '\u9577';
Kode lerroa:  t['\u2FA8'] = '\u9580';
Kode lerroa:  t['\u2FA9'] = '\u961C';
Kode lerroa:  t['\u2FAA'] = '\u96B6';
Kode lerroa:  t['\u2FAB'] = '\u96B9';
Kode lerroa:  t['\u2FAC'] = '\u96E8';
Kode lerroa:  t['\u2FAD'] = '\u9751';
Kode lerroa:  t['\u2FAE'] = '\u975E';
Kode lerroa:  t['\u2FAF'] = '\u9762';
Kode lerroa:  t['\u2FB0'] = '\u9769';
Kode lerroa:  t['\u2FB1'] = '\u97CB';
Kode lerroa:  t['\u2FB2'] = '\u97ED';
Kode lerroa:  t['\u2FB3'] = '\u97F3';
Kode lerroa:  t['\u2FB4'] = '\u9801';
Kode lerroa:  t['\u2FB5'] = '\u98A8';
Kode lerroa:  t['\u2FB6'] = '\u98DB';
Kode lerroa:  t['\u2FB7'] = '\u98DF';
Kode lerroa:  t['\u2FB8'] = '\u9996';
Kode lerroa:  t['\u2FB9'] = '\u9999';
Kode lerroa:  t['\u2FBA'] = '\u99AC';
Kode lerroa:  t['\u2FBB'] = '\u9AA8';
Kode lerroa:  t['\u2FBC'] = '\u9AD8';
Kode lerroa:  t['\u2FBD'] = '\u9ADF';
Kode lerroa:  t['\u2FBE'] = '\u9B25';
Kode lerroa:  t['\u2FBF'] = '\u9B2F';
Kode lerroa:  t['\u2FC0'] = '\u9B32';
Kode lerroa:  t['\u2FC1'] = '\u9B3C';
Kode lerroa:  t['\u2FC2'] = '\u9B5A';
Kode lerroa:  t['\u2FC3'] = '\u9CE5';
Kode lerroa:  t['\u2FC4'] = '\u9E75';
Kode lerroa:  t['\u2FC5'] = '\u9E7F';
Kode lerroa:  t['\u2FC6'] = '\u9EA5';
Kode lerroa:  t['\u2FC7'] = '\u9EBB';
Kode lerroa:  t['\u2FC8'] = '\u9EC3';
Kode lerroa:  t['\u2FC9'] = '\u9ECD';
Kode lerroa:  t['\u2FCA'] = '\u9ED1';
Kode lerroa:  t['\u2FCB'] = '\u9EF9';
Kode lerroa:  t['\u2FCC'] = '\u9EFD';
Kode lerroa:  t['\u2FCD'] = '\u9F0E';
Kode lerroa:  t['\u2FCE'] = '\u9F13';
Kode lerroa:  t['\u2FCF'] = '\u9F20';
Kode lerroa:  t['\u2FD0'] = '\u9F3B';
Kode lerroa:  t['\u2FD1'] = '\u9F4A';
Kode lerroa:  t['\u2FD2'] = '\u9F52';
Kode lerroa:  t['\u2FD3'] = '\u9F8D';
Kode lerroa:  t['\u2FD4'] = '\u9F9C';
Kode lerroa:  t['\u2FD5'] = '\u9FA0';
Kode lerroa:  t['\u3036'] = '\u3012';
Kode lerroa:  t['\u3038'] = '\u5341';
Kode lerroa:  t['\u3039'] = '\u5344';
Kode lerroa:  t['\u303A'] = '\u5345';
Kode lerroa:  t['\u309B'] = '\u0020\u3099';
Kode lerroa:  t['\u309C'] = '\u0020\u309A';
Kode lerroa:  t['\u3131'] = '\u1100';
Kode lerroa:  t['\u3132'] = '\u1101';
Kode lerroa:  t['\u3133'] = '\u11AA';
Kode lerroa:  t['\u3134'] = '\u1102';
Kode lerroa:  t['\u3135'] = '\u11AC';
Kode lerroa:  t['\u3136'] = '\u11AD';
Kode lerroa:  t['\u3137'] = '\u1103';
Kode lerroa:  t['\u3138'] = '\u1104';
Kode lerroa:  t['\u3139'] = '\u1105';
Kode lerroa:  t['\u313A'] = '\u11B0';
Kode lerroa:  t['\u313B'] = '\u11B1';
Kode lerroa:  t['\u313C'] = '\u11B2';
Kode lerroa:  t['\u313D'] = '\u11B3';
Kode lerroa:  t['\u313E'] = '\u11B4';
Kode lerroa:  t['\u313F'] = '\u11B5';
Kode lerroa:  t['\u3140'] = '\u111A';
Kode lerroa:  t['\u3141'] = '\u1106';
Kode lerroa:  t['\u3142'] = '\u1107';
Kode lerroa:  t['\u3143'] = '\u1108';
Kode lerroa:  t['\u3144'] = '\u1121';
Kode lerroa:  t['\u3145'] = '\u1109';
Kode lerroa:  t['\u3146'] = '\u110A';
Kode lerroa:  t['\u3147'] = '\u110B';
Kode lerroa:  t['\u3148'] = '\u110C';
Kode lerroa:  t['\u3149'] = '\u110D';
Kode lerroa:  t['\u314A'] = '\u110E';
Kode lerroa:  t['\u314B'] = '\u110F';
Kode lerroa:  t['\u314C'] = '\u1110';
Kode lerroa:  t['\u314D'] = '\u1111';
Kode lerroa:  t['\u314E'] = '\u1112';
Kode lerroa:  t['\u314F'] = '\u1161';
Kode lerroa:  t['\u3150'] = '\u1162';
Kode lerroa:  t['\u3151'] = '\u1163';
Kode lerroa:  t['\u3152'] = '\u1164';
Kode lerroa:  t['\u3153'] = '\u1165';
Kode lerroa:  t['\u3154'] = '\u1166';
Kode lerroa:  t['\u3155'] = '\u1167';
Kode lerroa:  t['\u3156'] = '\u1168';
Kode lerroa:  t['\u3157'] = '\u1169';
Kode lerroa:  t['\u3158'] = '\u116A';
Kode lerroa:  t['\u3159'] = '\u116B';
Kode lerroa:  t['\u315A'] = '\u116C';
Kode lerroa:  t['\u315B'] = '\u116D';
Kode lerroa:  t['\u315C'] = '\u116E';
Kode lerroa:  t['\u315D'] = '\u116F';
Kode lerroa:  t['\u315E'] = '\u1170';
Kode lerroa:  t['\u315F'] = '\u1171';
Kode lerroa:  t['\u3160'] = '\u1172';
Kode lerroa:  t['\u3161'] = '\u1173';
Kode lerroa:  t['\u3162'] = '\u1174';
Kode lerroa:  t['\u3163'] = '\u1175';
Kode lerroa:  t['\u3164'] = '\u1160';
Kode lerroa:  t['\u3165'] = '\u1114';
Kode lerroa:  t['\u3166'] = '\u1115';
Kode lerroa:  t['\u3167'] = '\u11C7';
Kode lerroa:  t['\u3168'] = '\u11C8';
Kode lerroa:  t['\u3169'] = '\u11CC';
Kode lerroa:  t['\u316A'] = '\u11CE';
Kode lerroa:  t['\u316B'] = '\u11D3';
Kode lerroa:  t['\u316C'] = '\u11D7';
Kode lerroa:  t['\u316D'] = '\u11D9';
Kode lerroa:  t['\u316E'] = '\u111C';
Kode lerroa:  t['\u316F'] = '\u11DD';
Kode lerroa:  t['\u3170'] = '\u11DF';
Kode lerroa:  t['\u3171'] = '\u111D';
Kode lerroa:  t['\u3172'] = '\u111E';
Kode lerroa:  t['\u3173'] = '\u1120';
Kode lerroa:  t['\u3174'] = '\u1122';
Kode lerroa:  t['\u3175'] = '\u1123';
Kode lerroa:  t['\u3176'] = '\u1127';
Kode lerroa:  t['\u3177'] = '\u1129';
Kode lerroa:  t['\u3178'] = '\u112B';
Kode lerroa:  t['\u3179'] = '\u112C';
Kode lerroa:  t['\u317A'] = '\u112D';
Kode lerroa:  t['\u317B'] = '\u112E';
Kode lerroa:  t['\u317C'] = '\u112F';
Kode lerroa:  t['\u317D'] = '\u1132';
Kode lerroa:  t['\u317E'] = '\u1136';
Kode lerroa:  t['\u317F'] = '\u1140';
Kode lerroa:  t['\u3180'] = '\u1147';
Kode lerroa:  t['\u3181'] = '\u114C';
Kode lerroa:  t['\u3182'] = '\u11F1';
Kode lerroa:  t['\u3183'] = '\u11F2';
Kode lerroa:  t['\u3184'] = '\u1157';
Kode lerroa:  t['\u3185'] = '\u1158';
Kode lerroa:  t['\u3186'] = '\u1159';
Kode lerroa:  t['\u3187'] = '\u1184';
Kode lerroa:  t['\u3188'] = '\u1185';
Kode lerroa:  t['\u3189'] = '\u1188';
Kode lerroa:  t['\u318A'] = '\u1191';
Kode lerroa:  t['\u318B'] = '\u1192';
Kode lerroa:  t['\u318C'] = '\u1194';
Kode lerroa:  t['\u318D'] = '\u119E';
Kode lerroa:  t['\u318E'] = '\u11A1';
Kode lerroa:  t['\u3200'] = '\u0028\u1100\u0029';
Kode lerroa:  t['\u3201'] = '\u0028\u1102\u0029';
Kode lerroa:  t['\u3202'] = '\u0028\u1103\u0029';
Kode lerroa:  t['\u3203'] = '\u0028\u1105\u0029';
Kode lerroa:  t['\u3204'] = '\u0028\u1106\u0029';
Kode lerroa:  t['\u3205'] = '\u0028\u1107\u0029';
Kode lerroa:  t['\u3206'] = '\u0028\u1109\u0029';
Kode lerroa:  t['\u3207'] = '\u0028\u110B\u0029';
Kode lerroa:  t['\u3208'] = '\u0028\u110C\u0029';
Kode lerroa:  t['\u3209'] = '\u0028\u110E\u0029';
Kode lerroa:  t['\u320A'] = '\u0028\u110F\u0029';
Kode lerroa:  t['\u320B'] = '\u0028\u1110\u0029';
Kode lerroa:  t['\u320C'] = '\u0028\u1111\u0029';
Kode lerroa:  t['\u320D'] = '\u0028\u1112\u0029';
Kode lerroa:  t['\u320E'] = '\u0028\u1100\u1161\u0029';
Kode lerroa:  t['\u320F'] = '\u0028\u1102\u1161\u0029';
Kode lerroa:  t['\u3210'] = '\u0028\u1103\u1161\u0029';
Kode lerroa:  t['\u3211'] = '\u0028\u1105\u1161\u0029';
Kode lerroa:  t['\u3212'] = '\u0028\u1106\u1161\u0029';
Kode lerroa:  t['\u3213'] = '\u0028\u1107\u1161\u0029';
Kode lerroa:  t['\u3214'] = '\u0028\u1109\u1161\u0029';
Kode lerroa:  t['\u3215'] = '\u0028\u110B\u1161\u0029';
Kode lerroa:  t['\u3216'] = '\u0028\u110C\u1161\u0029';
Kode lerroa:  t['\u3217'] = '\u0028\u110E\u1161\u0029';
Kode lerroa:  t['\u3218'] = '\u0028\u110F\u1161\u0029';
Kode lerroa:  t['\u3219'] = '\u0028\u1110\u1161\u0029';
Kode lerroa:  t['\u321A'] = '\u0028\u1111\u1161\u0029';
Kode lerroa:  t['\u321B'] = '\u0028\u1112\u1161\u0029';
Kode lerroa:  t['\u321C'] = '\u0028\u110C\u116E\u0029';
Kode lerroa:  t['\u321D'] = '\u0028\u110B\u1169\u110C\u1165\u11AB\u0029';
Kode lerroa:  t['\u321E'] = '\u0028\u110B\u1169\u1112\u116E\u0029';
Kode lerroa:  t['\u3220'] = '\u0028\u4E00\u0029';
Kode lerroa:  t['\u3221'] = '\u0028\u4E8C\u0029';
Kode lerroa:  t['\u3222'] = '\u0028\u4E09\u0029';
Kode lerroa:  t['\u3223'] = '\u0028\u56DB\u0029';
Kode lerroa:  t['\u3224'] = '\u0028\u4E94\u0029';
Kode lerroa:  t['\u3225'] = '\u0028\u516D\u0029';
Kode lerroa:  t['\u3226'] = '\u0028\u4E03\u0029';
Kode lerroa:  t['\u3227'] = '\u0028\u516B\u0029';
Kode lerroa:  t['\u3228'] = '\u0028\u4E5D\u0029';
Kode lerroa:  t['\u3229'] = '\u0028\u5341\u0029';
Kode lerroa:  t['\u322A'] = '\u0028\u6708\u0029';
Kode lerroa:  t['\u322B'] = '\u0028\u706B\u0029';
Kode lerroa:  t['\u322C'] = '\u0028\u6C34\u0029';
Kode lerroa:  t['\u322D'] = '\u0028\u6728\u0029';
Kode lerroa:  t['\u322E'] = '\u0028\u91D1\u0029';
Kode lerroa:  t['\u322F'] = '\u0028\u571F\u0029';
Kode lerroa:  t['\u3230'] = '\u0028\u65E5\u0029';
Kode lerroa:  t['\u3231'] = '\u0028\u682A\u0029';
Kode lerroa:  t['\u3232'] = '\u0028\u6709\u0029';
Kode lerroa:  t['\u3233'] = '\u0028\u793E\u0029';
Kode lerroa:  t['\u3234'] = '\u0028\u540D\u0029';
Kode lerroa:  t['\u3235'] = '\u0028\u7279\u0029';
Kode lerroa:  t['\u3236'] = '\u0028\u8CA1\u0029';
Kode lerroa:  t['\u3237'] = '\u0028\u795D\u0029';
Kode lerroa:  t['\u3238'] = '\u0028\u52B4\u0029';
Kode lerroa:  t['\u3239'] = '\u0028\u4EE3\u0029';
Kode lerroa:  t['\u323A'] = '\u0028\u547C\u0029';
Kode lerroa:  t['\u323B'] = '\u0028\u5B66\u0029';
Kode lerroa:  t['\u323C'] = '\u0028\u76E3\u0029';
Kode lerroa:  t['\u323D'] = '\u0028\u4F01\u0029';
Kode lerroa:  t['\u323E'] = '\u0028\u8CC7\u0029';
Kode lerroa:  t['\u323F'] = '\u0028\u5354\u0029';
Kode lerroa:  t['\u3240'] = '\u0028\u796D\u0029';
Kode lerroa:  t['\u3241'] = '\u0028\u4F11\u0029';
Kode lerroa:  t['\u3242'] = '\u0028\u81EA\u0029';
Kode lerroa:  t['\u3243'] = '\u0028\u81F3\u0029';
Kode lerroa:  t['\u32C0'] = '\u0031\u6708';
Kode lerroa:  t['\u32C1'] = '\u0032\u6708';
Kode lerroa:  t['\u32C2'] = '\u0033\u6708';
Kode lerroa:  t['\u32C3'] = '\u0034\u6708';
Kode lerroa:  t['\u32C4'] = '\u0035\u6708';
Kode lerroa:  t['\u32C5'] = '\u0036\u6708';
Kode lerroa:  t['\u32C6'] = '\u0037\u6708';
Kode lerroa:  t['\u32C7'] = '\u0038\u6708';
Kode lerroa:  t['\u32C8'] = '\u0039\u6708';
Kode lerroa:  t['\u32C9'] = '\u0031\u0030\u6708';
Kode lerroa:  t['\u32CA'] = '\u0031\u0031\u6708';
Kode lerroa:  t['\u32CB'] = '\u0031\u0032\u6708';
Kode lerroa:  t['\u3358'] = '\u0030\u70B9';
Kode lerroa:  t['\u3359'] = '\u0031\u70B9';
Kode lerroa:  t['\u335A'] = '\u0032\u70B9';
Kode lerroa:  t['\u335B'] = '\u0033\u70B9';
Kode lerroa:  t['\u335C'] = '\u0034\u70B9';
Kode lerroa:  t['\u335D'] = '\u0035\u70B9';
Kode lerroa:  t['\u335E'] = '\u0036\u70B9';
Kode lerroa:  t['\u335F'] = '\u0037\u70B9';
Kode lerroa:  t['\u3360'] = '\u0038\u70B9';
Kode lerroa:  t['\u3361'] = '\u0039\u70B9';
Kode lerroa:  t['\u3362'] = '\u0031\u0030\u70B9';
Kode lerroa:  t['\u3363'] = '\u0031\u0031\u70B9';
Kode lerroa:  t['\u3364'] = '\u0031\u0032\u70B9';
Kode lerroa:  t['\u3365'] = '\u0031\u0033\u70B9';
Kode lerroa:  t['\u3366'] = '\u0031\u0034\u70B9';
Kode lerroa:  t['\u3367'] = '\u0031\u0035\u70B9';
Kode lerroa:  t['\u3368'] = '\u0031\u0036\u70B9';
Kode lerroa:  t['\u3369'] = '\u0031\u0037\u70B9';
Kode lerroa:  t['\u336A'] = '\u0031\u0038\u70B9';
Kode lerroa:  t['\u336B'] = '\u0031\u0039\u70B9';
Kode lerroa:  t['\u336C'] = '\u0032\u0030\u70B9';
Kode lerroa:  t['\u336D'] = '\u0032\u0031\u70B9';
Kode lerroa:  t['\u336E'] = '\u0032\u0032\u70B9';
Kode lerroa:  t['\u336F'] = '\u0032\u0033\u70B9';
Kode lerroa:  t['\u3370'] = '\u0032\u0034\u70B9';
Kode lerroa:  t['\u33E0'] = '\u0031\u65E5';
Kode lerroa:  t['\u33E1'] = '\u0032\u65E5';
Kode lerroa:  t['\u33E2'] = '\u0033\u65E5';
Kode lerroa:  t['\u33E3'] = '\u0034\u65E5';
Kode lerroa:  t['\u33E4'] = '\u0035\u65E5';
Kode lerroa:  t['\u33E5'] = '\u0036\u65E5';
Kode lerroa:  t['\u33E6'] = '\u0037\u65E5';
Kode lerroa:  t['\u33E7'] = '\u0038\u65E5';
Kode lerroa:  t['\u33E8'] = '\u0039\u65E5';
Kode lerroa:  t['\u33E9'] = '\u0031\u0030\u65E5';
Kode lerroa:  t['\u33EA'] = '\u0031\u0031\u65E5';
Kode lerroa:  t['\u33EB'] = '\u0031\u0032\u65E5';
Kode lerroa:  t['\u33EC'] = '\u0031\u0033\u65E5';
Kode lerroa:  t['\u33ED'] = '\u0031\u0034\u65E5';
Kode lerroa:  t['\u33EE'] = '\u0031\u0035\u65E5';
Kode lerroa:  t['\u33EF'] = '\u0031\u0036\u65E5';
Kode lerroa:  t['\u33F0'] = '\u0031\u0037\u65E5';
Kode lerroa:  t['\u33F1'] = '\u0031\u0038\u65E5';
Kode lerroa:  t['\u33F2'] = '\u0031\u0039\u65E5';
Kode lerroa:  t['\u33F3'] = '\u0032\u0030\u65E5';
Kode lerroa:  t['\u33F4'] = '\u0032\u0031\u65E5';
Kode lerroa:  t['\u33F5'] = '\u0032\u0032\u65E5';
Kode lerroa:  t['\u33F6'] = '\u0032\u0033\u65E5';
Kode lerroa:  t['\u33F7'] = '\u0032\u0034\u65E5';
Kode lerroa:  t['\u33F8'] = '\u0032\u0035\u65E5';
Kode lerroa:  t['\u33F9'] = '\u0032\u0036\u65E5';
Kode lerroa:  t['\u33FA'] = '\u0032\u0037\u65E5';
Kode lerroa:  t['\u33FB'] = '\u0032\u0038\u65E5';
Kode lerroa:  t['\u33FC'] = '\u0032\u0039\u65E5';
Kode lerroa:  t['\u33FD'] = '\u0033\u0030\u65E5';
Kode lerroa:  t['\u33FE'] = '\u0033\u0031\u65E5';
Kode lerroa:  t['\uFB00'] = '\u0066\u0066';
Kode lerroa:  t['\uFB01'] = '\u0066\u0069';
Kode lerroa:  t['\uFB02'] = '\u0066\u006C';
Kode lerroa:  t['\uFB03'] = '\u0066\u0066\u0069';
Kode lerroa:  t['\uFB04'] = '\u0066\u0066\u006C';
Kode lerroa:  t['\uFB05'] = '\u017F\u0074';
Kode lerroa:  t['\uFB06'] = '\u0073\u0074';
Kode lerroa:  t['\uFB13'] = '\u0574\u0576';
Kode lerroa:  t['\uFB14'] = '\u0574\u0565';
Kode lerroa:  t['\uFB15'] = '\u0574\u056B';
Kode lerroa:  t['\uFB16'] = '\u057E\u0576';
Kode lerroa:  t['\uFB17'] = '\u0574\u056D';
Kode lerroa:  t['\uFB4F'] = '\u05D0\u05DC';
Kode lerroa:  t['\uFB50'] = '\u0671';
Kode lerroa:  t['\uFB51'] = '\u0671';
Kode lerroa:  t['\uFB52'] = '\u067B';
Kode lerroa:  t['\uFB53'] = '\u067B';
Kode lerroa:  t['\uFB54'] = '\u067B';
Kode lerroa:  t['\uFB55'] = '\u067B';
Kode lerroa:  t['\uFB56'] = '\u067E';
Kode lerroa:  t['\uFB57'] = '\u067E';
Kode lerroa:  t['\uFB58'] = '\u067E';
Kode lerroa:  t['\uFB59'] = '\u067E';
Kode lerroa:  t['\uFB5A'] = '\u0680';
Kode lerroa:  t['\uFB5B'] = '\u0680';
Kode lerroa:  t['\uFB5C'] = '\u0680';
Kode lerroa:  t['\uFB5D'] = '\u0680';
Kode lerroa:  t['\uFB5E'] = '\u067A';
Kode lerroa:  t['\uFB5F'] = '\u067A';
Kode lerroa:  t['\uFB60'] = '\u067A';
Kode lerroa:  t['\uFB61'] = '\u067A';
Kode lerroa:  t['\uFB62'] = '\u067F';
Kode lerroa:  t['\uFB63'] = '\u067F';
Kode lerroa:  t['\uFB64'] = '\u067F';
Kode lerroa:  t['\uFB65'] = '\u067F';
Kode lerroa:  t['\uFB66'] = '\u0679';
Kode lerroa:  t['\uFB67'] = '\u0679';
Kode lerroa:  t['\uFB68'] = '\u0679';
Kode lerroa:  t['\uFB69'] = '\u0679';
Kode lerroa:  t['\uFB6A'] = '\u06A4';
Kode lerroa:  t['\uFB6B'] = '\u06A4';
Kode lerroa:  t['\uFB6C'] = '\u06A4';
Kode lerroa:  t['\uFB6D'] = '\u06A4';
Kode lerroa:  t['\uFB6E'] = '\u06A6';
Kode lerroa:  t['\uFB6F'] = '\u06A6';
Kode lerroa:  t['\uFB70'] = '\u06A6';
Kode lerroa:  t['\uFB71'] = '\u06A6';
Kode lerroa:  t['\uFB72'] = '\u0684';
Kode lerroa:  t['\uFB73'] = '\u0684';
Kode lerroa:  t['\uFB74'] = '\u0684';
Kode lerroa:  t['\uFB75'] = '\u0684';
Kode lerroa:  t['\uFB76'] = '\u0683';
Kode lerroa:  t['\uFB77'] = '\u0683';
Kode lerroa:  t['\uFB78'] = '\u0683';
Kode lerroa:  t['\uFB79'] = '\u0683';
Kode lerroa:  t['\uFB7A'] = '\u0686';
Kode lerroa:  t['\uFB7B'] = '\u0686';
Kode lerroa:  t['\uFB7C'] = '\u0686';
Kode lerroa:  t['\uFB7D'] = '\u0686';
Kode lerroa:  t['\uFB7E'] = '\u0687';
Kode lerroa:  t['\uFB7F'] = '\u0687';
Kode lerroa:  t['\uFB80'] = '\u0687';
Kode lerroa:  t['\uFB81'] = '\u0687';
Kode lerroa:  t['\uFB82'] = '\u068D';
Kode lerroa:  t['\uFB83'] = '\u068D';
Kode lerroa:  t['\uFB84'] = '\u068C';
Kode lerroa:  t['\uFB85'] = '\u068C';
Kode lerroa:  t['\uFB86'] = '\u068E';
Kode lerroa:  t['\uFB87'] = '\u068E';
Kode lerroa:  t['\uFB88'] = '\u0688';
Kode lerroa:  t['\uFB89'] = '\u0688';
Kode lerroa:  t['\uFB8A'] = '\u0698';
Kode lerroa:  t['\uFB8B'] = '\u0698';
Kode lerroa:  t['\uFB8C'] = '\u0691';
Kode lerroa:  t['\uFB8D'] = '\u0691';
Kode lerroa:  t['\uFB8E'] = '\u06A9';
Kode lerroa:  t['\uFB8F'] = '\u06A9';
Kode lerroa:  t['\uFB90'] = '\u06A9';
Kode lerroa:  t['\uFB91'] = '\u06A9';
Kode lerroa:  t['\uFB92'] = '\u06AF';
Kode lerroa:  t['\uFB93'] = '\u06AF';
Kode lerroa:  t['\uFB94'] = '\u06AF';
Kode lerroa:  t['\uFB95'] = '\u06AF';
Kode lerroa:  t['\uFB96'] = '\u06B3';
Kode lerroa:  t['\uFB97'] = '\u06B3';
Kode lerroa:  t['\uFB98'] = '\u06B3';
Kode lerroa:  t['\uFB99'] = '\u06B3';
Kode lerroa:  t['\uFB9A'] = '\u06B1';
Kode lerroa:  t['\uFB9B'] = '\u06B1';
Kode lerroa:  t['\uFB9C'] = '\u06B1';
Kode lerroa:  t['\uFB9D'] = '\u06B1';
Kode lerroa:  t['\uFB9E'] = '\u06BA';
Kode lerroa:  t['\uFB9F'] = '\u06BA';
Kode lerroa:  t['\uFBA0'] = '\u06BB';
Kode lerroa:  t['\uFBA1'] = '\u06BB';
Kode lerroa:  t['\uFBA2'] = '\u06BB';
Kode lerroa:  t['\uFBA3'] = '\u06BB';
Kode lerroa:  t['\uFBA4'] = '\u06C0';
Kode lerroa:  t['\uFBA5'] = '\u06C0';
Kode lerroa:  t['\uFBA6'] = '\u06C1';
Kode lerroa:  t['\uFBA7'] = '\u06C1';
Kode lerroa:  t['\uFBA8'] = '\u06C1';
Kode lerroa:  t['\uFBA9'] = '\u06C1';
Kode lerroa:  t['\uFBAA'] = '\u06BE';
Kode lerroa:  t['\uFBAB'] = '\u06BE';
Kode lerroa:  t['\uFBAC'] = '\u06BE';
Kode lerroa:  t['\uFBAD'] = '\u06BE';
Kode lerroa:  t['\uFBAE'] = '\u06D2';
Kode lerroa:  t['\uFBAF'] = '\u06D2';
Kode lerroa:  t['\uFBB0'] = '\u06D3';
Kode lerroa:  t['\uFBB1'] = '\u06D3';
Kode lerroa:  t['\uFBD3'] = '\u06AD';
Kode lerroa:  t['\uFBD4'] = '\u06AD';
Kode lerroa:  t['\uFBD5'] = '\u06AD';
Kode lerroa:  t['\uFBD6'] = '\u06AD';
Kode lerroa:  t['\uFBD7'] = '\u06C7';
Kode lerroa:  t['\uFBD8'] = '\u06C7';
Kode lerroa:  t['\uFBD9'] = '\u06C6';
Kode lerroa:  t['\uFBDA'] = '\u06C6';
Kode lerroa:  t['\uFBDB'] = '\u06C8';
Kode lerroa:  t['\uFBDC'] = '\u06C8';
Kode lerroa:  t['\uFBDD'] = '\u0677';
Kode lerroa:  t['\uFBDE'] = '\u06CB';
Kode lerroa:  t['\uFBDF'] = '\u06CB';
Kode lerroa:  t['\uFBE0'] = '\u06C5';
Kode lerroa:  t['\uFBE1'] = '\u06C5';
Kode lerroa:  t['\uFBE2'] = '\u06C9';
Kode lerroa:  t['\uFBE3'] = '\u06C9';
Kode lerroa:  t['\uFBE4'] = '\u06D0';
Kode lerroa:  t['\uFBE5'] = '\u06D0';
Kode lerroa:  t['\uFBE6'] = '\u06D0';
Kode lerroa:  t['\uFBE7'] = '\u06D0';
Kode lerroa:  t['\uFBE8'] = '\u0649';
Kode lerroa:  t['\uFBE9'] = '\u0649';
Kode lerroa:  t['\uFBEA'] = '\u0626\u0627';
Kode lerroa:  t['\uFBEB'] = '\u0626\u0627';
Kode lerroa:  t['\uFBEC'] = '\u0626\u06D5';
Kode lerroa:  t['\uFBED'] = '\u0626\u06D5';
Kode lerroa:  t['\uFBEE'] = '\u0626\u0648';
Kode lerroa:  t['\uFBEF'] = '\u0626\u0648';
Kode lerroa:  t['\uFBF0'] = '\u0626\u06C7';
Kode lerroa:  t['\uFBF1'] = '\u0626\u06C7';
Kode lerroa:  t['\uFBF2'] = '\u0626\u06C6';
Kode lerroa:  t['\uFBF3'] = '\u0626\u06C6';
Kode lerroa:  t['\uFBF4'] = '\u0626\u06C8';
Kode lerroa:  t['\uFBF5'] = '\u0626\u06C8';
Kode lerroa:  t['\uFBF6'] = '\u0626\u06D0';
Kode lerroa:  t['\uFBF7'] = '\u0626\u06D0';
Kode lerroa:  t['\uFBF8'] = '\u0626\u06D0';
Kode lerroa:  t['\uFBF9'] = '\u0626\u0649';
Kode lerroa:  t['\uFBFA'] = '\u0626\u0649';
Kode lerroa:  t['\uFBFB'] = '\u0626\u0649';
Kode lerroa:  t['\uFBFC'] = '\u06CC';
Kode lerroa:  t['\uFBFD'] = '\u06CC';
Kode lerroa:  t['\uFBFE'] = '\u06CC';
Kode lerroa:  t['\uFBFF'] = '\u06CC';
Kode lerroa:  t['\uFC00'] = '\u0626\u062C';
Kode lerroa:  t['\uFC01'] = '\u0626\u062D';
Kode lerroa:  t['\uFC02'] = '\u0626\u0645';
Kode lerroa:  t['\uFC03'] = '\u0626\u0649';
Kode lerroa:  t['\uFC04'] = '\u0626\u064A';
Kode lerroa:  t['\uFC05'] = '\u0628\u062C';
Kode lerroa:  t['\uFC06'] = '\u0628\u062D';
Kode lerroa:  t['\uFC07'] = '\u0628\u062E';
Kode lerroa:  t['\uFC08'] = '\u0628\u0645';
Kode lerroa:  t['\uFC09'] = '\u0628\u0649';
Kode lerroa:  t['\uFC0A'] = '\u0628\u064A';
Kode lerroa:  t['\uFC0B'] = '\u062A\u062C';
Kode lerroa:  t['\uFC0C'] = '\u062A\u062D';
Kode lerroa:  t['\uFC0D'] = '\u062A\u062E';
Kode lerroa:  t['\uFC0E'] = '\u062A\u0645';
Kode lerroa:  t['\uFC0F'] = '\u062A\u0649';
Kode lerroa:  t['\uFC10'] = '\u062A\u064A';
Kode lerroa:  t['\uFC11'] = '\u062B\u062C';
Kode lerroa:  t['\uFC12'] = '\u062B\u0645';
Kode lerroa:  t['\uFC13'] = '\u062B\u0649';
Kode lerroa:  t['\uFC14'] = '\u062B\u064A';
Kode lerroa:  t['\uFC15'] = '\u062C\u062D';
Kode lerroa:  t['\uFC16'] = '\u062C\u0645';
Kode lerroa:  t['\uFC17'] = '\u062D\u062C';
Kode lerroa:  t['\uFC18'] = '\u062D\u0645';
Kode lerroa:  t['\uFC19'] = '\u062E\u062C';
Kode lerroa:  t['\uFC1A'] = '\u062E\u062D';
Kode lerroa:  t['\uFC1B'] = '\u062E\u0645';
Kode lerroa:  t['\uFC1C'] = '\u0633\u062C';
Kode lerroa:  t['\uFC1D'] = '\u0633\u062D';
Kode lerroa:  t['\uFC1E'] = '\u0633\u062E';
Kode lerroa:  t['\uFC1F'] = '\u0633\u0645';
Kode lerroa:  t['\uFC20'] = '\u0635\u062D';
Kode lerroa:  t['\uFC21'] = '\u0635\u0645';
Kode lerroa:  t['\uFC22'] = '\u0636\u062C';
Kode lerroa:  t['\uFC23'] = '\u0636\u062D';
Kode lerroa:  t['\uFC24'] = '\u0636\u062E';
Kode lerroa:  t['\uFC25'] = '\u0636\u0645';
Kode lerroa:  t['\uFC26'] = '\u0637\u062D';
Kode lerroa:  t['\uFC27'] = '\u0637\u0645';
Kode lerroa:  t['\uFC28'] = '\u0638\u0645';
Kode lerroa:  t['\uFC29'] = '\u0639\u062C';
Kode lerroa:  t['\uFC2A'] = '\u0639\u0645';
Kode lerroa:  t['\uFC2B'] = '\u063A\u062C';
Kode lerroa:  t['\uFC2C'] = '\u063A\u0645';
Kode lerroa:  t['\uFC2D'] = '\u0641\u062C';
Kode lerroa:  t['\uFC2E'] = '\u0641\u062D';
Kode lerroa:  t['\uFC2F'] = '\u0641\u062E';
Kode lerroa:  t['\uFC30'] = '\u0641\u0645';
Kode lerroa:  t['\uFC31'] = '\u0641\u0649';
Kode lerroa:  t['\uFC32'] = '\u0641\u064A';
Kode lerroa:  t['\uFC33'] = '\u0642\u062D';
Kode lerroa:  t['\uFC34'] = '\u0642\u0645';
Kode lerroa:  t['\uFC35'] = '\u0642\u0649';
Kode lerroa:  t['\uFC36'] = '\u0642\u064A';
Kode lerroa:  t['\uFC37'] = '\u0643\u0627';
Kode lerroa:  t['\uFC38'] = '\u0643\u062C';
Kode lerroa:  t['\uFC39'] = '\u0643\u062D';
Kode lerroa:  t['\uFC3A'] = '\u0643\u062E';
Kode lerroa:  t['\uFC3B'] = '\u0643\u0644';
Kode lerroa:  t['\uFC3C'] = '\u0643\u0645';
Kode lerroa:  t['\uFC3D'] = '\u0643\u0649';
Kode lerroa:  t['\uFC3E'] = '\u0643\u064A';
Kode lerroa:  t['\uFC3F'] = '\u0644\u062C';
Kode lerroa:  t['\uFC40'] = '\u0644\u062D';
Kode lerroa:  t['\uFC41'] = '\u0644\u062E';
Kode lerroa:  t['\uFC42'] = '\u0644\u0645';
Kode lerroa:  t['\uFC43'] = '\u0644\u0649';
Kode lerroa:  t['\uFC44'] = '\u0644\u064A';
Kode lerroa:  t['\uFC45'] = '\u0645\u062C';
Kode lerroa:  t['\uFC46'] = '\u0645\u062D';
Kode lerroa:  t['\uFC47'] = '\u0645\u062E';
Kode lerroa:  t['\uFC48'] = '\u0645\u0645';
Kode lerroa:  t['\uFC49'] = '\u0645\u0649';
Kode lerroa:  t['\uFC4A'] = '\u0645\u064A';
Kode lerroa:  t['\uFC4B'] = '\u0646\u062C';
Kode lerroa:  t['\uFC4C'] = '\u0646\u062D';
Kode lerroa:  t['\uFC4D'] = '\u0646\u062E';
Kode lerroa:  t['\uFC4E'] = '\u0646\u0645';
Kode lerroa:  t['\uFC4F'] = '\u0646\u0649';
Kode lerroa:  t['\uFC50'] = '\u0646\u064A';
Kode lerroa:  t['\uFC51'] = '\u0647\u062C';
Kode lerroa:  t['\uFC52'] = '\u0647\u0645';
Kode lerroa:  t['\uFC53'] = '\u0647\u0649';
Kode lerroa:  t['\uFC54'] = '\u0647\u064A';
Kode lerroa:  t['\uFC55'] = '\u064A\u062C';
Kode lerroa:  t['\uFC56'] = '\u064A\u062D';
Kode lerroa:  t['\uFC57'] = '\u064A\u062E';
Kode lerroa:  t['\uFC58'] = '\u064A\u0645';
Kode lerroa:  t['\uFC59'] = '\u064A\u0649';
Kode lerroa:  t['\uFC5A'] = '\u064A\u064A';
Kode lerroa:  t['\uFC5B'] = '\u0630\u0670';
Kode lerroa:  t['\uFC5C'] = '\u0631\u0670';
Kode lerroa:  t['\uFC5D'] = '\u0649\u0670';
Kode lerroa:  t['\uFC5E'] = '\u0020\u064C\u0651';
Kode lerroa:  t['\uFC5F'] = '\u0020\u064D\u0651';
Kode lerroa:  t['\uFC60'] = '\u0020\u064E\u0651';
Kode lerroa:  t['\uFC61'] = '\u0020\u064F\u0651';
Kode lerroa:  t['\uFC62'] = '\u0020\u0650\u0651';
Kode lerroa:  t['\uFC63'] = '\u0020\u0651\u0670';
Kode lerroa:  t['\uFC64'] = '\u0626\u0631';
Kode lerroa:  t['\uFC65'] = '\u0626\u0632';
Kode lerroa:  t['\uFC66'] = '\u0626\u0645';
Kode lerroa:  t['\uFC67'] = '\u0626\u0646';
Kode lerroa:  t['\uFC68'] = '\u0626\u0649';
Kode lerroa:  t['\uFC69'] = '\u0626\u064A';
Kode lerroa:  t['\uFC6A'] = '\u0628\u0631';
Kode lerroa:  t['\uFC6B'] = '\u0628\u0632';
Kode lerroa:  t['\uFC6C'] = '\u0628\u0645';
Kode lerroa:  t['\uFC6D'] = '\u0628\u0646';
Kode lerroa:  t['\uFC6E'] = '\u0628\u0649';
Kode lerroa:  t['\uFC6F'] = '\u0628\u064A';
Kode lerroa:  t['\uFC70'] = '\u062A\u0631';
Kode lerroa:  t['\uFC71'] = '\u062A\u0632';
Kode lerroa:  t['\uFC72'] = '\u062A\u0645';
Kode lerroa:  t['\uFC73'] = '\u062A\u0646';
Kode lerroa:  t['\uFC74'] = '\u062A\u0649';
Kode lerroa:  t['\uFC75'] = '\u062A\u064A';
Kode lerroa:  t['\uFC76'] = '\u062B\u0631';
Kode lerroa:  t['\uFC77'] = '\u062B\u0632';
Kode lerroa:  t['\uFC78'] = '\u062B\u0645';
Kode lerroa:  t['\uFC79'] = '\u062B\u0646';
Kode lerroa:  t['\uFC7A'] = '\u062B\u0649';
Kode lerroa:  t['\uFC7B'] = '\u062B\u064A';
Kode lerroa:  t['\uFC7C'] = '\u0641\u0649';
Kode lerroa:  t['\uFC7D'] = '\u0641\u064A';
Kode lerroa:  t['\uFC7E'] = '\u0642\u0649';
Kode lerroa:  t['\uFC7F'] = '\u0642\u064A';
Kode lerroa:  t['\uFC80'] = '\u0643\u0627';
Kode lerroa:  t['\uFC81'] = '\u0643\u0644';
Kode lerroa:  t['\uFC82'] = '\u0643\u0645';
Kode lerroa:  t['\uFC83'] = '\u0643\u0649';
Kode lerroa:  t['\uFC84'] = '\u0643\u064A';
Kode lerroa:  t['\uFC85'] = '\u0644\u0645';
Kode lerroa:  t['\uFC86'] = '\u0644\u0649';
Kode lerroa:  t['\uFC87'] = '\u0644\u064A';
Kode lerroa:  t['\uFC88'] = '\u0645\u0627';
Kode lerroa:  t['\uFC89'] = '\u0645\u0645';
Kode lerroa:  t['\uFC8A'] = '\u0646\u0631';
Kode lerroa:  t['\uFC8B'] = '\u0646\u0632';
Kode lerroa:  t['\uFC8C'] = '\u0646\u0645';
Kode lerroa:  t['\uFC8D'] = '\u0646\u0646';
Kode lerroa:  t['\uFC8E'] = '\u0646\u0649';
Kode lerroa:  t['\uFC8F'] = '\u0646\u064A';
Kode lerroa:  t['\uFC90'] = '\u0649\u0670';
Kode lerroa:  t['\uFC91'] = '\u064A\u0631';
Kode lerroa:  t['\uFC92'] = '\u064A\u0632';
Kode lerroa:  t['\uFC93'] = '\u064A\u0645';
Kode lerroa:  t['\uFC94'] = '\u064A\u0646';
Kode lerroa:  t['\uFC95'] = '\u064A\u0649';
Kode lerroa:  t['\uFC96'] = '\u064A\u064A';
Kode lerroa:  t['\uFC97'] = '\u0626\u062C';
Kode lerroa:  t['\uFC98'] = '\u0626\u062D';
Kode lerroa:  t['\uFC99'] = '\u0626\u062E';
Kode lerroa:  t['\uFC9A'] = '\u0626\u0645';
Kode lerroa:  t['\uFC9B'] = '\u0626\u0647';
Kode lerroa:  t['\uFC9C'] = '\u0628\u062C';
Kode lerroa:  t['\uFC9D'] = '\u0628\u062D';
Kode lerroa:  t['\uFC9E'] = '\u0628\u062E';
Kode lerroa:  t['\uFC9F'] = '\u0628\u0645';
Kode lerroa:  t['\uFCA0'] = '\u0628\u0647';
Kode lerroa:  t['\uFCA1'] = '\u062A\u062C';
Kode lerroa:  t['\uFCA2'] = '\u062A\u062D';
Kode lerroa:  t['\uFCA3'] = '\u062A\u062E';
Kode lerroa:  t['\uFCA4'] = '\u062A\u0645';
Kode lerroa:  t['\uFCA5'] = '\u062A\u0647';
Kode lerroa:  t['\uFCA6'] = '\u062B\u0645';
Kode lerroa:  t['\uFCA7'] = '\u062C\u062D';
Kode lerroa:  t['\uFCA8'] = '\u062C\u0645';
Kode lerroa:  t['\uFCA9'] = '\u062D\u062C';
Kode lerroa:  t['\uFCAA'] = '\u062D\u0645';
Kode lerroa:  t['\uFCAB'] = '\u062E\u062C';
Kode lerroa:  t['\uFCAC'] = '\u062E\u0645';
Kode lerroa:  t['\uFCAD'] = '\u0633\u062C';
Kode lerroa:  t['\uFCAE'] = '\u0633\u062D';
Kode lerroa:  t['\uFCAF'] = '\u0633\u062E';
Kode lerroa:  t['\uFCB0'] = '\u0633\u0645';
Kode lerroa:  t['\uFCB1'] = '\u0635\u062D';
Kode lerroa:  t['\uFCB2'] = '\u0635\u062E';
Kode lerroa:  t['\uFCB3'] = '\u0635\u0645';
Kode lerroa:  t['\uFCB4'] = '\u0636\u062C';
Kode lerroa:  t['\uFCB5'] = '\u0636\u062D';
Kode lerroa:  t['\uFCB6'] = '\u0636\u062E';
Kode lerroa:  t['\uFCB7'] = '\u0636\u0645';
Kode lerroa:  t['\uFCB8'] = '\u0637\u062D';
Kode lerroa:  t['\uFCB9'] = '\u0638\u0645';
Kode lerroa:  t['\uFCBA'] = '\u0639\u062C';
Kode lerroa:  t['\uFCBB'] = '\u0639\u0645';
Kode lerroa:  t['\uFCBC'] = '\u063A\u062C';
Kode lerroa:  t['\uFCBD'] = '\u063A\u0645';
Kode lerroa:  t['\uFCBE'] = '\u0641\u062C';
Kode lerroa:  t['\uFCBF'] = '\u0641\u062D';
Kode lerroa:  t['\uFCC0'] = '\u0641\u062E';
Kode lerroa:  t['\uFCC1'] = '\u0641\u0645';
Kode lerroa:  t['\uFCC2'] = '\u0642\u062D';
Kode lerroa:  t['\uFCC3'] = '\u0642\u0645';
Kode lerroa:  t['\uFCC4'] = '\u0643\u062C';
Kode lerroa:  t['\uFCC5'] = '\u0643\u062D';
Kode lerroa:  t['\uFCC6'] = '\u0643\u062E';
Kode lerroa:  t['\uFCC7'] = '\u0643\u0644';
Kode lerroa:  t['\uFCC8'] = '\u0643\u0645';
Kode lerroa:  t['\uFCC9'] = '\u0644\u062C';
Kode lerroa:  t['\uFCCA'] = '\u0644\u062D';
Kode lerroa:  t['\uFCCB'] = '\u0644\u062E';
Kode lerroa:  t['\uFCCC'] = '\u0644\u0645';
Kode lerroa:  t['\uFCCD'] = '\u0644\u0647';
Kode lerroa:  t['\uFCCE'] = '\u0645\u062C';
Kode lerroa:  t['\uFCCF'] = '\u0645\u062D';
Kode lerroa:  t['\uFCD0'] = '\u0645\u062E';
Kode lerroa:  t['\uFCD1'] = '\u0645\u0645';
Kode lerroa:  t['\uFCD2'] = '\u0646\u062C';
Kode lerroa:  t['\uFCD3'] = '\u0646\u062D';
Kode lerroa:  t['\uFCD4'] = '\u0646\u062E';
Kode lerroa:  t['\uFCD5'] = '\u0646\u0645';
Kode lerroa:  t['\uFCD6'] = '\u0646\u0647';
Kode lerroa:  t['\uFCD7'] = '\u0647\u062C';
Kode lerroa:  t['\uFCD8'] = '\u0647\u0645';
Kode lerroa:  t['\uFCD9'] = '\u0647\u0670';
Kode lerroa:  t['\uFCDA'] = '\u064A\u062C';
Kode lerroa:  t['\uFCDB'] = '\u064A\u062D';
Kode lerroa:  t['\uFCDC'] = '\u064A\u062E';
Kode lerroa:  t['\uFCDD'] = '\u064A\u0645';
Kode lerroa:  t['\uFCDE'] = '\u064A\u0647';
Kode lerroa:  t['\uFCDF'] = '\u0626\u0645';
Kode lerroa:  t['\uFCE0'] = '\u0626\u0647';
Kode lerroa:  t['\uFCE1'] = '\u0628\u0645';
Kode lerroa:  t['\uFCE2'] = '\u0628\u0647';
Kode lerroa:  t['\uFCE3'] = '\u062A\u0645';
Kode lerroa:  t['\uFCE4'] = '\u062A\u0647';
Kode lerroa:  t['\uFCE5'] = '\u062B\u0645';
Kode lerroa:  t['\uFCE6'] = '\u062B\u0647';
Kode lerroa:  t['\uFCE7'] = '\u0633\u0645';
Kode lerroa:  t['\uFCE8'] = '\u0633\u0647';
Kode lerroa:  t['\uFCE9'] = '\u0634\u0645';
Kode lerroa:  t['\uFCEA'] = '\u0634\u0647';
Kode lerroa:  t['\uFCEB'] = '\u0643\u0644';
Kode lerroa:  t['\uFCEC'] = '\u0643\u0645';
Kode lerroa:  t['\uFCED'] = '\u0644\u0645';
Kode lerroa:  t['\uFCEE'] = '\u0646\u0645';
Kode lerroa:  t['\uFCEF'] = '\u0646\u0647';
Kode lerroa:  t['\uFCF0'] = '\u064A\u0645';
Kode lerroa:  t['\uFCF1'] = '\u064A\u0647';
Kode lerroa:  t['\uFCF2'] = '\u0640\u064E\u0651';
Kode lerroa:  t['\uFCF3'] = '\u0640\u064F\u0651';
Kode lerroa:  t['\uFCF4'] = '\u0640\u0650\u0651';
Kode lerroa:  t['\uFCF5'] = '\u0637\u0649';
Kode lerroa:  t['\uFCF6'] = '\u0637\u064A';
Kode lerroa:  t['\uFCF7'] = '\u0639\u0649';
Kode lerroa:  t['\uFCF8'] = '\u0639\u064A';
Kode lerroa:  t['\uFCF9'] = '\u063A\u0649';
Kode lerroa:  t['\uFCFA'] = '\u063A\u064A';
Kode lerroa:  t['\uFCFB'] = '\u0633\u0649';
Kode lerroa:  t['\uFCFC'] = '\u0633\u064A';
Kode lerroa:  t['\uFCFD'] = '\u0634\u0649';
Kode lerroa:  t['\uFCFE'] = '\u0634\u064A';
Kode lerroa:  t['\uFCFF'] = '\u062D\u0649';
Kode lerroa:  t['\uFD00'] = '\u062D\u064A';
Kode lerroa:  t['\uFD01'] = '\u062C\u0649';
Kode lerroa:  t['\uFD02'] = '\u062C\u064A';
Kode lerroa:  t['\uFD03'] = '\u062E\u0649';
Kode lerroa:  t['\uFD04'] = '\u062E\u064A';
Kode lerroa:  t['\uFD05'] = '\u0635\u0649';
Kode lerroa:  t['\uFD06'] = '\u0635\u064A';
Kode lerroa:  t['\uFD07'] = '\u0636\u0649';
Kode lerroa:  t['\uFD08'] = '\u0636\u064A';
Kode lerroa:  t['\uFD09'] = '\u0634\u062C';
Kode lerroa:  t['\uFD0A'] = '\u0634\u062D';
Kode lerroa:  t['\uFD0B'] = '\u0634\u062E';
Kode lerroa:  t['\uFD0C'] = '\u0634\u0645';
Kode lerroa:  t['\uFD0D'] = '\u0634\u0631';
Kode lerroa:  t['\uFD0E'] = '\u0633\u0631';
Kode lerroa:  t['\uFD0F'] = '\u0635\u0631';
Kode lerroa:  t['\uFD10'] = '\u0636\u0631';
Kode lerroa:  t['\uFD11'] = '\u0637\u0649';
Kode lerroa:  t['\uFD12'] = '\u0637\u064A';
Kode lerroa:  t['\uFD13'] = '\u0639\u0649';
Kode lerroa:  t['\uFD14'] = '\u0639\u064A';
Kode lerroa:  t['\uFD15'] = '\u063A\u0649';
Kode lerroa:  t['\uFD16'] = '\u063A\u064A';
Kode lerroa:  t['\uFD17'] = '\u0633\u0649';
Kode lerroa:  t['\uFD18'] = '\u0633\u064A';
Kode lerroa:  t['\uFD19'] = '\u0634\u0649';
Kode lerroa:  t['\uFD1A'] = '\u0634\u064A';
Kode lerroa:  t['\uFD1B'] = '\u062D\u0649';
Kode lerroa:  t['\uFD1C'] = '\u062D\u064A';
Kode lerroa:  t['\uFD1D'] = '\u062C\u0649';
Kode lerroa:  t['\uFD1E'] = '\u062C\u064A';
Kode lerroa:  t['\uFD1F'] = '\u062E\u0649';
Kode lerroa:  t['\uFD20'] = '\u062E\u064A';
Kode lerroa:  t['\uFD21'] = '\u0635\u0649';
Kode lerroa:  t['\uFD22'] = '\u0635\u064A';
Kode lerroa:  t['\uFD23'] = '\u0636\u0649';
Kode lerroa:  t['\uFD24'] = '\u0636\u064A';
Kode lerroa:  t['\uFD25'] = '\u0634\u062C';
Kode lerroa:  t['\uFD26'] = '\u0634\u062D';
Kode lerroa:  t['\uFD27'] = '\u0634\u062E';
Kode lerroa:  t['\uFD28'] = '\u0634\u0645';
Kode lerroa:  t['\uFD29'] = '\u0634\u0631';
Kode lerroa:  t['\uFD2A'] = '\u0633\u0631';
Kode lerroa:  t['\uFD2B'] = '\u0635\u0631';
Kode lerroa:  t['\uFD2C'] = '\u0636\u0631';
Kode lerroa:  t['\uFD2D'] = '\u0634\u062C';
Kode lerroa:  t['\uFD2E'] = '\u0634\u062D';
Kode lerroa:  t['\uFD2F'] = '\u0634\u062E';
Kode lerroa:  t['\uFD30'] = '\u0634\u0645';
Kode lerroa:  t['\uFD31'] = '\u0633\u0647';
Kode lerroa:  t['\uFD32'] = '\u0634\u0647';
Kode lerroa:  t['\uFD33'] = '\u0637\u0645';
Kode lerroa:  t['\uFD34'] = '\u0633\u062C';
Kode lerroa:  t['\uFD35'] = '\u0633\u062D';
Kode lerroa:  t['\uFD36'] = '\u0633\u062E';
Kode lerroa:  t['\uFD37'] = '\u0634\u062C';
Kode lerroa:  t['\uFD38'] = '\u0634\u062D';
Kode lerroa:  t['\uFD39'] = '\u0634\u062E';
Kode lerroa:  t['\uFD3A'] = '\u0637\u0645';
Kode lerroa:  t['\uFD3B'] = '\u0638\u0645';
Kode lerroa:  t['\uFD3C'] = '\u0627\u064B';
Kode lerroa:  t['\uFD3D'] = '\u0627\u064B';
Kode lerroa:  t['\uFD50'] = '\u062A\u062C\u0645';
Kode lerroa:  t['\uFD51'] = '\u062A\u062D\u062C';
Kode lerroa:  t['\uFD52'] = '\u062A\u062D\u062C';
Kode lerroa:  t['\uFD53'] = '\u062A\u062D\u0645';
Kode lerroa:  t['\uFD54'] = '\u062A\u062E\u0645';
Kode lerroa:  t['\uFD55'] = '\u062A\u0645\u062C';
Kode lerroa:  t['\uFD56'] = '\u062A\u0645\u062D';
Kode lerroa:  t['\uFD57'] = '\u062A\u0645\u062E';
Kode lerroa:  t['\uFD58'] = '\u062C\u0645\u062D';
Kode lerroa:  t['\uFD59'] = '\u062C\u0645\u062D';
Kode lerroa:  t['\uFD5A'] = '\u062D\u0645\u064A';
Kode lerroa:  t['\uFD5B'] = '\u062D\u0645\u0649';
Kode lerroa:  t['\uFD5C'] = '\u0633\u062D\u062C';
Kode lerroa:  t['\uFD5D'] = '\u0633\u062C\u062D';
Kode lerroa:  t['\uFD5E'] = '\u0633\u062C\u0649';
Kode lerroa:  t['\uFD5F'] = '\u0633\u0645\u062D';
Kode lerroa:  t['\uFD60'] = '\u0633\u0645\u062D';
Kode lerroa:  t['\uFD61'] = '\u0633\u0645\u062C';
Kode lerroa:  t['\uFD62'] = '\u0633\u0645\u0645';
Kode lerroa:  t['\uFD63'] = '\u0633\u0645\u0645';
Kode lerroa:  t['\uFD64'] = '\u0635\u062D\u062D';
Kode lerroa:  t['\uFD65'] = '\u0635\u062D\u062D';
Kode lerroa:  t['\uFD66'] = '\u0635\u0645\u0645';
Kode lerroa:  t['\uFD67'] = '\u0634\u062D\u0645';
Kode lerroa:  t['\uFD68'] = '\u0634\u062D\u0645';
Kode lerroa:  t['\uFD69'] = '\u0634\u062C\u064A';
Kode lerroa:  t['\uFD6A'] = '\u0634\u0645\u062E';
Kode lerroa:  t['\uFD6B'] = '\u0634\u0645\u062E';
Kode lerroa:  t['\uFD6C'] = '\u0634\u0645\u0645';
Kode lerroa:  t['\uFD6D'] = '\u0634\u0645\u0645';
Kode lerroa:  t['\uFD6E'] = '\u0636\u062D\u0649';
Kode lerroa:  t['\uFD6F'] = '\u0636\u062E\u0645';
Kode lerroa:  t['\uFD70'] = '\u0636\u062E\u0645';
Kode lerroa:  t['\uFD71'] = '\u0637\u0645\u062D';
Kode lerroa:  t['\uFD72'] = '\u0637\u0645\u062D';
Kode lerroa:  t['\uFD73'] = '\u0637\u0645\u0645';
Kode lerroa:  t['\uFD74'] = '\u0637\u0645\u064A';
Kode lerroa:  t['\uFD75'] = '\u0639\u062C\u0645';
Kode lerroa:  t['\uFD76'] = '\u0639\u0645\u0645';
Kode lerroa:  t['\uFD77'] = '\u0639\u0645\u0645';
Kode lerroa:  t['\uFD78'] = '\u0639\u0645\u0649';
Kode lerroa:  t['\uFD79'] = '\u063A\u0645\u0645';
Kode lerroa:  t['\uFD7A'] = '\u063A\u0645\u064A';
Kode lerroa:  t['\uFD7B'] = '\u063A\u0645\u0649';
Kode lerroa:  t['\uFD7C'] = '\u0641\u062E\u0645';
Kode lerroa:  t['\uFD7D'] = '\u0641\u062E\u0645';
Kode lerroa:  t['\uFD7E'] = '\u0642\u0645\u062D';
Kode lerroa:  t['\uFD7F'] = '\u0642\u0645\u0645';
Kode lerroa:  t['\uFD80'] = '\u0644\u062D\u0645';
Kode lerroa:  t['\uFD81'] = '\u0644\u062D\u064A';
Kode lerroa:  t['\uFD82'] = '\u0644\u062D\u0649';
Kode lerroa:  t['\uFD83'] = '\u0644\u062C\u062C';
Kode lerroa:  t['\uFD84'] = '\u0644\u062C\u062C';
Kode lerroa:  t['\uFD85'] = '\u0644\u062E\u0645';
Kode lerroa:  t['\uFD86'] = '\u0644\u062E\u0645';
Kode lerroa:  t['\uFD87'] = '\u0644\u0645\u062D';
Kode lerroa:  t['\uFD88'] = '\u0644\u0645\u062D';
Kode lerroa:  t['\uFD89'] = '\u0645\u062D\u062C';
Kode lerroa:  t['\uFD8A'] = '\u0645\u062D\u0645';
Kode lerroa:  t['\uFD8B'] = '\u0645\u062D\u064A';
Kode lerroa:  t['\uFD8C'] = '\u0645\u062C\u062D';
Kode lerroa:  t['\uFD8D'] = '\u0645\u062C\u0645';
Kode lerroa:  t['\uFD8E'] = '\u0645\u062E\u062C';
Kode lerroa:  t['\uFD8F'] = '\u0645\u062E\u0645';
Kode lerroa:  t['\uFD92'] = '\u0645\u062C\u062E';
Kode lerroa:  t['\uFD93'] = '\u0647\u0645\u062C';
Kode lerroa:  t['\uFD94'] = '\u0647\u0645\u0645';
Kode lerroa:  t['\uFD95'] = '\u0646\u062D\u0645';
Kode lerroa:  t['\uFD96'] = '\u0646\u062D\u0649';
Kode lerroa:  t['\uFD97'] = '\u0646\u062C\u0645';
Kode lerroa:  t['\uFD98'] = '\u0646\u062C\u0645';
Kode lerroa:  t['\uFD99'] = '\u0646\u062C\u0649';
Kode lerroa:  t['\uFD9A'] = '\u0646\u0645\u064A';
Kode lerroa:  t['\uFD9B'] = '\u0646\u0645\u0649';
Kode lerroa:  t['\uFD9C'] = '\u064A\u0645\u0645';
Kode lerroa:  t['\uFD9D'] = '\u064A\u0645\u0645';
Kode lerroa:  t['\uFD9E'] = '\u0628\u062E\u064A';
Kode lerroa:  t['\uFD9F'] = '\u062A\u062C\u064A';
Kode lerroa:  t['\uFDA0'] = '\u062A\u062C\u0649';
Kode lerroa:  t['\uFDA1'] = '\u062A\u062E\u064A';
Kode lerroa:  t['\uFDA2'] = '\u062A\u062E\u0649';
Kode lerroa:  t['\uFDA3'] = '\u062A\u0645\u064A';
Kode lerroa:  t['\uFDA4'] = '\u062A\u0645\u0649';
Kode lerroa:  t['\uFDA5'] = '\u062C\u0645\u064A';
Kode lerroa:  t['\uFDA6'] = '\u062C\u062D\u0649';
Kode lerroa:  t['\uFDA7'] = '\u062C\u0645\u0649';
Kode lerroa:  t['\uFDA8'] = '\u0633\u062E\u0649';
Kode lerroa:  t['\uFDA9'] = '\u0635\u062D\u064A';
Kode lerroa:  t['\uFDAA'] = '\u0634\u062D\u064A';
Kode lerroa:  t['\uFDAB'] = '\u0636\u062D\u064A';
Kode lerroa:  t['\uFDAC'] = '\u0644\u062C\u064A';
Kode lerroa:  t['\uFDAD'] = '\u0644\u0645\u064A';
Kode lerroa:  t['\uFDAE'] = '\u064A\u062D\u064A';
Kode lerroa:  t['\uFDAF'] = '\u064A\u062C\u064A';
Kode lerroa:  t['\uFDB0'] = '\u064A\u0645\u064A';
Kode lerroa:  t['\uFDB1'] = '\u0645\u0645\u064A';
Kode lerroa:  t['\uFDB2'] = '\u0642\u0645\u064A';
Kode lerroa:  t['\uFDB3'] = '\u0646\u062D\u064A';
Kode lerroa:  t['\uFDB4'] = '\u0642\u0645\u062D';
Kode lerroa:  t['\uFDB5'] = '\u0644\u062D\u0645';
Kode lerroa:  t['\uFDB6'] = '\u0639\u0645\u064A';
Kode lerroa:  t['\uFDB7'] = '\u0643\u0645\u064A';
Kode lerroa:  t['\uFDB8'] = '\u0646\u062C\u062D';
Kode lerroa:  t['\uFDB9'] = '\u0645\u062E\u064A';
Kode lerroa:  t['\uFDBA'] = '\u0644\u062C\u0645';
Kode lerroa:  t['\uFDBB'] = '\u0643\u0645\u0645';
Kode lerroa:  t['\uFDBC'] = '\u0644\u062C\u0645';
Kode lerroa:  t['\uFDBD'] = '\u0646\u062C\u062D';
Kode lerroa:  t['\uFDBE'] = '\u062C\u062D\u064A';
Kode lerroa:  t['\uFDBF'] = '\u062D\u062C\u064A';
Kode lerroa:  t['\uFDC0'] = '\u0645\u062C\u064A';
Kode lerroa:  t['\uFDC1'] = '\u0641\u0645\u064A';
Kode lerroa:  t['\uFDC2'] = '\u0628\u062D\u064A';
Kode lerroa:  t['\uFDC3'] = '\u0643\u0645\u0645';
Kode lerroa:  t['\uFDC4'] = '\u0639\u062C\u0645';
Kode lerroa:  t['\uFDC5'] = '\u0635\u0645\u0645';
Kode lerroa:  t['\uFDC6'] = '\u0633\u062E\u064A';
Kode lerroa:  t['\uFDC7'] = '\u0646\u062C\u064A';
Kode lerroa:  t['\uFE49'] = '\u203E';
Kode lerroa:  t['\uFE4A'] = '\u203E';
Kode lerroa:  t['\uFE4B'] = '\u203E';
Kode lerroa:  t['\uFE4C'] = '\u203E';
Kode lerroa:  t['\uFE4D'] = '\u005F';
Kode lerroa:  t['\uFE4E'] = '\u005F';
Kode lerroa:  t['\uFE4F'] = '\u005F';
Kode lerroa:  t['\uFE80'] = '\u0621';
Kode lerroa:  t['\uFE81'] = '\u0622';
Kode lerroa:  t['\uFE82'] = '\u0622';
Kode lerroa:  t['\uFE83'] = '\u0623';
Kode lerroa:  t['\uFE84'] = '\u0623';
Kode lerroa:  t['\uFE85'] = '\u0624';
Kode lerroa:  t['\uFE86'] = '\u0624';
Kode lerroa:  t['\uFE87'] = '\u0625';
Kode lerroa:  t['\uFE88'] = '\u0625';
Kode lerroa:  t['\uFE89'] = '\u0626';
Kode lerroa:  t['\uFE8A'] = '\u0626';
Kode lerroa:  t['\uFE8B'] = '\u0626';
Kode lerroa:  t['\uFE8C'] = '\u0626';
Kode lerroa:  t['\uFE8D'] = '\u0627';
Kode lerroa:  t['\uFE8E'] = '\u0627';
Kode lerroa:  t['\uFE8F'] = '\u0628';
Kode lerroa:  t['\uFE90'] = '\u0628';
Kode lerroa:  t['\uFE91'] = '\u0628';
Kode lerroa:  t['\uFE92'] = '\u0628';
Kode lerroa:  t['\uFE93'] = '\u0629';
Kode lerroa:  t['\uFE94'] = '\u0629';
Kode lerroa:  t['\uFE95'] = '\u062A';
Kode lerroa:  t['\uFE96'] = '\u062A';
Kode lerroa:  t['\uFE97'] = '\u062A';
Kode lerroa:  t['\uFE98'] = '\u062A';
Kode lerroa:  t['\uFE99'] = '\u062B';
Kode lerroa:  t['\uFE9A'] = '\u062B';
Kode lerroa:  t['\uFE9B'] = '\u062B';
Kode lerroa:  t['\uFE9C'] = '\u062B';
Kode lerroa:  t['\uFE9D'] = '\u062C';
Kode lerroa:  t['\uFE9E'] = '\u062C';
Kode lerroa:  t['\uFE9F'] = '\u062C';
Kode lerroa:  t['\uFEA0'] = '\u062C';
Kode lerroa:  t['\uFEA1'] = '\u062D';
Kode lerroa:  t['\uFEA2'] = '\u062D';
Kode lerroa:  t['\uFEA3'] = '\u062D';
Kode lerroa:  t['\uFEA4'] = '\u062D';
Kode lerroa:  t['\uFEA5'] = '\u062E';
Kode lerroa:  t['\uFEA6'] = '\u062E';
Kode lerroa:  t['\uFEA7'] = '\u062E';
Kode lerroa:  t['\uFEA8'] = '\u062E';
Kode lerroa:  t['\uFEA9'] = '\u062F';
Kode lerroa:  t['\uFEAA'] = '\u062F';
Kode lerroa:  t['\uFEAB'] = '\u0630';
Kode lerroa:  t['\uFEAC'] = '\u0630';
Kode lerroa:  t['\uFEAD'] = '\u0631';
Kode lerroa:  t['\uFEAE'] = '\u0631';
Kode lerroa:  t['\uFEAF'] = '\u0632';
Kode lerroa:  t['\uFEB0'] = '\u0632';
Kode lerroa:  t['\uFEB1'] = '\u0633';
Kode lerroa:  t['\uFEB2'] = '\u0633';
Kode lerroa:  t['\uFEB3'] = '\u0633';
Kode lerroa:  t['\uFEB4'] = '\u0633';
Kode lerroa:  t['\uFEB5'] = '\u0634';
Kode lerroa:  t['\uFEB6'] = '\u0634';
Kode lerroa:  t['\uFEB7'] = '\u0634';
Kode lerroa:  t['\uFEB8'] = '\u0634';
Kode lerroa:  t['\uFEB9'] = '\u0635';
Kode lerroa:  t['\uFEBA'] = '\u0635';
Kode lerroa:  t['\uFEBB'] = '\u0635';
Kode lerroa:  t['\uFEBC'] = '\u0635';
Kode lerroa:  t['\uFEBD'] = '\u0636';
Kode lerroa:  t['\uFEBE'] = '\u0636';
Kode lerroa:  t['\uFEBF'] = '\u0636';
Kode lerroa:  t['\uFEC0'] = '\u0636';
Kode lerroa:  t['\uFEC1'] = '\u0637';
Kode lerroa:  t['\uFEC2'] = '\u0637';
Kode lerroa:  t['\uFEC3'] = '\u0637';
Kode lerroa:  t['\uFEC4'] = '\u0637';
Kode lerroa:  t['\uFEC5'] = '\u0638';
Kode lerroa:  t['\uFEC6'] = '\u0638';
Kode lerroa:  t['\uFEC7'] = '\u0638';
Kode lerroa:  t['\uFEC8'] = '\u0638';
Kode lerroa:  t['\uFEC9'] = '\u0639';
Kode lerroa:  t['\uFECA'] = '\u0639';
Kode lerroa:  t['\uFECB'] = '\u0639';
Kode lerroa:  t['\uFECC'] = '\u0639';
Kode lerroa:  t['\uFECD'] = '\u063A';
Kode lerroa:  t['\uFECE'] = '\u063A';
Kode lerroa:  t['\uFECF'] = '\u063A';
Kode lerroa:  t['\uFED0'] = '\u063A';
Kode lerroa:  t['\uFED1'] = '\u0641';
Kode lerroa:  t['\uFED2'] = '\u0641';
Kode lerroa:  t['\uFED3'] = '\u0641';
Kode lerroa:  t['\uFED4'] = '\u0641';
Kode lerroa:  t['\uFED5'] = '\u0642';
Kode lerroa:  t['\uFED6'] = '\u0642';
Kode lerroa:  t['\uFED7'] = '\u0642';
Kode lerroa:  t['\uFED8'] = '\u0642';
Kode lerroa:  t['\uFED9'] = '\u0643';
Kode lerroa:  t['\uFEDA'] = '\u0643';
Kode lerroa:  t['\uFEDB'] = '\u0643';
Kode lerroa:  t['\uFEDC'] = '\u0643';
Kode lerroa:  t['\uFEDD'] = '\u0644';
Kode lerroa:  t['\uFEDE'] = '\u0644';
Kode lerroa:  t['\uFEDF'] = '\u0644';
Kode lerroa:  t['\uFEE0'] = '\u0644';
Kode lerroa:  t['\uFEE1'] = '\u0645';
Kode lerroa:  t['\uFEE2'] = '\u0645';
Kode lerroa:  t['\uFEE3'] = '\u0645';
Kode lerroa:  t['\uFEE4'] = '\u0645';
Kode lerroa:  t['\uFEE5'] = '\u0646';
Kode lerroa:  t['\uFEE6'] = '\u0646';
Kode lerroa:  t['\uFEE7'] = '\u0646';
Kode lerroa:  t['\uFEE8'] = '\u0646';
Kode lerroa:  t['\uFEE9'] = '\u0647';
Kode lerroa:  t['\uFEEA'] = '\u0647';
Kode lerroa:  t['\uFEEB'] = '\u0647';
Kode lerroa:  t['\uFEEC'] = '\u0647';
Kode lerroa:  t['\uFEED'] = '\u0648';
Kode lerroa:  t['\uFEEE'] = '\u0648';
Kode lerroa:  t['\uFEEF'] = '\u0649';
Kode lerroa:  t['\uFEF0'] = '\u0649';
Kode lerroa:  t['\uFEF1'] = '\u064A';
Kode lerroa:  t['\uFEF2'] = '\u064A';
Kode lerroa:  t['\uFEF3'] = '\u064A';
Kode lerroa:  t['\uFEF4'] = '\u064A';
Kode lerroa:  t['\uFEF5'] = '\u0644\u0622';
Kode lerroa:  t['\uFEF6'] = '\u0644\u0622';
Kode lerroa:  t['\uFEF7'] = '\u0644\u0623';
Kode lerroa:  t['\uFEF8'] = '\u0644\u0623';
Kode lerroa:  t['\uFEF9'] = '\u0644\u0625';
Kode lerroa:  t['\uFEFA'] = '\u0644\u0625';
Kode lerroa:  t['\uFEFB'] = '\u0644\u0627';
Kode lerroa:  t['\uFEFC'] = '\u0644\u0627';
Kode lerroa: });
Kode lerroa: function reverseIfRtl(chars) {
Kode lerroa:  var charsLength = chars.length;
Kode lerroa:  if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
Kode lerroa:   return chars;
Kode lerroa:  }
Kode lerroa:  var s = '';
Kode lerroa:  for (var ii = charsLength - 1; ii >= 0; ii--) {
Kode lerroa:   s += chars[ii];
Kode lerroa:  }
Kode lerroa:  return s;
Kode lerroa: }
Kode lerroa: exports.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
Kode lerroa: exports.reverseIfRtl = reverseIfRtl;
Kode lerroa: exports.getUnicodeRangeFor = getUnicodeRangeFor;
Kode lerroa: exports.getNormalizedUnicodes = getNormalizedUnicodes;
Kode lerroa: exports.getUnicodeForGlyph = getUnicodeForGlyph;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 81 */
Kode lerroa: /***/ (function(module, exports, __w_pdfjs_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PostScriptCompiler = exports.PostScriptEvaluator = exports.PDFFunctionFactory = exports.isPDFFunction = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _util = __w_pdfjs_require__(0);
Kode lerroa: 
Kode lerroa: var _primitives = __w_pdfjs_require__(2);
Kode lerroa: 
Kode lerroa: var _ps_parser = __w_pdfjs_require__(142);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var IsEvalSupportedCached = {
Kode lerroa:   get value() {
Kode lerroa:     return (0, _util.shadow)(this, 'value', (0, _util.isEvalSupported)());
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: 
Kode lerroa: var PDFFunctionFactory = function () {
Kode lerroa:   function PDFFunctionFactory(_ref) {
Kode lerroa:     var xref = _ref.xref,
Kode lerroa:         _ref$isEvalSupported = _ref.isEvalSupported,
Kode lerroa:         isEvalSupported = _ref$isEvalSupported === undefined ? true : _ref$isEvalSupported;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFFunctionFactory);
Kode lerroa: 
Kode lerroa:     this.xref = xref;
Kode lerroa:     this.isEvalSupported = isEvalSupported !== false;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFFunctionFactory, [{
Kode lerroa:     key: 'create',
Kode lerroa:     value: function create(fn) {
Kode lerroa:       return PDFFunction.parse({
Kode lerroa:         xref: this.xref,
Kode lerroa:         isEvalSupported: this.isEvalSupported,
Kode lerroa:         fn: fn
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'createFromArray',
Kode lerroa:     value: function createFromArray(fnObj) {
Kode lerroa:       return PDFFunction.parseArray({
Kode lerroa:         xref: this.xref,
Kode lerroa:         isEvalSupported: this.isEvalSupported,
Kode lerroa:         fnObj: fnObj
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFFunctionFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: function toNumberArray(arr) {
Kode lerroa:   if (!Array.isArray(arr)) {
Kode lerroa:     return null;
Kode lerroa:   }
Kode lerroa:   var length = arr.length;
Kode lerroa:   for (var i = 0; i < length; i++) {
Kode lerroa:     if (typeof arr[i] !== 'number') {
Kode lerroa:       var result = new Array(length);
Kode lerroa:       for (var _i = 0; _i < length; _i++) {
Kode lerroa:         result[_i] = +arr[_i];
Kode lerroa:       }
Kode lerroa:       return result;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return arr;
Kode lerroa: }
Kode lerroa: var PDFFunction = function PDFFunctionClosure() {
Kode lerroa:   var CONSTRUCT_SAMPLED = 0;
Kode lerroa:   var CONSTRUCT_INTERPOLATED = 2;
Kode lerroa:   var CONSTRUCT_STICHED = 3;
Kode lerroa:   var CONSTRUCT_POSTSCRIPT = 4;
Kode lerroa:   return {
Kode lerroa:     getSampleArray: function getSampleArray(size, outputSize, bps, stream) {
Kode lerroa:       var i, ii;
Kode lerroa:       var length = 1;
Kode lerroa:       for (i = 0, ii = size.length; i < ii; i++) {
Kode lerroa:         length *= size[i];
Kode lerroa:       }
Kode lerroa:       length *= outputSize;
Kode lerroa:       var array = new Array(length);
Kode lerroa:       var codeSize = 0;
Kode lerroa:       var codeBuf = 0;
Kode lerroa:       var sampleMul = 1.0 / (Math.pow(2.0, bps) - 1);
Kode lerroa:       var strBytes = stream.getBytes((length * bps + 7) / 8);
Kode lerroa:       var strIdx = 0;
Kode lerroa:       for (i = 0; i < length; i++) {
Kode lerroa:         while (codeSize < bps) {
Kode lerroa:           codeBuf <<= 8;
Kode lerroa:           codeBuf |= strBytes[strIdx++];
Kode lerroa:           codeSize += 8;
Kode lerroa:         }
Kode lerroa:         codeSize -= bps;
Kode lerroa:         array[i] = (codeBuf >> codeSize) * sampleMul;
Kode lerroa:         codeBuf &= (1 << codeSize) - 1;
Kode lerroa:       }
Kode lerroa:       return array;
Kode lerroa:     },
Kode lerroa:     getIR: function getIR(_ref2) {
Kode lerroa:       var xref = _ref2.xref,
Kode lerroa:           isEvalSupported = _ref2.isEvalSupported,
Kode lerroa:           fn = _ref2.fn;
Kode lerroa: 
Kode lerroa:       var dict = fn.dict;
Kode lerroa:       if (!dict) {
Kode lerroa:         dict = fn;
Kode lerroa:       }
Kode lerroa:       var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
Kode lerroa:       var typeNum = dict.get('FunctionType');
Kode lerroa:       var typeFn = types[typeNum];
Kode lerroa:       if (!typeFn) {
Kode lerroa:         throw new _util.FormatError('Unknown type of function');
Kode lerroa:       }
Kode lerroa:       return typeFn.call(this, {
Kode lerroa:         xref: xref,
Kode lerroa:         isEvalSupported: isEvalSupported,
Kode lerroa:         fn: fn,
Kode lerroa:         dict: dict
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     fromIR: function fromIR(_ref3) {
Kode lerroa:       var xref = _ref3.xref,
Kode lerroa:           isEvalSupported = _ref3.isEvalSupported,
Kode lerroa:           IR = _ref3.IR;
Kode lerroa: 
Kode lerroa:       var type = IR[0];
Kode lerroa:       switch (type) {
Kode lerroa:         case CONSTRUCT_SAMPLED:
Kode lerroa:           return this.constructSampledFromIR({
Kode lerroa:             xref: xref,
Kode lerroa:             isEvalSupported: isEvalSupported,
Kode lerroa:             IR: IR
Kode lerroa:           });
Kode lerroa:         case CONSTRUCT_INTERPOLATED:
Kode lerroa:           return this.constructInterpolatedFromIR({
Kode lerroa:             xref: xref,
Kode lerroa:             isEvalSupported: isEvalSupported,
Kode lerroa:             IR: IR
Kode lerroa:           });
Kode lerroa:         case CONSTRUCT_STICHED:
Kode lerroa:           return this.constructStichedFromIR({
Kode lerroa:             xref: xref,
Kode lerroa:             isEvalSupported: isEvalSupported,
Kode lerroa:             IR: IR
Kode lerroa:           });
Kode lerroa:         default:
Kode lerroa:           return this.constructPostScriptFromIR({
Kode lerroa:             xref: xref,
Kode lerroa:             isEvalSupported: isEvalSupported,
Kode lerroa:             IR: IR
Kode lerroa:           });
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     parse: function parse(_ref4) {
Kode lerroa:       var xref = _ref4.xref,
Kode lerroa:           isEvalSupported = _ref4.isEvalSupported,
Kode lerroa:           fn = _ref4.fn;
Kode lerroa: 
Kode lerroa:       var IR = this.getIR({
Kode lerroa:         xref: xref,
Kode lerroa:         isEvalSupported: isEvalSupported,
Kode lerroa:         fn: fn
Kode lerroa:       });
Kode lerroa:       return this.fromIR({
Kode lerroa:         xref: xref,
Kode lerroa:         isEvalSupported: isEvalSupported,
Kode lerroa:         IR: IR
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     parseArray: function parseArray(_ref5) {
Kode lerroa:       var xref = _ref5.xref,
Kode lerroa:           isEvalSupported = _ref5.isEvalSupported,
Kode lerroa:           fnObj = _ref5.fnObj;
Kode lerroa: 
Kode lerroa:       if (!Array.isArray(fnObj)) {
Kode lerroa:         return this.parse({
Kode lerroa:           xref: xref,
Kode lerroa:           isEvalSupported: isEvalSupported,
Kode lerroa:           fn: fnObj
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var fnArray = [];
Kode lerroa:       for (var j = 0, jj = fnObj.length; j < jj; j++) {
Kode lerroa:         fnArray.push(this.parse({
Kode lerroa:           xref: xref,
Kode lerroa:           isEvalSupported: isEvalSupported,
Kode lerroa:           fn: xref.fetchIfRef(fnObj[j])
Kode lerroa:         }));
Kode lerroa:       }
Kode lerroa:       return function (src, srcOffset, dest, destOffset) {
Kode lerroa:         for (var i = 0, ii = fnArray.length; i < ii; i++) {
Kode lerroa:           fnArray[i](src, srcOffset, dest, destOffset + i);
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     constructSampled: function constructSampled(_ref6) {
Kode lerroa:       var xref = _ref6.xref,
Kode lerroa:           isEvalSupported = _ref6.isEvalSupported,
Kode lerroa:           fn = _ref6.fn,
Kode lerroa:           dict = _ref6.dict;
Kode lerroa: 
Kode lerroa:       function toMultiArray(arr) {
Kode lerroa:         var inputLength = arr.length;
Kode lerroa:         var out = [];
Kode lerroa:         var index = 0;
Kode lerroa:         for (var i = 0; i < inputLength; i += 2) {
Kode lerroa:           out[index] = [arr[i], arr[i + 1]];
Kode lerroa:           ++index;
Kode lerroa:         }
Kode lerroa:         return out;
Kode lerroa:       }
Kode lerroa:       var domain = toNumberArray(dict.getArray('Domain'));
Kode lerroa:       var range = toNumberArray(dict.getArray('Range'));
Kode lerroa:       if (!domain || !range) {
Kode lerroa:         throw new _util.FormatError('No domain or range');
Kode lerroa:       }
Kode lerroa:       var inputSize = domain.length / 2;
Kode lerroa:       var outputSize = range.length / 2;
Kode lerroa:       domain = toMultiArray(domain);
Kode lerroa:       range = toMultiArray(range);
Kode lerroa:       var size = toNumberArray(dict.get('Size'));
Kode lerroa:       var bps = dict.get('BitsPerSample');
Kode lerroa:       var order = dict.get('Order') || 1;
Kode lerroa:       if (order !== 1) {
Kode lerroa:         (0, _util.info)('No support for cubic spline interpolation: ' + order);
Kode lerroa:       }
Kode lerroa:       var encode = toNumberArray(dict.getArray('Encode'));
Kode lerroa:       if (!encode) {
Kode lerroa:         encode = [];
Kode lerroa:         for (var i = 0; i < inputSize; ++i) {
Kode lerroa:           encode.push([0, size[i] - 1]);
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         encode = toMultiArray(encode);
Kode lerroa:       }
Kode lerroa:       var decode = toNumberArray(dict.getArray('Decode'));
Kode lerroa:       if (!decode) {
Kode lerroa:         decode = range;
Kode lerroa:       } else {
Kode lerroa:         decode = toMultiArray(decode);
Kode lerroa:       }
Kode lerroa:       var samples = this.getSampleArray(size, outputSize, bps, fn);
Kode lerroa:       return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, Math.pow(2, bps) - 1, range];
Kode lerroa:     },
Kode lerroa:     constructSampledFromIR: function constructSampledFromIR(_ref7) {
Kode lerroa:       var xref = _ref7.xref,
Kode lerroa:           isEvalSupported = _ref7.isEvalSupported,
Kode lerroa:           IR = _ref7.IR;
Kode lerroa: 
Kode lerroa:       function interpolate(x, xmin, xmax, ymin, ymax) {
Kode lerroa:         return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
Kode lerroa:       }
Kode lerroa:       return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
Kode lerroa:         var m = IR[1];
Kode lerroa:         var domain = IR[2];
Kode lerroa:         var encode = IR[3];
Kode lerroa:         var decode = IR[4];
Kode lerroa:         var samples = IR[5];
Kode lerroa:         var size = IR[6];
Kode lerroa:         var n = IR[7];
Kode lerroa:         var range = IR[9];
Kode lerroa:         var cubeVertices = 1 << m;
Kode lerroa:         var cubeN = new Float64Array(cubeVertices);
Kode lerroa:         var cubeVertex = new Uint32Array(cubeVertices);
Kode lerroa:         var i, j;
Kode lerroa:         for (j = 0; j < cubeVertices; j++) {
Kode lerroa:           cubeN[j] = 1;
Kode lerroa:         }
Kode lerroa:         var k = n,
Kode lerroa:             pos = 1;
Kode lerroa:         for (i = 0; i < m; ++i) {
Kode lerroa:           var domain_2i = domain[i][0];
Kode lerroa:           var domain_2i_1 = domain[i][1];
Kode lerroa:           var xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
Kode lerroa:           var e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
Kode lerroa:           var size_i = size[i];
Kode lerroa:           e = Math.min(Math.max(e, 0), size_i - 1);
Kode lerroa:           var e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
Kode lerroa:           var n0 = e0 + 1 - e;
Kode lerroa:           var n1 = e - e0;
Kode lerroa:           var offset0 = e0 * k;
Kode lerroa:           var offset1 = offset0 + k;
Kode lerroa:           for (j = 0; j < cubeVertices; j++) {
Kode lerroa:             if (j & pos) {
Kode lerroa:               cubeN[j] *= n1;
Kode lerroa:               cubeVertex[j] += offset1;
Kode lerroa:             } else {
Kode lerroa:               cubeN[j] *= n0;
Kode lerroa:               cubeVertex[j] += offset0;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           k *= size_i;
Kode lerroa:           pos <<= 1;
Kode lerroa:         }
Kode lerroa:         for (j = 0; j < n; ++j) {
Kode lerroa:           var rj = 0;
Kode lerroa:           for (i = 0; i < cubeVertices; i++) {
Kode lerroa:             rj += samples[cubeVertex[i] + j] * cubeN[i];
Kode lerroa:           }
Kode lerroa:           rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
Kode lerroa:           dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     constructInterpolated: function constructInterpolated(_ref8) {
Kode lerroa:       var xref = _ref8.xref,
Kode lerroa:           isEvalSupported = _ref8.isEvalSupported,
Kode lerroa:           fn = _ref8.fn,
Kode lerroa:           dict = _ref8.dict;
Kode lerroa: 
Kode lerroa:       var c0 = toNumberArray(dict.getArray('C0')) || [0];
Kode lerroa:       var c1 = toNumberArray(dict.getArray('C1')) || [1];
Kode lerroa:       var n = dict.get('N');
Kode lerroa:       var length = c0.length;
Kode lerroa:       var diff = [];
Kode lerroa:       for (var i = 0; i < length; ++i) {
Kode lerroa:         diff.push(c1[i] - c0[i]);
Kode lerroa:       }
Kode lerroa:       return [CONSTRUCT_INTERPOLATED, c0, diff, n];
Kode lerroa:     },
Kode lerroa:     constructInterpolatedFromIR: function constructInterpolatedFromIR(_ref9) {
Kode lerroa:       var xref = _ref9.xref,
Kode lerroa:           isEvalSupported = _ref9.isEvalSupported,
Kode lerroa:           IR = _ref9.IR;
Kode lerroa: 
Kode lerroa:       var c0 = IR[1];
Kode lerroa:       var diff = IR[2];
Kode lerroa:       var n = IR[3];
Kode lerroa:       var length = diff.length;
Kode lerroa:       return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
Kode lerroa:         var x = n === 1 ? src[srcOffset] : Math.pow(src[srcOffset], n);
Kode lerroa:         for (var j = 0; j < length; ++j) {
Kode lerroa:           dest[destOffset + j] = c0[j] + x * diff[j];
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     constructStiched: function constructStiched(_ref10) {
Kode lerroa:       var xref = _ref10.xref,
Kode lerroa:           isEvalSupported = _ref10.isEvalSupported,
Kode lerroa:           fn = _ref10.fn,
Kode lerroa:           dict = _ref10.dict;
Kode lerroa: 
Kode lerroa:       var domain = toNumberArray(dict.getArray('Domain'));
Kode lerroa:       if (!domain) {
Kode lerroa:         throw new _util.FormatError('No domain');
Kode lerroa:       }
Kode lerroa:       var inputSize = domain.length / 2;
Kode lerroa:       if (inputSize !== 1) {
Kode lerroa:         throw new _util.FormatError('Bad domain for stiched function');
Kode lerroa:       }
Kode lerroa:       var fnRefs = dict.get('Functions');
Kode lerroa:       var fns = [];
Kode lerroa:       for (var i = 0, ii = fnRefs.length; i < ii; ++i) {
Kode lerroa:         fns.push(this.parse({
Kode lerroa:           xref: xref,
Kode lerroa:           isEvalSupported: isEvalSupported,
Kode lerroa:           fn: xref.fetchIfRef(fnRefs[i])
Kode lerroa:         }));
Kode lerroa:       }
Kode lerroa:       var bounds = toNumberArray(dict.getArray('Bounds'));
Kode lerroa:       var encode = toNumberArray(dict.getArray('Encode'));
Kode lerroa:       return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
Kode lerroa:     },
Kode lerroa:     constructStichedFromIR: function constructStichedFromIR(_ref11) {
Kode lerroa:       var xref = _ref11.xref,
Kode lerroa:           isEvalSupported = _ref11.isEvalSupported,
Kode lerroa:           IR = _ref11.IR;
Kode lerroa: 
Kode lerroa:       var domain = IR[1];
Kode lerroa:       var bounds = IR[2];
Kode lerroa:       var encode = IR[3];
Kode lerroa:       var fns = IR[4];
Kode lerroa:       var tmpBuf = new Float32Array(1);
Kode lerroa:       return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
Kode lerroa:         var clip = function constructStichedFromIRClip(v, min, max) {
Kode lerroa:           if (v > max) {
Kode lerroa:             v = max;
Kode lerroa:           } else if (v < min) {
Kode lerroa:             v = min;
Kode lerroa:           }
Kode lerroa:           return v;
Kode lerroa:         };
Kode lerroa:         var v = clip(src[srcOffset], domain[0], domain[1]);
Kode lerroa:         for (var i = 0, ii = bounds.length; i < ii; ++i) {
Kode lerroa:           if (v < bounds[i]) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         var dmin = domain[0];
Kode lerroa:         if (i > 0) {
Kode lerroa:           dmin = bounds[i - 1];
Kode lerroa:         }
Kode lerroa:         var dmax = domain[1];
Kode lerroa:         if (i < bounds.length) {
Kode lerroa:           dmax = bounds[i];
Kode lerroa:         }
Kode lerroa:         var rmin = encode[2 * i];
Kode lerroa:         var rmax = encode[2 * i + 1];
Kode lerroa:         tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
Kode lerroa:         fns[i](tmpBuf, 0, dest, destOffset);
Kode lerroa:       };
Kode lerroa:     },
Kode lerroa:     constructPostScript: function constructPostScript(_ref12) {
Kode lerroa:       var xref = _ref12.xref,
Kode lerroa:           isEvalSupported = _ref12.isEvalSupported,
Kode lerroa:           fn = _ref12.fn,
Kode lerroa:           dict = _ref12.dict;
Kode lerroa: 
Kode lerroa:       var domain = toNumberArray(dict.getArray('Domain'));
Kode lerroa:       var range = toNumberArray(dict.getArray('Range'));
Kode lerroa:       if (!domain) {
Kode lerroa:         throw new _util.FormatError('No domain.');
Kode lerroa:       }
Kode lerroa:       if (!range) {
Kode lerroa:         throw new _util.FormatError('No range.');
Kode lerroa:       }
Kode lerroa:       var lexer = new _ps_parser.PostScriptLexer(fn);
Kode lerroa:       var parser = new _ps_parser.PostScriptParser(lexer);
Kode lerroa:       var code = parser.parse();
Kode lerroa:       return [CONSTRUCT_POSTSCRIPT, domain, range, code];
Kode lerroa:     },
Kode lerroa:     constructPostScriptFromIR: function constructPostScriptFromIR(_ref13) {
Kode lerroa:       var xref = _ref13.xref,
Kode lerroa:           isEvalSupported = _ref13.isEvalSupported,
Kode lerroa:           IR = _ref13.IR;
Kode lerroa: 
Kode lerroa:       var domain = IR[1];
Kode lerroa:       var range = IR[2];
Kode lerroa:       var code = IR[3];
Kode lerroa:       if (isEvalSupported && IsEvalSupportedCached.value) {
Kode lerroa:         var compiled = new PostScriptCompiler().compile(code, domain, range);
Kode lerroa:         if (compiled) {
Kode lerroa:           return new Function('src', 'srcOffset', 'dest', 'destOffset', compiled);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       (0, _util.info)('Unable to compile PS function');
Kode lerroa:       var numOutputs = range.length >> 1;
Kode lerroa:       var numInputs = domain.length >> 1;
Kode lerroa:       var evaluator = new PostScriptEvaluator(code);
Kode lerroa:       var cache = Object.create(null);
Kode lerroa:       var MAX_CACHE_SIZE = 2048 * 4;
Kode lerroa:       var cache_available = MAX_CACHE_SIZE;
Kode lerroa:       var tmpBuf = new Float32Array(numInputs);
Kode lerroa:       return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
Kode lerroa:         var i, value;
Kode lerroa:         var key = '';
Kode lerroa:         var input = tmpBuf;
Kode lerroa:         for (i = 0; i < numInputs; i++) {
Kode lerroa:           value = src[srcOffset + i];
Kode lerroa:           input[i] = value;
Kode lerroa:           key += value + '_';
Kode lerroa:         }
Kode lerroa:         var cachedValue = cache[key];
Kode lerroa:         if (cachedValue !== undefined) {
Kode lerroa:           dest.set(cachedValue, destOffset);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var output = new Float32Array(numOutputs);
Kode lerroa:         var stack = evaluator.execute(input);
Kode lerroa:         var stackIndex = stack.length - numOutputs;
Kode lerroa:         for (i = 0; i < numOutputs; i++) {
Kode lerroa:           value = stack[stackIndex + i];
Kode lerroa:           var bound = range[i * 2];
Kode lerroa:           if (value < bound) {
Kode lerroa:             value = bound;
Kode lerroa:           } else {
Kode lerroa:             bound = range[i * 2 + 1];
Kode lerroa:             if (value > bound) {
Kode lerroa:               value = bound;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           output[i] = value;
Kode lerroa:         }
Kode lerroa:         if (cache_available > 0) {
Kode lerroa:           cache_available--;
Kode lerroa:           cache[key] = output;
Kode lerroa:         }
Kode lerroa:         dest.set(output, destOffset);
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }();
Kode lerroa: function isPDFFunction(v) {
Kode lerroa:   var fnDict;
Kode lerroa:   if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) !== 'object') {
Kode lerroa:     return false;
Kode lerroa:   } else if ((0, _primitives.isDict)(v)) {
Kode lerroa:     fnDict = v;
Kode lerroa:   } else if ((0, _primitives.isStream)(v)) {
Kode lerroa:     fnDict = v.dict;
Kode lerroa:   } else {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   return fnDict.has('FunctionType');
Kode lerroa: }
Kode lerroa: var PostScriptStack = function PostScriptStackClosure() {
Kode lerroa:   var MAX_STACK_SIZE = 100;
Kode lerroa:   function PostScriptStack(initialStack) {
Kode lerroa:     this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
Kode lerroa:   }
Kode lerroa:   PostScriptStack.prototype = {
Kode lerroa:     push: function PostScriptStack_push(value) {
Kode lerroa:       if (this.stack.length >= MAX_STACK_SIZE) {
Kode lerroa:         throw new Error('PostScript function stack overflow.');
Kode lerroa:       }
Kode lerroa:       this.stack.push(value);
Kode lerroa:     },
Kode lerroa:     pop: function PostScriptStack_pop() {
Kode lerroa:       if (this.stack.length <= 0) {
Kode lerroa:         throw new Error('PostScript function stack underflow.');
Kode lerroa:       }
Kode lerroa:       return this.stack.pop();
Kode lerroa:     },
Kode lerroa:     copy: function PostScriptStack_copy(n) {
Kode lerroa:       if (this.stack.length + n >= MAX_STACK_SIZE) {
Kode lerroa:         throw new Error('PostScript function stack overflow.');
Kode lerroa:       }
Kode lerroa:       var stack = this.stack;
Kode lerroa:       for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
Kode lerroa:         stack.push(stack[i]);
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     index: function PostScriptStack_index(n) {
Kode lerroa:       this.push(this.stack[this.stack.length - n - 1]);
Kode lerroa:     },
Kode lerroa:     roll: function PostScriptStack_roll(n, p) {
Kode lerroa:       var stack = this.stack;
Kode lerroa:       var l = stack.length - n;
Kode lerroa:       var r = stack.length - 1,
Kode lerroa:           c = l + (p - Math.floor(p / n) * n),
Kode lerroa:           i,
Kode lerroa:           j,
Kode lerroa:           t;
Kode lerroa:       for (i = l, j = r; i < j; i++, j--) {
Kode lerroa:         t = stack[i];
Kode lerroa:         stack[i] = stack[j];
Kode lerroa:         stack[j] = t;
Kode lerroa:       }
Kode lerroa:       for (i = l, j = c - 1; i < j; i++, j--) {
Kode lerroa:         t = stack[i];
Kode lerroa:         stack[i] = stack[j];
Kode lerroa:         stack[j] = t;
Kode lerroa:       }
Kode lerroa:       for (i = c, j = r; i < j; i++, j--) {
Kode lerroa:         t = stack[i];
Kode lerroa:         stack[i] = stack[j];
Kode lerroa:         stack[j] = t;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PostScriptStack;
Kode lerroa: }();
Kode lerroa: var PostScriptEvaluator = function PostScriptEvaluatorClosure() {
Kode lerroa:   function PostScriptEvaluator(operators) {
Kode lerroa:     this.operators = operators;
Kode lerroa:   }
Kode lerroa:   PostScriptEvaluator.prototype = {
Kode lerroa:     execute: function PostScriptEvaluator_execute(initialStack) {
Kode lerroa:       var stack = new PostScriptStack(initialStack);
Kode lerroa:       var counter = 0;
Kode lerroa:       var operators = this.operators;
Kode lerroa:       var length = operators.length;
Kode lerroa:       var operator, a, b;
Kode lerroa:       while (counter < length) {
Kode lerroa:         operator = operators[counter++];
Kode lerroa:         if (typeof operator === 'number') {
Kode lerroa:           stack.push(operator);
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         switch (operator) {
Kode lerroa:           case 'jz':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             if (!a) {
Kode lerroa:               counter = b;
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'j':
Kode lerroa:             a = stack.pop();
Kode lerroa:             counter = a;
Kode lerroa:             break;
Kode lerroa:           case 'abs':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.abs(a));
Kode lerroa:             break;
Kode lerroa:           case 'add':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a + b);
Kode lerroa:             break;
Kode lerroa:           case 'and':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
Kode lerroa:               stack.push(a && b);
Kode lerroa:             } else {
Kode lerroa:               stack.push(a & b);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'atan':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.atan(a));
Kode lerroa:             break;
Kode lerroa:           case 'bitshift':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             if (a > 0) {
Kode lerroa:               stack.push(a << b);
Kode lerroa:             } else {
Kode lerroa:               stack.push(a >> b);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'ceiling':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.ceil(a));
Kode lerroa:             break;
Kode lerroa:           case 'copy':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.copy(a);
Kode lerroa:             break;
Kode lerroa:           case 'cos':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.cos(a));
Kode lerroa:             break;
Kode lerroa:           case 'cvi':
Kode lerroa:             a = stack.pop() | 0;
Kode lerroa:             stack.push(a);
Kode lerroa:             break;
Kode lerroa:           case 'cvr':
Kode lerroa:             break;
Kode lerroa:           case 'div':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a / b);
Kode lerroa:             break;
Kode lerroa:           case 'dup':
Kode lerroa:             stack.copy(1);
Kode lerroa:             break;
Kode lerroa:           case 'eq':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a === b);
Kode lerroa:             break;
Kode lerroa:           case 'exch':
Kode lerroa:             stack.roll(2, 1);
Kode lerroa:             break;
Kode lerroa:           case 'exp':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.pow(a, b));
Kode lerroa:             break;
Kode lerroa:           case 'false':
Kode lerroa:             stack.push(false);
Kode lerroa:             break;
Kode lerroa:           case 'floor':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.floor(a));
Kode lerroa:             break;
Kode lerroa:           case 'ge':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a >= b);
Kode lerroa:             break;
Kode lerroa:           case 'gt':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a > b);
Kode lerroa:             break;
Kode lerroa:           case 'idiv':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a / b | 0);
Kode lerroa:             break;
Kode lerroa:           case 'index':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.index(a);
Kode lerroa:             break;
Kode lerroa:           case 'le':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a <= b);
Kode lerroa:             break;
Kode lerroa:           case 'ln':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.log(a));
Kode lerroa:             break;
Kode lerroa:           case 'log':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.log(a) / Math.LN10);
Kode lerroa:             break;
Kode lerroa:           case 'lt':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a < b);
Kode lerroa:             break;
Kode lerroa:           case 'mod':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a % b);
Kode lerroa:             break;
Kode lerroa:           case 'mul':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a * b);
Kode lerroa:             break;
Kode lerroa:           case 'ne':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a !== b);
Kode lerroa:             break;
Kode lerroa:           case 'neg':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(-a);
Kode lerroa:             break;
Kode lerroa:           case 'not':
Kode lerroa:             a = stack.pop();
Kode lerroa:             if ((0, _util.isBool)(a)) {
Kode lerroa:               stack.push(!a);
Kode lerroa:             } else {
Kode lerroa:               stack.push(~a);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'or':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
Kode lerroa:               stack.push(a || b);
Kode lerroa:             } else {
Kode lerroa:               stack.push(a | b);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           case 'pop':
Kode lerroa:             stack.pop();
Kode lerroa:             break;
Kode lerroa:           case 'roll':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.roll(a, b);
Kode lerroa:             break;
Kode lerroa:           case 'round':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.round(a));
Kode lerroa:             break;
Kode lerroa:           case 'sin':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.sin(a));
Kode lerroa:             break;
Kode lerroa:           case 'sqrt':
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(Math.sqrt(a));
Kode lerroa:             break;
Kode lerroa:           case 'sub':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             stack.push(a - b);
Kode lerroa:             break;
Kode lerroa:           case 'true':
Kode lerroa:             stack.push(true);
Kode lerroa:             break;
Kode lerroa:           case 'truncate':
Kode lerroa:             a = stack.pop();
Kode lerroa:             a = a < 0 ? Math.ceil(a) : Math.floor(a);
Kode lerroa:             stack.push(a);
Kode lerroa:             break;
Kode lerroa:           case 'xor':
Kode lerroa:             b = stack.pop();
Kode lerroa:             a = stack.pop();
Kode lerroa:             if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
Kode lerroa:               stack.push(a !== b);
Kode lerroa:             } else {
Kode lerroa:               stack.push(a ^ b);
Kode lerroa:             }
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             throw new _util.FormatError('Unknown operator ' + operator);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return stack.stack;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   return PostScriptEvaluator;
Kode lerroa: }();
Kode lerroa: var PostScriptCompiler = function PostScriptCompilerClosure() {
Kode lerroa:   function AstNode(type) {
Kode lerroa:     this.type = type;
Kode lerroa:   }
Kode lerroa:   AstNode.prototype.visit = function (visitor) {
Kode lerroa:     throw new Error('abstract method');
Kode lerroa:   };
Kode lerroa:   function AstArgument(index, min, max) {
Kode lerroa:     AstNode.call(this, 'args');
Kode lerroa:     this.index = index;
Kode lerroa:     this.min = min;
Kode lerroa:     this.max = max;
Kode lerroa:   }
Kode lerroa:   AstArgument.prototype = Object.create(AstNode.prototype);
Kode lerroa:   AstArgument.prototype.visit = function (visitor) {
Kode lerroa:     visitor.visitArgument(this);
Kode lerroa:   };
Kode lerroa:   function AstLiteral(number) {
Kode lerroa:     AstNode.call(this, 'literal');
Kode lerroa:     this.number = number;
Kode lerroa:     this.min = number;
Kode lerroa:     this.max = number;
Kode lerroa:   }
Kode lerroa:   AstLiteral.prototype = Object.create(AstNode.prototype);
Kode lerroa:   AstLiteral.prototype.visit = function (visitor) {
Kode lerroa:     visitor.visitLiteral(this);
Kode lerroa:   };
Kode lerroa:   function AstBinaryOperation(op, arg1, arg2, min, max) {
Kode lerroa:     AstNode.call(this, 'binary');
Kode lerroa:     this.op = op;
Kode lerroa:     this.arg1 = arg1;
Kode lerroa:     this.arg2 = arg2;
Kode lerroa:     this.min = min;
Kode lerroa:     this.max = max;
Kode lerroa:   }
Kode lerroa:   AstBinaryOperation.prototype = Object.create(AstNode.prototype);
Kode lerroa:   AstBinaryOperation.prototype.visit = function (visitor) {
Kode lerroa:     visitor.visitBinaryOperation(this);
Kode lerroa:   };
Kode lerroa:   function AstMin(arg, max) {
Kode lerroa:     AstNode.call(this, 'max');
Kode lerroa:     this.arg = arg;
Kode lerroa:     this.min = arg.min;
Kode lerroa:     this.max = max;
Kode lerroa:   }
Kode lerroa:   AstMin.prototype = Object.create(AstNode.prototype);
Kode lerroa:   AstMin.prototype.visit = function (visitor) {
Kode lerroa:     visitor.visitMin(this);
Kode lerroa:   };
Kode lerroa:   function AstVariable(index, min, max) {
Kode lerroa:     AstNode.call(this, 'var');
Kode lerroa: /* Copyright 2014 Mozilla Foundation
Kode lerroa:  *
Kode lerroa:  * Licensed under the Apache License, Version 2.0 (the "License");
Kode lerroa:  * you may not use this file except in compliance with the License.
Kode lerroa:  * You may obtain a copy of the License at
Kode lerroa:  *
Kode lerroa:  *     http://www.apache.org/licenses/LICENSE-2.0
Kode lerroa:  *
Kode lerroa:  * Unless required by applicable law or agreed to in writing, software
Kode lerroa:  * distributed under the License is distributed on an "AS IS" BASIS,
Kode lerroa:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
Kode lerroa:  * See the License for the specific language governing permissions and
Kode lerroa:  * limitations under the License.
Kode lerroa:  */
Kode lerroa: 
Kode lerroa: .textLayer {
Kode lerroa:   position: absolute;
Kode lerroa:   left: 0;
Kode lerroa:   top: 0;
Kode lerroa:   right: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   overflow: hidden;
Kode lerroa:   opacity: 0.2;
Kode lerroa:   line-height: 1.0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer > div {
Kode lerroa:   color: transparent;
Kode lerroa:   position: absolute;
Kode lerroa:   white-space: pre;
Kode lerroa:   cursor: text;
Kode lerroa:   -webkit-transform-origin: 0% 0%;
Kode lerroa:   -moz-transform-origin: 0% 0%;
Kode lerroa:   -o-transform-origin: 0% 0%;
Kode lerroa:   -ms-transform-origin: 0% 0%;
Kode lerroa:   transform-origin: 0% 0%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .highlight {
Kode lerroa:   margin: -1px;
Kode lerroa:   padding: 1px;
Kode lerroa: 
Kode lerroa:   background-color: rgb(180, 0, 170);
Kode lerroa:   border-radius: 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .highlight.begin {
Kode lerroa:   border-radius: 4px 0px 0px 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .highlight.end {
Kode lerroa:   border-radius: 0px 4px 4px 0px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .highlight.middle {
Kode lerroa:   border-radius: 0px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .highlight.selected {
Kode lerroa:   background-color: rgb(0, 100, 0);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer ::selection { background: rgb(0,0,255); }
Kode lerroa: .textLayer ::-moz-selection { background: rgb(0,0,255); }
Kode lerroa: 
Kode lerroa: .textLayer .endOfContent {
Kode lerroa:   display: block;
Kode lerroa:   position: absolute;
Kode lerroa:   left: 0px;
Kode lerroa:   top: 100%;
Kode lerroa:   right: 0px;
Kode lerroa:   bottom: 0px;
Kode lerroa:   z-index: -1;
Kode lerroa:   cursor: default;
Kode lerroa:   -webkit-user-select: none;
Kode lerroa:   -ms-user-select: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .endOfContent.active {
Kode lerroa:   top: 0px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: 
Kode lerroa: .annotationLayer section {
Kode lerroa:   position: absolute;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .linkAnnotation > a {
Kode lerroa:   position: absolute;
Kode lerroa:   font-size: 1em;
Kode lerroa:   top: 0;
Kode lerroa:   left: 0;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .linkAnnotation > a /* -ms-a */  {
Kode lerroa:   background: url("data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7") 0 0 repeat;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .linkAnnotation > a:hover {
Kode lerroa:   opacity: 0.2;
Kode lerroa:   background: #ff0;
Kode lerroa:   box-shadow: 0px 2px 10px #ff0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textAnnotation img {
Kode lerroa:   position: absolute;
Kode lerroa:   cursor: pointer;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation input,
Kode lerroa: .annotationLayer .textWidgetAnnotation textarea,
Kode lerroa: .annotationLayer .choiceWidgetAnnotation select,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input {
Kode lerroa:   background-color: rgba(0, 54, 255, 0.13);
Kode lerroa:   border: 1px solid transparent;
Kode lerroa:   box-sizing: border-box;
Kode lerroa:   font-size: 9px;
Kode lerroa:   height: 100%;
Kode lerroa:   margin: 0;
Kode lerroa:   padding: 0 3px;
Kode lerroa:   vertical-align: top;
Kode lerroa:   width: 100%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .choiceWidgetAnnotation select option {
Kode lerroa:   padding: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input {
Kode lerroa:   border-radius: 50%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation textarea {
Kode lerroa:   font: message-box;
Kode lerroa:   font-size: 9px;
Kode lerroa:   resize: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation input[disabled],
Kode lerroa: .annotationLayer .textWidgetAnnotation textarea[disabled],
Kode lerroa: .annotationLayer .choiceWidgetAnnotation select[disabled],
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] {
Kode lerroa:   background: none;
Kode lerroa:   border: 1px solid transparent;
Kode lerroa:   cursor: not-allowed;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation input:hover,
Kode lerroa: .annotationLayer .textWidgetAnnotation textarea:hover,
Kode lerroa: .annotationLayer .choiceWidgetAnnotation select:hover,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:hover,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input:hover {
Kode lerroa:   border: 1px solid #000;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation input:focus,
Kode lerroa: .annotationLayer .textWidgetAnnotation textarea:focus,
Kode lerroa: .annotationLayer .choiceWidgetAnnotation select:focus {
Kode lerroa:   background: none;
Kode lerroa:   border: 1px solid transparent;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {
Kode lerroa:   background-color: #000;
Kode lerroa:   content: '';
Kode lerroa:   display: block;
Kode lerroa:   position: absolute;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {
Kode lerroa:   height: 80%;
Kode lerroa:   left: 45%;
Kode lerroa:   width: 1px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before {
Kode lerroa:   transform: rotate(45deg);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {
Kode lerroa:   transform: rotate(-45deg);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {
Kode lerroa:   border-radius: 50%;
Kode lerroa:   height: 50%;
Kode lerroa:   left: 30%;
Kode lerroa:   top: 20%;
Kode lerroa:   width: 50%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation input.comb {
Kode lerroa:   font-family: monospace;
Kode lerroa:   padding-left: 2px;
Kode lerroa:   padding-right: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .textWidgetAnnotation input.comb:focus {
Kode lerroa:   /*
Kode lerroa:    * Letter spacing is placed on the right side of each character. Hence, the
Kode lerroa:    * letter spacing of the last character may be placed outside the visible
Kode lerroa:    * area, causing horizontal scrolling. We avoid this by extending the width
Kode lerroa:    * when the element has focus and revert this when it loses focus.
Kode lerroa:    */
Kode lerroa:   width: 115%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.checkBox input,
Kode lerroa: .annotationLayer .buttonWidgetAnnotation.radioButton input {
Kode lerroa:   -webkit-appearance: none;
Kode lerroa:   -moz-appearance: none;
Kode lerroa:   -ms-appearance: none;
Kode lerroa:   appearance: none;
Kode lerroa:   padding: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .popupWrapper {
Kode lerroa:   position: absolute;
Kode lerroa:   width: 20em;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .popup {
Kode lerroa:   position: absolute;
Kode lerroa:   z-index: 200;
Kode lerroa:   max-width: 20em;
Kode lerroa:   background-color: #FFFF99;
Kode lerroa:   box-shadow: 0px 2px 5px #333;
Kode lerroa:   border-radius: 2px;
Kode lerroa:   padding: 0.6em;
Kode lerroa:   margin-left: 5px;
Kode lerroa:   cursor: pointer;
Kode lerroa:   font: message-box;
Kode lerroa:   word-wrap: break-word;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .popup h1 {
Kode lerroa:   font-size: 1em;
Kode lerroa:   border-bottom: 1px solid #000000;
Kode lerroa:   margin: 0;
Kode lerroa:   padding-bottom: 0.2em;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .popup p {
Kode lerroa:   margin: 0;
Kode lerroa:   padding-top: 0.2em;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationLayer .highlightAnnotation,
Kode lerroa: .annotationLayer .underlineAnnotation,
Kode lerroa: .annotationLayer .squigglyAnnotation,
Kode lerroa: .annotationLayer .strikeoutAnnotation,
Kode lerroa: .annotationLayer .lineAnnotation svg line,
Kode lerroa: .annotationLayer .squareAnnotation svg rect,
Kode lerroa: .annotationLayer .circleAnnotation svg ellipse,
Kode lerroa: .annotationLayer .polylineAnnotation svg polyline,
Kode lerroa: .annotationLayer .polygonAnnotation svg polygon,
Kode lerroa: .annotationLayer .stampAnnotation,
Kode lerroa: .annotationLayer .fileAttachmentAnnotation {
Kode lerroa:   cursor: pointer;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer .canvasWrapper {
Kode lerroa:   overflow: hidden;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer .page {
Kode lerroa:   direction: ltr;
Kode lerroa:   width: 816px;
Kode lerroa:   height: 1056px;
Kode lerroa:   margin: 1px auto -8px auto;
Kode lerroa:   position: relative;
Kode lerroa:   overflow: visible;
Kode lerroa:   border: 9px solid transparent;
Kode lerroa:   background-clip: content-box;
Kode lerroa:   border-image: url(images/shadow.png) 9 9 repeat;
Kode lerroa:   background-color: white;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer.removePageBorders .page {
Kode lerroa:   margin: 0px auto 10px auto;
Kode lerroa:   border: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer.singlePageView {
Kode lerroa:   display: inline-block;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer.singlePageView .page {
Kode lerroa:   margin: 0;
Kode lerroa:   border: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer .page canvas {
Kode lerroa:   margin: 0;
Kode lerroa:   display: block;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer .page canvas[hidden] {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfViewer .page .loadingIcon {
Kode lerroa:   position: absolute;
Kode lerroa:   display: block;
Kode lerroa:   left: 0;
Kode lerroa:   top: 0;
Kode lerroa:   right: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   background: url('images/loading-icon.gif') center no-repeat;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-webkit-full-screen .pdfViewer .page {
Kode lerroa:   margin-bottom: 100%;
Kode lerroa:   border: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-moz-full-screen .pdfViewer .page {
Kode lerroa:   margin-bottom: 100%;
Kode lerroa:   border: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-ms-fullscreen .pdfViewer .page {
Kode lerroa:   margin-bottom: 100% !important;
Kode lerroa:   border: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:fullscreen .pdfViewer .page {
Kode lerroa:   margin-bottom: 100%;
Kode lerroa:   border: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: * {
Kode lerroa:   padding: 0;
Kode lerroa:   margin: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html {
Kode lerroa:   height: 100%;
Kode lerroa:   width: 100%;
Kode lerroa:   /* Font size is needed to make the activity bar the correct size. */
Kode lerroa:   font-size: 10px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: body {
Kode lerroa:   height: 100%;
Kode lerroa:   width: 100%;
Kode lerroa:   background-color: #404040;
Kode lerroa:   background-image: url(images/texture.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: body,
Kode lerroa: input,
Kode lerroa: button,
Kode lerroa: select {
Kode lerroa:   font: message-box;
Kode lerroa:   outline: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .hidden {
Kode lerroa:   display: none !important;
Kode lerroa: }
Kode lerroa: [hidden] {
Kode lerroa:   display: none !important;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewerContainer.pdfPresentationMode:-webkit-full-screen {
Kode lerroa:   top: 0px;
Kode lerroa:   border-top: 2px solid transparent;
Kode lerroa:   background-color: #000;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa:   overflow: hidden;
Kode lerroa:   cursor: none;
Kode lerroa:   -webkit-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewerContainer.pdfPresentationMode:-moz-full-screen {
Kode lerroa:   top: 0px;
Kode lerroa:   border-top: 2px solid transparent;
Kode lerroa:   background-color: #000;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa:   overflow: hidden;
Kode lerroa:   cursor: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewerContainer.pdfPresentationMode:-ms-fullscreen {
Kode lerroa:   top: 0px !important;
Kode lerroa:   border-top: 2px solid transparent;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa:   overflow: hidden !important;
Kode lerroa:   cursor: none;
Kode lerroa:   -ms-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewerContainer.pdfPresentationMode:-ms-fullscreen::-ms-backdrop {
Kode lerroa:   background-color: #000;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewerContainer.pdfPresentationMode:fullscreen {
Kode lerroa:   top: 0px;
Kode lerroa:   border-top: 2px solid transparent;
Kode lerroa:   background-color: #000;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa:   overflow: hidden;
Kode lerroa:   cursor: none;
Kode lerroa:   -webkit-user-select: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa:   -ms-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-webkit-full-screen a:not(.internalLink) {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-moz-full-screen a:not(.internalLink) {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-ms-fullscreen a:not(.internalLink) {
Kode lerroa:   display: none !important;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:fullscreen a:not(.internalLink) {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-webkit-full-screen .textLayer > div {
Kode lerroa:   cursor: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-moz-full-screen .textLayer > div {
Kode lerroa:   cursor: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:-ms-fullscreen .textLayer > div {
Kode lerroa:   cursor: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode:fullscreen .textLayer > div {
Kode lerroa:   cursor: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .pdfPresentationMode.pdfPresentationModeControls > *,
Kode lerroa: .pdfPresentationMode.pdfPresentationModeControls .textLayer > div {
Kode lerroa:   cursor: default;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #outerContainer {
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa:   position: relative;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #sidebarContainer {
Kode lerroa:   position: absolute;
Kode lerroa:   top: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   width: 200px;
Kode lerroa:   visibility: hidden;
Kode lerroa:   -webkit-transition-duration: 200ms;
Kode lerroa:   -webkit-transition-timing-function: ease;
Kode lerroa:   transition-duration: 200ms;
Kode lerroa:   transition-timing-function: ease;
Kode lerroa: 
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #sidebarContainer {
Kode lerroa:   -webkit-transition-property: left;
Kode lerroa:   transition-property: left;
Kode lerroa:   left: -200px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #sidebarContainer {
Kode lerroa:   -webkit-transition-property: right;
Kode lerroa:   transition-property: right;
Kode lerroa:   right: -200px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #outerContainer.sidebarMoving > #sidebarContainer,
Kode lerroa: #outerContainer.sidebarOpen > #sidebarContainer {
Kode lerroa:   visibility: visible;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #outerContainer.sidebarOpen > #sidebarContainer {
Kode lerroa:   left: 0px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #outerContainer.sidebarOpen > #sidebarContainer {
Kode lerroa:   right: 0px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #mainContainer {
Kode lerroa:   position: absolute;
Kode lerroa:   top: 0;
Kode lerroa:   right: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   left: 0;
Kode lerroa:   min-width: 320px;
Kode lerroa:   -webkit-transition-duration: 200ms;
Kode lerroa:   -webkit-transition-timing-function: ease;
Kode lerroa:   transition-duration: 200ms;
Kode lerroa:   transition-timing-function: ease;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #outerContainer.sidebarOpen > #mainContainer {
Kode lerroa:   -webkit-transition-property: left;
Kode lerroa:   transition-property: left;
Kode lerroa:   left: 200px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #outerContainer.sidebarOpen > #mainContainer {
Kode lerroa:   -webkit-transition-property: right;
Kode lerroa:   transition-property: right;
Kode lerroa:   right: 200px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #sidebarContent {
Kode lerroa:   top: 32px;
Kode lerroa:   bottom: 0;
Kode lerroa:   overflow: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa:   position: absolute;
Kode lerroa:   width: 200px;
Kode lerroa:   background-color: hsla(0,0%,0%,.1);
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #sidebarContent {
Kode lerroa:   left: 0;
Kode lerroa:   box-shadow: inset -1px 0 0 hsla(0,0%,0%,.25);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #sidebarContent {
Kode lerroa:   right: 0;
Kode lerroa:   box-shadow: inset 1px 0 0 hsla(0,0%,0%,.25);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewerContainer {
Kode lerroa:   overflow: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa:   position: absolute;
Kode lerroa:   top: 32px;
Kode lerroa:   right: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   left: 0;
Kode lerroa:   outline: none;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #viewerContainer {
Kode lerroa:   box-shadow: inset 1px 0 0 hsla(0,0%,100%,.05);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #viewerContainer {
Kode lerroa:   box-shadow: inset -1px 0 0 hsla(0,0%,100%,.05);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbar {
Kode lerroa:   position: relative;
Kode lerroa:   left: 0;
Kode lerroa:   right: 0;
Kode lerroa:   z-index: 9999;
Kode lerroa:   cursor: default;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #toolbarContainer {
Kode lerroa:   width: 100%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #toolbarSidebar {
Kode lerroa:   width: 200px;
Kode lerroa:   height: 32px;
Kode lerroa:   background-color: #424242; /* fallback */
Kode lerroa:   background-image: url(images/texture.png),
Kode lerroa:                     linear-gradient(hsla(0,0%,30%,.99), hsla(0,0%,25%,.95));
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #toolbarSidebar {
Kode lerroa:   box-shadow: inset -1px 0 0 rgba(0, 0, 0, 0.25),
Kode lerroa:               inset 0 -1px 0 hsla(0,0%,100%,.05),
Kode lerroa:               0 1px 0 hsla(0,0%,0%,.15),
Kode lerroa:               0 0 1px hsla(0,0%,0%,.1);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #toolbarSidebar {
Kode lerroa:   box-shadow: inset 1px 0 0 rgba(0, 0, 0, 0.25),
Kode lerroa:               inset 0 1px 0 hsla(0,0%,100%,.05),
Kode lerroa:               0 1px 0 hsla(0,0%,0%,.15),
Kode lerroa:               0 0 1px hsla(0,0%,0%,.1);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #toolbarContainer, .findbar, .secondaryToolbar {
Kode lerroa:   position: relative;
Kode lerroa:   height: 32px;
Kode lerroa:   background-color: #474747; /* fallback */
Kode lerroa:   background-image: url(images/texture.png),
Kode lerroa:                     linear-gradient(hsla(0,0%,32%,.99), hsla(0,0%,27%,.95));
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #toolbarContainer, .findbar, .secondaryToolbar {
Kode lerroa:   box-shadow: inset 1px 0 0 hsla(0,0%,100%,.08),
Kode lerroa:               inset 0 1px 1px hsla(0,0%,0%,.15),
Kode lerroa:               inset 0 -1px 0 hsla(0,0%,100%,.05),
Kode lerroa:               0 1px 0 hsla(0,0%,0%,.15),
Kode lerroa:               0 1px 1px hsla(0,0%,0%,.1);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #toolbarContainer, .findbar, .secondaryToolbar {
Kode lerroa:   box-shadow: inset -1px 0 0 hsla(0,0%,100%,.08),
Kode lerroa:               inset 0 1px 1px hsla(0,0%,0%,.15),
Kode lerroa:               inset 0 -1px 0 hsla(0,0%,100%,.05),
Kode lerroa:               0 1px 0 hsla(0,0%,0%,.15),
Kode lerroa:               0 1px 1px hsla(0,0%,0%,.1);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #toolbarViewer {
Kode lerroa:   height: 32px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #loadingBar {
Kode lerroa:   position: relative;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 4px;
Kode lerroa:   background-color: #333;
Kode lerroa:   border-bottom: 1px solid #333;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #loadingBar .progress {
Kode lerroa:   position: absolute;
Kode lerroa:   top: 0;
Kode lerroa:   left: 0;
Kode lerroa:   width: 0%;
Kode lerroa:   height: 100%;
Kode lerroa:   background-color: #ddd;
Kode lerroa:   overflow: hidden;
Kode lerroa:   -webkit-transition: width 200ms;
Kode lerroa:   transition: width 200ms;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @-webkit-keyframes progressIndeterminate {
Kode lerroa:   0% { left: -142px; }
Kode lerroa:   100% { left: 0; }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @keyframes progressIndeterminate {
Kode lerroa:   0% { left: -142px; }
Kode lerroa:   100% { left: 0; }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #loadingBar .progress.indeterminate {
Kode lerroa:   background-color: #999;
Kode lerroa:   -webkit-transition: none;
Kode lerroa:   transition: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #loadingBar .progress.indeterminate .glimmer {
Kode lerroa:   position: absolute;
Kode lerroa:   top: 0;
Kode lerroa:   left: 0;
Kode lerroa:   height: 100%;
Kode lerroa:   width: calc(100% + 150px);
Kode lerroa: 
Kode lerroa:   background: repeating-linear-gradient(135deg,
Kode lerroa:                                         #bbb 0, #999 5px,
Kode lerroa:                                         #999 45px, #ddd 55px,
Kode lerroa:                                         #ddd 95px, #bbb 100px);
Kode lerroa: 
Kode lerroa:   -webkit-animation: progressIndeterminate 950ms linear infinite;
Kode lerroa:   animation: progressIndeterminate 950ms linear infinite;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .findbar, .secondaryToolbar {
Kode lerroa:   top: 32px;
Kode lerroa:   position: absolute;
Kode lerroa:   z-index: 10000;
Kode lerroa:   height: auto;
Kode lerroa:   min-width: 16px;
Kode lerroa:   padding: 0px 6px 0px 6px;
Kode lerroa:   margin: 4px 2px 4px 2px;
Kode lerroa:   color: hsl(0,0%,85%);
Kode lerroa:   font-size: 12px;
Kode lerroa:   line-height: 14px;
Kode lerroa:   text-align: left;
Kode lerroa:   cursor: default;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .findbar {
Kode lerroa:   min-width: 300px;
Kode lerroa: }
Kode lerroa: .findbar > div {
Kode lerroa:   height: 32px;
Kode lerroa: }
Kode lerroa: .findbar.wrapContainers > div {
Kode lerroa:   clear: both;
Kode lerroa: }
Kode lerroa: .findbar.wrapContainers > div#findbarMessageContainer {
Kode lerroa:   height: auto;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .findbar {
Kode lerroa:   left: 68px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .findbar {
Kode lerroa:   right: 68px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .findbar label {
Kode lerroa:   -webkit-user-select: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #findInput {
Kode lerroa:   width: 200px;
Kode lerroa: }
Kode lerroa: #findInput::-webkit-input-placeholder {
Kode lerroa:   font-style: italic;
Kode lerroa: }
Kode lerroa: #findInput::-moz-placeholder {
Kode lerroa:   font-style: italic;
Kode lerroa: }
Kode lerroa: #findInput:-ms-input-placeholder {
Kode lerroa:   font-style: italic;
Kode lerroa: }
Kode lerroa: #findInput::placeholder {
Kode lerroa:   font-style: italic;
Kode lerroa: }
Kode lerroa: #findInput[data-status="pending"] {
Kode lerroa:   background-image: url(images/loading-small.png);
Kode lerroa:   background-repeat: no-repeat;
Kode lerroa:   background-position: right;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #findInput[data-status="pending"] {
Kode lerroa:   background-position: left;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbar {
Kode lerroa:   padding: 6px;
Kode lerroa:   height: auto;
Kode lerroa:   z-index: 30000;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .secondaryToolbar {
Kode lerroa:   right: 4px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .secondaryToolbar {
Kode lerroa:   left: 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #secondaryToolbarButtonContainer {
Kode lerroa:   max-width: 200px;
Kode lerroa:   max-height: 400px;
Kode lerroa:   overflow-y: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa:   margin-bottom: -4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .doorHanger,
Kode lerroa: .doorHangerRight {
Kode lerroa:   border: 1px solid hsla(0,0%,0%,.5);
Kode lerroa:   border-radius: 2px;
Kode lerroa:   box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
Kode lerroa: }
Kode lerroa: .doorHanger:after, .doorHanger:before,
Kode lerroa: .doorHangerRight:after, .doorHangerRight:before {
Kode lerroa:   bottom: 100%;
Kode lerroa:   border: solid transparent;
Kode lerroa:   content: " ";
Kode lerroa:   height: 0;
Kode lerroa:   width: 0;
Kode lerroa:   position: absolute;
Kode lerroa:   pointer-events: none;
Kode lerroa: }
Kode lerroa: .doorHanger:after,
Kode lerroa: .doorHangerRight:after {
Kode lerroa:   border-bottom-color: hsla(0,0%,32%,.99);
Kode lerroa:   border-width: 8px;
Kode lerroa: }
Kode lerroa: .doorHanger:before,
Kode lerroa: .doorHangerRight:before {
Kode lerroa:   border-bottom-color: hsla(0,0%,0%,.5);
Kode lerroa:   border-width: 9px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .doorHanger:after,
Kode lerroa: html[dir='rtl'] .doorHangerRight:after {
Kode lerroa:   left: 13px;
Kode lerroa:   margin-left: -8px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .doorHanger:before,
Kode lerroa: html[dir='rtl'] .doorHangerRight:before {
Kode lerroa:   left: 13px;
Kode lerroa:   margin-left: -9px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='rtl'] .doorHanger:after,
Kode lerroa: html[dir='ltr'] .doorHangerRight:after {
Kode lerroa:   right: 13px;
Kode lerroa:   margin-right: -8px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='rtl'] .doorHanger:before,
Kode lerroa: html[dir='ltr'] .doorHangerRight:before {
Kode lerroa:   right: 13px;
Kode lerroa:   margin-right: -9px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #findResultsCount {
Kode lerroa:   background-color: hsl(0, 0%, 85%);
Kode lerroa:   color: hsl(0, 0%, 32%);
Kode lerroa:   text-align: center;
Kode lerroa:   padding: 3px 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #findMsg {
Kode lerroa:   font-style: italic;
Kode lerroa:   color: #A6B7D0;
Kode lerroa: }
Kode lerroa: #findMsg:empty {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #findInput.notFound {
Kode lerroa:   background-color: rgb(255, 102, 102);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #toolbarViewerMiddle {
Kode lerroa:   position: absolute;
Kode lerroa:   left: 50%;
Kode lerroa:   transform: translateX(-50%);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] #toolbarViewerLeft,
Kode lerroa: html[dir='rtl'] #toolbarViewerRight {
Kode lerroa:   float: left;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #toolbarViewerRight,
Kode lerroa: html[dir='rtl'] #toolbarViewerLeft {
Kode lerroa:   float: right;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #toolbarViewerLeft > *,
Kode lerroa: html[dir='ltr'] #toolbarViewerMiddle > *,
Kode lerroa: html[dir='ltr'] #toolbarViewerRight > *,
Kode lerroa: html[dir='ltr'] .findbar * {
Kode lerroa:   position: relative;
Kode lerroa:   float: left;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #toolbarViewerLeft > *,
Kode lerroa: html[dir='rtl'] #toolbarViewerMiddle > *,
Kode lerroa: html[dir='rtl'] #toolbarViewerRight > *,
Kode lerroa: html[dir='rtl'] .findbar * {
Kode lerroa:   position: relative;
Kode lerroa:   float: right;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .splitToolbarButton {
Kode lerroa:   margin: 3px 2px 4px 0;
Kode lerroa:   display: inline-block;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .splitToolbarButton {
Kode lerroa:   margin: 3px 0 4px 2px;
Kode lerroa:   display: inline-block;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .splitToolbarButton > .toolbarButton {
Kode lerroa:   border-radius: 0;
Kode lerroa:   float: left;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .splitToolbarButton > .toolbarButton {
Kode lerroa:   border-radius: 0;
Kode lerroa:   float: right;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton,
Kode lerroa: .secondaryToolbarButton,
Kode lerroa: .overlayButton {
Kode lerroa:   border: 0 none;
Kode lerroa:   background: none;
Kode lerroa:   width: 32px;
Kode lerroa:   height: 25px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton > span {
Kode lerroa:   display: inline-block;
Kode lerroa:   width: 0;
Kode lerroa:   height: 0;
Kode lerroa:   overflow: hidden;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton[disabled],
Kode lerroa: .secondaryToolbarButton[disabled],
Kode lerroa: .overlayButton[disabled] {
Kode lerroa:   opacity: .5;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .splitToolbarButton.toggled .toolbarButton {
Kode lerroa:   margin: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .splitToolbarButton:hover > .toolbarButton,
Kode lerroa: .splitToolbarButton:focus > .toolbarButton,
Kode lerroa: .splitToolbarButton.toggled > .toolbarButton,
Kode lerroa: .toolbarButton.textButton {
Kode lerroa:   background-color: hsla(0,0%,0%,.12);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   border: 1px solid hsla(0,0%,0%,.35);
Kode lerroa:   border-color: hsla(0,0%,0%,.32) hsla(0,0%,0%,.38) hsla(0,0%,0%,.42);
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.15) inset,
Kode lerroa:               0 1px 0 hsla(0,0%,100%,.05);
Kode lerroa:   -webkit-transition-property: background-color, border-color, box-shadow;
Kode lerroa:   -webkit-transition-duration: 150ms;
Kode lerroa:   -webkit-transition-timing-function: ease;
Kode lerroa:   transition-property: background-color, border-color, box-shadow;
Kode lerroa:   transition-duration: 150ms;
Kode lerroa:   transition-timing-function: ease;
Kode lerroa: 
Kode lerroa: }
Kode lerroa: .splitToolbarButton > .toolbarButton:hover,
Kode lerroa: .splitToolbarButton > .toolbarButton:focus,
Kode lerroa: .dropdownToolbarButton:hover,
Kode lerroa: .overlayButton:hover,
Kode lerroa: .overlayButton:focus,
Kode lerroa: .toolbarButton.textButton:hover,
Kode lerroa: .toolbarButton.textButton:focus {
Kode lerroa:   background-color: hsla(0,0%,0%,.2);
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.15) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.05);
Kode lerroa:   z-index: 199;
Kode lerroa: }
Kode lerroa: .splitToolbarButton > .toolbarButton {
Kode lerroa:   position: relative;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .splitToolbarButton > .toolbarButton:first-child,
Kode lerroa: html[dir='rtl'] .splitToolbarButton > .toolbarButton:last-child {
Kode lerroa:   position: relative;
Kode lerroa:   margin: 0;
Kode lerroa:   margin-right: -1px;
Kode lerroa:   border-top-left-radius: 2px;
Kode lerroa:   border-bottom-left-radius: 2px;
Kode lerroa:   border-right-color: transparent;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .splitToolbarButton > .toolbarButton:last-child,
Kode lerroa: html[dir='rtl'] .splitToolbarButton > .toolbarButton:first-child {
Kode lerroa:   position: relative;
Kode lerroa:   margin: 0;
Kode lerroa:   margin-left: -1px;
Kode lerroa:   border-top-right-radius: 2px;
Kode lerroa:   border-bottom-right-radius: 2px;
Kode lerroa:   border-left-color: transparent;
Kode lerroa: }
Kode lerroa: .splitToolbarButtonSeparator {
Kode lerroa:   padding: 8px 0;
Kode lerroa:   width: 1px;
Kode lerroa:   background-color: hsla(0,0%,0%,.5);
Kode lerroa:   z-index: 99;
Kode lerroa:   box-shadow: 0 0 0 1px hsla(0,0%,100%,.08);
Kode lerroa:   display: inline-block;
Kode lerroa:   margin: 5px 0;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .splitToolbarButtonSeparator {
Kode lerroa:   float: left;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .splitToolbarButtonSeparator {
Kode lerroa:   float: right;
Kode lerroa: }
Kode lerroa: .splitToolbarButton:hover > .splitToolbarButtonSeparator,
Kode lerroa: .splitToolbarButton.toggled > .splitToolbarButtonSeparator {
Kode lerroa:   padding: 12px 0;
Kode lerroa:   margin: 1px 0;
Kode lerroa:   box-shadow: 0 0 0 1px hsla(0,0%,100%,.03);
Kode lerroa:   -webkit-transition-property: padding;
Kode lerroa:   -webkit-transition-duration: 10ms;
Kode lerroa:   -webkit-transition-timing-function: ease;
Kode lerroa:   transition-property: padding;
Kode lerroa:   transition-duration: 10ms;
Kode lerroa:   transition-timing-function: ease;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton,
Kode lerroa: .dropdownToolbarButton,
Kode lerroa: .secondaryToolbarButton,
Kode lerroa: .overlayButton {
Kode lerroa:   min-width: 16px;
Kode lerroa:   padding: 2px 6px 0;
Kode lerroa:   border: 1px solid transparent;
Kode lerroa:   border-radius: 2px;
Kode lerroa:   color: hsla(0,0%,100%,.8);
Kode lerroa:   font-size: 12px;
Kode lerroa:   line-height: 14px;
Kode lerroa:   -webkit-user-select: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa:   -ms-user-select: none;
Kode lerroa:   /* Opera does not support user-select, use <... unselectable="on"> instead */
Kode lerroa:   cursor: default;
Kode lerroa:   -webkit-transition-property: background-color, border-color, box-shadow;
Kode lerroa:   -webkit-transition-duration: 150ms;
Kode lerroa:   -webkit-transition-timing-function: ease;
Kode lerroa:   transition-property: background-color, border-color, box-shadow;
Kode lerroa:   transition-duration: 150ms;
Kode lerroa:   transition-timing-function: ease;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton,
Kode lerroa: html[dir='ltr'] .overlayButton,
Kode lerroa: html[dir='ltr'] .dropdownToolbarButton {
Kode lerroa:   margin: 3px 2px 4px 0;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton,
Kode lerroa: html[dir='rtl'] .overlayButton,
Kode lerroa: html[dir='rtl'] .dropdownToolbarButton {
Kode lerroa:   margin: 3px 0 4px 2px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton:hover,
Kode lerroa: .toolbarButton:focus,
Kode lerroa: .dropdownToolbarButton,
Kode lerroa: .overlayButton,
Kode lerroa: .secondaryToolbarButton:hover,
Kode lerroa: .secondaryToolbarButton:focus {
Kode lerroa:   background-color: hsla(0,0%,0%,.12);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   border: 1px solid hsla(0,0%,0%,.35);
Kode lerroa:   border-color: hsla(0,0%,0%,.32) hsla(0,0%,0%,.38) hsla(0,0%,0%,.42);
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.15) inset,
Kode lerroa:               0 1px 0 hsla(0,0%,100%,.05);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton:hover:active,
Kode lerroa: .overlayButton:hover:active,
Kode lerroa: .dropdownToolbarButton:hover:active,
Kode lerroa: .secondaryToolbarButton:hover:active {
Kode lerroa:   background-color: hsla(0,0%,0%,.2);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   border-color: hsla(0,0%,0%,.35) hsla(0,0%,0%,.4) hsla(0,0%,0%,.45);
Kode lerroa:   box-shadow: 0 1px 1px hsla(0,0%,0%,.1) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.2) inset,
Kode lerroa:               0 1px 0 hsla(0,0%,100%,.05);
Kode lerroa:   -webkit-transition-property: background-color, border-color, box-shadow;
Kode lerroa:   -webkit-transition-duration: 10ms;
Kode lerroa:   -webkit-transition-timing-function: linear;
Kode lerroa:   transition-property: background-color, border-color, box-shadow;
Kode lerroa:   transition-duration: 10ms;
Kode lerroa:   transition-timing-function: linear;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.toggled,
Kode lerroa: .splitToolbarButton.toggled > .toolbarButton.toggled,
Kode lerroa: .secondaryToolbarButton.toggled {
Kode lerroa:   background-color: hsla(0,0%,0%,.3);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   border-color: hsla(0,0%,0%,.4) hsla(0,0%,0%,.45) hsla(0,0%,0%,.5);
Kode lerroa:   box-shadow: 0 1px 1px hsla(0,0%,0%,.1) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.2) inset,
Kode lerroa:               0 1px 0 hsla(0,0%,100%,.05);
Kode lerroa:   -webkit-transition-property: background-color, border-color, box-shadow;
Kode lerroa:   -webkit-transition-duration: 10ms;
Kode lerroa:   -webkit-transition-timing-function: linear;
Kode lerroa:   transition-property: background-color, border-color, box-shadow;
Kode lerroa:   transition-duration: 10ms;
Kode lerroa:   transition-timing-function: linear;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.toggled:hover:active,
Kode lerroa: .splitToolbarButton.toggled > .toolbarButton.toggled:hover:active,
Kode lerroa: .secondaryToolbarButton.toggled:hover:active {
Kode lerroa:   background-color: hsla(0,0%,0%,.4);
Kode lerroa:   border-color: hsla(0,0%,0%,.4) hsla(0,0%,0%,.5) hsla(0,0%,0%,.55);
Kode lerroa:   box-shadow: 0 1px 1px hsla(0,0%,0%,.2) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.3) inset,
Kode lerroa:               0 1px 0 hsla(0,0%,100%,.05);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dropdownToolbarButton {
Kode lerroa:   width: 120px;
Kode lerroa:   max-width: 120px;
Kode lerroa:   padding: 0;
Kode lerroa:   overflow: hidden;
Kode lerroa:   background: url(images/toolbarButton-menuArrows.png) no-repeat;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .dropdownToolbarButton {
Kode lerroa:   background-position: 95%;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .dropdownToolbarButton {
Kode lerroa:   background-position: 5%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dropdownToolbarButton > select {
Kode lerroa:   min-width: 140px;
Kode lerroa:   font-size: 12px;
Kode lerroa:   color: hsl(0,0%,95%);
Kode lerroa:   margin: 0;
Kode lerroa:   padding: 3px 2px 2px;
Kode lerroa:   border: none;
Kode lerroa:   background: rgba(0,0,0,0); /* Opera does not support 'transparent' <select> background */
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dropdownToolbarButton > select > option {
Kode lerroa:   background: hsl(0,0%,24%);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #customScaleOption {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #pageWidthOption {
Kode lerroa:   border-bottom: 1px rgba(255, 255, 255, .5) solid;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .splitToolbarButton:first-child,
Kode lerroa: html[dir='ltr'] .toolbarButton:first-child,
Kode lerroa: html[dir='rtl'] .splitToolbarButton:last-child,
Kode lerroa: html[dir='rtl'] .toolbarButton:last-child {
Kode lerroa:   margin-left: 4px;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .splitToolbarButton:last-child,
Kode lerroa: html[dir='ltr'] .toolbarButton:last-child,
Kode lerroa: html[dir='rtl'] .splitToolbarButton:first-child,
Kode lerroa: html[dir='rtl'] .toolbarButton:first-child {
Kode lerroa:   margin-right: 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButtonSpacer {
Kode lerroa:   width: 30px;
Kode lerroa:   display: inline-block;
Kode lerroa:   height: 1px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] #findPrevious {
Kode lerroa:   margin-left: 3px;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #findNext {
Kode lerroa:   margin-right: 3px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='rtl'] #findPrevious {
Kode lerroa:   margin-right: 3px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #findNext {
Kode lerroa:   margin-left: 3px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton::before,
Kode lerroa: .secondaryToolbarButton::before {
Kode lerroa:   /* All matching images have a size of 16x16
Kode lerroa:    * All relevant containers have a size of 32x25 */
Kode lerroa:   position: absolute;
Kode lerroa:   display: inline-block;
Kode lerroa:   top: 4px;
Kode lerroa:   left: 7px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir="ltr"] .secondaryToolbarButton::before {
Kode lerroa:   left: 4px;
Kode lerroa: }
Kode lerroa: html[dir="rtl"] .secondaryToolbarButton::before {
Kode lerroa:   right: 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton#sidebarToggle::before {
Kode lerroa:   content: url(images/toolbarButton-sidebarToggle.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton#sidebarToggle::before {
Kode lerroa:   content: url(images/toolbarButton-sidebarToggle-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton#secondaryToolbarToggle::before {
Kode lerroa:   content: url(images/toolbarButton-secondaryToolbarToggle.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton#secondaryToolbarToggle::before {
Kode lerroa:   content: url(images/toolbarButton-secondaryToolbarToggle-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton.findPrevious::before {
Kode lerroa:   content: url(images/findbarButton-previous.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton.findPrevious::before {
Kode lerroa:   content: url(images/findbarButton-previous-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton.findNext::before {
Kode lerroa:   content: url(images/findbarButton-next.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton.findNext::before {
Kode lerroa:   content: url(images/findbarButton-next-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton.pageUp::before {
Kode lerroa:   content: url(images/toolbarButton-pageUp.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton.pageUp::before {
Kode lerroa:   content: url(images/toolbarButton-pageUp-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .toolbarButton.pageDown::before {
Kode lerroa:   content: url(images/toolbarButton-pageDown.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton.pageDown::before {
Kode lerroa:   content: url(images/toolbarButton-pageDown-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.zoomOut::before {
Kode lerroa:   content: url(images/toolbarButton-zoomOut.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.zoomIn::before {
Kode lerroa:   content: url(images/toolbarButton-zoomIn.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.presentationMode::before,
Kode lerroa: .secondaryToolbarButton.presentationMode::before {
Kode lerroa:   content: url(images/toolbarButton-presentationMode.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.print::before,
Kode lerroa: .secondaryToolbarButton.print::before {
Kode lerroa:   content: url(images/toolbarButton-print.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.openFile::before,
Kode lerroa: .secondaryToolbarButton.openFile::before {
Kode lerroa:   content: url(images/toolbarButton-openFile.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.download::before,
Kode lerroa: .secondaryToolbarButton.download::before {
Kode lerroa:   content: url(images/toolbarButton-download.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.bookmark,
Kode lerroa: .secondaryToolbarButton.bookmark {
Kode lerroa:   -webkit-box-sizing: border-box;
Kode lerroa:   -moz-box-sizing: border-box;
Kode lerroa:   box-sizing: border-box;
Kode lerroa:   outline: none;
Kode lerroa:   padding-top: 4px;
Kode lerroa:   text-decoration: none;
Kode lerroa: }
Kode lerroa: .secondaryToolbarButton.bookmark {
Kode lerroa:   padding-top: 5px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .bookmark[href='#'] {
Kode lerroa:   opacity: .5;
Kode lerroa:   pointer-events: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.bookmark::before,
Kode lerroa: .secondaryToolbarButton.bookmark::before {
Kode lerroa:   content: url(images/toolbarButton-bookmark.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewThumbnail.toolbarButton::before {
Kode lerroa:   content: url(images/toolbarButton-viewThumbnail.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir="ltr"] #viewOutline.toolbarButton::before {
Kode lerroa:   content: url(images/toolbarButton-viewOutline.png);
Kode lerroa: }
Kode lerroa: html[dir="rtl"] #viewOutline.toolbarButton::before {
Kode lerroa:   content: url(images/toolbarButton-viewOutline-rtl.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewAttachments.toolbarButton::before {
Kode lerroa:   content: url(images/toolbarButton-viewAttachments.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewFind.toolbarButton::before {
Kode lerroa:   content: url(images/toolbarButton-search.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarButton.pdfSidebarNotification::after {
Kode lerroa:   position: absolute;
Kode lerroa:   display: inline-block;
Kode lerroa:   top: 1px;
Kode lerroa:   /* Create a filled circle, with a diameter of 9 pixels, using only CSS: */
Kode lerroa:   content: '';
Kode lerroa:   background-color: #70DB55;
Kode lerroa:   height: 9px;
Kode lerroa:   width: 9px;
Kode lerroa:   border-radius: 50%;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .toolbarButton.pdfSidebarNotification::after {
Kode lerroa:   left: 17px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .toolbarButton.pdfSidebarNotification::after {
Kode lerroa:   right: 17px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton {
Kode lerroa:   position: relative;
Kode lerroa:   margin: 0 0 4px 0;
Kode lerroa:   padding: 3px 0 1px 0;
Kode lerroa:   height: auto;
Kode lerroa:   min-height: 25px;
Kode lerroa:   width: auto;
Kode lerroa:   min-width: 100%;
Kode lerroa:   white-space: normal;
Kode lerroa: }
Kode lerroa: html[dir="ltr"] .secondaryToolbarButton {
Kode lerroa:   padding-left: 24px;
Kode lerroa:   text-align: left;
Kode lerroa: }
Kode lerroa: html[dir="rtl"] .secondaryToolbarButton {
Kode lerroa:   padding-right: 24px;
Kode lerroa:   text-align: right;
Kode lerroa: }
Kode lerroa: html[dir="ltr"] .secondaryToolbarButton.bookmark {
Kode lerroa:   padding-left: 27px;
Kode lerroa: }
Kode lerroa: html[dir="rtl"] .secondaryToolbarButton.bookmark {
Kode lerroa:   padding-right: 27px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir="ltr"] .secondaryToolbarButton > span {
Kode lerroa:   padding-right: 4px;
Kode lerroa: }
Kode lerroa: html[dir="rtl"] .secondaryToolbarButton > span {
Kode lerroa:   padding-left: 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.firstPage::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-firstPage.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.lastPage::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-lastPage.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.rotateCcw::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-rotateCcw.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.rotateCw::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-rotateCw.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.selectTool::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-selectTool.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.handTool::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-handTool.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .secondaryToolbarButton.documentProperties::before {
Kode lerroa:   content: url(images/secondaryToolbarButton-documentProperties.png);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .verticalToolbarSeparator {
Kode lerroa:   display: block;
Kode lerroa:   padding: 8px 0;
Kode lerroa:   margin: 8px 4px;
Kode lerroa:   width: 1px;
Kode lerroa:   background-color: hsla(0,0%,0%,.5);
Kode lerroa:   box-shadow: 0 0 0 1px hsla(0,0%,100%,.08);
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .verticalToolbarSeparator {
Kode lerroa:   margin-left: 2px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .verticalToolbarSeparator {
Kode lerroa:   margin-right: 2px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .horizontalToolbarSeparator {
Kode lerroa:   display: block;
Kode lerroa:   margin: 0 0 4px 0;
Kode lerroa:   height: 1px;
Kode lerroa:   width: 100%;
Kode lerroa:   background-color: hsla(0,0%,0%,.5);
Kode lerroa:   box-shadow: 0 0 0 1px hsla(0,0%,100%,.08);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField {
Kode lerroa:   padding: 3px 6px;
Kode lerroa:   margin: 4px 0 4px 0;
Kode lerroa:   border: 1px solid transparent;
Kode lerroa:   border-radius: 2px;
Kode lerroa:   background-color: hsla(0,0%,100%,.09);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   border: 1px solid hsla(0,0%,0%,.35);
Kode lerroa:   border-color: hsla(0,0%,0%,.32) hsla(0,0%,0%,.38) hsla(0,0%,0%,.42);
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,0%,.05) inset,
Kode lerroa:               0 1px 0 hsla(0,0%,100%,.05);
Kode lerroa:   color: hsl(0,0%,95%);
Kode lerroa:   font-size: 12px;
Kode lerroa:   line-height: 14px;
Kode lerroa:   outline-style: none;
Kode lerroa:   transition-property: background-color, border-color, box-shadow;
Kode lerroa:   transition-duration: 150ms;
Kode lerroa:   transition-timing-function: ease;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField[type=checkbox] {
Kode lerroa:   display: inline-block;
Kode lerroa:   margin: 8px 0px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField.pageNumber {
Kode lerroa:   -moz-appearance: textfield; /* hides the spinner in moz */
Kode lerroa:   min-width: 16px;
Kode lerroa:   text-align: right;
Kode lerroa:   width: 40px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField.pageNumber.visiblePageIsLoading {
Kode lerroa:   background-image: url(images/loading-small.png);
Kode lerroa:   background-repeat: no-repeat;
Kode lerroa:   background-position: 1px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField.pageNumber::-webkit-inner-spin-button,
Kode lerroa: .toolbarField.pageNumber::-webkit-outer-spin-button {
Kode lerroa:     -webkit-appearance: none;
Kode lerroa:     margin: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField:hover {
Kode lerroa:   background-color: hsla(0,0%,100%,.11);
Kode lerroa:   border-color: hsla(0,0%,0%,.4) hsla(0,0%,0%,.43) hsla(0,0%,0%,.45);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarField:focus {
Kode lerroa:   background-color: hsla(0,0%,100%,.15);
Kode lerroa:   border-color: hsla(204,100%,65%,.8) hsla(204,100%,65%,.85) hsla(204,100%,65%,.9);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .toolbarLabel {
Kode lerroa:   min-width: 16px;
Kode lerroa:   padding: 3px 6px 3px 2px;
Kode lerroa:   margin: 4px 2px 4px 0;
Kode lerroa:   border: 1px solid transparent;
Kode lerroa:   border-radius: 2px;
Kode lerroa:   color: hsl(0,0%,85%);
Kode lerroa:   font-size: 12px;
Kode lerroa:   line-height: 14px;
Kode lerroa:   text-align: left;
Kode lerroa:   -webkit-user-select: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa:   cursor: default;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #thumbnailView {
Kode lerroa:   position: absolute;
Kode lerroa:   width: 120px;
Kode lerroa:   top: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   padding: 10px 40px 0;
Kode lerroa:   overflow: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .thumbnail {
Kode lerroa:   float: left;
Kode lerroa:   margin-bottom: 5px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #thumbnailView > a:last-of-type > .thumbnail {
Kode lerroa:   margin-bottom: 10px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #thumbnailView > a:last-of-type > .thumbnail:not([data-loaded]) {
Kode lerroa:   margin-bottom: 9px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .thumbnail:not([data-loaded]) {
Kode lerroa:   border: 1px dashed rgba(255, 255, 255, 0.5);
Kode lerroa:   margin: -1px -1px 4px -1px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .thumbnailImage {
Kode lerroa:   border: 1px solid transparent;
Kode lerroa:   box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3);
Kode lerroa:   opacity: 0.8;
Kode lerroa:   z-index: 99;
Kode lerroa:   background-color: white;
Kode lerroa:   background-clip: content-box;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .thumbnailSelectionRing {
Kode lerroa:   border-radius: 2px;
Kode lerroa:   padding: 7px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: a:focus > .thumbnail > .thumbnailSelectionRing > .thumbnailImage,
Kode lerroa: .thumbnail:hover > .thumbnailSelectionRing > .thumbnailImage {
Kode lerroa:   opacity: .9;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: a:focus > .thumbnail > .thumbnailSelectionRing,
Kode lerroa: .thumbnail:hover > .thumbnailSelectionRing {
Kode lerroa:   background-color: hsla(0,0%,100%,.15);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.2) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.2);
Kode lerroa:   color: hsla(0,0%,100%,.9);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .thumbnail.selected > .thumbnailSelectionRing > .thumbnailImage {
Kode lerroa:   box-shadow: 0 0 0 1px hsla(0,0%,0%,.5);
Kode lerroa:   opacity: 1;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .thumbnail.selected > .thumbnailSelectionRing {
Kode lerroa:   background-color: hsla(0,0%,100%,.3);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.1) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.2);
Kode lerroa:   color: hsla(0,0%,100%,1);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #outlineView,
Kode lerroa: #attachmentsView {
Kode lerroa:   position: absolute;
Kode lerroa:   width: 192px;
Kode lerroa:   top: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   overflow: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa:   -webkit-user-select: none;
Kode lerroa:   -moz-user-select: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #outlineView {
Kode lerroa:   padding: 4px 4px 0;
Kode lerroa: }
Kode lerroa: #attachmentsView {
Kode lerroa:   padding: 3px 4px 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .outlineWithDeepNesting > .outlineItem,
Kode lerroa: html[dir='ltr'] .outlineItem > .outlineItems {
Kode lerroa:   margin-left: 20px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='rtl'] .outlineWithDeepNesting > .outlineItem,
Kode lerroa: html[dir='rtl'] .outlineItem > .outlineItems {
Kode lerroa:   margin-right: 20px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .outlineItem > a,
Kode lerroa: .attachmentsItem > button {
Kode lerroa:   text-decoration: none;
Kode lerroa:   display: inline-block;
Kode lerroa:   min-width: 95%;
Kode lerroa:   min-width: calc(100% - 4px); /* Subtract the right padding (left, in RTL mode)
Kode lerroa:                                   of the container. */
Kode lerroa:   height: auto;
Kode lerroa:   margin-bottom: 1px;
Kode lerroa:   border-radius: 2px;
Kode lerroa:   color: hsla(0,0%,100%,.8);
Kode lerroa:   font-size: 13px;
Kode lerroa:   line-height: 15px;
Kode lerroa:   -moz-user-select: none;
Kode lerroa:   white-space: normal;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .attachmentsItem > button {
Kode lerroa:   border: 0 none;
Kode lerroa:   background: none;
Kode lerroa:   cursor: pointer;
Kode lerroa:   width: 100%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='ltr'] .outlineItem > a {
Kode lerroa:   padding: 2px 0 5px 4px;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .attachmentsItem > button {
Kode lerroa:   padding: 2px 0 3px 7px;
Kode lerroa:   text-align: left;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: html[dir='rtl'] .outlineItem > a {
Kode lerroa:   padding: 2px 4px 5px 0;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .attachmentsItem > button {
Kode lerroa:   padding: 2px 7px 3px 0;
Kode lerroa:   text-align: right;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .outlineItemToggler {
Kode lerroa:   position: relative;
Kode lerroa:   height: 0;
Kode lerroa:   width: 0;
Kode lerroa:   color: hsla(0,0%,100%,.5);
Kode lerroa: }
Kode lerroa: .outlineItemToggler::before {
Kode lerroa:   content: url(images/treeitem-expanded.png);
Kode lerroa:   display: inline-block;
Kode lerroa:   position: absolute;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .outlineItemToggler.outlineItemsHidden::before {
Kode lerroa:   content: url(images/treeitem-collapsed.png);
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .outlineItemToggler.outlineItemsHidden::before {
Kode lerroa:   content: url(images/treeitem-collapsed-rtl.png);
Kode lerroa: }
Kode lerroa: .outlineItemToggler.outlineItemsHidden ~ .outlineItems {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .outlineItemToggler {
Kode lerroa:   float: left;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .outlineItemToggler {
Kode lerroa:   float: right;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] .outlineItemToggler::before {
Kode lerroa:   right: 4px;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] .outlineItemToggler::before {
Kode lerroa:   left: 4px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .outlineItemToggler:hover,
Kode lerroa: .outlineItemToggler:hover + a,
Kode lerroa: .outlineItemToggler:hover ~ .outlineItems,
Kode lerroa: .outlineItem > a:hover,
Kode lerroa: .attachmentsItem > button:hover {
Kode lerroa:   background-color: hsla(0,0%,100%,.02);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.2) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.2);
Kode lerroa:   border-radius: 2px;
Kode lerroa:   color: hsla(0,0%,100%,.9);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .outlineItem.selected {
Kode lerroa:   background-color: hsla(0,0%,100%,.08);
Kode lerroa:   background-image: linear-gradient(hsla(0,0%,100%,.05), hsla(0,0%,100%,0));
Kode lerroa:   background-clip: padding-box;
Kode lerroa:   box-shadow: 0 1px 0 hsla(0,0%,100%,.05) inset,
Kode lerroa:               0 0 1px hsla(0,0%,100%,.1) inset,
Kode lerroa:               0 0 1px hsla(0,0%,0%,.2);
Kode lerroa:   color: hsla(0,0%,100%,1);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .noResults {
Kode lerroa:   font-size: 12px;
Kode lerroa:   color: hsla(0,0%,100%,.8);
Kode lerroa:   font-style: italic;
Kode lerroa:   cursor: default;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /* TODO: file FF bug to support ::-moz-selection:window-inactive
Kode lerroa:    so we can override the opaque grey background when the window is inactive;
Kode lerroa:    see https://bugzilla.mozilla.org/show_bug.cgi?id=706209 */
Kode lerroa: ::selection { background: rgba(0,0,255,0.3); }
Kode lerroa: ::-moz-selection { background: rgba(0,0,255,0.3); }
Kode lerroa: 
Kode lerroa: #errorWrapper {
Kode lerroa:   background: none repeat scroll 0 0 #FF5555;
Kode lerroa:   color: white;
Kode lerroa:   left: 0;
Kode lerroa:   position: absolute;
Kode lerroa:   right: 0;
Kode lerroa:   z-index: 1000;
Kode lerroa:   padding: 3px;
Kode lerroa:   font-size: 0.8em;
Kode lerroa: }
Kode lerroa: .loadingInProgress #errorWrapper {
Kode lerroa:   top: 37px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #errorMessageLeft {
Kode lerroa:   float: left;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #errorMessageRight {
Kode lerroa:   float: right;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #errorMoreInfo {
Kode lerroa:   background-color: #FFFFFF;
Kode lerroa:   color: black;
Kode lerroa:   padding: 3px;
Kode lerroa:   margin: 3px;
Kode lerroa:   width: 98%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .overlayButton {
Kode lerroa:   width: auto;
Kode lerroa:   margin: 3px 4px 2px 4px !important;
Kode lerroa:   padding: 2px 6px 3px 6px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #overlayContainer {
Kode lerroa:   display: table;
Kode lerroa:   position: absolute;
Kode lerroa:   width: 100%;
Kode lerroa:   height: 100%;
Kode lerroa:   background-color: hsla(0,0%,0%,.2);
Kode lerroa:   z-index: 40000;
Kode lerroa: }
Kode lerroa: #overlayContainer > * {
Kode lerroa:   overflow: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #overlayContainer > .container {
Kode lerroa:   display: table-cell;
Kode lerroa:   vertical-align: middle;
Kode lerroa:   text-align: center;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #overlayContainer > .container > .dialog {
Kode lerroa:   display: inline-block;
Kode lerroa:   padding: 15px;
Kode lerroa:   border-spacing: 4px;
Kode lerroa:   color: hsl(0,0%,85%);
Kode lerroa:   font-size: 12px;
Kode lerroa:   line-height: 14px;
Kode lerroa:   background-color: #474747; /* fallback */
Kode lerroa:   background-image: url(images/texture.png),
Kode lerroa:                     linear-gradient(hsla(0,0%,32%,.99), hsla(0,0%,27%,.95));
Kode lerroa:   box-shadow: inset 1px 0 0 hsla(0,0%,100%,.08),
Kode lerroa:               inset 0 1px 1px hsla(0,0%,0%,.15),
Kode lerroa:               inset 0 -1px 0 hsla(0,0%,100%,.05),
Kode lerroa:               0 1px 0 hsla(0,0%,0%,.15),
Kode lerroa:               0 1px 1px hsla(0,0%,0%,.1);
Kode lerroa:   border: 1px solid hsla(0,0%,0%,.5);
Kode lerroa:   border-radius: 4px;
Kode lerroa:   box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dialog > .row {
Kode lerroa:   display: table-row;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dialog > .row > * {
Kode lerroa:   display: table-cell;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dialog .toolbarField {
Kode lerroa:   margin: 5px 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dialog .separator {
Kode lerroa:   display: block;
Kode lerroa:   margin: 4px 0 4px 0;
Kode lerroa:   height: 1px;
Kode lerroa:   width: 100%;
Kode lerroa:   background-color: hsla(0,0%,0%,.5);
Kode lerroa:   box-shadow: 0 0 0 1px hsla(0,0%,100%,.08);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dialog .buttonRow {
Kode lerroa:   text-align: center;
Kode lerroa:   vertical-align: middle;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .dialog :link {
Kode lerroa:   color: white;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #passwordOverlay > .dialog {
Kode lerroa:   text-align: center;
Kode lerroa: }
Kode lerroa: #passwordOverlay .toolbarField {
Kode lerroa:   width: 200px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #documentPropertiesOverlay > .dialog {
Kode lerroa:   text-align: left;
Kode lerroa: }
Kode lerroa: #documentPropertiesOverlay .row > * {
Kode lerroa:   min-width: 100px;
Kode lerroa: }
Kode lerroa: html[dir='ltr'] #documentPropertiesOverlay .row > * {
Kode lerroa:   text-align: left;
Kode lerroa: }
Kode lerroa: html[dir='rtl'] #documentPropertiesOverlay .row > * {
Kode lerroa:   text-align: right;
Kode lerroa: }
Kode lerroa: #documentPropertiesOverlay .row > span {
Kode lerroa:   width: 125px;
Kode lerroa:   word-wrap: break-word;
Kode lerroa: }
Kode lerroa: #documentPropertiesOverlay .row > p {
Kode lerroa:   max-width: 225px;
Kode lerroa:   word-wrap: break-word;
Kode lerroa: }
Kode lerroa: #documentPropertiesOverlay .buttonRow {
Kode lerroa:   margin-top: 10px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .clearBoth {
Kode lerroa:   clear: both;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .fileInput {
Kode lerroa:   background: white;
Kode lerroa:   color: black;
Kode lerroa:   margin-top: 5px;
Kode lerroa:   visibility: hidden;
Kode lerroa:   position: fixed;
Kode lerroa:   right: 0;
Kode lerroa:   top: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #PDFBug {
Kode lerroa:   background: none repeat scroll 0 0 white;
Kode lerroa:   border: 1px solid #666666;
Kode lerroa:   position: fixed;
Kode lerroa:   top: 32px;
Kode lerroa:   right: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   font-size: 10px;
Kode lerroa:   padding: 0;
Kode lerroa:   width: 300px;
Kode lerroa: }
Kode lerroa: #PDFBug .controls {
Kode lerroa:     background:#EEEEEE;
Kode lerroa:     border-bottom: 1px solid #666666;
Kode lerroa:     padding: 3px;
Kode lerroa: }
Kode lerroa: #PDFBug .panels {
Kode lerroa:   bottom: 0;
Kode lerroa:   left: 0;
Kode lerroa:   overflow: auto;
Kode lerroa:   -webkit-overflow-scrolling: touch;
Kode lerroa:   position: absolute;
Kode lerroa:   right: 0;
Kode lerroa:   top: 27px;
Kode lerroa: }
Kode lerroa: #PDFBug button.active {
Kode lerroa:   font-weight: bold;
Kode lerroa: }
Kode lerroa: .debuggerShowText {
Kode lerroa:   background: none repeat scroll 0 0 yellow;
Kode lerroa:   color: blue;
Kode lerroa: }
Kode lerroa: .debuggerHideText:hover {
Kode lerroa:   background: none repeat scroll 0 0 yellow;
Kode lerroa: }
Kode lerroa: #PDFBug .stats {
Kode lerroa:   font-family: courier;
Kode lerroa:   font-size: 10px;
Kode lerroa:   white-space: pre;
Kode lerroa: }
Kode lerroa: #PDFBug .stats .title {
Kode lerroa:     font-weight: bold;
Kode lerroa: }
Kode lerroa: #PDFBug table {
Kode lerroa:   font-size: 10px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewer.textLayer-visible .textLayer {
Kode lerroa:   opacity: 1.0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewer.textLayer-visible .canvasWrapper {
Kode lerroa:   background-color: rgb(128,255,128);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewer.textLayer-visible .canvasWrapper canvas {
Kode lerroa:   mix-blend-mode: screen;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewer.textLayer-visible .textLayer > div {
Kode lerroa:   background-color: rgba(255, 255, 0, 0.1);
Kode lerroa:   color: black;
Kode lerroa:   border: solid 1px rgba(255, 0, 0, 0.5);
Kode lerroa:   -webkit-box-sizing: border-box;
Kode lerroa:   -moz-box-sizing: border-box;
Kode lerroa:   box-sizing: border-box;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewer.textLayer-hover .textLayer > div:hover {
Kode lerroa:   background-color: white;
Kode lerroa:   color: black;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #viewer.textLayer-shadow .textLayer > div {
Kode lerroa:   background-color: rgba(255,255,255, .6);
Kode lerroa:   color: black;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .grab-to-pan-grab {
Kode lerroa:   cursor: url("images/grab.cur"), move !important;
Kode lerroa:   cursor: -webkit-grab !important;
Kode lerroa:   cursor: -moz-grab !important;
Kode lerroa:   cursor: grab !important;
Kode lerroa: }
Kode lerroa: .grab-to-pan-grab *:not(input):not(textarea):not(button):not(select):not(:link) {
Kode lerroa:   cursor: inherit !important;
Kode lerroa: }
Kode lerroa: .grab-to-pan-grab:active,
Kode lerroa: .grab-to-pan-grabbing {
Kode lerroa:   cursor: url("images/grabbing.cur"), move !important;
Kode lerroa:   cursor: -webkit-grabbing !important;
Kode lerroa:   cursor: -moz-grabbing !important;
Kode lerroa:   cursor: grabbing !important;
Kode lerroa: 
Kode lerroa:   position: fixed;
Kode lerroa:   background: transparent;
Kode lerroa:   display: block;
Kode lerroa:   top: 0;
Kode lerroa:   left: 0;
Kode lerroa:   right: 0;
Kode lerroa:   bottom: 0;
Kode lerroa:   overflow: hidden;
Kode lerroa:   z-index: 50000; /* should be higher than anything else in PDF.js! */
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @page {
Kode lerroa:   margin: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #printContainer {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media screen and (min-resolution: 2dppx) {
Kode lerroa:   /* Rules for Retina screens */
Kode lerroa:   .toolbarButton::before {
Kode lerroa:     -webkit-transform: scale(0.5);
Kode lerroa:     transform: scale(0.5);
Kode lerroa:     top: -5px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton::before {
Kode lerroa:     -webkit-transform: scale(0.5);
Kode lerroa:     transform: scale(0.5);
Kode lerroa:     top: -4px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton::before,
Kode lerroa:   html[dir='rtl'] .toolbarButton::before {
Kode lerroa:     left: -1px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .secondaryToolbarButton::before {
Kode lerroa:     left: -2px;
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .secondaryToolbarButton::before {
Kode lerroa:     left: 186px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarField.pageNumber.visiblePageIsLoading,
Kode lerroa:   #findInput[data-status="pending"] {
Kode lerroa:     background-image: url(images/loading-small@2x.png);
Kode lerroa:     background-size: 16px 17px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .dropdownToolbarButton {
Kode lerroa:     background: url(images/toolbarButton-menuArrows@2x.png) no-repeat;
Kode lerroa:     background-size: 7px 16px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton#sidebarToggle::before {
Kode lerroa:     content: url(images/toolbarButton-sidebarToggle@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .toolbarButton#sidebarToggle::before {
Kode lerroa:     content: url(images/toolbarButton-sidebarToggle-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton#secondaryToolbarToggle::before {
Kode lerroa:     content: url(images/toolbarButton-secondaryToolbarToggle@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .toolbarButton#secondaryToolbarToggle::before {
Kode lerroa:     content: url(images/toolbarButton-secondaryToolbarToggle-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton.findPrevious::before {
Kode lerroa:     content: url(images/findbarButton-previous@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .toolbarButton.findPrevious::before {
Kode lerroa:     content: url(images/findbarButton-previous-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton.findNext::before {
Kode lerroa:     content: url(images/findbarButton-next@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .toolbarButton.findNext::before {
Kode lerroa:     content: url(images/findbarButton-next-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton.pageUp::before {
Kode lerroa:     content: url(images/toolbarButton-pageUp@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .toolbarButton.pageUp::before {
Kode lerroa:     content: url(images/toolbarButton-pageUp-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] .toolbarButton.pageDown::before {
Kode lerroa:     content: url(images/toolbarButton-pageDown@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .toolbarButton.pageDown::before {
Kode lerroa:     content: url(images/toolbarButton-pageDown-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.zoomIn::before {
Kode lerroa:     content: url(images/toolbarButton-zoomIn@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.zoomOut::before {
Kode lerroa:     content: url(images/toolbarButton-zoomOut@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.presentationMode::before,
Kode lerroa:   .secondaryToolbarButton.presentationMode::before {
Kode lerroa:     content: url(images/toolbarButton-presentationMode@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.print::before,
Kode lerroa:   .secondaryToolbarButton.print::before {
Kode lerroa:     content: url(images/toolbarButton-print@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.openFile::before,
Kode lerroa:   .secondaryToolbarButton.openFile::before {
Kode lerroa:     content: url(images/toolbarButton-openFile@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.download::before,
Kode lerroa:   .secondaryToolbarButton.download::before {
Kode lerroa:     content: url(images/toolbarButton-download@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .toolbarButton.bookmark::before,
Kode lerroa:   .secondaryToolbarButton.bookmark::before {
Kode lerroa:     content: url(images/toolbarButton-bookmark@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   #viewThumbnail.toolbarButton::before {
Kode lerroa:     content: url(images/toolbarButton-viewThumbnail@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir="ltr"] #viewOutline.toolbarButton::before {
Kode lerroa:     content: url(images/toolbarButton-viewOutline@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir="rtl"] #viewOutline.toolbarButton::before {
Kode lerroa:     content: url(images/toolbarButton-viewOutline-rtl@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   #viewAttachments.toolbarButton::before {
Kode lerroa:     content: url(images/toolbarButton-viewAttachments@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   #viewFind.toolbarButton::before {
Kode lerroa:     content: url(images/toolbarButton-search@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.firstPage::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-firstPage@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.lastPage::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-lastPage@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.rotateCcw::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-rotateCcw@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.rotateCw::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-rotateCw@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.selectTool::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-selectTool@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.handTool::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-handTool@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .secondaryToolbarButton.documentProperties::before {
Kode lerroa:     content: url(images/secondaryToolbarButton-documentProperties@2x.png);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .outlineItemToggler::before {
Kode lerroa:     -webkit-transform: scale(0.5);
Kode lerroa:     transform: scale(0.5);
Kode lerroa:     top: -1px;
Kode lerroa:     content: url(images/treeitem-expanded@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='ltr'] .outlineItemToggler.outlineItemsHidden::before {
Kode lerroa:     content: url(images/treeitem-collapsed@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .outlineItemToggler.outlineItemsHidden::before {
Kode lerroa:     content: url(images/treeitem-collapsed-rtl@2x.png);
Kode lerroa:   }
Kode lerroa:   html[dir='ltr'] .outlineItemToggler::before {
Kode lerroa:     right: 0;
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .outlineItemToggler::before {
Kode lerroa:     left: 0;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media print {
Kode lerroa:   /* General rules for printing. */
Kode lerroa:   body {
Kode lerroa:     background: transparent none;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /* Rules for browsers that don't support mozPrintCallback. */
Kode lerroa:   #sidebarContainer, #secondaryToolbar, .toolbar, #loadingBox, #errorWrapper, .textLayer {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   #viewerContainer {
Kode lerroa:     overflow: visible;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   #mainContainer, #viewerContainer, .page, .page canvas {
Kode lerroa:     position: static;
Kode lerroa:     padding: 0;
Kode lerroa:     margin: 0;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .page {
Kode lerroa:     float: left;
Kode lerroa:     display: none;
Kode lerroa:     border: none;
Kode lerroa:     box-shadow: none;
Kode lerroa:     background-clip: content-box;
Kode lerroa:     background-color: white;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .page[data-loaded] {
Kode lerroa:     display: block;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   .fileInput {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /* Rules for browsers that support PDF.js printing */
Kode lerroa:   body[data-pdfjsprinting] #outerContainer {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   body[data-pdfjsprinting] #printContainer {
Kode lerroa:     display: block;
Kode lerroa:   }
Kode lerroa:   #printContainer {
Kode lerroa:     height: 100%;
Kode lerroa:   }
Kode lerroa:   /* wrapper around (scaled) print canvas elements */
Kode lerroa:   #printContainer > div {
Kode lerroa:     position: relative;
Kode lerroa:     top: 0;
Kode lerroa:     left: 0;
Kode lerroa:     width: 1px;
Kode lerroa:     height: 1px;
Kode lerroa:     overflow: visible;
Kode lerroa:     page-break-after: always;
Kode lerroa:     page-break-inside: avoid;
Kode lerroa:   }
Kode lerroa:   #printContainer canvas,
Kode lerroa:   #printContainer img {
Kode lerroa:     display: block;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .visibleLargeView,
Kode lerroa: .visibleMediumView,
Kode lerroa: .visibleSmallView {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 1040px) {
Kode lerroa:   #outerContainer.sidebarMoving #toolbarViewerMiddle,
Kode lerroa:   #outerContainer.sidebarOpen #toolbarViewerMiddle {
Kode lerroa:     display: table;
Kode lerroa:     margin: auto;
Kode lerroa:     left: auto;
Kode lerroa:     position: inherit;
Kode lerroa:     transform: none;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 980px) {
Kode lerroa:   .sidebarMoving .hiddenLargeView,
Kode lerroa:   .sidebarOpen .hiddenLargeView {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   .sidebarMoving .visibleLargeView,
Kode lerroa:   .sidebarOpen .visibleLargeView {
Kode lerroa:     display: inherit;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 900px) {
Kode lerroa:   #toolbarViewerMiddle {
Kode lerroa:     display: table;
Kode lerroa:     margin: auto;
Kode lerroa:     left: auto;
Kode lerroa:     position: inherit;
Kode lerroa:     transform: none;
Kode lerroa:   }
Kode lerroa:   .sidebarMoving .hiddenMediumView,
Kode lerroa:   .sidebarOpen .hiddenMediumView {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   .sidebarMoving .visibleMediumView,
Kode lerroa:   .sidebarOpen .visibleMediumView {
Kode lerroa:     display: inherit;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 840px) {
Kode lerroa:   #sidebarContainer {
Kode lerroa:     top: 32px;
Kode lerroa:     z-index: 100;
Kode lerroa:   }
Kode lerroa:   .loadingInProgress #sidebarContainer {
Kode lerroa:     top: 37px;
Kode lerroa:   }
Kode lerroa:   #sidebarContent {
Kode lerroa:     top: 32px;
Kode lerroa:     background-color: hsla(0,0%,0%,.7);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   html[dir='ltr'] #outerContainer.sidebarOpen > #mainContainer {
Kode lerroa:     left: 0px;
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] #outerContainer.sidebarOpen > #mainContainer {
Kode lerroa:     right: 0px;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   #outerContainer .hiddenLargeView,
Kode lerroa:   #outerContainer .hiddenMediumView {
Kode lerroa:     display: inherit;
Kode lerroa:   }
Kode lerroa:   #outerContainer .visibleLargeView,
Kode lerroa:   #outerContainer .visibleMediumView {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 770px) {
Kode lerroa:   #outerContainer .hiddenLargeView {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   #outerContainer .visibleLargeView {
Kode lerroa:     display: inherit;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 700px) {
Kode lerroa:   #outerContainer .hiddenMediumView {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   #outerContainer .visibleMediumView {
Kode lerroa:     display: inherit;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 640px) {
Kode lerroa:   .hiddenSmallView, .hiddenSmallView * {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa:   .visibleSmallView {
Kode lerroa:     display: inherit;
Kode lerroa:   }
Kode lerroa:   .toolbarButtonSpacer {
Kode lerroa:     width: 0;
Kode lerroa:   }
Kode lerroa:   html[dir='ltr'] .findbar {
Kode lerroa:     left: 38px;
Kode lerroa:   }
Kode lerroa:   html[dir='rtl'] .findbar {
Kode lerroa:     right: 38px;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: @media all and (max-width: 535px) {
Kode lerroa:   #scaleSelectContainer {
Kode lerroa:     display: none;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: <!DOCTYPE html>
Kode lerroa: <!--
Kode lerroa: Copyright 2012 Mozilla Foundation
Kode lerroa: 
Kode lerroa: Licensed under the Apache License, Version 2.0 (the "License");
Kode lerroa: you may not use this file except in compliance with the License.
Kode lerroa: You may obtain a copy of the License at
Kode lerroa: 
Kode lerroa:     http://www.apache.org/licenses/LICENSE-2.0
Kode lerroa: 
Kode lerroa: Unless required by applicable law or agreed to in writing, software
Kode lerroa: distributed under the License is distributed on an "AS IS" BASIS,
Kode lerroa: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
Kode lerroa: See the License for the specific language governing permissions and
Kode lerroa: limitations under the License.
Kode lerroa: 
Kode lerroa: Adobe CMap resources are covered by their own copyright but the same license:
Kode lerroa: 
Kode lerroa:     Copyright 1990-2015 Adobe Systems Incorporated.
Kode lerroa: 
Kode lerroa: See https://github.com/adobe-type-tools/cmap-resources
Kode lerroa: -->
Kode lerroa: <html dir="ltr" mozdisallowselectionprint moznomarginboxes>
Kode lerroa:   <head>
Kode lerroa:     <meta charset="utf-8">
Kode lerroa:     <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
Kode lerroa:     <meta name="google" content="notranslate">
Kode lerroa:     <meta http-equiv="X-UA-Compatible" content="IE=edge">
Kode lerroa:     <title>PDF.js viewer</title>
Kode lerroa: 
Kode lerroa:     <link rel="stylesheet" href="viewer.css">
Kode lerroa: 
Kode lerroa: 
Kode lerroa: 
Kode lerroa: <!-- This snippet is used in production (included from viewer.html) -->
Kode lerroa: <link rel="resource" type="application/l10n" href="locale/locale.properties">
Kode lerroa: <script src="../build/pdf.js"></script>
Kode lerroa: 
Kode lerroa: 
Kode lerroa:     <script src="viewer.js"></script>
Kode lerroa: 
Kode lerroa:     <link rel="stylesheet" href="../../../styles/contentScript.css"/>
Kode lerroa:     <link rel="stylesheet" href="../../../styles/pdfjs.css"/>
Kode lerroa: 
Kode lerroa:   </head>
Kode lerroa: 
Kode lerroa:   <body tabindex="1" class="loadingInProgress">
Kode lerroa:     <div id="outerContainer">
Kode lerroa: 
Kode lerroa:       <div id="sidebarContainer">
Kode lerroa:         <div id="toolbarSidebar">
Kode lerroa:           <div class="splitToolbarButton">
Kode lerroa:             <button id="viewThumbnail" class="toolbarButton" title="Show Thumbnails" tabindex="2" data-l10n-id="thumbs">
Kode lerroa:                <span data-l10n-id="thumbs_label">Thumbnails</span>
Kode lerroa:             </button>
Kode lerroa:             <button id="viewOutline" class="toolbarButton" title="Show Document Outline (double-click to expand/collapse all items)" tabindex="3" data-l10n-id="document_outline">
Kode lerroa:                <span data-l10n-id="document_outline_label">Document Outline</span>
Kode lerroa:             </button>
Kode lerroa:             <button id="viewAttachments" class="toolbarButton" title="Show Attachments" tabindex="4" data-l10n-id="attachments">
Kode lerroa:                <span data-l10n-id="attachments_label">Attachments</span>
Kode lerroa:             </button>
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa:         <div id="sidebarContent">
Kode lerroa:           <div id="thumbnailView">
Kode lerroa:           </div>
Kode lerroa:           <div id="outlineView" class="hidden">
Kode lerroa:           </div>
Kode lerroa:           <div id="attachmentsView" class="hidden">
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa:       </div>  <!-- sidebarContainer -->
Kode lerroa: 
Kode lerroa:       <div id="mainContainer">
Kode lerroa:         <div class="findbar hidden doorHanger" id="findbar">
Kode lerroa:           <div id="findbarInputContainer">
Kode lerroa:             <input id="findInput" class="toolbarField" title="Find" placeholder="Find in document" tabindex="91" data-l10n-id="find_input">
Kode lerroa:             <div class="splitToolbarButton">
Kode lerroa:               <button id="findPrevious" class="toolbarButton findPrevious" title="Find the previous occurrence of the phrase" tabindex="92" data-l10n-id="find_previous">
Kode lerroa:                 <span data-l10n-id="find_previous_label">Previous</span>
Kode lerroa:               </button>
Kode lerroa:               <div class="splitToolbarButtonSeparator"></div>
Kode lerroa:               <button id="findNext" class="toolbarButton findNext" title="Find the next occurrence of the phrase" tabindex="93" data-l10n-id="find_next">
Kode lerroa:                 <span data-l10n-id="find_next_label">Next</span>
Kode lerroa:               </button>
Kode lerroa:             </div>
Kode lerroa:           </div>
Kode lerroa: 
Kode lerroa:           <div id="findbarOptionsContainer">
Kode lerroa:             <input type="checkbox" id="findHighlightAll" class="toolbarField" tabindex="94">
Kode lerroa:             <label for="findHighlightAll" class="toolbarLabel" data-l10n-id="find_highlight">Highlight all</label>
Kode lerroa:             <input type="checkbox" id="findMatchCase" class="toolbarField" tabindex="95">
Kode lerroa:             <label for="findMatchCase" class="toolbarLabel" data-l10n-id="find_match_case_label">Match case</label>
Kode lerroa:             <span id="findResultsCount" class="toolbarLabel hidden"></span>
Kode lerroa:           </div>
Kode lerroa: 
Kode lerroa:           <div id="findbarMessageContainer">
Kode lerroa:             <span id="findMsg" class="toolbarLabel"></span>
Kode lerroa:           </div>
Kode lerroa:         </div>  <!-- findbar -->
Kode lerroa: 
Kode lerroa:         <div id="secondaryToolbar" class="secondaryToolbar hidden doorHangerRight">
Kode lerroa:           <div id="secondaryToolbarButtonContainer">
Kode lerroa:             <button id="secondaryPresentationMode" class="secondaryToolbarButton presentationMode visibleLargeView" title="Switch to Presentation Mode" tabindex="51" data-l10n-id="presentation_mode">
Kode lerroa:               <span data-l10n-id="presentation_mode_label">Presentation Mode</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <button id="secondaryOpenFile" class="secondaryToolbarButton openFile visibleLargeView" title="Open File" tabindex="52" data-l10n-id="open_file">
Kode lerroa:               <span data-l10n-id="open_file_label">Open</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <button id="secondaryPrint" class="secondaryToolbarButton print visibleMediumView" title="Print" tabindex="53" data-l10n-id="print">
Kode lerroa:               <span data-l10n-id="print_label">Print</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <button id="secondaryDownload" class="secondaryToolbarButton download visibleMediumView" title="Download" tabindex="54" data-l10n-id="download">
Kode lerroa:               <span data-l10n-id="download_label">Download</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <a href="#" id="secondaryViewBookmark" class="secondaryToolbarButton bookmark visibleSmallView" title="Current view (copy or open in new window)" tabindex="55" data-l10n-id="bookmark">
Kode lerroa:               <span data-l10n-id="bookmark_label">Current View</span>
Kode lerroa:             </a>
Kode lerroa: 
Kode lerroa:             <div class="horizontalToolbarSeparator visibleLargeView"></div>
Kode lerroa: 
Kode lerroa:             <button id="firstPage" class="secondaryToolbarButton firstPage" title="Go to First Page" tabindex="56" data-l10n-id="first_page">
Kode lerroa:               <span data-l10n-id="first_page_label">Go to First Page</span>
Kode lerroa:             </button>
Kode lerroa:             <button id="lastPage" class="secondaryToolbarButton lastPage" title="Go to Last Page" tabindex="57" data-l10n-id="last_page">
Kode lerroa:               <span data-l10n-id="last_page_label">Go to Last Page</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <div class="horizontalToolbarSeparator"></div>
Kode lerroa: 
Kode lerroa:             <button id="pageRotateCw" class="secondaryToolbarButton rotateCw" title="Rotate Clockwise" tabindex="58" data-l10n-id="page_rotate_cw">
Kode lerroa:               <span data-l10n-id="page_rotate_cw_label">Rotate Clockwise</span>
Kode lerroa:             </button>
Kode lerroa:             <button id="pageRotateCcw" class="secondaryToolbarButton rotateCcw" title="Rotate Counterclockwise" tabindex="59" data-l10n-id="page_rotate_ccw">
Kode lerroa:               <span data-l10n-id="page_rotate_ccw_label">Rotate Counterclockwise</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <div class="horizontalToolbarSeparator"></div>
Kode lerroa: 
Kode lerroa:             <button id="cursorSelectTool" class="secondaryToolbarButton selectTool" title="Enable Text Selection Tool" tabindex="60" data-l10n-id="cursor_text_select_tool">
Kode lerroa:               <span data-l10n-id="cursor_text_select_tool_label">Text Selection Tool</span>
Kode lerroa:             </button>
Kode lerroa:             <button id="cursorHandTool" class="secondaryToolbarButton handTool" title="Enable Hand Tool" tabindex="61" data-l10n-id="cursor_hand_tool">
Kode lerroa:               <span data-l10n-id="cursor_hand_tool_label">Hand Tool</span>
Kode lerroa:             </button>
Kode lerroa: 
Kode lerroa:             <div class="horizontalToolbarSeparator"></div>
Kode lerroa: 
Kode lerroa:             <button id="documentProperties" class="secondaryToolbarButton documentProperties" title="Document Properties" tabindex="62" data-l10n-id="document_properties">
Kode lerroa:               <span data-l10n-id="document_properties_label">Document Properties</span>
Kode lerroa:             </button>
Kode lerroa:           </div>
Kode lerroa:         </div>  <!-- secondaryToolbar -->
Kode lerroa: 
Kode lerroa:         <div class="toolbar">
Kode lerroa:           <div id="toolbarContainer">
Kode lerroa:             <div id="toolbarViewer">
Kode lerroa:               <div id="toolbarViewerLeft">
Kode lerroa:                 <button id="sidebarToggle" class="toolbarButton" title="Toggle Sidebar" tabindex="11" data-l10n-id="toggle_sidebar">
Kode lerroa:                   <span data-l10n-id="toggle_sidebar_label">Toggle Sidebar</span>
Kode lerroa:                 </button>
Kode lerroa:                 <div class="toolbarButtonSpacer"></div>
Kode lerroa:                 <button id="viewFind" class="toolbarButton" title="Find in Document" tabindex="12" data-l10n-id="findbar">
Kode lerroa:                   <span data-l10n-id="findbar_label">Find</span>
Kode lerroa:                 </button>
Kode lerroa:                 <div class="splitToolbarButton hiddenSmallView">
Kode lerroa:                   <button class="toolbarButton pageUp" title="Previous Page" id="previous" tabindex="13" data-l10n-id="previous">
Kode lerroa:                     <span data-l10n-id="previous_label">Previous</span>
Kode lerroa:                   </button>
Kode lerroa:                   <div class="splitToolbarButtonSeparator"></div>
Kode lerroa:                   <button class="toolbarButton pageDown" title="Next Page" id="next" tabindex="14" data-l10n-id="next">
Kode lerroa:                     <span data-l10n-id="next_label">Next</span>
Kode lerroa:                   </button>
Kode lerroa:                 </div>
Kode lerroa:                 <input type="number" id="pageNumber" class="toolbarField pageNumber" title="Page" value="1" size="4" min="1" tabindex="15" data-l10n-id="page">
Kode lerroa:                 <span id="numPages" class="toolbarLabel"></span>
Kode lerroa:               </div>
Kode lerroa:               <div id="toolbarViewerRight">
Kode lerroa:                 <button id="presentationMode" class="toolbarButton presentationMode hiddenLargeView" title="Switch to Presentation Mode" tabindex="31" data-l10n-id="presentation_mode">
Kode lerroa:                   <span data-l10n-id="presentation_mode_label">Presentation Mode</span>
Kode lerroa:                 </button>
Kode lerroa: 
Kode lerroa:                 <button id="openFile" class="toolbarButton openFile hiddenLargeView" title="Open File" tabindex="32" data-l10n-id="open_file">
Kode lerroa:                   <span data-l10n-id="open_file_label">Open</span>
Kode lerroa:                 </button>
Kode lerroa: 
Kode lerroa:                 <button id="print" class="toolbarButton print hiddenMediumView" title="Print" tabindex="33" data-l10n-id="print">
Kode lerroa:                   <span data-l10n-id="print_label">Print</span>
Kode lerroa:                 </button>
Kode lerroa: 
Kode lerroa:                 <button id="download" class="toolbarButton download hiddenMediumView" title="Download" tabindex="34" data-l10n-id="download">
Kode lerroa:                   <span data-l10n-id="download_label">Download</span>
Kode lerroa:                 </button>
Kode lerroa:                 <a href="#" id="viewBookmark" class="toolbarButton bookmark hiddenSmallView" title="Current view (copy or open in new window)" tabindex="35" data-l10n-id="bookmark">
Kode lerroa:                   <span data-l10n-id="bookmark_label">Current View</span>
Kode lerroa:                 </a>
Kode lerroa: 
Kode lerroa:                 <div class="verticalToolbarSeparator hiddenSmallView"></div>
Kode lerroa: 
Kode lerroa:                 <button id="secondaryToolbarToggle" class="toolbarButton" title="Tools" tabindex="36" data-l10n-id="tools">
Kode lerroa:                   <span data-l10n-id="tools_label">Tools</span>
Kode lerroa:                 </button>
Kode lerroa:               </div>
Kode lerroa:               <div id="toolbarViewerMiddle">
Kode lerroa:                 <div class="splitToolbarButton">
Kode lerroa:                   <button id="zoomOut" class="toolbarButton zoomOut" title="Zoom Out" tabindex="21" data-l10n-id="zoom_out">
Kode lerroa:                     <span data-l10n-id="zoom_out_label">Zoom Out</span>
Kode lerroa:                   </button>
Kode lerroa:                   <div class="splitToolbarButtonSeparator"></div>
Kode lerroa:                   <button id="zoomIn" class="toolbarButton zoomIn" title="Zoom In" tabindex="22" data-l10n-id="zoom_in">
Kode lerroa:                     <span data-l10n-id="zoom_in_label">Zoom In</span>
Kode lerroa:                    </button>
Kode lerroa:                 </div>
Kode lerroa:                 <span id="scaleSelectContainer" class="dropdownToolbarButton">
Kode lerroa:                   <select id="scaleSelect" title="Zoom" tabindex="23" data-l10n-id="zoom">
Kode lerroa:                     <option id="pageAutoOption" title="" value="auto" selected="selected" data-l10n-id="page_scale_auto">Automatic Zoom</option>
Kode lerroa:                     <option id="pageActualOption" title="" value="page-actual" data-l10n-id="page_scale_actual">Actual Size</option>
Kode lerroa:                     <option id="pageFitOption" title="" value="page-fit" data-l10n-id="page_scale_fit">Page Fit</option>
Kode lerroa:                     <option id="pageWidthOption" title="" value="page-width" data-l10n-id="page_scale_width">Page Width</option>
Kode lerroa:                     <option id="customScaleOption" title="" value="custom" disabled="disabled" hidden="true"></option>
Kode lerroa:                     <option title="" value="0.5" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 50 }'>50%</option>
Kode lerroa:                     <option title="" value="0.75" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 75 }'>75%</option>
Kode lerroa:                     <option title="" value="1" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 100 }'>100%</option>
Kode lerroa:                     <option title="" value="1.25" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 125 }'>125%</option>
Kode lerroa:                     <option title="" value="1.5" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 150 }'>150%</option>
Kode lerroa:                     <option title="" value="2" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 200 }'>200%</option>
Kode lerroa:                     <option title="" value="3" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 300 }'>300%</option>
Kode lerroa:                     <option title="" value="4" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 400 }'>400%</option>
Kode lerroa:                   </select>
Kode lerroa:                 </span>
Kode lerroa:               </div>
Kode lerroa:             </div>
Kode lerroa:             <div id="loadingBar">
Kode lerroa:               <div class="progress">
Kode lerroa:                 <div class="glimmer">
Kode lerroa:                 </div>
Kode lerroa:               </div>
Kode lerroa:             </div>
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa: 
Kode lerroa:         <menu type="context" id="viewerContextMenu">
Kode lerroa:           <menuitem id="contextFirstPage" label="First Page"
Kode lerroa:                     data-l10n-id="first_page"></menuitem>
Kode lerroa:           <menuitem id="contextLastPage" label="Last Page"
Kode lerroa:                     data-l10n-id="last_page"></menuitem>
Kode lerroa:           <menuitem id="contextPageRotateCw" label="Rotate Clockwise"
Kode lerroa:                     data-l10n-id="page_rotate_cw"></menuitem>
Kode lerroa:           <menuitem id="contextPageRotateCcw" label="Rotate Counter-Clockwise"
Kode lerroa:                     data-l10n-id="page_rotate_ccw"></menuitem>
Kode lerroa:         </menu>
Kode lerroa: 
Kode lerroa:         <div id="viewerContainer" tabindex="0">
Kode lerroa:           <div id="viewer" class="pdfViewer"></div>
Kode lerroa:         </div>
Kode lerroa: 
Kode lerroa:         <div id="errorWrapper" hidden='true'>
Kode lerroa:           <div id="errorMessageLeft">
Kode lerroa:             <span id="errorMessage"></span>
Kode lerroa:             <button id="errorShowMore" data-l10n-id="error_more_info">
Kode lerroa:               More Information
Kode lerroa:             </button>
Kode lerroa:             <button id="errorShowLess" data-l10n-id="error_less_info" hidden='true'>
Kode lerroa:               Less Information
Kode lerroa:             </button>
Kode lerroa:           </div>
Kode lerroa:           <div id="errorMessageRight">
Kode lerroa:             <button id="errorClose" data-l10n-id="error_close">
Kode lerroa:               Close
Kode lerroa:             </button>
Kode lerroa:           </div>
Kode lerroa:           <div class="clearBoth"></div>
Kode lerroa:           <textarea id="errorMoreInfo" hidden='true' readonly="readonly"></textarea>
Kode lerroa:         </div>
Kode lerroa:       </div> <!-- mainContainer -->
Kode lerroa: 
Kode lerroa:       <div id="overlayContainer" class="hidden">
Kode lerroa:         <div id="passwordOverlay" class="container hidden">
Kode lerroa:           <div class="dialog">
Kode lerroa:             <div class="row">
Kode lerroa:               <p id="passwordText" data-l10n-id="password_label">Enter the password to open this PDF file:</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <input type="password" id="password" class="toolbarField">
Kode lerroa:             </div>
Kode lerroa:             <div class="buttonRow">
Kode lerroa:               <button id="passwordCancel" class="overlayButton"><span data-l10n-id="password_cancel">Cancel</span></button>
Kode lerroa:               <button id="passwordSubmit" class="overlayButton"><span data-l10n-id="password_ok">OK</span></button>
Kode lerroa:             </div>
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa:         <div id="documentPropertiesOverlay" class="container hidden">
Kode lerroa:           <div class="dialog">
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_file_name">File name:</span> <p id="fileNameField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_file_size">File size:</span> <p id="fileSizeField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="separator"></div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_title">Title:</span> <p id="titleField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_author">Author:</span> <p id="authorField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_subject">Subject:</span> <p id="subjectField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_keywords">Keywords:</span> <p id="keywordsField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_creation_date">Creation Date:</span> <p id="creationDateField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_modification_date">Modification Date:</span> <p id="modificationDateField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_creator">Creator:</span> <p id="creatorField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="separator"></div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_producer">PDF Producer:</span> <p id="producerField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_version">PDF Version:</span> <p id="versionField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="document_properties_page_count">Page Count:</span> <p id="pageCountField">-</p>
Kode lerroa:             </div>
Kode lerroa:             <div class="buttonRow">
Kode lerroa:               <button id="documentPropertiesClose" class="overlayButton"><span data-l10n-id="document_properties_close">Close</span></button>
Kode lerroa:             </div>
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa:         <div id="printServiceOverlay" class="container hidden">
Kode lerroa:           <div class="dialog">
Kode lerroa:             <div class="row">
Kode lerroa:               <span data-l10n-id="print_progress_message">Preparing document for printing</span>
Kode lerroa:             </div>
Kode lerroa:             <div class="row">
Kode lerroa:               <progress value="0" max="100"></progress>
Kode lerroa:               <span data-l10n-id="print_progress_percent" data-l10n-args='{ "progress": 0 }' class="relative-progress">0%</span>
Kode lerroa:             </div>
Kode lerroa:             <div class="buttonRow">
Kode lerroa:               <button id="printCancel" class="overlayButton"><span data-l10n-id="print_progress_close">Cancel</span></button>
Kode lerroa:             </div>
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa:       </div>  <!-- overlayContainer -->
Kode lerroa: 
Kode lerroa:     </div> <!-- outerContainer -->
Kode lerroa:     <div id="printContainer"></div>
Kode lerroa:     <script src="../../../scripts/contentScript.js"></script>
Kode lerroa:   </body>
Kode lerroa: </html>
Kode lerroa: 
Kode lerroa: /* Copyright 2017 Mozilla Foundation
Kode lerroa:  *
Kode lerroa:  * Licensed under the Apache License, Version 2.0 (the "License");
Kode lerroa:  * you may not use this file except in compliance with the License.
Kode lerroa:  * You may obtain a copy of the License at
Kode lerroa:  *
Kode lerroa:  *     http://www.apache.org/licenses/LICENSE-2.0
Kode lerroa:  *
Kode lerroa:  * Unless required by applicable law or agreed to in writing, software
Kode lerroa:  * distributed under the License is distributed on an "AS IS" BASIS,
Kode lerroa:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
Kode lerroa:  * See the License for the specific language governing permissions and
Kode lerroa:  * limitations under the License.
Kode lerroa:  */
Kode lerroa: 
Kode lerroa: /******/ (function(modules) { // webpackBootstrap
Kode lerroa: /******/ 	// The module cache
Kode lerroa: /******/ 	var installedModules = {};
Kode lerroa: /******/
Kode lerroa: /******/ 	// The require function
Kode lerroa: /******/ 	function __webpack_require__(moduleId) {
Kode lerroa: /******/
Kode lerroa: /******/ 		// Check if module is in cache
Kode lerroa: /******/ 		if(installedModules[moduleId]) {
Kode lerroa: /******/ 			return installedModules[moduleId].exports;
Kode lerroa: /******/ 		}
Kode lerroa: /******/ 		// Create a new module (and put it into the cache)
Kode lerroa: /******/ 		var module = installedModules[moduleId] = {
Kode lerroa: /******/ 			i: moduleId,
Kode lerroa: /******/ 			l: false,
Kode lerroa: /******/ 			exports: {}
Kode lerroa: /******/ 		};
Kode lerroa: /******/
Kode lerroa: /******/ 		// Execute the module function
Kode lerroa: /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
Kode lerroa: /******/
Kode lerroa: /******/ 		// Flag the module as loaded
Kode lerroa: /******/ 		module.l = true;
Kode lerroa: /******/
Kode lerroa: /******/ 		// Return the exports of the module
Kode lerroa: /******/ 		return module.exports;
Kode lerroa: /******/ 	}
Kode lerroa: /******/
Kode lerroa: /******/
Kode lerroa: /******/ 	// expose the modules object (__webpack_modules__)
Kode lerroa: /******/ 	__webpack_require__.m = modules;
Kode lerroa: /******/
Kode lerroa: /******/ 	// expose the module cache
Kode lerroa: /******/ 	__webpack_require__.c = installedModules;
Kode lerroa: /******/
Kode lerroa: /******/ 	// define getter function for harmony exports
Kode lerroa: /******/ 	__webpack_require__.d = function(exports, name, getter) {
Kode lerroa: /******/ 		if(!__webpack_require__.o(exports, name)) {
Kode lerroa: /******/ 			Object.defineProperty(exports, name, {
Kode lerroa: /******/ 				configurable: false,
Kode lerroa: /******/ 				enumerable: true,
Kode lerroa: /******/ 				get: getter
Kode lerroa: /******/ 			});
Kode lerroa: /******/ 		}
Kode lerroa: /******/ 	};
Kode lerroa: /******/
Kode lerroa: /******/ 	// getDefaultExport function for compatibility with non-harmony modules
Kode lerroa: /******/ 	__webpack_require__.n = function(module) {
Kode lerroa: /******/ 		var getter = module && module.__esModule ?
Kode lerroa: /******/ 			function getDefault() { return module['default']; } :
Kode lerroa: /******/ 			function getModuleExports() { return module; };
Kode lerroa: /******/ 		__webpack_require__.d(getter, 'a', getter);
Kode lerroa: /******/ 		return getter;
Kode lerroa: /******/ 	};
Kode lerroa: /******/
Kode lerroa: /******/ 	// Object.prototype.hasOwnProperty.call
Kode lerroa: /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
Kode lerroa: /******/
Kode lerroa: /******/ 	// __webpack_public_path__
Kode lerroa: /******/ 	__webpack_require__.p = "";
Kode lerroa: /******/
Kode lerroa: /******/ 	// Load entry module and return exports
Kode lerroa: /******/ 	return __webpack_require__(__webpack_require__.s = 8);
Kode lerroa: /******/ })
Kode lerroa: /************************************************************************/
Kode lerroa: /******/ ([
Kode lerroa: /* 0 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.waitOnEventOrTimeout = exports.WaitOnType = exports.localized = exports.animationStarted = exports.normalizeWheelEventDelta = exports.binarySearchFirstItem = exports.watchScroll = exports.scrollIntoView = exports.getOutputScale = exports.approximateFraction = exports.roundToDivide = exports.getVisibleElements = exports.parseQueryString = exports.noContextMenuHandler = exports.getPDFFileNameFromURL = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.mozL10n = exports.RendererType = exports.PresentationModeState = exports.cloneObj = exports.isValidRotation = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var CSS_UNITS = 96.0 / 72.0;
Kode lerroa: var DEFAULT_SCALE_VALUE = 'auto';
Kode lerroa: var DEFAULT_SCALE = 1.0;
Kode lerroa: var MIN_SCALE = 0.25;
Kode lerroa: var MAX_SCALE = 10.0;
Kode lerroa: var UNKNOWN_SCALE = 0;
Kode lerroa: var MAX_AUTO_SCALE = 1.25;
Kode lerroa: var SCROLLBAR_PADDING = 40;
Kode lerroa: var VERTICAL_PADDING = 5;
Kode lerroa: var PresentationModeState = {
Kode lerroa:   UNKNOWN: 0,
Kode lerroa:   NORMAL: 1,
Kode lerroa:   CHANGING: 2,
Kode lerroa:   FULLSCREEN: 3
Kode lerroa: };
Kode lerroa: var RendererType = {
Kode lerroa:   CANVAS: 'canvas',
Kode lerroa:   SVG: 'svg'
Kode lerroa: };
Kode lerroa: function formatL10nValue(text, args) {
Kode lerroa:   if (!args) {
Kode lerroa:     return text;
Kode lerroa:   }
Kode lerroa:   return text.replace(/\{\{\s*(\w+)\s*\}\}/g, function (all, name) {
Kode lerroa:     return name in args ? args[name] : '{{' + name + '}}';
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: var NullL10n = {
Kode lerroa:   get: function get(property, args, fallback) {
Kode lerroa:     return Promise.resolve(formatL10nValue(fallback, args));
Kode lerroa:   },
Kode lerroa:   translate: function translate(element) {
Kode lerroa:     return Promise.resolve();
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: _pdfjsLib.PDFJS.disableFullscreen = _pdfjsLib.PDFJS.disableFullscreen === undefined ? false : _pdfjsLib.PDFJS.disableFullscreen;
Kode lerroa: _pdfjsLib.PDFJS.useOnlyCssZoom = _pdfjsLib.PDFJS.useOnlyCssZoom === undefined ? false : _pdfjsLib.PDFJS.useOnlyCssZoom;
Kode lerroa: _pdfjsLib.PDFJS.maxCanvasPixels = _pdfjsLib.PDFJS.maxCanvasPixels === undefined ? 16777216 : _pdfjsLib.PDFJS.maxCanvasPixels;
Kode lerroa: _pdfjsLib.PDFJS.disableHistory = _pdfjsLib.PDFJS.disableHistory === undefined ? false : _pdfjsLib.PDFJS.disableHistory;
Kode lerroa: _pdfjsLib.PDFJS.disableTextLayer = _pdfjsLib.PDFJS.disableTextLayer === undefined ? false : _pdfjsLib.PDFJS.disableTextLayer;
Kode lerroa: _pdfjsLib.PDFJS.ignoreCurrentPositionOnZoom = _pdfjsLib.PDFJS.ignoreCurrentPositionOnZoom === undefined ? false : _pdfjsLib.PDFJS.ignoreCurrentPositionOnZoom;
Kode lerroa: {
Kode lerroa:   _pdfjsLib.PDFJS.locale = _pdfjsLib.PDFJS.locale === undefined && typeof navigator !== 'undefined' ? navigator.language : _pdfjsLib.PDFJS.locale;
Kode lerroa: }
Kode lerroa: function getOutputScale(ctx) {
Kode lerroa:   var devicePixelRatio = window.devicePixelRatio || 1;
Kode lerroa:   var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
Kode lerroa:   var pixelRatio = devicePixelRatio / backingStoreRatio;
Kode lerroa:   return {
Kode lerroa:     sx: pixelRatio,
Kode lerroa:     sy: pixelRatio,
Kode lerroa:     scaled: pixelRatio !== 1
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function scrollIntoView(element, spot) {
Kode lerroa:   var skipOverflowHiddenElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:   var parent = element.offsetParent;
Kode lerroa:   if (!parent) {
Kode lerroa:     console.error('offsetParent is not set -- cannot scroll');
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   var offsetY = element.offsetTop + element.clientTop;
Kode lerroa:   var offsetX = element.offsetLeft + element.clientLeft;
Kode lerroa:   while (parent.clientHeight === parent.scrollHeight || skipOverflowHiddenElements && getComputedStyle(parent).overflow === 'hidden') {
Kode lerroa:     if (parent.dataset._scaleY) {
Kode lerroa:       offsetY /= parent.dataset._scaleY;
Kode lerroa:       offsetX /= parent.dataset._scaleX;
Kode lerroa:     }
Kode lerroa:     offsetY += parent.offsetTop;
Kode lerroa:     offsetX += parent.offsetLeft;
Kode lerroa:     parent = parent.offsetParent;
Kode lerroa:     if (!parent) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (spot) {
Kode lerroa:     if (spot.top !== undefined) {
Kode lerroa:       offsetY += spot.top;
Kode lerroa:     }
Kode lerroa:     if (spot.left !== undefined) {
Kode lerroa:       offsetX += spot.left;
Kode lerroa:       parent.scrollLeft = offsetX;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   parent.scrollTop = offsetY;
Kode lerroa: }
Kode lerroa: function watchScroll(viewAreaElement, callback) {
Kode lerroa:   var debounceScroll = function debounceScroll(evt) {
Kode lerroa:     if (rAF) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
Kode lerroa:       rAF = null;
Kode lerroa:       var currentY = viewAreaElement.scrollTop;
Kode lerroa:       var lastY = state.lastY;
Kode lerroa:       if (currentY !== lastY) {
Kode lerroa:         state.down = currentY > lastY;
Kode lerroa:       }
Kode lerroa:       state.lastY = currentY;
Kode lerroa:       callback(state);
Kode lerroa:     });
Kode lerroa:   };
Kode lerroa:   var state = {
Kode lerroa:     down: true,
Kode lerroa:     lastY: viewAreaElement.scrollTop,
Kode lerroa:     _eventHandler: debounceScroll
Kode lerroa:   };
Kode lerroa:   var rAF = null;
Kode lerroa:   viewAreaElement.addEventListener('scroll', debounceScroll, true);
Kode lerroa:   return state;
Kode lerroa: }
Kode lerroa: function parseQueryString(query) {
Kode lerroa:   var parts = query.split('&');
Kode lerroa:   var params = Object.create(null);
Kode lerroa:   for (var i = 0, ii = parts.length; i < ii; ++i) {
Kode lerroa:     var param = parts[i].split('=');
Kode lerroa:     var key = param[0].toLowerCase();
Kode lerroa:     var value = param.length > 1 ? param[1] : null;
Kode lerroa:     params[decodeURIComponent(key)] = decodeURIComponent(value);
Kode lerroa:   }
Kode lerroa:   return params;
Kode lerroa: }
Kode lerroa: function binarySearchFirstItem(items, condition) {
Kode lerroa:   var minIndex = 0;
Kode lerroa:   var maxIndex = items.length - 1;
Kode lerroa:   if (items.length === 0 || !condition(items[maxIndex])) {
Kode lerroa:     return items.length;
Kode lerroa:   }
Kode lerroa:   if (condition(items[minIndex])) {
Kode lerroa:     return minIndex;
Kode lerroa:   }
Kode lerroa:   while (minIndex < maxIndex) {
Kode lerroa:     var currentIndex = minIndex + maxIndex >> 1;
Kode lerroa:     var currentItem = items[currentIndex];
Kode lerroa:     if (condition(currentItem)) {
Kode lerroa:       maxIndex = currentIndex;
Kode lerroa:     } else {
Kode lerroa:       minIndex = currentIndex + 1;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return minIndex;
Kode lerroa: }
Kode lerroa: function approximateFraction(x) {
Kode lerroa:   if (Math.floor(x) === x) {
Kode lerroa:     return [x, 1];
Kode lerroa:   }
Kode lerroa:   var xinv = 1 / x;
Kode lerroa:   var limit = 8;
Kode lerroa:   if (xinv > limit) {
Kode lerroa:     return [1, limit];
Kode lerroa:   } else if (Math.floor(xinv) === xinv) {
Kode lerroa:     return [1, xinv];
Kode lerroa:   }
Kode lerroa:   var x_ = x > 1 ? xinv : x;
Kode lerroa:   var a = 0,
Kode lerroa:       b = 1,
Kode lerroa:       c = 1,
Kode lerroa:       d = 1;
Kode lerroa:   while (true) {
Kode lerroa:     var p = a + c,
Kode lerroa:         q = b + d;
Kode lerroa:     if (q > limit) {
Kode lerroa:       break;
Kode lerroa:     }
Kode lerroa:     if (x_ <= p / q) {
Kode lerroa:       c = p;
Kode lerroa:       d = q;
Kode lerroa:     } else {
Kode lerroa:       a = p;
Kode lerroa:       b = q;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   var result = void 0;
Kode lerroa:   if (x_ - a / b < c / d - x_) {
Kode lerroa:     result = x_ === x ? [a, b] : [b, a];
Kode lerroa:   } else {
Kode lerroa:     result = x_ === x ? [c, d] : [d, c];
Kode lerroa:   }
Kode lerroa:   return result;
Kode lerroa: }
Kode lerroa: function roundToDivide(x, div) {
Kode lerroa:   var r = x % div;
Kode lerroa:   return r === 0 ? x : Math.round(x - r + div);
Kode lerroa: }
Kode lerroa: function getVisibleElements(scrollEl, views) {
Kode lerroa:   var sortByVisibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:   var top = scrollEl.scrollTop,
Kode lerroa:       bottom = top + scrollEl.clientHeight;
Kode lerroa:   var left = scrollEl.scrollLeft,
Kode lerroa:       right = left + scrollEl.clientWidth;
Kode lerroa:   function isElementBottomBelowViewTop(view) {
Kode lerroa:     var element = view.div;
Kode lerroa:     var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
Kode lerroa:     return elementBottom > top;
Kode lerroa:   }
Kode lerroa:   var visible = [],
Kode lerroa:       view = void 0,
Kode lerroa:       element = void 0;
Kode lerroa:   var currentHeight = void 0,
Kode lerroa:       viewHeight = void 0,
Kode lerroa:       hiddenHeight = void 0,
Kode lerroa:       percentHeight = void 0;
Kode lerroa:   var currentWidth = void 0,
Kode lerroa:       viewWidth = void 0;
Kode lerroa:   var firstVisibleElementInd = views.length === 0 ? 0 : binarySearchFirstItem(views, isElementBottomBelowViewTop);
Kode lerroa:   for (var i = firstVisibleElementInd, ii = views.length; i < ii; i++) {
Kode lerroa:     view = views[i];
Kode lerroa:     element = view.div;
Kode lerroa:     currentHeight = element.offsetTop + element.clientTop;
Kode lerroa:     viewHeight = element.clientHeight;
Kode lerroa:     if (currentHeight > bottom) {
Kode lerroa:       break;
Kode lerroa:     }
Kode lerroa:     currentWidth = element.offsetLeft + element.clientLeft;
Kode lerroa:     viewWidth = element.clientWidth;
Kode lerroa:     if (currentWidth + viewWidth < left || currentWidth > right) {
Kode lerroa:       continue;
Kode lerroa:     }
Kode lerroa:     hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, currentHeight + viewHeight - bottom);
Kode lerroa:     percentHeight = (viewHeight - hiddenHeight) * 100 / viewHeight | 0;
Kode lerroa:     visible.push({
Kode lerroa:       id: view.id,
Kode lerroa:       x: currentWidth,
Kode lerroa:       y: currentHeight,
Kode lerroa:       view: view,
Kode lerroa:       percent: percentHeight
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   var first = visible[0];
Kode lerroa:   var last = visible[visible.length - 1];
Kode lerroa:   if (sortByVisibility) {
Kode lerroa:     visible.sort(function (a, b) {
Kode lerroa:       var pc = a.percent - b.percent;
Kode lerroa:       if (Math.abs(pc) > 0.001) {
Kode lerroa:         return -pc;
Kode lerroa:       }
Kode lerroa:       return a.id - b.id;
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   return {
Kode lerroa:     first: first,
Kode lerroa:     last: last,
Kode lerroa:     views: visible
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function noContextMenuHandler(evt) {
Kode lerroa:   evt.preventDefault();
Kode lerroa: }
Kode lerroa: function isDataSchema(url) {
Kode lerroa:   var i = 0,
Kode lerroa:       ii = url.length;
Kode lerroa:   while (i < ii && url[i].trim() === '') {
Kode lerroa:     i++;
Kode lerroa:   }
Kode lerroa:   return url.substr(i, 5).toLowerCase() === 'data:';
Kode lerroa: }
Kode lerroa: function getPDFFileNameFromURL(url) {
Kode lerroa:   var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'document.pdf';
Kode lerroa: 
Kode lerroa:   if (isDataSchema(url)) {
Kode lerroa:     console.warn('getPDFFileNameFromURL: ' + 'ignoring "data:" URL for performance reasons.');
Kode lerroa:     return defaultFilename;
Kode lerroa:   }
Kode lerroa:   var reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
Kode lerroa:   var reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
Kode lerroa:   var splitURI = reURI.exec(url);
Kode lerroa:   var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
Kode lerroa:   if (suggestedFilename) {
Kode lerroa:     suggestedFilename = suggestedFilename[0];
Kode lerroa:     if (suggestedFilename.indexOf('%') !== -1) {
Kode lerroa:       try {
Kode lerroa:         suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
Kode lerroa:       } catch (ex) {}
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return suggestedFilename || defaultFilename;
Kode lerroa: }
Kode lerroa: function normalizeWheelEventDelta(evt) {
Kode lerroa:   var delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
Kode lerroa:   var angle = Math.atan2(evt.deltaY, evt.deltaX);
Kode lerroa:   if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
Kode lerroa:     delta = -delta;
Kode lerroa:   }
Kode lerroa:   var MOUSE_DOM_DELTA_PIXEL_MODE = 0;
Kode lerroa:   var MOUSE_DOM_DELTA_LINE_MODE = 1;
Kode lerroa:   var MOUSE_PIXELS_PER_LINE = 30;
Kode lerroa:   var MOUSE_LINES_PER_PAGE = 30;
Kode lerroa:   if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
Kode lerroa:     delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
Kode lerroa:   } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
Kode lerroa:     delta /= MOUSE_LINES_PER_PAGE;
Kode lerroa:   }
Kode lerroa:   return delta;
Kode lerroa: }
Kode lerroa: function isValidRotation(angle) {
Kode lerroa:   return Number.isInteger(angle) && angle % 90 === 0;
Kode lerroa: }
Kode lerroa: function cloneObj(obj) {
Kode lerroa:   var result = Object.create(null);
Kode lerroa:   for (var i in obj) {
Kode lerroa:     if (Object.prototype.hasOwnProperty.call(obj, i)) {
Kode lerroa:       result[i] = obj[i];
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return result;
Kode lerroa: }
Kode lerroa: var WaitOnType = {
Kode lerroa:   EVENT: 'event',
Kode lerroa:   TIMEOUT: 'timeout'
Kode lerroa: };
Kode lerroa: function waitOnEventOrTimeout(_ref) {
Kode lerroa:   var target = _ref.target,
Kode lerroa:       name = _ref.name,
Kode lerroa:       _ref$delay = _ref.delay,
Kode lerroa:       delay = _ref$delay === undefined ? 0 : _ref$delay;
Kode lerroa: 
Kode lerroa:   if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object' || !(name && typeof name === 'string') || !(Number.isInteger(delay) && delay >= 0)) {
Kode lerroa:     return Promise.reject(new Error('waitOnEventOrTimeout - invalid paramaters.'));
Kode lerroa:   }
Kode lerroa:   var capability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:   function handler(type) {
Kode lerroa:     if (target instanceof EventBus) {
Kode lerroa:       target.off(name, eventHandler);
Kode lerroa:     } else {
Kode lerroa:       target.removeEventListener(name, eventHandler);
Kode lerroa:     }
Kode lerroa:     if (timeout) {
Kode lerroa:       clearTimeout(timeout);
Kode lerroa:     }
Kode lerroa:     capability.resolve(type);
Kode lerroa:   }
Kode lerroa:   var eventHandler = handler.bind(null, WaitOnType.EVENT);
Kode lerroa:   if (target instanceof EventBus) {
Kode lerroa:     target.on(name, eventHandler);
Kode lerroa:   } else {
Kode lerroa:     target.addEventListener(name, eventHandler);
Kode lerroa:   }
Kode lerroa:   var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
Kode lerroa:   var timeout = setTimeout(timeoutHandler, delay);
Kode lerroa:   return capability.promise;
Kode lerroa: }
Kode lerroa: var animationStarted = new Promise(function (resolve) {
Kode lerroa:   window.requestAnimationFrame(resolve);
Kode lerroa: });
Kode lerroa: var mozL10n = void 0;
Kode lerroa: var localized = Promise.resolve();
Kode lerroa: 
Kode lerroa: var EventBus = function () {
Kode lerroa:   function EventBus() {
Kode lerroa:     _classCallCheck(this, EventBus);
Kode lerroa: 
Kode lerroa:     this._listeners = Object.create(null);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(EventBus, [{
Kode lerroa:     key: 'on',
Kode lerroa:     value: function on(eventName, listener) {
Kode lerroa:       var eventListeners = this._listeners[eventName];
Kode lerroa:       if (!eventListeners) {
Kode lerroa:         eventListeners = [];
Kode lerroa:         this._listeners[eventName] = eventListeners;
Kode lerroa:       }
Kode lerroa:       eventListeners.push(listener);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'off',
Kode lerroa:     value: function off(eventName, listener) {
Kode lerroa:       var eventListeners = this._listeners[eventName];
Kode lerroa:       var i = void 0;
Kode lerroa:       if (!eventListeners || (i = eventListeners.indexOf(listener)) < 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       eventListeners.splice(i, 1);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'dispatch',
Kode lerroa:     value: function dispatch(eventName) {
Kode lerroa:       var eventListeners = this._listeners[eventName];
Kode lerroa:       if (!eventListeners || eventListeners.length === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var args = Array.prototype.slice.call(arguments, 1);
Kode lerroa:       eventListeners.slice(0).forEach(function (listener) {
Kode lerroa:         listener.apply(null, args);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return EventBus;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: function clamp(v, min, max) {
Kode lerroa:   return Math.min(Math.max(v, min), max);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var ProgressBar = function () {
Kode lerroa:   function ProgressBar(id) {
Kode lerroa:     var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
Kode lerroa:         height = _ref2.height,
Kode lerroa:         width = _ref2.width,
Kode lerroa:         units = _ref2.units;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, ProgressBar);
Kode lerroa: 
Kode lerroa:     this.visible = true;
Kode lerroa:     this.div = document.querySelector(id + ' .progress');
Kode lerroa:     this.bar = this.div.parentNode;
Kode lerroa:     this.height = height || 100;
Kode lerroa:     this.width = width || 100;
Kode lerroa:     this.units = units || '%';
Kode lerroa:     this.div.style.height = this.height + this.units;
Kode lerroa:     this.percent = 0;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(ProgressBar, [{
Kode lerroa:     key: '_updateBar',
Kode lerroa:     value: function _updateBar() {
Kode lerroa:       if (this._indeterminate) {
Kode lerroa:         this.div.classList.add('indeterminate');
Kode lerroa:         this.div.style.width = this.width + this.units;
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.div.classList.remove('indeterminate');
Kode lerroa:       var progressSize = this.width * this._percent / 100;
Kode lerroa:       this.div.style.width = progressSize + this.units;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setWidth',
Kode lerroa:     value: function setWidth(viewer) {
Kode lerroa:       if (!viewer) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var container = viewer.parentNode;
Kode lerroa:       var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
Kode lerroa:       if (scrollbarWidth > 0) {
Kode lerroa:         this.bar.setAttribute('style', 'width: calc(100% - ' + scrollbarWidth + 'px);');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'hide',
Kode lerroa:     value: function hide() {
Kode lerroa:       if (!this.visible) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.visible = false;
Kode lerroa:       this.bar.classList.add('hidden');
Kode lerroa:       document.body.classList.remove('loadingInProgress');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'show',
Kode lerroa:     value: function show() {
Kode lerroa:       if (this.visible) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.visible = true;
Kode lerroa:       document.body.classList.add('loadingInProgress');
Kode lerroa:       this.bar.classList.remove('hidden');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'percent',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._percent;
Kode lerroa:     },
Kode lerroa:     set: function set(val) {
Kode lerroa:       this._indeterminate = isNaN(val);
Kode lerroa:       this._percent = clamp(val, 0, 100);
Kode lerroa:       this._updateBar();
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return ProgressBar;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.CSS_UNITS = CSS_UNITS;
Kode lerroa: exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
Kode lerroa: exports.DEFAULT_SCALE = DEFAULT_SCALE;
Kode lerroa: exports.MIN_SCALE = MIN_SCALE;
Kode lerroa: exports.MAX_SCALE = MAX_SCALE;
Kode lerroa: exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
Kode lerroa: exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
Kode lerroa: exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
Kode lerroa: exports.VERTICAL_PADDING = VERTICAL_PADDING;
Kode lerroa: exports.isValidRotation = isValidRotation;
Kode lerroa: exports.cloneObj = cloneObj;
Kode lerroa: exports.PresentationModeState = PresentationModeState;
Kode lerroa: exports.RendererType = RendererType;
Kode lerroa: exports.mozL10n = mozL10n;
Kode lerroa: exports.NullL10n = NullL10n;
Kode lerroa: exports.EventBus = EventBus;
Kode lerroa: exports.ProgressBar = ProgressBar;
Kode lerroa: exports.getPDFFileNameFromURL = getPDFFileNameFromURL;
Kode lerroa: exports.noContextMenuHandler = noContextMenuHandler;
Kode lerroa: exports.parseQueryString = parseQueryString;
Kode lerroa: exports.getVisibleElements = getVisibleElements;
Kode lerroa: exports.roundToDivide = roundToDivide;
Kode lerroa: exports.approximateFraction = approximateFraction;
Kode lerroa: exports.getOutputScale = getOutputScale;
Kode lerroa: exports.scrollIntoView = scrollIntoView;
Kode lerroa: exports.watchScroll = watchScroll;
Kode lerroa: exports.binarySearchFirstItem = binarySearchFirstItem;
Kode lerroa: exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
Kode lerroa: exports.animationStarted = animationStarted;
Kode lerroa: exports.localized = localized;
Kode lerroa: exports.WaitOnType = WaitOnType;
Kode lerroa: exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 1 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var pdfjsLib;
Kode lerroa: if (typeof window !== 'undefined' && window['pdfjs-dist/build/pdf']) {
Kode lerroa:   pdfjsLib = window['pdfjs-dist/build/pdf'];
Kode lerroa: } else {
Kode lerroa:   pdfjsLib = require('../build/pdf.js');
Kode lerroa: }
Kode lerroa: module.exports = pdfjsLib;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 2 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.getGlobalEventBus = exports.attachDOMEventsToEventBus = undefined;
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function attachDOMEventsToEventBus(eventBus) {
Kode lerroa:   eventBus.on('documentload', function () {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('documentload', true, true, {});
Kode lerroa:     window.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('pagerendered', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('pagerendered', true, true, {
Kode lerroa:       pageNumber: evt.pageNumber,
Kode lerroa:       cssTransform: evt.cssTransform
Kode lerroa:     });
Kode lerroa:     evt.source.div.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('textlayerrendered', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('textlayerrendered', true, true, { pageNumber: evt.pageNumber });
Kode lerroa:     evt.source.textLayerDiv.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('pagechange', function (evt) {
Kode lerroa:     var event = document.createEvent('UIEvents');
Kode lerroa:     event.initUIEvent('pagechange', true, true, window, 0);
Kode lerroa:     event.pageNumber = evt.pageNumber;
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('pagesinit', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('pagesinit', true, true, null);
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('pagesloaded', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('pagesloaded', true, true, { pagesCount: evt.pagesCount });
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('scalechange', function (evt) {
Kode lerroa:     var event = document.createEvent('UIEvents');
Kode lerroa:     event.initUIEvent('scalechange', true, true, window, 0);
Kode lerroa:     event.scale = evt.scale;
Kode lerroa:     event.presetValue = evt.presetValue;
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('updateviewarea', function (evt) {
Kode lerroa:     var event = document.createEvent('UIEvents');
Kode lerroa:     event.initUIEvent('updateviewarea', true, true, window, 0);
Kode lerroa:     event.location = evt.location;
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('find', function (evt) {
Kode lerroa:     if (evt.source === window) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('find' + evt.type, true, true, {
Kode lerroa:       query: evt.query,
Kode lerroa:       phraseSearch: evt.phraseSearch,
Kode lerroa:       caseSensitive: evt.caseSensitive,
Kode lerroa:       highlightAll: evt.highlightAll,
Kode lerroa:       findPrevious: evt.findPrevious
Kode lerroa:     });
Kode lerroa:     window.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('attachmentsloaded', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('attachmentsloaded', true, true, { attachmentsCount: evt.attachmentsCount });
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('sidebarviewchanged', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('sidebarviewchanged', true, true, { view: evt.view });
Kode lerroa:     evt.source.outerContainer.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('pagemode', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('pagemode', true, true, { mode: evt.mode });
Kode lerroa:     evt.source.pdfViewer.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('namedaction', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('namedaction', true, true, { action: evt.action });
Kode lerroa:     evt.source.pdfViewer.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('presentationmodechanged', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('presentationmodechanged', true, true, {
Kode lerroa:       active: evt.active,
Kode lerroa:       switchInProgress: evt.switchInProgress
Kode lerroa:     });
Kode lerroa:     window.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa:   eventBus.on('outlineloaded', function (evt) {
Kode lerroa:     var event = document.createEvent('CustomEvent');
Kode lerroa:     event.initCustomEvent('outlineloaded', true, true, { outlineCount: evt.outlineCount });
Kode lerroa:     evt.source.container.dispatchEvent(event);
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: var globalEventBus = null;
Kode lerroa: function getGlobalEventBus() {
Kode lerroa:   if (globalEventBus) {
Kode lerroa:     return globalEventBus;
Kode lerroa:   }
Kode lerroa:   globalEventBus = new _ui_utils.EventBus();
Kode lerroa:   attachDOMEventsToEventBus(globalEventBus);
Kode lerroa:   return globalEventBus;
Kode lerroa: }
Kode lerroa: exports.attachDOMEventsToEventBus = attachDOMEventsToEventBus;
Kode lerroa: exports.getGlobalEventBus = getGlobalEventBus;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 3 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var CLEANUP_TIMEOUT = 30000;
Kode lerroa: var RenderingStates = {
Kode lerroa:   INITIAL: 0,
Kode lerroa:   RUNNING: 1,
Kode lerroa:   PAUSED: 2,
Kode lerroa:   FINISHED: 3
Kode lerroa: };
Kode lerroa: 
Kode lerroa: var PDFRenderingQueue = function () {
Kode lerroa:   function PDFRenderingQueue() {
Kode lerroa:     _classCallCheck(this, PDFRenderingQueue);
Kode lerroa: 
Kode lerroa:     this.pdfViewer = null;
Kode lerroa:     this.pdfThumbnailViewer = null;
Kode lerroa:     this.onIdle = null;
Kode lerroa:     this.highestPriorityPage = null;
Kode lerroa:     this.idleTimeout = null;
Kode lerroa:     this.printing = false;
Kode lerroa:     this.isThumbnailViewEnabled = false;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFRenderingQueue, [{
Kode lerroa:     key: "setViewer",
Kode lerroa:     value: function setViewer(pdfViewer) {
Kode lerroa:       this.pdfViewer = pdfViewer;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "setThumbnailViewer",
Kode lerroa:     value: function setThumbnailViewer(pdfThumbnailViewer) {
Kode lerroa:       this.pdfThumbnailViewer = pdfThumbnailViewer;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "isHighestPriority",
Kode lerroa:     value: function isHighestPriority(view) {
Kode lerroa:       return this.highestPriorityPage === view.renderingId;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "renderHighestPriority",
Kode lerroa:     value: function renderHighestPriority(currentlyVisiblePages) {
Kode lerroa:       if (this.idleTimeout) {
Kode lerroa:         clearTimeout(this.idleTimeout);
Kode lerroa:         this.idleTimeout = null;
Kode lerroa:       }
Kode lerroa:       if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
Kode lerroa:         if (this.pdfThumbnailViewer.forceRendering()) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (this.printing) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.onIdle) {
Kode lerroa:         this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "getHighestPriority",
Kode lerroa:     value: function getHighestPriority(visible, views, scrolledDown) {
Kode lerroa:       var visibleViews = visible.views;
Kode lerroa:       var numVisible = visibleViews.length;
Kode lerroa:       if (numVisible === 0) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       for (var i = 0; i < numVisible; ++i) {
Kode lerroa:         var view = visibleViews[i].view;
Kode lerroa:         if (!this.isViewFinished(view)) {
Kode lerroa:           return view;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (scrolledDown) {
Kode lerroa:         var nextPageIndex = visible.last.id;
Kode lerroa:         if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
Kode lerroa:           return views[nextPageIndex];
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         var previousPageIndex = visible.first.id - 2;
Kode lerroa:         if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
Kode lerroa:           return views[previousPageIndex];
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return null;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "isViewFinished",
Kode lerroa:     value: function isViewFinished(view) {
Kode lerroa:       return view.renderingState === RenderingStates.FINISHED;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "renderView",
Kode lerroa:     value: function renderView(view) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       switch (view.renderingState) {
Kode lerroa:         case RenderingStates.FINISHED:
Kode lerroa:           return false;
Kode lerroa:         case RenderingStates.PAUSED:
Kode lerroa:           this.highestPriorityPage = view.renderingId;
Kode lerroa:           view.resume();
Kode lerroa:           break;
Kode lerroa:         case RenderingStates.RUNNING:
Kode lerroa:           this.highestPriorityPage = view.renderingId;
Kode lerroa:           break;
Kode lerroa:         case RenderingStates.INITIAL:
Kode lerroa:           this.highestPriorityPage = view.renderingId;
Kode lerroa:           var continueRendering = function continueRendering() {
Kode lerroa:             _this.renderHighestPriority();
Kode lerroa:           };
Kode lerroa:           view.draw().then(continueRendering, continueRendering);
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFRenderingQueue;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.RenderingStates = RenderingStates;
Kode lerroa: exports.PDFRenderingQueue = PDFRenderingQueue;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 4 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFPrintServiceFactory = exports.DefaultExternalServices = exports.PDFViewerApplication = undefined;
Kode lerroa: 
Kode lerroa: var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var _pdf_cursor_tools = __webpack_require__(6);
Kode lerroa: 
Kode lerroa: var _pdf_rendering_queue = __webpack_require__(3);
Kode lerroa: 
Kode lerroa: var _pdf_sidebar = __webpack_require__(10);
Kode lerroa: 
Kode lerroa: var _dom_events = __webpack_require__(2);
Kode lerroa: 
Kode lerroa: var _overlay_manager = __webpack_require__(11);
Kode lerroa: 
Kode lerroa: var _password_prompt = __webpack_require__(12);
Kode lerroa: 
Kode lerroa: var _pdf_attachment_viewer = __webpack_require__(13);
Kode lerroa: 
Kode lerroa: var _pdf_document_properties = __webpack_require__(14);
Kode lerroa: 
Kode lerroa: var _pdf_find_bar = __webpack_require__(15);
Kode lerroa: 
Kode lerroa: var _pdf_find_controller = __webpack_require__(7);
Kode lerroa: 
Kode lerroa: var _pdf_history = __webpack_require__(16);
Kode lerroa: 
Kode lerroa: var _pdf_link_service = __webpack_require__(5);
Kode lerroa: 
Kode lerroa: var _pdf_outline_viewer = __webpack_require__(17);
Kode lerroa: 
Kode lerroa: var _pdf_presentation_mode = __webpack_require__(18);
Kode lerroa: 
Kode lerroa: var _pdf_thumbnail_viewer = __webpack_require__(19);
Kode lerroa: 
Kode lerroa: var _pdf_viewer = __webpack_require__(21);
Kode lerroa: 
Kode lerroa: var _secondary_toolbar = __webpack_require__(26);
Kode lerroa: 
Kode lerroa: var _toolbar = __webpack_require__(27);
Kode lerroa: 
Kode lerroa: var _view_history = __webpack_require__(28);
Kode lerroa: 
Kode lerroa: var DEFAULT_SCALE_DELTA = 1.1;
Kode lerroa: var DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000;
Kode lerroa: function configure(PDFJS) {
Kode lerroa:   PDFJS.imageResourcesPath = './images/';
Kode lerroa:   PDFJS.workerSrc = '../build/pdf.worker.js';
Kode lerroa:   PDFJS.cMapUrl = '../web/cmaps/';
Kode lerroa:   PDFJS.cMapPacked = true;
Kode lerroa: }
Kode lerroa: var DefaultExternalServices = {
Kode lerroa:   updateFindControlState: function updateFindControlState(data) {},
Kode lerroa:   initPassiveLoading: function initPassiveLoading(callbacks) {},
Kode lerroa:   fallback: function fallback(data, callback) {},
Kode lerroa:   reportTelemetry: function reportTelemetry(data) {},
Kode lerroa:   createDownloadManager: function createDownloadManager() {
Kode lerroa:     throw new Error('Not implemented: createDownloadManager');
Kode lerroa:   },
Kode lerroa:   createPreferences: function createPreferences() {
Kode lerroa:     throw new Error('Not implemented: createPreferences');
Kode lerroa:   },
Kode lerroa:   createL10n: function createL10n() {
Kode lerroa:     throw new Error('Not implemented: createL10n');
Kode lerroa:   },
Kode lerroa: 
Kode lerroa:   supportsIntegratedFind: false,
Kode lerroa:   supportsDocumentFonts: true,
Kode lerroa:   supportsDocumentColors: true,
Kode lerroa:   supportedMouseWheelZoomModifierKeys: {
Kode lerroa:     ctrlKey: true,
Kode lerroa:     metaKey: true
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var PDFViewerApplication = {
Kode lerroa:   initialBookmark: document.location.hash.substring(1),
Kode lerroa:   initialized: false,
Kode lerroa:   fellback: false,
Kode lerroa:   appConfig: null,
Kode lerroa:   pdfDocument: null,
Kode lerroa:   pdfLoadingTask: null,
Kode lerroa:   printService: null,
Kode lerroa:   pdfViewer: null,
Kode lerroa:   pdfThumbnailViewer: null,
Kode lerroa:   pdfRenderingQueue: null,
Kode lerroa:   pdfPresentationMode: null,
Kode lerroa:   pdfDocumentProperties: null,
Kode lerroa:   pdfLinkService: null,
Kode lerroa:   pdfHistory: null,
Kode lerroa:   pdfSidebar: null,
Kode lerroa:   pdfOutlineViewer: null,
Kode lerroa:   pdfAttachmentViewer: null,
Kode lerroa:   pdfCursorTools: null,
Kode lerroa:   store: null,
Kode lerroa:   downloadManager: null,
Kode lerroa:   overlayManager: null,
Kode lerroa:   preferences: null,
Kode lerroa:   toolbar: null,
Kode lerroa:   secondaryToolbar: null,
Kode lerroa:   eventBus: null,
Kode lerroa:   l10n: null,
Kode lerroa:   isInitialViewSet: false,
Kode lerroa:   downloadComplete: false,
Kode lerroa:   viewerPrefs: {
Kode lerroa:     sidebarViewOnLoad: _pdf_sidebar.SidebarView.NONE,
Kode lerroa:     pdfBugEnabled: false,
Kode lerroa:     showPreviousViewOnLoad: true,
Kode lerroa:     defaultZoomValue: '',
Kode lerroa:     disablePageMode: false,
Kode lerroa:     disablePageLabels: false,
Kode lerroa:     renderer: 'canvas',
Kode lerroa:     enhanceTextSelection: false,
Kode lerroa:     renderInteractiveForms: false,
Kode lerroa:     enablePrintAutoRotate: false
Kode lerroa:   },
Kode lerroa:   isViewerEmbedded: window.parent !== window,
Kode lerroa:   url: '',
Kode lerroa:   baseUrl: '',
Kode lerroa:   externalServices: DefaultExternalServices,
Kode lerroa:   _boundEvents: {},
Kode lerroa:   initialize: function initialize(appConfig) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     this.preferences = this.externalServices.createPreferences();
Kode lerroa:     configure(_pdfjsLib.PDFJS);
Kode lerroa:     this.appConfig = appConfig;
Kode lerroa:     return this._readPreferences().then(function () {
Kode lerroa:       return _this._initializeL10n();
Kode lerroa:     }).then(function () {
Kode lerroa:       return _this._initializeViewerComponents();
Kode lerroa:     }).then(function () {
Kode lerroa:       _this.bindEvents();
Kode lerroa:       _this.bindWindowEvents();
Kode lerroa:       var appContainer = appConfig.appContainer || document.documentElement;
Kode lerroa:       _this.l10n.translate(appContainer).then(function () {
Kode lerroa:         _this.eventBus.dispatch('localized');
Kode lerroa:       });
Kode lerroa:       if (_this.isViewerEmbedded && !_pdfjsLib.PDFJS.isExternalLinkTargetSet()) {
Kode lerroa:         _pdfjsLib.PDFJS.externalLinkTarget = _pdfjsLib.PDFJS.LinkTarget.TOP;
Kode lerroa:       }
Kode lerroa:       _this.initialized = true;
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   _readPreferences: function _readPreferences() {
Kode lerroa:     var preferences = this.preferences,
Kode lerroa:         viewerPrefs = this.viewerPrefs;
Kode lerroa: 
Kode lerroa:     return Promise.all([preferences.get('enableWebGL').then(function resolved(value) {
Kode lerroa:       _pdfjsLib.PDFJS.disableWebGL = !value;
Kode lerroa:     }), preferences.get('sidebarViewOnLoad').then(function resolved(value) {
Kode lerroa:       viewerPrefs['sidebarViewOnLoad'] = value;
Kode lerroa:     }), preferences.get('pdfBugEnabled').then(function resolved(value) {
Kode lerroa:       viewerPrefs['pdfBugEnabled'] = value;
Kode lerroa:     }), preferences.get('showPreviousViewOnLoad').then(function resolved(value) {
Kode lerroa:       viewerPrefs['showPreviousViewOnLoad'] = value;
Kode lerroa:     }), preferences.get('defaultZoomValue').then(function resolved(value) {
Kode lerroa:       viewerPrefs['defaultZoomValue'] = value;
Kode lerroa:     }), preferences.get('enhanceTextSelection').then(function resolved(value) {
Kode lerroa:       viewerPrefs['enhanceTextSelection'] = value;
Kode lerroa:     }), preferences.get('disableTextLayer').then(function resolved(value) {
Kode lerroa:       if (_pdfjsLib.PDFJS.disableTextLayer === true) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _pdfjsLib.PDFJS.disableTextLayer = value;
Kode lerroa:     }), preferences.get('disableRange').then(function resolved(value) {
Kode lerroa:       if (_pdfjsLib.PDFJS.disableRange === true) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _pdfjsLib.PDFJS.disableRange = value;
Kode lerroa:     }), preferences.get('disableStream').then(function resolved(value) {
Kode lerroa:       if (_pdfjsLib.PDFJS.disableStream === true) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _pdfjsLib.PDFJS.disableStream = value;
Kode lerroa:     }), preferences.get('disableAutoFetch').then(function resolved(value) {
Kode lerroa:       _pdfjsLib.PDFJS.disableAutoFetch = value;
Kode lerroa:     }), preferences.get('disableFontFace').then(function resolved(value) {
Kode lerroa:       if (_pdfjsLib.PDFJS.disableFontFace === true) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _pdfjsLib.PDFJS.disableFontFace = value;
Kode lerroa:     }), preferences.get('useOnlyCssZoom').then(function resolved(value) {
Kode lerroa:       _pdfjsLib.PDFJS.useOnlyCssZoom = value;
Kode lerroa:     }), preferences.get('externalLinkTarget').then(function resolved(value) {
Kode lerroa:       if (_pdfjsLib.PDFJS.isExternalLinkTargetSet()) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _pdfjsLib.PDFJS.externalLinkTarget = value;
Kode lerroa:     }), preferences.get('renderer').then(function resolved(value) {
Kode lerroa:       viewerPrefs['renderer'] = value;
Kode lerroa:     }), preferences.get('renderInteractiveForms').then(function resolved(value) {
Kode lerroa:       viewerPrefs['renderInteractiveForms'] = value;
Kode lerroa:     }), preferences.get('disablePageMode').then(function resolved(value) {
Kode lerroa:       viewerPrefs['disablePageMode'] = value;
Kode lerroa:     }), preferences.get('disablePageLabels').then(function resolved(value) {
Kode lerroa:       viewerPrefs['disablePageLabels'] = value;
Kode lerroa:     }), preferences.get('enablePrintAutoRotate').then(function resolved(value) {
Kode lerroa:       viewerPrefs['enablePrintAutoRotate'] = value;
Kode lerroa:     })]).catch(function (reason) {});
Kode lerroa:   },
Kode lerroa:   _initializeL10n: function _initializeL10n() {
Kode lerroa:     if (this.viewerPrefs['pdfBugEnabled']) {
Kode lerroa:       var hash = document.location.hash.substring(1);
Kode lerroa:       var hashParams = (0, _ui_utils.parseQueryString)(hash);
Kode lerroa:       if ('locale' in hashParams) {
Kode lerroa:         _pdfjsLib.PDFJS.locale = hashParams['locale'];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     this.l10n = this.externalServices.createL10n();
Kode lerroa:     return this.l10n.getDirection().then(function (dir) {
Kode lerroa:       document.getElementsByTagName('html')[0].dir = dir;
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   _initializeViewerComponents: function _initializeViewerComponents() {
Kode lerroa:     var _this2 = this;
Kode lerroa: 
Kode lerroa:     var appConfig = this.appConfig;
Kode lerroa:     return new Promise(function (resolve, reject) {
Kode lerroa:       _this2.overlayManager = new _overlay_manager.OverlayManager();
Kode lerroa:       var eventBus = appConfig.eventBus || (0, _dom_events.getGlobalEventBus)();
Kode lerroa:       _this2.eventBus = eventBus;
Kode lerroa:       var pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
Kode lerroa:       pdfRenderingQueue.onIdle = _this2.cleanup.bind(_this2);
Kode lerroa:       _this2.pdfRenderingQueue = pdfRenderingQueue;
Kode lerroa:       var pdfLinkService = new _pdf_link_service.PDFLinkService({ eventBus: eventBus });
Kode lerroa:       _this2.pdfLinkService = pdfLinkService;
Kode lerroa:       var downloadManager = _this2.externalServices.createDownloadManager();
Kode lerroa:       _this2.downloadManager = downloadManager;
Kode lerroa:       var container = appConfig.mainContainer;
Kode lerroa:       var viewer = appConfig.viewerContainer;
Kode lerroa:       _this2.pdfViewer = new _pdf_viewer.PDFViewer({
Kode lerroa:         container: container,
Kode lerroa:         viewer: viewer,
Kode lerroa:         eventBus: eventBus,
Kode lerroa:         renderingQueue: pdfRenderingQueue,
Kode lerroa:         linkService: pdfLinkService,
Kode lerroa:         downloadManager: downloadManager,
Kode lerroa:         renderer: _this2.viewerPrefs['renderer'],
Kode lerroa:         l10n: _this2.l10n,
Kode lerroa:         enhanceTextSelection: _this2.viewerPrefs['enhanceTextSelection'],
Kode lerroa:         renderInteractiveForms: _this2.viewerPrefs['renderInteractiveForms'],
Kode lerroa:         enablePrintAutoRotate: _this2.viewerPrefs['enablePrintAutoRotate']
Kode lerroa:       });
Kode lerroa:       pdfRenderingQueue.setViewer(_this2.pdfViewer);
Kode lerroa:       pdfLinkService.setViewer(_this2.pdfViewer);
Kode lerroa:       var thumbnailContainer = appConfig.sidebar.thumbnailView;
Kode lerroa:       _this2.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({
Kode lerroa:         container: thumbnailContainer,
Kode lerroa:         renderingQueue: pdfRenderingQueue,
Kode lerroa:         linkService: pdfLinkService,
Kode lerroa:         l10n: _this2.l10n
Kode lerroa:       });
Kode lerroa:       pdfRenderingQueue.setThumbnailViewer(_this2.pdfThumbnailViewer);
Kode lerroa:       _this2.pdfHistory = new _pdf_history.PDFHistory({
Kode lerroa:         linkService: pdfLinkService,
Kode lerroa:         eventBus: eventBus
Kode lerroa:       });
Kode lerroa:       pdfLinkService.setHistory(_this2.pdfHistory);
Kode lerroa:       _this2.findController = new _pdf_find_controller.PDFFindController({ pdfViewer: _this2.pdfViewer });
Kode lerroa:       _this2.findController.onUpdateResultsCount = function (matchCount) {
Kode lerroa:         if (_this2.supportsIntegratedFind) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         _this2.findBar.updateResultsCount(matchCount);
Kode lerroa:       };
Kode lerroa:       _this2.findController.onUpdateState = function (state, previous, matchCount) {
Kode lerroa:         if (_this2.supportsIntegratedFind) {
Kode lerroa:           _this2.externalServices.updateFindControlState({
Kode lerroa:             result: state,
Kode lerroa:             findPrevious: previous
Kode lerroa:           });
Kode lerroa:         } else {
Kode lerroa:           _this2.findBar.updateUIState(state, previous, matchCount);
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       _this2.pdfViewer.setFindController(_this2.findController);
Kode lerroa:       var findBarConfig = Object.create(appConfig.findBar);
Kode lerroa:       findBarConfig.findController = _this2.findController;
Kode lerroa:       findBarConfig.eventBus = eventBus;
Kode lerroa:       _this2.findBar = new _pdf_find_bar.PDFFindBar(findBarConfig, _this2.l10n);
Kode lerroa:       _this2.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, _this2.overlayManager, _this2.l10n);
Kode lerroa:       _this2.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({
Kode lerroa:         container: container,
Kode lerroa:         eventBus: eventBus,
Kode lerroa:         preferences: _this2.preferences
Kode lerroa:       });
Kode lerroa:       _this2.toolbar = new _toolbar.Toolbar(appConfig.toolbar, container, eventBus, _this2.l10n);
Kode lerroa:       _this2.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);
Kode lerroa:       if (_this2.supportsFullscreen) {
Kode lerroa:         _this2.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({
Kode lerroa:           container: container,
Kode lerroa:           viewer: viewer,
Kode lerroa:           pdfViewer: _this2.pdfViewer,
Kode lerroa:           eventBus: eventBus,
Kode lerroa:           contextMenuItems: appConfig.fullscreen
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       _this2.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, _this2.overlayManager, _this2.l10n);
Kode lerroa:       _this2.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({
Kode lerroa:         container: appConfig.sidebar.outlineView,
Kode lerroa:         eventBus: eventBus,
Kode lerroa:         linkService: pdfLinkService
Kode lerroa:       });
Kode lerroa:       _this2.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({
Kode lerroa:         container: appConfig.sidebar.attachmentsView,
Kode lerroa:         eventBus: eventBus,
Kode lerroa:         downloadManager: downloadManager
Kode lerroa:       });
Kode lerroa:       var sidebarConfig = Object.create(appConfig.sidebar);
Kode lerroa:       sidebarConfig.pdfViewer = _this2.pdfViewer;
Kode lerroa:       sidebarConfig.pdfThumbnailViewer = _this2.pdfThumbnailViewer;
Kode lerroa:       sidebarConfig.pdfOutlineViewer = _this2.pdfOutlineViewer;
Kode lerroa:       sidebarConfig.eventBus = eventBus;
Kode lerroa:       _this2.pdfSidebar = new _pdf_sidebar.PDFSidebar(sidebarConfig, _this2.l10n);
Kode lerroa:       _this2.pdfSidebar.onToggled = _this2.forceRendering.bind(_this2);
Kode lerroa:       resolve(undefined);
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   run: function run(config) {
Kode lerroa:     this.initialize(config).then(webViewerInitialized);
Kode lerroa:   },
Kode lerroa:   zoomIn: function zoomIn(ticks) {
Kode lerroa:     var newScale = this.pdfViewer.currentScale;
Kode lerroa:     do {
Kode lerroa:       newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);
Kode lerroa:       newScale = Math.ceil(newScale * 10) / 10;
Kode lerroa:       newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
Kode lerroa:     } while (--ticks > 0 && newScale < _ui_utils.MAX_SCALE);
Kode lerroa:     this.pdfViewer.currentScaleValue = newScale;
Kode lerroa:   },
Kode lerroa:   zoomOut: function zoomOut(ticks) {
Kode lerroa:     var newScale = this.pdfViewer.currentScale;
Kode lerroa:     do {
Kode lerroa:       newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);
Kode lerroa:       newScale = Math.floor(newScale * 10) / 10;
Kode lerroa:       newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
Kode lerroa:     } while (--ticks > 0 && newScale > _ui_utils.MIN_SCALE);
Kode lerroa:     this.pdfViewer.currentScaleValue = newScale;
Kode lerroa:   },
Kode lerroa: 
Kode lerroa:   get pagesCount() {
Kode lerroa:     return this.pdfDocument ? this.pdfDocument.numPages : 0;
Kode lerroa:   },
Kode lerroa:   get pageRotation() {
Kode lerroa:     return this.pdfViewer.pagesRotation;
Kode lerroa:   },
Kode lerroa:   set page(val) {
Kode lerroa:     this.pdfViewer.currentPageNumber = val;
Kode lerroa:   },
Kode lerroa:   get page() {
Kode lerroa:     return this.pdfViewer.currentPageNumber;
Kode lerroa:   },
Kode lerroa:   get printing() {
Kode lerroa:     return !!this.printService;
Kode lerroa:   },
Kode lerroa:   get supportsPrinting() {
Kode lerroa:     return PDFPrintServiceFactory.instance.supportsPrinting;
Kode lerroa:   },
Kode lerroa:   get supportsFullscreen() {
Kode lerroa:     var support = void 0;
Kode lerroa:     var doc = document.documentElement;
Kode lerroa:     support = !!(doc.requestFullscreen || doc.mozRequestFullScreen || doc.webkitRequestFullScreen || doc.msRequestFullscreen);
Kode lerroa:     if (document.fullscreenEnabled === false || document.mozFullScreenEnabled === false || document.webkitFullscreenEnabled === false || document.msFullscreenEnabled === false) {
Kode lerroa:       support = false;
Kode lerroa:     }
Kode lerroa:     if (support && _pdfjsLib.PDFJS.disableFullscreen === true) {
Kode lerroa:       support = false;
Kode lerroa:     }
Kode lerroa:     return (0, _pdfjsLib.shadow)(this, 'supportsFullscreen', support);
Kode lerroa:   },
Kode lerroa:   get supportsIntegratedFind() {
Kode lerroa:     return this.externalServices.supportsIntegratedFind;
Kode lerroa:   },
Kode lerroa:   get supportsDocumentFonts() {
Kode lerroa:     return this.externalServices.supportsDocumentFonts;
Kode lerroa:   },
Kode lerroa:   get supportsDocumentColors() {
Kode lerroa:     return this.externalServices.supportsDocumentColors;
Kode lerroa:   },
Kode lerroa:   get loadingBar() {
Kode lerroa:     var bar = new _ui_utils.ProgressBar('#loadingBar');
Kode lerroa:     return (0, _pdfjsLib.shadow)(this, 'loadingBar', bar);
Kode lerroa:   },
Kode lerroa:   get supportedMouseWheelZoomModifierKeys() {
Kode lerroa:     return this.externalServices.supportedMouseWheelZoomModifierKeys;
Kode lerroa:   },
Kode lerroa:   initPassiveLoading: function initPassiveLoading() {
Kode lerroa:     throw new Error('Not implemented: initPassiveLoading');
Kode lerroa:   },
Kode lerroa:   setTitleUsingUrl: function setTitleUsingUrl(url) {
Kode lerroa:     this.url = url;
Kode lerroa:     this.baseUrl = url.split('#')[0];
Kode lerroa:     var title = (0, _ui_utils.getPDFFileNameFromURL)(url, '');
Kode lerroa:     if (!title) {
Kode lerroa:       try {
Kode lerroa:         title = decodeURIComponent((0, _pdfjsLib.getFilenameFromUrl)(url)) || url;
Kode lerroa:       } catch (ex) {
Kode lerroa:         title = url;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     this.setTitle(title);
Kode lerroa:   },
Kode lerroa:   setTitle: function setTitle(title) {
Kode lerroa:     if (this.isViewerEmbedded) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     document.title = title;
Kode lerroa:   },
Kode lerroa:   close: function close() {
Kode lerroa:     var errorWrapper = this.appConfig.errorWrapper.container;
Kode lerroa:     errorWrapper.setAttribute('hidden', 'true');
Kode lerroa:     if (!this.pdfLoadingTask) {
Kode lerroa:       return Promise.resolve();
Kode lerroa:     }
Kode lerroa:     var promise = this.pdfLoadingTask.destroy();
Kode lerroa:     this.pdfLoadingTask = null;
Kode lerroa:     if (this.pdfDocument) {
Kode lerroa:       this.pdfDocument = null;
Kode lerroa:       this.pdfThumbnailViewer.setDocument(null);
Kode lerroa:       this.pdfViewer.setDocument(null);
Kode lerroa:       this.pdfLinkService.setDocument(null, null);
Kode lerroa:       this.pdfDocumentProperties.setDocument(null, null);
Kode lerroa:     }
Kode lerroa:     this.store = null;
Kode lerroa:     this.isInitialViewSet = false;
Kode lerroa:     this.downloadComplete = false;
Kode lerroa:     this.pdfSidebar.reset();
Kode lerroa:     this.pdfOutlineViewer.reset();
Kode lerroa:     this.pdfAttachmentViewer.reset();
Kode lerroa:     this.findController.reset();
Kode lerroa:     this.findBar.reset();
Kode lerroa:     this.toolbar.reset();
Kode lerroa:     this.secondaryToolbar.reset();
Kode lerroa:     if (typeof PDFBug !== 'undefined') {
Kode lerroa:       PDFBug.cleanup();
Kode lerroa:     }
Kode lerroa:     return promise;
Kode lerroa:   },
Kode lerroa:   open: function open(file, args) {
Kode lerroa:     var _this3 = this;
Kode lerroa: 
Kode lerroa:     if (arguments.length > 2 || typeof args === 'number') {
Kode lerroa:       return Promise.reject(new Error('Call of open() with obsolete signature.'));
Kode lerroa:     }
Kode lerroa:     if (this.pdfLoadingTask) {
Kode lerroa:       return this.close().then(function () {
Kode lerroa:         _this3.preferences.reload();
Kode lerroa:         return _this3.open(file, args);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     var parameters = Object.create(null);
Kode lerroa:     if (typeof file === 'string') {
Kode lerroa:       this.setTitleUsingUrl(file);
Kode lerroa:       parameters.url = file;
Kode lerroa:     } else if (file && 'byteLength' in file) {
Kode lerroa:       parameters.data = file;
Kode lerroa:     } else if (file.url && file.originalUrl) {
Kode lerroa:       this.setTitleUsingUrl(file.originalUrl);
Kode lerroa:       parameters.url = file.url;
Kode lerroa:     }
Kode lerroa:     if (args) {
Kode lerroa:       for (var prop in args) {
Kode lerroa:         if (!_pdfjsLib.PDFJS.pdfjsNext && prop === 'scale') {
Kode lerroa:           console.error('Call of open() with obsolete "scale" argument, ' + 'please use the "defaultZoomValue" preference instead.');
Kode lerroa:           continue;
Kode lerroa:         } else if (prop === 'length') {
Kode lerroa:           this.pdfDocumentProperties.setFileSize(args[prop]);
Kode lerroa:         }
Kode lerroa:         parameters[prop] = args[prop];
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var loadingTask = (0, _pdfjsLib.getDocument)(parameters);
Kode lerroa:     this.pdfLoadingTask = loadingTask;
Kode lerroa:     loadingTask.onPassword = function (updateCallback, reason) {
Kode lerroa:       _this3.passwordPrompt.setUpdateCallback(updateCallback, reason);
Kode lerroa:       _this3.passwordPrompt.open();
Kode lerroa:     };
Kode lerroa:     loadingTask.onProgress = function (_ref) {
Kode lerroa:       var loaded = _ref.loaded,
Kode lerroa:           total = _ref.total;
Kode lerroa: 
Kode lerroa:       _this3.progress(loaded / total);
Kode lerroa:     };
Kode lerroa:     loadingTask.onUnsupportedFeature = this.fallback.bind(this);
Kode lerroa:     return loadingTask.promise.then(function (pdfDocument) {
Kode lerroa:       _this3.load(pdfDocument);
Kode lerroa:     }, function (exception) {
Kode lerroa:       var message = exception && exception.message;
Kode lerroa:       var loadingErrorMessage = void 0;
Kode lerroa:       if (exception instanceof _pdfjsLib.InvalidPDFException) {
Kode lerroa:         loadingErrorMessage = _this3.l10n.get('invalid_file_error', null, 'Invalid or corrupted PDF file.');
Kode lerroa:       } else if (exception instanceof _pdfjsLib.MissingPDFException) {
Kode lerroa:         loadingErrorMessage = _this3.l10n.get('missing_file_error', null, 'Missing PDF file.');
Kode lerroa:       } else if (exception instanceof _pdfjsLib.UnexpectedResponseException) {
Kode lerroa:         loadingErrorMessage = _this3.l10n.get('unexpected_response_error', null, 'Unexpected server response.');
Kode lerroa:       } else {
Kode lerroa:         loadingErrorMessage = _this3.l10n.get('loading_error', null, 'An error occurred while loading the PDF.');
Kode lerroa:       }
Kode lerroa:       return loadingErrorMessage.then(function (msg) {
Kode lerroa:         _this3.error(msg, { message: message });
Kode lerroa:         throw new Error(msg);
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   download: function download() {
Kode lerroa:     var _this4 = this;
Kode lerroa: 
Kode lerroa:     function downloadByUrl() {
Kode lerroa:       downloadManager.downloadUrl(url, filename);
Kode lerroa:     }
Kode lerroa:     var url = this.baseUrl;
Kode lerroa:     var filename = (0, _ui_utils.getPDFFileNameFromURL)(this.url);
Kode lerroa:     var downloadManager = this.downloadManager;
Kode lerroa:     downloadManager.onerror = function (err) {
Kode lerroa:       _this4.error('PDF failed to download: ' + err);
Kode lerroa:     };
Kode lerroa:     if (!this.pdfDocument || !this.downloadComplete) {
Kode lerroa:       downloadByUrl();
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.pdfDocument.getData().then(function (data) {
Kode lerroa:       var blob = (0, _pdfjsLib.createBlob)(data, 'application/pdf');
Kode lerroa:       downloadManager.download(blob, url, filename);
Kode lerroa:     }).catch(downloadByUrl);
Kode lerroa:   },
Kode lerroa:   fallback: function fallback(featureId) {},
Kode lerroa:   error: function error(message, moreInfo) {
Kode lerroa:     var moreInfoText = [this.l10n.get('error_version_info', {
Kode lerroa:       version: _pdfjsLib.version || '?',
Kode lerroa:       build: _pdfjsLib.build || '?'
Kode lerroa:     }, 'PDF.js v{{version}} (build: {{build}})')];
Kode lerroa:     if (moreInfo) {
Kode lerroa:       moreInfoText.push(this.l10n.get('error_message', { message: moreInfo.message }, 'Message: {{message}}'));
Kode lerroa:       if (moreInfo.stack) {
Kode lerroa:         moreInfoText.push(this.l10n.get('error_stack', { stack: moreInfo.stack }, 'Stack: {{stack}}'));
Kode lerroa:       } else {
Kode lerroa:         if (moreInfo.filename) {
Kode lerroa:           moreInfoText.push(this.l10n.get('error_file', { file: moreInfo.filename }, 'File: {{file}}'));
Kode lerroa:         }
Kode lerroa:         if (moreInfo.lineNumber) {
Kode lerroa:           moreInfoText.push(this.l10n.get('error_line', { line: moreInfo.lineNumber }, 'Line: {{line}}'));
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     var errorWrapperConfig = this.appConfig.errorWrapper;
Kode lerroa:     var errorWrapper = errorWrapperConfig.container;
Kode lerroa:     errorWrapper.removeAttribute('hidden');
Kode lerroa:     var errorMessage = errorWrapperConfig.errorMessage;
Kode lerroa:     errorMessage.textContent = message;
Kode lerroa:     var closeButton = errorWrapperConfig.closeButton;
Kode lerroa:     closeButton.onclick = function () {
Kode lerroa:       errorWrapper.setAttribute('hidden', 'true');
Kode lerroa:     };
Kode lerroa:     var errorMoreInfo = errorWrapperConfig.errorMoreInfo;
Kode lerroa:     var moreInfoButton = errorWrapperConfig.moreInfoButton;
Kode lerroa:     var lessInfoButton = errorWrapperConfig.lessInfoButton;
Kode lerroa:     moreInfoButton.onclick = function () {
Kode lerroa:       errorMoreInfo.removeAttribute('hidden');
Kode lerroa:       moreInfoButton.setAttribute('hidden', 'true');
Kode lerroa:       lessInfoButton.removeAttribute('hidden');
Kode lerroa:       errorMoreInfo.style.height = errorMoreInfo.scrollHeight + 'px';
Kode lerroa:     };
Kode lerroa:     lessInfoButton.onclick = function () {
Kode lerroa:       errorMoreInfo.setAttribute('hidden', 'true');
Kode lerroa:       moreInfoButton.removeAttribute('hidden');
Kode lerroa:       lessInfoButton.setAttribute('hidden', 'true');
Kode lerroa:     };
Kode lerroa:     moreInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
Kode lerroa:     lessInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
Kode lerroa:     closeButton.oncontextmenu = _ui_utils.noContextMenuHandler;
Kode lerroa:     moreInfoButton.removeAttribute('hidden');
Kode lerroa:     lessInfoButton.setAttribute('hidden', 'true');
Kode lerroa:     Promise.all(moreInfoText).then(function (parts) {
Kode lerroa:       errorMoreInfo.value = parts.join('\n');
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   progress: function progress(level) {
Kode lerroa:     var _this5 = this;
Kode lerroa: 
Kode lerroa:     if (this.downloadComplete) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var percent = Math.round(level * 100);
Kode lerroa:     if (percent > this.loadingBar.percent || isNaN(percent)) {
Kode lerroa:       this.loadingBar.percent = percent;
Kode lerroa:       if (_pdfjsLib.PDFJS.disableAutoFetch && percent) {
Kode lerroa:         if (this.disableAutoFetchLoadingBarTimeout) {
Kode lerroa:           clearTimeout(this.disableAutoFetchLoadingBarTimeout);
Kode lerroa:           this.disableAutoFetchLoadingBarTimeout = null;
Kode lerroa:         }
Kode lerroa:         this.loadingBar.show();
Kode lerroa:         this.disableAutoFetchLoadingBarTimeout = setTimeout(function () {
Kode lerroa:           _this5.loadingBar.hide();
Kode lerroa:           _this5.disableAutoFetchLoadingBarTimeout = null;
Kode lerroa:         }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   load: function load(pdfDocument) {
Kode lerroa:     var _this6 = this;
Kode lerroa: 
Kode lerroa:     this.pdfDocument = pdfDocument;
Kode lerroa:     pdfDocument.getDownloadInfo().then(function () {
Kode lerroa:       _this6.downloadComplete = true;
Kode lerroa:       _this6.loadingBar.hide();
Kode lerroa:       firstPagePromise.then(function () {
Kode lerroa:         _this6.eventBus.dispatch('documentload', { source: _this6 });
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     var pageModePromise = pdfDocument.getPageMode().catch(function () {});
Kode lerroa:     this.toolbar.setPagesCount(pdfDocument.numPages, false);
Kode lerroa:     this.secondaryToolbar.setPagesCount(pdfDocument.numPages);
Kode lerroa:     var id = this.documentFingerprint = pdfDocument.fingerprint;
Kode lerroa:     var store = this.store = new _view_history.ViewHistory(id);
Kode lerroa:     var baseDocumentUrl = void 0;
Kode lerroa:     baseDocumentUrl = null;
Kode lerroa:     this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);
Kode lerroa:     this.pdfDocumentProperties.setDocument(pdfDocument, this.url);
Kode lerroa:     var pdfViewer = this.pdfViewer;
Kode lerroa:     pdfViewer.setDocument(pdfDocument);
Kode lerroa:     var firstPagePromise = pdfViewer.firstPagePromise;
Kode lerroa:     var pagesPromise = pdfViewer.pagesPromise;
Kode lerroa:     var onePageRendered = pdfViewer.onePageRendered;
Kode lerroa:     var pdfThumbnailViewer = this.pdfThumbnailViewer;
Kode lerroa:     pdfThumbnailViewer.setDocument(pdfDocument);
Kode lerroa:     firstPagePromise.then(function (pdfPage) {
Kode lerroa:       _this6.loadingBar.setWidth(_this6.appConfig.viewerContainer);
Kode lerroa:       if (!_pdfjsLib.PDFJS.disableHistory && !_this6.isViewerEmbedded) {
Kode lerroa:         var resetHistory = !_this6.viewerPrefs['showPreviousViewOnLoad'];
Kode lerroa:         _this6.pdfHistory.initialize(id, resetHistory);
Kode lerroa:         if (_this6.pdfHistory.initialBookmark) {
Kode lerroa:           _this6.initialBookmark = _this6.pdfHistory.initialBookmark;
Kode lerroa:           _this6.initialRotation = _this6.pdfHistory.initialRotation;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var initialParams = {
Kode lerroa:         bookmark: null,
Kode lerroa:         hash: null
Kode lerroa:       };
Kode lerroa:       var storePromise = store.getMultiple({
Kode lerroa:         exists: false,
Kode lerroa:         page: '1',
Kode lerroa:         zoom: _ui_utils.DEFAULT_SCALE_VALUE,
Kode lerroa:         scrollLeft: '0',
Kode lerroa:         scrollTop: '0',
Kode lerroa:         rotation: null,
Kode lerroa:         sidebarView: _pdf_sidebar.SidebarView.NONE
Kode lerroa:       }).catch(function () {});
Kode lerroa:       Promise.all([storePromise, pageModePromise]).then(function (_ref2) {
Kode lerroa:         var _ref3 = _slicedToArray(_ref2, 2),
Kode lerroa:             _ref3$ = _ref3[0],
Kode lerroa:             values = _ref3$ === undefined ? {} : _ref3$,
Kode lerroa:             pageMode = _ref3[1];
Kode lerroa: 
Kode lerroa:         var hash = _this6.viewerPrefs['defaultZoomValue'] ? 'zoom=' + _this6.viewerPrefs['defaultZoomValue'] : null;
Kode lerroa:         var rotation = null;
Kode lerroa:         var sidebarView = _this6.viewerPrefs['sidebarViewOnLoad'];
Kode lerroa:         if (values.exists && _this6.viewerPrefs['showPreviousViewOnLoad']) {
Kode lerroa:           hash = 'page=' + values.page + '&zoom=' + (_this6.viewerPrefs['defaultZoomValue'] || values.zoom) + ',' + values.scrollLeft + ',' + values.scrollTop;
Kode lerroa:           rotation = parseInt(values.rotation, 10);
Kode lerroa:           sidebarView = sidebarView || values.sidebarView | 0;
Kode lerroa:         }
Kode lerroa:         if (pageMode && !_this6.viewerPrefs['disablePageMode']) {
Kode lerroa:           sidebarView = sidebarView || apiPageModeToSidebarView(pageMode);
Kode lerroa:         }
Kode lerroa:         return {
Kode lerroa:           hash: hash,
Kode lerroa:           rotation: rotation,
Kode lerroa:           sidebarView: sidebarView
Kode lerroa:         };
Kode lerroa:       }).then(function (_ref4) {
Kode lerroa:         var hash = _ref4.hash,
Kode lerroa:             rotation = _ref4.rotation,
Kode lerroa:             sidebarView = _ref4.sidebarView;
Kode lerroa: 
Kode lerroa:         initialParams.bookmark = _this6.initialBookmark;
Kode lerroa:         initialParams.hash = hash;
Kode lerroa:         _this6.setInitialView(hash, {
Kode lerroa:           rotation: rotation,
Kode lerroa:           sidebarView: sidebarView
Kode lerroa:         });
Kode lerroa:         if (!_this6.isViewerEmbedded) {
Kode lerroa:           pdfViewer.focus();
Kode lerroa:         }
Kode lerroa:         return pagesPromise;
Kode lerroa:       }).then(function () {
Kode lerroa:         if (!initialParams.bookmark && !initialParams.hash) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (pdfViewer.hasEqualPageSizes) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         _this6.initialBookmark = initialParams.bookmark;
Kode lerroa:         pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;
Kode lerroa:         _this6.setInitialView(initialParams.hash);
Kode lerroa:       }).then(function () {
Kode lerroa:         pdfViewer.update();
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     pdfDocument.getPageLabels().then(function (labels) {
Kode lerroa:       if (!labels || _this6.viewerPrefs['disablePageLabels']) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var i = 0,
Kode lerroa:           numLabels = labels.length;
Kode lerroa:       if (numLabels !== _this6.pagesCount) {
Kode lerroa:         console.error('The number of Page Labels does not match ' + 'the number of pages in the document.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       while (i < numLabels && labels[i] === (i + 1).toString()) {
Kode lerroa:         i++;
Kode lerroa:       }
Kode lerroa:       if (i === numLabels) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       pdfViewer.setPageLabels(labels);
Kode lerroa:       pdfThumbnailViewer.setPageLabels(labels);
Kode lerroa:       _this6.toolbar.setPagesCount(pdfDocument.numPages, true);
Kode lerroa:       _this6.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
Kode lerroa:     });
Kode lerroa:     pagesPromise.then(function () {
Kode lerroa:       if (!_this6.supportsPrinting) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       pdfDocument.getJavaScript().then(function (javaScript) {
Kode lerroa:         if (javaScript.length === 0) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         javaScript.some(function (js) {
Kode lerroa:           if (!js) {
Kode lerroa:             return false;
Kode lerroa:           }
Kode lerroa:           console.warn('Warning: JavaScript is not supported');
Kode lerroa:           _this6.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.javaScript);
Kode lerroa:           return true;
Kode lerroa:         });
Kode lerroa:         var regex = /\bprint\s*\(/;
Kode lerroa:         for (var i = 0, ii = javaScript.length; i < ii; i++) {
Kode lerroa:           var js = javaScript[i];
Kode lerroa:           if (js && regex.test(js)) {
Kode lerroa:             setTimeout(function () {
Kode lerroa:               window.print();
Kode lerroa:             });
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     Promise.all([onePageRendered, _ui_utils.animationStarted]).then(function () {
Kode lerroa:       pdfDocument.getOutline().then(function (outline) {
Kode lerroa:         _this6.pdfOutlineViewer.render({ outline: outline });
Kode lerroa:       });
Kode lerroa:       pdfDocument.getAttachments().then(function (attachments) {
Kode lerroa:         _this6.pdfAttachmentViewer.render({ attachments: attachments });
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:     pdfDocument.getMetadata().then(function (_ref5) {
Kode lerroa:       var info = _ref5.info,
Kode lerroa:           metadata = _ref5.metadata;
Kode lerroa: 
Kode lerroa:       _this6.documentInfo = info;
Kode lerroa:       _this6.metadata = metadata;
Kode lerroa:       console.log('PDF ' + pdfDocument.fingerprint + ' [' + info.PDFFormatVersion + ' ' + (info.Producer || '-').trim() + ' / ' + (info.Creator || '-').trim() + ']' + ' (PDF.js: ' + (_pdfjsLib.version || '-') + (!_pdfjsLib.PDFJS.disableWebGL ? ' [WebGL]' : '') + ')');
Kode lerroa:       var pdfTitle = void 0;
Kode lerroa:       if (metadata && metadata.has('dc:title')) {
Kode lerroa:         var title = metadata.get('dc:title');
Kode lerroa:         if (title !== 'Untitled') {
Kode lerroa:           pdfTitle = title;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (!pdfTitle && info && info['Title']) {
Kode lerroa:         pdfTitle = info['Title'];
Kode lerroa:       }
Kode lerroa:       if (pdfTitle) {
Kode lerroa:         _this6.setTitle(pdfTitle + ' - ' + document.title);
Kode lerroa:       }
Kode lerroa:       if (info.IsAcroFormPresent) {
Kode lerroa:         console.warn('Warning: AcroForm/XFA is not supported');
Kode lerroa:         _this6.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.forms);
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   setInitialView: function setInitialView(storedHash) {
Kode lerroa:     var _this7 = this;
Kode lerroa: 
Kode lerroa:     var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
Kode lerroa:         rotation = _ref6.rotation,
Kode lerroa:         sidebarView = _ref6.sidebarView;
Kode lerroa: 
Kode lerroa:     var setRotation = function setRotation(angle) {
Kode lerroa:       if ((0, _ui_utils.isValidRotation)(angle)) {
Kode lerroa:         _this7.pdfViewer.pagesRotation = angle;
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     this.isInitialViewSet = true;
Kode lerroa:     this.pdfSidebar.setInitialView(sidebarView);
Kode lerroa:     if (this.initialBookmark) {
Kode lerroa:       setRotation(this.initialRotation);
Kode lerroa:       delete this.initialRotation;
Kode lerroa:       this.pdfLinkService.setHash(this.initialBookmark);
Kode lerroa:       this.initialBookmark = null;
Kode lerroa:     } else if (storedHash) {
Kode lerroa:       setRotation(rotation);
Kode lerroa:       this.pdfLinkService.setHash(storedHash);
Kode lerroa:     }
Kode lerroa:     this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);
Kode lerroa:     this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);
Kode lerroa:     if (!this.pdfViewer.currentScaleValue) {
Kode lerroa:       this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   cleanup: function cleanup() {
Kode lerroa:     if (!this.pdfDocument) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.pdfViewer.cleanup();
Kode lerroa:     this.pdfThumbnailViewer.cleanup();
Kode lerroa:     if (this.pdfViewer.renderer !== _ui_utils.RendererType.SVG) {
Kode lerroa:       this.pdfDocument.cleanup();
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   forceRendering: function forceRendering() {
Kode lerroa:     this.pdfRenderingQueue.printing = this.printing;
Kode lerroa:     this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;
Kode lerroa:     this.pdfRenderingQueue.renderHighestPriority();
Kode lerroa:   },
Kode lerroa:   beforePrint: function beforePrint() {
Kode lerroa:     var _this8 = this;
Kode lerroa: 
Kode lerroa:     if (this.printService) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!this.supportsPrinting) {
Kode lerroa:       this.l10n.get('printing_not_supported', null, 'Warning: Printing is not fully supported by ' + 'this browser.').then(function (printMessage) {
Kode lerroa:         _this8.error(printMessage);
Kode lerroa:       });
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (!this.pdfViewer.pageViewsReady) {
Kode lerroa:       this.l10n.get('printing_not_ready', null, 'Warning: The PDF is not fully loaded for printing.').then(function (notReadyMessage) {
Kode lerroa:         window.alert(notReadyMessage);
Kode lerroa:       });
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var pagesOverview = this.pdfViewer.getPagesOverview();
Kode lerroa:     var printContainer = this.appConfig.printContainer;
Kode lerroa:     var printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, this.l10n);
Kode lerroa:     this.printService = printService;
Kode lerroa:     this.forceRendering();
Kode lerroa:     printService.layout();
Kode lerroa:   },
Kode lerroa: 
Kode lerroa:   afterPrint: function pdfViewSetupAfterPrint() {
Kode lerroa:     if (this.printService) {
Kode lerroa:       this.printService.destroy();
Kode lerroa:       this.printService = null;
Kode lerroa:     }
Kode lerroa:     this.forceRendering();
Kode lerroa:   },
Kode lerroa:   rotatePages: function rotatePages(delta) {
Kode lerroa:     if (!this.pdfDocument) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var newRotation = (this.pdfViewer.pagesRotation + 360 + delta) % 360;
Kode lerroa:     this.pdfViewer.pagesRotation = newRotation;
Kode lerroa:   },
Kode lerroa:   requestPresentationMode: function requestPresentationMode() {
Kode lerroa:     if (!this.pdfPresentationMode) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.pdfPresentationMode.request();
Kode lerroa:   },
Kode lerroa:   bindEvents: function bindEvents() {
Kode lerroa:     var eventBus = this.eventBus,
Kode lerroa:         _boundEvents = this._boundEvents;
Kode lerroa: 
Kode lerroa:     _boundEvents.beforePrint = this.beforePrint.bind(this);
Kode lerroa:     _boundEvents.afterPrint = this.afterPrint.bind(this);
Kode lerroa:     eventBus.on('resize', webViewerResize);
Kode lerroa:     eventBus.on('hashchange', webViewerHashchange);
Kode lerroa:     eventBus.on('beforeprint', _boundEvents.beforePrint);
Kode lerroa:     eventBus.on('afterprint', _boundEvents.afterPrint);
Kode lerroa:     eventBus.on('pagerendered', webViewerPageRendered);
Kode lerroa:     eventBus.on('textlayerrendered', webViewerTextLayerRendered);
Kode lerroa:     eventBus.on('updateviewarea', webViewerUpdateViewarea);
Kode lerroa:     eventBus.on('pagechanging', webViewerPageChanging);
Kode lerroa:     eventBus.on('scalechanging', webViewerScaleChanging);
Kode lerroa:     eventBus.on('rotationchanging', webViewerRotationChanging);
Kode lerroa:     eventBus.on('sidebarviewchanged', webViewerSidebarViewChanged);
Kode lerroa:     eventBus.on('pagemode', webViewerPageMode);
Kode lerroa:     eventBus.on('namedaction', webViewerNamedAction);
Kode lerroa:     eventBus.on('presentationmodechanged', webViewerPresentationModeChanged);
Kode lerroa:     eventBus.on('presentationmode', webViewerPresentationMode);
Kode lerroa:     eventBus.on('openfile', webViewerOpenFile);
Kode lerroa:     eventBus.on('print', webViewerPrint);
Kode lerroa:     eventBus.on('download', webViewerDownload);
Kode lerroa:     eventBus.on('firstpage', webViewerFirstPage);
Kode lerroa:     eventBus.on('lastpage', webViewerLastPage);
Kode lerroa:     eventBus.on('nextpage', webViewerNextPage);
Kode lerroa:     eventBus.on('previouspage', webViewerPreviousPage);
Kode lerroa:     eventBus.on('zoomin', webViewerZoomIn);
Kode lerroa:     eventBus.on('zoomout', webViewerZoomOut);
Kode lerroa:     eventBus.on('pagenumberchanged', webViewerPageNumberChanged);
Kode lerroa:     eventBus.on('scalechanged', webViewerScaleChanged);
Kode lerroa:     eventBus.on('rotatecw', webViewerRotateCw);
Kode lerroa:     eventBus.on('rotateccw', webViewerRotateCcw);
Kode lerroa:     eventBus.on('documentproperties', webViewerDocumentProperties);
Kode lerroa:     eventBus.on('find', webViewerFind);
Kode lerroa:     eventBus.on('findfromurlhash', webViewerFindFromUrlHash);
Kode lerroa:     eventBus.on('fileinputchange', webViewerFileInputChange);
Kode lerroa:   },
Kode lerroa:   bindWindowEvents: function bindWindowEvents() {
Kode lerroa:     var eventBus = this.eventBus,
Kode lerroa:         _boundEvents = this._boundEvents;
Kode lerroa: 
Kode lerroa:     _boundEvents.windowResize = function () {
Kode lerroa:       eventBus.dispatch('resize');
Kode lerroa:     };
Kode lerroa:     _boundEvents.windowHashChange = function () {
Kode lerroa:       eventBus.dispatch('hashchange', { hash: document.location.hash.substring(1) });
Kode lerroa:     };
Kode lerroa:     _boundEvents.windowBeforePrint = function () {
Kode lerroa:       eventBus.dispatch('beforeprint');
Kode lerroa:     };
Kode lerroa:     _boundEvents.windowAfterPrint = function () {
Kode lerroa:       eventBus.dispatch('afterprint');
Kode lerroa:     };
Kode lerroa:     window.addEventListener('wheel', webViewerWheel);
Kode lerroa:     window.addEventListener('click', webViewerClick);
Kode lerroa:     window.addEventListener('keydown', webViewerKeyDown);
Kode lerroa:     window.addEventListener('resize', _boundEvents.windowResize);
Kode lerroa:     window.addEventListener('hashchange', _boundEvents.windowHashChange);
Kode lerroa:     window.addEventListener('beforeprint', _boundEvents.windowBeforePrint);
Kode lerroa:     window.addEventListener('afterprint', _boundEvents.windowAfterPrint);
Kode lerroa:   },
Kode lerroa:   unbindEvents: function unbindEvents() {
Kode lerroa:     var eventBus = this.eventBus,
Kode lerroa:         _boundEvents = this._boundEvents;
Kode lerroa: 
Kode lerroa:     eventBus.off('resize', webViewerResize);
Kode lerroa:     eventBus.off('hashchange', webViewerHashchange);
Kode lerroa:     eventBus.off('beforeprint', _boundEvents.beforePrint);
Kode lerroa:     eventBus.off('afterprint', _boundEvents.afterPrint);
Kode lerroa:     eventBus.off('pagerendered', webViewerPageRendered);
Kode lerroa:     eventBus.off('textlayerrendered', webViewerTextLayerRendered);
Kode lerroa:     eventBus.off('updateviewarea', webViewerUpdateViewarea);
Kode lerroa:     eventBus.off('pagechanging', webViewerPageChanging);
Kode lerroa:     eventBus.off('scalechanging', webViewerScaleChanging);
Kode lerroa:     eventBus.off('rotationchanging', webViewerRotationChanging);
Kode lerroa:     eventBus.off('sidebarviewchanged', webViewerSidebarViewChanged);
Kode lerroa:     eventBus.off('pagemode', webViewerPageMode);
Kode lerroa:     eventBus.off('namedaction', webViewerNamedAction);
Kode lerroa:     eventBus.off('presentationmodechanged', webViewerPresentationModeChanged);
Kode lerroa:     eventBus.off('presentationmode', webViewerPresentationMode);
Kode lerroa:     eventBus.off('openfile', webViewerOpenFile);
Kode lerroa:     eventBus.off('print', webViewerPrint);
Kode lerroa:     eventBus.off('download', webViewerDownload);
Kode lerroa:     eventBus.off('firstpage', webViewerFirstPage);
Kode lerroa:     eventBus.off('lastpage', webViewerLastPage);
Kode lerroa:     eventBus.off('nextpage', webViewerNextPage);
Kode lerroa:     eventBus.off('previouspage', webViewerPreviousPage);
Kode lerroa:     eventBus.off('zoomin', webViewerZoomIn);
Kode lerroa:     eventBus.off('zoomout', webViewerZoomOut);
Kode lerroa:     eventBus.off('pagenumberchanged', webViewerPageNumberChanged);
Kode lerroa:     eventBus.off('scalechanged', webViewerScaleChanged);
Kode lerroa:     eventBus.off('rotatecw', webViewerRotateCw);
Kode lerroa:     eventBus.off('rotateccw', webViewerRotateCcw);
Kode lerroa:     eventBus.off('documentproperties', webViewerDocumentProperties);
Kode lerroa:     eventBus.off('find', webViewerFind);
Kode lerroa:     eventBus.off('findfromurlhash', webViewerFindFromUrlHash);
Kode lerroa:     eventBus.off('fileinputchange', webViewerFileInputChange);
Kode lerroa:     _boundEvents.beforePrint = null;
Kode lerroa:     _boundEvents.afterPrint = null;
Kode lerroa:   },
Kode lerroa:   unbindWindowEvents: function unbindWindowEvents() {
Kode lerroa:     var _boundEvents = this._boundEvents;
Kode lerroa: 
Kode lerroa:     window.removeEventListener('wheel', webViewerWheel);
Kode lerroa:     window.removeEventListener('click', webViewerClick);
Kode lerroa:     window.removeEventListener('keydown', webViewerKeyDown);
Kode lerroa:     window.removeEventListener('resize', _boundEvents.windowResize);
Kode lerroa:     window.removeEventListener('hashchange', _boundEvents.windowHashChange);
Kode lerroa:     window.removeEventListener('beforeprint', _boundEvents.windowBeforePrint);
Kode lerroa:     window.removeEventListener('afterprint', _boundEvents.windowAfterPrint);
Kode lerroa:     _boundEvents.windowResize = null;
Kode lerroa:     _boundEvents.windowHashChange = null;
Kode lerroa:     _boundEvents.windowBeforePrint = null;
Kode lerroa:     _boundEvents.windowAfterPrint = null;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var validateFileURL = void 0;
Kode lerroa: {
Kode lerroa:   var HOSTED_VIEWER_ORIGINS = ['null', 'http://mozilla.github.io', 'https://mozilla.github.io'];
Kode lerroa:   validateFileURL = function validateFileURL(file) {
Kode lerroa:     if (file === undefined) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     try {
Kode lerroa:       var viewerOrigin = new URL(window.location.href).origin || 'null';
Kode lerroa:       if (HOSTED_VIEWER_ORIGINS.indexOf(viewerOrigin) >= 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var fileOrigin = new URL(file, window.location.href).origin;
Kode lerroa:       /* if (fileOrigin !== viewerOrigin) {
Kode lerroa:         throw new Error('file origin does not match viewer\'s');
Kode lerroa:       } */
Kode lerroa:     } catch (ex) {
Kode lerroa:       var message = ex && ex.message;
Kode lerroa:       PDFViewerApplication.l10n.get('loading_error', null, 'An error occurred while loading the PDF.').then(function (loadingErrorMessage) {
Kode lerroa:         PDFViewerApplication.error(loadingErrorMessage, { message: message });
Kode lerroa:       });
Kode lerroa:       throw ex;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function loadAndEnablePDFBug(enabledTabs) {
Kode lerroa:   return new Promise(function (resolve, reject) {
Kode lerroa:     var appConfig = PDFViewerApplication.appConfig;
Kode lerroa:     var script = document.createElement('script');
Kode lerroa:     script.src = appConfig.debuggerScriptPath;
Kode lerroa:     script.onload = function () {
Kode lerroa:       PDFBug.enable(enabledTabs);
Kode lerroa:       PDFBug.init({
Kode lerroa:         PDFJS: _pdfjsLib.PDFJS,
Kode lerroa:         OPS: _pdfjsLib.OPS
Kode lerroa:       }, appConfig.mainContainer);
Kode lerroa:       resolve();
Kode lerroa:     };
Kode lerroa:     script.onerror = function () {
Kode lerroa:       reject(new Error('Cannot load debugger at ' + script.src));
Kode lerroa:     };
Kode lerroa:     (document.getElementsByTagName('head')[0] || document.body).appendChild(script);
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function webViewerInitialized() {
Kode lerroa:   var appConfig = PDFViewerApplication.appConfig;
Kode lerroa:   var file = void 0;
Kode lerroa:   var queryString = document.location.search.substring(1);
Kode lerroa:   var params = (0, _ui_utils.parseQueryString)(queryString);
Kode lerroa:   file = 'file' in params ? params.file : appConfig.defaultUrl;
Kode lerroa:   validateFileURL(file);
Kode lerroa:   var waitForBeforeOpening = [];
Kode lerroa:   var fileInput = document.createElement('input');
Kode lerroa:   fileInput.id = appConfig.openFileInputName;
Kode lerroa:   fileInput.className = 'fileInput';
Kode lerroa:   fileInput.setAttribute('type', 'file');
Kode lerroa:   fileInput.oncontextmenu = _ui_utils.noContextMenuHandler;
Kode lerroa:   document.body.appendChild(fileInput);
Kode lerroa:   if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
Kode lerroa:     appConfig.toolbar.openFile.setAttribute('hidden', 'true');
Kode lerroa:     appConfig.secondaryToolbar.openFileButton.setAttribute('hidden', 'true');
Kode lerroa:   } else {
Kode lerroa:     fileInput.value = null;
Kode lerroa:   }
Kode lerroa:   fileInput.addEventListener('change', function (evt) {
Kode lerroa:     var files = evt.target.files;
Kode lerroa:     if (!files || files.length === 0) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     PDFViewerApplication.eventBus.dispatch('fileinputchange', { fileInput: evt.target });
Kode lerroa:   });
Kode lerroa:   if (PDFViewerApplication.viewerPrefs['pdfBugEnabled']) {
Kode lerroa:     var hash = document.location.hash.substring(1);
Kode lerroa:     var hashParams = (0, _ui_utils.parseQueryString)(hash);
Kode lerroa:     if ('disableworker' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableWorker = hashParams['disableworker'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('disablerange' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableRange = hashParams['disablerange'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('disablestream' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableStream = hashParams['disablestream'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('disableautofetch' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableAutoFetch = hashParams['disableautofetch'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('disablefontface' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableFontFace = hashParams['disablefontface'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('disablehistory' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableHistory = hashParams['disablehistory'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('webgl' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.disableWebGL = hashParams['webgl'] !== 'true';
Kode lerroa:     }
Kode lerroa:     if ('useonlycsszoom' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.useOnlyCssZoom = hashParams['useonlycsszoom'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('verbosity' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.verbosity = hashParams['verbosity'] | 0;
Kode lerroa:     }
Kode lerroa:     if ('ignorecurrentpositiononzoom' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.ignoreCurrentPositionOnZoom = hashParams['ignorecurrentpositiononzoom'] === 'true';
Kode lerroa:     }
Kode lerroa:     if ('textlayer' in hashParams) {
Kode lerroa:       switch (hashParams['textlayer']) {
Kode lerroa:         case 'off':
Kode lerroa:           _pdfjsLib.PDFJS.disableTextLayer = true;
Kode lerroa:           break;
Kode lerroa:         case 'visible':
Kode lerroa:         case 'shadow':
Kode lerroa:         case 'hover':
Kode lerroa:           var viewer = appConfig.viewerContainer;
Kode lerroa:           viewer.classList.add('textLayer-' + hashParams['textlayer']);
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if ('pdfbug' in hashParams) {
Kode lerroa:       _pdfjsLib.PDFJS.pdfBug = true;
Kode lerroa:       var pdfBug = hashParams['pdfbug'];
Kode lerroa:       var enabled = pdfBug.split(',');
Kode lerroa:       waitForBeforeOpening.push(loadAndEnablePDFBug(enabled));
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (!PDFViewerApplication.supportsPrinting) {
Kode lerroa:     appConfig.toolbar.print.classList.add('hidden');
Kode lerroa:     appConfig.secondaryToolbar.printButton.classList.add('hidden');
Kode lerroa:   }
Kode lerroa:   if (!PDFViewerApplication.supportsFullscreen) {
Kode lerroa:     appConfig.toolbar.presentationModeButton.classList.add('hidden');
Kode lerroa:     appConfig.secondaryToolbar.presentationModeButton.classList.add('hidden');
Kode lerroa:   }
Kode lerroa:   if (PDFViewerApplication.supportsIntegratedFind) {
Kode lerroa:     appConfig.toolbar.viewFind.classList.add('hidden');
Kode lerroa:   }
Kode lerroa:   appConfig.sidebar.mainContainer.addEventListener('transitionend', function (evt) {
Kode lerroa:     if (evt.target === this) {
Kode lerroa:       PDFViewerApplication.eventBus.dispatch('resize');
Kode lerroa:     }
Kode lerroa:   }, true);
Kode lerroa:   appConfig.sidebar.toggleButton.addEventListener('click', function () {
Kode lerroa:     PDFViewerApplication.pdfSidebar.toggle();
Kode lerroa:   });
Kode lerroa:   Promise.all(waitForBeforeOpening).then(function () {
Kode lerroa:     webViewerOpenFileViaURL(file);
Kode lerroa:   }).catch(function (reason) {
Kode lerroa:     PDFViewerApplication.l10n.get('loading_error', null, 'An error occurred while opening.').then(function (msg) {
Kode lerroa:       PDFViewerApplication.error(msg, reason);
Kode lerroa:     });
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: var webViewerOpenFileViaURL = void 0;
Kode lerroa: {
Kode lerroa:   webViewerOpenFileViaURL = function webViewerOpenFileViaURL(file) {
Kode lerroa:     if (file && file.lastIndexOf('file:', 0) === 0) {
Kode lerroa:       PDFViewerApplication.setTitleUsingUrl(file);
Kode lerroa:       var xhr = new XMLHttpRequest();
Kode lerroa:       xhr.onload = function () {
Kode lerroa:         PDFViewerApplication.open(new Uint8Array(xhr.response));
Kode lerroa:       };
Kode lerroa:       try {
Kode lerroa:         xhr.open('GET', file);
Kode lerroa:         xhr.responseType = 'arraybuffer';
Kode lerroa:         xhr.send();
Kode lerroa:       } catch (ex) {
Kode lerroa:         PDFViewerApplication.l10n.get('loading_error', null, 'An error occurred while loading the PDF.').then(function (msg) {
Kode lerroa:           PDFViewerApplication.error(msg, ex);
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (file) {
Kode lerroa:       PDFViewerApplication.open(file);
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function webViewerPageRendered(evt) {
Kode lerroa:   var pageNumber = evt.pageNumber;
Kode lerroa:   var pageIndex = pageNumber - 1;
Kode lerroa:   var pageView = PDFViewerApplication.pdfViewer.getPageView(pageIndex);
Kode lerroa:   if (pageNumber === PDFViewerApplication.page) {
Kode lerroa:     PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);
Kode lerroa:   }
Kode lerroa:   if (!pageView) {
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
Kode lerroa:     var thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageIndex);
Kode lerroa:     thumbnailView.setImage(pageView);
Kode lerroa:   }
Kode lerroa:   if (_pdfjsLib.PDFJS.pdfBug && Stats.enabled && pageView.stats) {
Kode lerroa:     Stats.add(pageNumber, pageView.stats);
Kode lerroa:   }
Kode lerroa:   if (pageView.error) {
Kode lerroa:     PDFViewerApplication.l10n.get('rendering_error', null, 'An error occurred while rendering the page.').then(function (msg) {
Kode lerroa:       PDFViewerApplication.error(msg, pageView.error);
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerTextLayerRendered(evt) {}
Kode lerroa: function webViewerPageMode(evt) {
Kode lerroa:   var mode = evt.mode,
Kode lerroa:       view = void 0;
Kode lerroa:   switch (mode) {
Kode lerroa:     case 'thumbs':
Kode lerroa:       view = _pdf_sidebar.SidebarView.THUMBS;
Kode lerroa:       break;
Kode lerroa:     case 'bookmarks':
Kode lerroa:     case 'outline':
Kode lerroa:       view = _pdf_sidebar.SidebarView.OUTLINE;
Kode lerroa:       break;
Kode lerroa:     case 'attachments':
Kode lerroa:       view = _pdf_sidebar.SidebarView.ATTACHMENTS;
Kode lerroa:       break;
Kode lerroa:     case 'none':
Kode lerroa:       view = _pdf_sidebar.SidebarView.NONE;
Kode lerroa:       break;
Kode lerroa:     default:
Kode lerroa:       console.error('Invalid "pagemode" hash parameter: ' + mode);
Kode lerroa:       return;
Kode lerroa:   }
Kode lerroa:   PDFViewerApplication.pdfSidebar.switchView(view, true);
Kode lerroa: }
Kode lerroa: function webViewerNamedAction(evt) {
Kode lerroa:   var action = evt.action;
Kode lerroa:   switch (action) {
Kode lerroa:     case 'GoToPage':
Kode lerroa:       PDFViewerApplication.appConfig.toolbar.pageNumber.select();
Kode lerroa:       break;
Kode lerroa:     case 'Find':
Kode lerroa:       if (!PDFViewerApplication.supportsIntegratedFind) {
Kode lerroa:         PDFViewerApplication.findBar.toggle();
Kode lerroa:       }
Kode lerroa:       break;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerPresentationModeChanged(evt) {
Kode lerroa:   var active = evt.active,
Kode lerroa:       switchInProgress = evt.switchInProgress;
Kode lerroa: 
Kode lerroa:   PDFViewerApplication.pdfViewer.presentationModeState = switchInProgress ? _ui_utils.PresentationModeState.CHANGING : active ? _ui_utils.PresentationModeState.FULLSCREEN : _ui_utils.PresentationModeState.NORMAL;
Kode lerroa: }
Kode lerroa: function webViewerSidebarViewChanged(evt) {
Kode lerroa:   PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;
Kode lerroa:   var store = PDFViewerApplication.store;
Kode lerroa:   if (store && PDFViewerApplication.isInitialViewSet) {
Kode lerroa:     store.set('sidebarView', evt.view).catch(function () {});
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerUpdateViewarea(evt) {
Kode lerroa:   var location = evt.location,
Kode lerroa:       store = PDFViewerApplication.store;
Kode lerroa:   if (store && PDFViewerApplication.isInitialViewSet) {
Kode lerroa:     store.setMultiple({
Kode lerroa:       'exists': true,
Kode lerroa:       'page': location.pageNumber,
Kode lerroa:       'zoom': location.scale,
Kode lerroa:       'scrollLeft': location.left,
Kode lerroa:       'scrollTop': location.top,
Kode lerroa:       'rotation': location.rotation
Kode lerroa:     }).catch(function () {});
Kode lerroa:   }
Kode lerroa:   var href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);
Kode lerroa:   PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;
Kode lerroa:   PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;
Kode lerroa:   var currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);
Kode lerroa:   var loading = currentPage.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED;
Kode lerroa:   PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);
Kode lerroa: }
Kode lerroa: function webViewerResize() {
Kode lerroa:   var pdfDocument = PDFViewerApplication.pdfDocument,
Kode lerroa:       pdfViewer = PDFViewerApplication.pdfViewer;
Kode lerroa: 
Kode lerroa:   if (!pdfDocument) {
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   var currentScaleValue = pdfViewer.currentScaleValue;
Kode lerroa:   if (currentScaleValue === 'auto' || currentScaleValue === 'page-fit' || currentScaleValue === 'page-width') {
Kode lerroa:     pdfViewer.currentScaleValue = currentScaleValue;
Kode lerroa:   }
Kode lerroa:   pdfViewer.update();
Kode lerroa: }
Kode lerroa: function webViewerHashchange(evt) {
Kode lerroa:   var hash = evt.hash;
Kode lerroa:   if (!hash) {
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   if (!PDFViewerApplication.isInitialViewSet) {
Kode lerroa:     PDFViewerApplication.initialBookmark = hash;
Kode lerroa:   } else if (!PDFViewerApplication.pdfHistory.popStateInProgress) {
Kode lerroa:     PDFViewerApplication.pdfLinkService.setHash(hash);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var webViewerFileInputChange = void 0;
Kode lerroa: {
Kode lerroa:   webViewerFileInputChange = function webViewerFileInputChange(evt) {
Kode lerroa:     var file = evt.fileInput.files[0];
Kode lerroa:     if (!_pdfjsLib.PDFJS.disableCreateObjectURL && URL.createObjectURL) {
Kode lerroa:       PDFViewerApplication.open(URL.createObjectURL(file));
Kode lerroa:     } else {
Kode lerroa:       var fileReader = new FileReader();
Kode lerroa:       fileReader.onload = function webViewerChangeFileReaderOnload(evt) {
Kode lerroa:         var buffer = evt.target.result;
Kode lerroa:         PDFViewerApplication.open(new Uint8Array(buffer));
Kode lerroa:       };
Kode lerroa:       fileReader.readAsArrayBuffer(file);
Kode lerroa:     }
Kode lerroa:     PDFViewerApplication.setTitleUsingUrl(file.name);
Kode lerroa:     var appConfig = PDFViewerApplication.appConfig;
Kode lerroa:     appConfig.toolbar.viewBookmark.setAttribute('hidden', 'true');
Kode lerroa:     appConfig.secondaryToolbar.viewBookmarkButton.setAttribute('hidden', 'true');
Kode lerroa:     appConfig.toolbar.download.setAttribute('hidden', 'true');
Kode lerroa:     appConfig.secondaryToolbar.downloadButton.setAttribute('hidden', 'true');
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function webViewerPresentationMode() {
Kode lerroa:   PDFViewerApplication.requestPresentationMode();
Kode lerroa: }
Kode lerroa: function webViewerOpenFile() {
Kode lerroa:   var openFileInputName = PDFViewerApplication.appConfig.openFileInputName;
Kode lerroa:   document.getElementById(openFileInputName).click();
Kode lerroa: }
Kode lerroa: function webViewerPrint() {
Kode lerroa:   window.print();
Kode lerroa: }
Kode lerroa: function webViewerDownload() {
Kode lerroa:   PDFViewerApplication.download();
Kode lerroa: }
Kode lerroa: function webViewerFirstPage() {
Kode lerroa:   if (PDFViewerApplication.pdfDocument) {
Kode lerroa:     PDFViewerApplication.page = 1;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerLastPage() {
Kode lerroa:   if (PDFViewerApplication.pdfDocument) {
Kode lerroa:     PDFViewerApplication.page = PDFViewerApplication.pagesCount;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerNextPage() {
Kode lerroa:   PDFViewerApplication.page++;
Kode lerroa: }
Kode lerroa: function webViewerPreviousPage() {
Kode lerroa:   PDFViewerApplication.page--;
Kode lerroa: }
Kode lerroa: function webViewerZoomIn() {
Kode lerroa:   PDFViewerApplication.zoomIn();
Kode lerroa: }
Kode lerroa: function webViewerZoomOut() {
Kode lerroa:   PDFViewerApplication.zoomOut();
Kode lerroa: }
Kode lerroa: function webViewerPageNumberChanged(evt) {
Kode lerroa:   var pdfViewer = PDFViewerApplication.pdfViewer;
Kode lerroa:   pdfViewer.currentPageLabel = evt.value;
Kode lerroa:   if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {
Kode lerroa:     PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerScaleChanged(evt) {
Kode lerroa:   PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;
Kode lerroa: }
Kode lerroa: function webViewerRotateCw() {
Kode lerroa:   PDFViewerApplication.rotatePages(90);
Kode lerroa: }
Kode lerroa: function webViewerRotateCcw() {
Kode lerroa:   PDFViewerApplication.rotatePages(-90);
Kode lerroa: }
Kode lerroa: function webViewerDocumentProperties() {
Kode lerroa:   PDFViewerApplication.pdfDocumentProperties.open();
Kode lerroa: }
Kode lerroa: function webViewerFind(evt) {
Kode lerroa:   PDFViewerApplication.findController.executeCommand('find' + evt.type, {
Kode lerroa:     query: evt.query,
Kode lerroa:     phraseSearch: evt.phraseSearch,
Kode lerroa:     caseSensitive: evt.caseSensitive,
Kode lerroa:     highlightAll: evt.highlightAll,
Kode lerroa:     findPrevious: evt.findPrevious
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function webViewerFindFromUrlHash(evt) {
Kode lerroa:   PDFViewerApplication.findController.executeCommand('find', {
Kode lerroa:     query: evt.query,
Kode lerroa:     phraseSearch: evt.phraseSearch,
Kode lerroa:     caseSensitive: false,
Kode lerroa:     highlightAll: true,
Kode lerroa:     findPrevious: false
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function webViewerScaleChanging(evt) {
Kode lerroa:   PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);
Kode lerroa:   PDFViewerApplication.pdfViewer.update();
Kode lerroa: }
Kode lerroa: function webViewerRotationChanging(evt) {
Kode lerroa:   PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;
Kode lerroa:   PDFViewerApplication.forceRendering();
Kode lerroa:   PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;
Kode lerroa: }
Kode lerroa: function webViewerPageChanging(evt) {
Kode lerroa:   var page = evt.pageNumber;
Kode lerroa:   PDFViewerApplication.toolbar.setPageNumber(page, evt.pageLabel || null);
Kode lerroa:   PDFViewerApplication.secondaryToolbar.setPageNumber(page);
Kode lerroa:   if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
Kode lerroa:     PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(page);
Kode lerroa:   }
Kode lerroa:   if (_pdfjsLib.PDFJS.pdfBug && Stats.enabled) {
Kode lerroa:     var pageView = PDFViewerApplication.pdfViewer.getPageView(page - 1);
Kode lerroa:     if (pageView.stats) {
Kode lerroa:       Stats.add(page, pageView.stats);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: var zoomDisabled = false,
Kode lerroa:     zoomDisabledTimeout = void 0;
Kode lerroa: function webViewerWheel(evt) {
Kode lerroa:   var pdfViewer = PDFViewerApplication.pdfViewer;
Kode lerroa:   if (pdfViewer.isInPresentationMode) {
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   if (evt.ctrlKey || evt.metaKey) {
Kode lerroa:     var support = PDFViewerApplication.supportedMouseWheelZoomModifierKeys;
Kode lerroa:     if (evt.ctrlKey && !support.ctrlKey || evt.metaKey && !support.metaKey) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     evt.preventDefault();
Kode lerroa:     if (zoomDisabled) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var previousScale = pdfViewer.currentScale;
Kode lerroa:     var delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
Kode lerroa:     var MOUSE_WHEEL_DELTA_PER_PAGE_SCALE = 3.0;
Kode lerroa:     var ticks = delta * MOUSE_WHEEL_DELTA_PER_PAGE_SCALE;
Kode lerroa:     if (ticks < 0) {
Kode lerroa:       PDFViewerApplication.zoomOut(-ticks);
Kode lerroa:     } else {
Kode lerroa:       PDFViewerApplication.zoomIn(ticks);
Kode lerroa:     }
Kode lerroa:     var currentScale = pdfViewer.currentScale;
Kode lerroa:     if (previousScale !== currentScale) {
Kode lerroa:       var scaleCorrectionFactor = currentScale / previousScale - 1;
Kode lerroa:       var rect = pdfViewer.container.getBoundingClientRect();
Kode lerroa:       var dx = evt.clientX - rect.left;
Kode lerroa:       var dy = evt.clientY - rect.top;
Kode lerroa:       pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;
Kode lerroa:       pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;
Kode lerroa:     }
Kode lerroa:   } else {
Kode lerroa:     zoomDisabled = true;
Kode lerroa:     clearTimeout(zoomDisabledTimeout);
Kode lerroa:     zoomDisabledTimeout = setTimeout(function () {
Kode lerroa:       zoomDisabled = false;
Kode lerroa:     }, 1000);
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerClick(evt) {
Kode lerroa:   if (!PDFViewerApplication.secondaryToolbar.isOpen) {
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   var appConfig = PDFViewerApplication.appConfig;
Kode lerroa:   if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {
Kode lerroa:     PDFViewerApplication.secondaryToolbar.close();
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function webViewerKeyDown(evt) {
Kode lerroa:   if (PDFViewerApplication.overlayManager.active) {
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   var handled = false,
Kode lerroa:       ensureViewerFocused = false;
Kode lerroa:   var cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);
Kode lerroa:   var pdfViewer = PDFViewerApplication.pdfViewer;
Kode lerroa:   var isViewerInPresentationMode = pdfViewer && pdfViewer.isInPresentationMode;
Kode lerroa:   if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {
Kode lerroa:     switch (evt.keyCode) {
Kode lerroa:       case 70:
Kode lerroa:         if (!PDFViewerApplication.supportsIntegratedFind) {
Kode lerroa:           PDFViewerApplication.findBar.open();
Kode lerroa:           handled = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 71:
Kode lerroa:         if (!PDFViewerApplication.supportsIntegratedFind) {
Kode lerroa:           var findState = PDFViewerApplication.findController.state;
Kode lerroa:           if (findState) {
Kode lerroa:             PDFViewerApplication.findController.executeCommand('findagain', {
Kode lerroa:               query: findState.query,
Kode lerroa:               phraseSearch: findState.phraseSearch,
Kode lerroa:               caseSensitive: findState.caseSensitive,
Kode lerroa:               highlightAll: findState.highlightAll,
Kode lerroa:               findPrevious: cmd === 5 || cmd === 12
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:           handled = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 61:
Kode lerroa:       case 107:
Kode lerroa:       case 187:
Kode lerroa:       case 171:
Kode lerroa:         if (!isViewerInPresentationMode) {
Kode lerroa:           PDFViewerApplication.zoomIn();
Kode lerroa:         }
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:       case 173:
Kode lerroa:       case 109:
Kode lerroa:       case 189:
Kode lerroa:         if (!isViewerInPresentationMode) {
Kode lerroa:           PDFViewerApplication.zoomOut();
Kode lerroa:         }
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:       case 48:
Kode lerroa:       case 96:
Kode lerroa:         if (!isViewerInPresentationMode) {
Kode lerroa:           setTimeout(function () {
Kode lerroa:             pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
Kode lerroa:           });
Kode lerroa:           handled = false;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 38:
Kode lerroa:         if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
Kode lerroa:           PDFViewerApplication.page = 1;
Kode lerroa:           handled = true;
Kode lerroa:           ensureViewerFocused = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 40:
Kode lerroa:         if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
Kode lerroa:           PDFViewerApplication.page = PDFViewerApplication.pagesCount;
Kode lerroa:           handled = true;
Kode lerroa:           ensureViewerFocused = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (cmd === 1 || cmd === 8) {
Kode lerroa:     switch (evt.keyCode) {
Kode lerroa:       case 83:
Kode lerroa:         PDFViewerApplication.download();
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (cmd === 3 || cmd === 10) {
Kode lerroa:     switch (evt.keyCode) {
Kode lerroa:       case 80:
Kode lerroa:         PDFViewerApplication.requestPresentationMode();
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:       case 71:
Kode lerroa:         PDFViewerApplication.appConfig.toolbar.pageNumber.select();
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (handled) {
Kode lerroa:     if (ensureViewerFocused && !isViewerInPresentationMode) {
Kode lerroa:       pdfViewer.focus();
Kode lerroa:     }
Kode lerroa:     evt.preventDefault();
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   var curElement = document.activeElement || document.querySelector(':focus');
Kode lerroa:   var curElementTagName = curElement && curElement.tagName.toUpperCase();
Kode lerroa:   if (curElementTagName === 'INPUT' || curElementTagName === 'TEXTAREA' || curElementTagName === 'SELECT') {
Kode lerroa:     if (evt.keyCode !== 27) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (cmd === 0) {
Kode lerroa:     switch (evt.keyCode) {
Kode lerroa:       case 38:
Kode lerroa:       case 33:
Kode lerroa:       case 8:
Kode lerroa:         if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== 'page-fit') {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       case 37:
Kode lerroa:         if (pdfViewer.isHorizontalScrollbarEnabled) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       case 75:
Kode lerroa:       case 80:
Kode lerroa:         if (PDFViewerApplication.page > 1) {
Kode lerroa:           PDFViewerApplication.page--;
Kode lerroa:         }
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:       case 27:
Kode lerroa:         if (PDFViewerApplication.secondaryToolbar.isOpen) {
Kode lerroa:           PDFViewerApplication.secondaryToolbar.close();
Kode lerroa:           handled = true;
Kode lerroa:         }
Kode lerroa:         if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {
Kode lerroa:           PDFViewerApplication.findBar.close();
Kode lerroa:           handled = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 40:
Kode lerroa:       case 34:
Kode lerroa:       case 32:
Kode lerroa:         if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== 'page-fit') {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       case 39:
Kode lerroa:         if (pdfViewer.isHorizontalScrollbarEnabled) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       case 74:
Kode lerroa:       case 78:
Kode lerroa:         if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
Kode lerroa:           PDFViewerApplication.page++;
Kode lerroa:         }
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:       case 36:
Kode lerroa:         if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
Kode lerroa:           PDFViewerApplication.page = 1;
Kode lerroa:           handled = true;
Kode lerroa:           ensureViewerFocused = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 35:
Kode lerroa:         if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
Kode lerroa:           PDFViewerApplication.page = PDFViewerApplication.pagesCount;
Kode lerroa:           handled = true;
Kode lerroa:           ensureViewerFocused = true;
Kode lerroa:         }
Kode lerroa:         break;
Kode lerroa:       case 83:
Kode lerroa:         PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.SELECT);
Kode lerroa:         break;
Kode lerroa:       case 72:
Kode lerroa:         PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.HAND);
Kode lerroa:         break;
Kode lerroa:       case 82:
Kode lerroa:         PDFViewerApplication.rotatePages(90);
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (cmd === 4) {
Kode lerroa:     switch (evt.keyCode) {
Kode lerroa:       case 32:
Kode lerroa:         if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== 'page-fit') {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         if (PDFViewerApplication.page > 1) {
Kode lerroa:           PDFViewerApplication.page--;
Kode lerroa:         }
Kode lerroa:         handled = true;
Kode lerroa:         break;
Kode lerroa:       case 82:
Kode lerroa:         PDFViewerApplication.rotatePages(-90);
Kode lerroa:         break;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (!handled && !isViewerInPresentationMode) {
Kode lerroa:     if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== 'BUTTON') {
Kode lerroa:       ensureViewerFocused = true;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {
Kode lerroa:     pdfViewer.focus();
Kode lerroa:   }
Kode lerroa:   if (handled) {
Kode lerroa:     evt.preventDefault();
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function apiPageModeToSidebarView(mode) {
Kode lerroa:   switch (mode) {
Kode lerroa:     case 'UseNone':
Kode lerroa:       return _pdf_sidebar.SidebarView.NONE;
Kode lerroa:     case 'UseThumbs':
Kode lerroa:       return _pdf_sidebar.SidebarView.THUMBS;
Kode lerroa:     case 'UseOutlines':
Kode lerroa:       return _pdf_sidebar.SidebarView.OUTLINE;
Kode lerroa:     case 'UseAttachments':
Kode lerroa:       return _pdf_sidebar.SidebarView.ATTACHMENTS;
Kode lerroa:     case 'UseOC':
Kode lerroa:   }
Kode lerroa:   return _pdf_sidebar.SidebarView.NONE;
Kode lerroa: }
Kode lerroa: var PDFPrintServiceFactory = {
Kode lerroa:   instance: {
Kode lerroa:     supportsPrinting: false,
Kode lerroa:     createPrintService: function createPrintService() {
Kode lerroa:       throw new Error('Not implemented: createPrintService');
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: exports.PDFViewerApplication = PDFViewerApplication;
Kode lerroa: exports.DefaultExternalServices = DefaultExternalServices;
Kode lerroa: exports.PDFPrintServiceFactory = PDFPrintServiceFactory;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 5 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.SimpleLinkService = exports.PDFLinkService = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _dom_events = __webpack_require__(2);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var PDFLinkService = function () {
Kode lerroa:   function PDFLinkService() {
Kode lerroa:     var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
Kode lerroa:         eventBus = _ref.eventBus;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFLinkService);
Kode lerroa: 
Kode lerroa:     this.eventBus = eventBus || (0, _dom_events.getGlobalEventBus)();
Kode lerroa:     this.baseUrl = null;
Kode lerroa:     this.pdfDocument = null;
Kode lerroa:     this.pdfViewer = null;
Kode lerroa:     this.pdfHistory = null;
Kode lerroa:     this._pagesRefCache = null;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFLinkService, [{
Kode lerroa:     key: 'setDocument',
Kode lerroa:     value: function setDocument(pdfDocument, baseUrl) {
Kode lerroa:       this.baseUrl = baseUrl;
Kode lerroa:       this.pdfDocument = pdfDocument;
Kode lerroa:       this._pagesRefCache = Object.create(null);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setViewer',
Kode lerroa:     value: function setViewer(pdfViewer) {
Kode lerroa:       this.pdfViewer = pdfViewer;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setHistory',
Kode lerroa:     value: function setHistory(pdfHistory) {
Kode lerroa:       this.pdfHistory = pdfHistory;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'navigateTo',
Kode lerroa:     value: function navigateTo(dest) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var goToDestination = function goToDestination(_ref2) {
Kode lerroa:         var namedDest = _ref2.namedDest,
Kode lerroa:             explicitDest = _ref2.explicitDest;
Kode lerroa: 
Kode lerroa:         var destRef = explicitDest[0],
Kode lerroa:             pageNumber = void 0;
Kode lerroa:         if (destRef instanceof Object) {
Kode lerroa:           pageNumber = _this._cachedPageNumber(destRef);
Kode lerroa:           if (pageNumber === null) {
Kode lerroa:             _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
Kode lerroa:               _this.cachePageRef(pageIndex + 1, destRef);
Kode lerroa:               goToDestination({
Kode lerroa:                 namedDest: namedDest,
Kode lerroa:                 explicitDest: explicitDest
Kode lerroa:               });
Kode lerroa:             }).catch(function () {
Kode lerroa:               console.error('PDFLinkService.navigateTo: "' + destRef + '" is not ' + ('a valid page reference, for dest="' + dest + '".'));
Kode lerroa:             });
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:         } else if (Number.isInteger(destRef)) {
Kode lerroa:           pageNumber = destRef + 1;
Kode lerroa:         } else {
Kode lerroa:           console.error('PDFLinkService.navigateTo: "' + destRef + '" is not ' + ('a valid destination reference, for dest="' + dest + '".'));
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (!pageNumber || pageNumber < 1 || pageNumber > _this.pagesCount) {
Kode lerroa:           console.error('PDFLinkService.navigateTo: "' + pageNumber + '" is not ' + ('a valid page number, for dest="' + dest + '".'));
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (_this.pdfHistory) {
Kode lerroa:           _this.pdfHistory.pushCurrentPosition();
Kode lerroa:           _this.pdfHistory.push({
Kode lerroa:             namedDest: namedDest,
Kode lerroa:             explicitDest: explicitDest,
Kode lerroa:             pageNumber: pageNumber
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         _this.pdfViewer.scrollPageIntoView({
Kode lerroa:           pageNumber: pageNumber,
Kode lerroa:           destArray: explicitDest
Kode lerroa:         });
Kode lerroa:       };
Kode lerroa:       new Promise(function (resolve, reject) {
Kode lerroa:         if (typeof dest === 'string') {
Kode lerroa:           _this.pdfDocument.getDestination(dest).then(function (destArray) {
Kode lerroa:             resolve({
Kode lerroa:               namedDest: dest,
Kode lerroa:               explicitDest: destArray
Kode lerroa:             });
Kode lerroa:           });
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         resolve({
Kode lerroa:           namedDest: '',
Kode lerroa:           explicitDest: dest
Kode lerroa:         });
Kode lerroa:       }).then(function (data) {
Kode lerroa:         if (!(data.explicitDest instanceof Array)) {
Kode lerroa:           console.error('PDFLinkService.navigateTo: "' + data.explicitDest + '" is' + (' not a valid destination array, for dest="' + dest + '".'));
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         goToDestination(data);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getDestinationHash',
Kode lerroa:     value: function getDestinationHash(dest) {
Kode lerroa:       if (typeof dest === 'string') {
Kode lerroa:         return this.getAnchorUrl('#' + escape(dest));
Kode lerroa:       }
Kode lerroa:       if (dest instanceof Array) {
Kode lerroa:         var str = JSON.stringify(dest);
Kode lerroa:         return this.getAnchorUrl('#' + escape(str));
Kode lerroa:       }
Kode lerroa:       return this.getAnchorUrl('');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getAnchorUrl',
Kode lerroa:     value: function getAnchorUrl(anchor) {
Kode lerroa:       return (this.baseUrl || '') + anchor;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setHash',
Kode lerroa:     value: function setHash(hash) {
Kode lerroa:       var pageNumber = void 0,
Kode lerroa:           dest = void 0;
Kode lerroa:       if (hash.indexOf('=') >= 0) {
Kode lerroa:         var params = (0, _ui_utils.parseQueryString)(hash);
Kode lerroa:         if ('search' in params) {
Kode lerroa:           this.eventBus.dispatch('findfromurlhash', {
Kode lerroa:             source: this,
Kode lerroa:             query: params['search'].replace(/"/g, ''),
Kode lerroa:             phraseSearch: params['phrase'] === 'true'
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         if ('nameddest' in params) {
Kode lerroa:           this.navigateTo(params.nameddest);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if ('page' in params) {
Kode lerroa:           pageNumber = params.page | 0 || 1;
Kode lerroa:         }
Kode lerroa:         if ('zoom' in params) {
Kode lerroa:           var zoomArgs = params.zoom.split(',');
Kode lerroa:           var zoomArg = zoomArgs[0];
Kode lerroa:           var zoomArgNumber = parseFloat(zoomArg);
Kode lerroa:           if (zoomArg.indexOf('Fit') === -1) {
Kode lerroa:             dest = [null, { name: 'XYZ' }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
Kode lerroa:           } else {
Kode lerroa:             if (zoomArg === 'Fit' || zoomArg === 'FitB') {
Kode lerroa:               dest = [null, { name: zoomArg }];
Kode lerroa:             } else if (zoomArg === 'FitH' || zoomArg === 'FitBH' || zoomArg === 'FitV' || zoomArg === 'FitBV') {
Kode lerroa:               dest = [null, { name: zoomArg }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
Kode lerroa:             } else if (zoomArg === 'FitR') {
Kode lerroa:               if (zoomArgs.length !== 5) {
Kode lerroa:                 console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
Kode lerroa:               } else {
Kode lerroa:                 dest = [null, { name: zoomArg }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               console.error('PDFLinkService.setHash: "' + zoomArg + '" is not ' + 'a valid zoom value.');
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (dest) {
Kode lerroa:           this.pdfViewer.scrollPageIntoView({
Kode lerroa:             pageNumber: pageNumber || this.page,
Kode lerroa:             destArray: dest,
Kode lerroa:             allowNegativeOffset: true
Kode lerroa:           });
Kode lerroa:         } else if (pageNumber) {
Kode lerroa:           this.page = pageNumber;
Kode lerroa:         }
Kode lerroa:         if ('pagemode' in params) {
Kode lerroa:           this.eventBus.dispatch('pagemode', {
Kode lerroa:             source: this,
Kode lerroa:             mode: params.pagemode
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (/^\d+$/.test(hash) && hash <= this.pagesCount) {
Kode lerroa:           console.warn('PDFLinkService_setHash: specifying a page number ' + 'directly after the hash symbol (#) is deprecated, ' + ('please use the "#page=' + hash + '" form instead.'));
Kode lerroa:           this.page = hash | 0;
Kode lerroa:         }
Kode lerroa:         dest = unescape(hash);
Kode lerroa:         try {
Kode lerroa:           dest = JSON.parse(dest);
Kode lerroa:           if (!(dest instanceof Array)) {
Kode lerroa:             dest = dest.toString();
Kode lerroa:           }
Kode lerroa:         } catch (ex) {}
Kode lerroa:         if (typeof dest === 'string' || isValidExplicitDestination(dest)) {
Kode lerroa:           this.navigateTo(dest);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         console.error('PDFLinkService.setHash: "' + unescape(hash) + '" is not ' + 'a valid destination.');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'executeNamedAction',
Kode lerroa:     value: function executeNamedAction(action) {
Kode lerroa:       switch (action) {
Kode lerroa:         case 'GoBack':
Kode lerroa:           if (this.pdfHistory) {
Kode lerroa:             this.pdfHistory.back();
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'GoForward':
Kode lerroa:           if (this.pdfHistory) {
Kode lerroa:             this.pdfHistory.forward();
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'NextPage':
Kode lerroa:           if (this.page < this.pagesCount) {
Kode lerroa:             this.page++;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'PrevPage':
Kode lerroa:           if (this.page > 1) {
Kode lerroa:             this.page--;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'LastPage':
Kode lerroa:           this.page = this.pagesCount;
Kode lerroa:           break;
Kode lerroa:         case 'FirstPage':
Kode lerroa:           this.page = 1;
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:       this.eventBus.dispatch('namedaction', {
Kode lerroa:         source: this,
Kode lerroa:         action: action
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'onFileAttachmentAnnotation',
Kode lerroa:     value: function onFileAttachmentAnnotation(_ref3) {
Kode lerroa:       var id = _ref3.id,
Kode lerroa:           filename = _ref3.filename,
Kode lerroa:           content = _ref3.content;
Kode lerroa: 
Kode lerroa:       this.eventBus.dispatch('fileattachmentannotation', {
Kode lerroa:         source: this,
Kode lerroa:         id: id,
Kode lerroa:         filename: filename,
Kode lerroa:         content: content
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cachePageRef',
Kode lerroa:     value: function cachePageRef(pageNum, pageRef) {
Kode lerroa:       var refStr = pageRef.num + ' ' + pageRef.gen + ' R';
Kode lerroa:       this._pagesRefCache[refStr] = pageNum;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_cachedPageNumber',
Kode lerroa:     value: function _cachedPageNumber(pageRef) {
Kode lerroa:       var refStr = pageRef.num + ' ' + pageRef.gen + ' R';
Kode lerroa:       return this._pagesRefCache && this._pagesRefCache[refStr] || null;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pagesCount',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.pdfDocument ? this.pdfDocument.numPages : 0;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'page',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.pdfViewer.currentPageNumber;
Kode lerroa:     },
Kode lerroa:     set: function set(value) {
Kode lerroa:       this.pdfViewer.currentPageNumber = value;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'rotation',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.pdfViewer.pagesRotation;
Kode lerroa:     },
Kode lerroa:     set: function set(value) {
Kode lerroa:       this.pdfViewer.pagesRotation = value;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFLinkService;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: function isValidExplicitDestination(dest) {
Kode lerroa:   if (!(dest instanceof Array)) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   var destLength = dest.length,
Kode lerroa:       allowNull = true;
Kode lerroa:   if (destLength < 2) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   var page = dest[0];
Kode lerroa:   if (!((typeof page === 'undefined' ? 'undefined' : _typeof(page)) === 'object' && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   var zoom = dest[1];
Kode lerroa:   if (!((typeof zoom === 'undefined' ? 'undefined' : _typeof(zoom)) === 'object' && typeof zoom.name === 'string')) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   switch (zoom.name) {
Kode lerroa:     case 'XYZ':
Kode lerroa:       if (destLength !== 5) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       break;
Kode lerroa:     case 'Fit':
Kode lerroa:     case 'FitB':
Kode lerroa:       return destLength === 2;
Kode lerroa:     case 'FitH':
Kode lerroa:     case 'FitBH':
Kode lerroa:     case 'FitV':
Kode lerroa:     case 'FitBV':
Kode lerroa:       if (destLength !== 3) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       break;
Kode lerroa:     case 'FitR':
Kode lerroa:       if (destLength !== 6) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       allowNull = false;
Kode lerroa:       break;
Kode lerroa:     default:
Kode lerroa:       return false;
Kode lerroa:   }
Kode lerroa:   for (var i = 2; i < destLength; i++) {
Kode lerroa:     var param = dest[i];
Kode lerroa:     if (!(typeof param === 'number' || allowNull && param === null)) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return true;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var SimpleLinkService = function () {
Kode lerroa:   function SimpleLinkService() {
Kode lerroa:     _classCallCheck(this, SimpleLinkService);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(SimpleLinkService, [{
Kode lerroa:     key: 'navigateTo',
Kode lerroa:     value: function navigateTo(dest) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'getDestinationHash',
Kode lerroa:     value: function getDestinationHash(dest) {
Kode lerroa:       return '#';
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getAnchorUrl',
Kode lerroa:     value: function getAnchorUrl(hash) {
Kode lerroa:       return '#';
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setHash',
Kode lerroa:     value: function setHash(hash) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'executeNamedAction',
Kode lerroa:     value: function executeNamedAction(action) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'onFileAttachmentAnnotation',
Kode lerroa:     value: function onFileAttachmentAnnotation(_ref4) {
Kode lerroa:       var id = _ref4.id,
Kode lerroa:           filename = _ref4.filename,
Kode lerroa:           content = _ref4.content;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cachePageRef',
Kode lerroa:     value: function cachePageRef(pageNum, pageRef) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'page',
Kode lerroa:     get: function get() {
Kode lerroa:       return 0;
Kode lerroa:     },
Kode lerroa:     set: function set(value) {}
Kode lerroa:   }, {
Kode lerroa:     key: 'rotation',
Kode lerroa:     get: function get() {
Kode lerroa:       return 0;
Kode lerroa:     },
Kode lerroa:     set: function set(value) {}
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return SimpleLinkService;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFLinkService = PDFLinkService;
Kode lerroa: exports.SimpleLinkService = SimpleLinkService;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 6 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFCursorTools = exports.CursorTool = undefined;
Kode lerroa: 
Kode lerroa: var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _grab_to_pan = __webpack_require__(9);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var CursorTool = {
Kode lerroa:   SELECT: 0,
Kode lerroa:   HAND: 1,
Kode lerroa:   ZOOM: 2
Kode lerroa: };
Kode lerroa: 
Kode lerroa: var PDFCursorTools = function () {
Kode lerroa:   function PDFCursorTools(_ref) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var container = _ref.container,
Kode lerroa:         eventBus = _ref.eventBus,
Kode lerroa:         preferences = _ref.preferences;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFCursorTools);
Kode lerroa: 
Kode lerroa:     this.container = container;
Kode lerroa:     this.eventBus = eventBus;
Kode lerroa:     this.active = CursorTool.SELECT;
Kode lerroa:     this.activeBeforePresentationMode = null;
Kode lerroa:     this.handTool = new _grab_to_pan.GrabToPan({ element: this.container });
Kode lerroa:     this._addEventListeners();
Kode lerroa:     Promise.all([preferences.get('cursorToolOnLoad'), preferences.get('enableHandToolOnLoad')]).then(function (_ref2) {
Kode lerroa:       var _ref3 = _slicedToArray(_ref2, 2),
Kode lerroa:           cursorToolPref = _ref3[0],
Kode lerroa:           handToolPref = _ref3[1];
Kode lerroa: 
Kode lerroa:       if (handToolPref === true) {
Kode lerroa:         preferences.set('enableHandToolOnLoad', false);
Kode lerroa:         if (cursorToolPref === CursorTool.SELECT) {
Kode lerroa:           cursorToolPref = CursorTool.HAND;
Kode lerroa:           preferences.set('cursorToolOnLoad', cursorToolPref).catch(function () {});
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       _this.switchTool(cursorToolPref);
Kode lerroa:     }).catch(function () {});
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFCursorTools, [{
Kode lerroa:     key: 'switchTool',
Kode lerroa:     value: function switchTool(tool) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (this.activeBeforePresentationMode !== null) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (tool === this.active) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var disableActiveTool = function disableActiveTool() {
Kode lerroa:         switch (_this2.active) {
Kode lerroa:           case CursorTool.SELECT:
Kode lerroa:             break;
Kode lerroa:           case CursorTool.HAND:
Kode lerroa:             _this2.handTool.deactivate();
Kode lerroa:             break;
Kode lerroa:           case CursorTool.ZOOM:
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       switch (tool) {
Kode lerroa:         case CursorTool.SELECT:
Kode lerroa:           disableActiveTool();
Kode lerroa:           break;
Kode lerroa:         case CursorTool.HAND:
Kode lerroa:           disableActiveTool();
Kode lerroa:           this.handTool.activate();
Kode lerroa:           break;
Kode lerroa:         case CursorTool.ZOOM:
Kode lerroa:         default:
Kode lerroa:           console.error('switchTool: "' + tool + '" is an unsupported value.');
Kode lerroa:           return;
Kode lerroa:       }
Kode lerroa:       this.active = tool;
Kode lerroa:       this._dispatchEvent();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_dispatchEvent',
Kode lerroa:     value: function _dispatchEvent() {
Kode lerroa:       this.eventBus.dispatch('cursortoolchanged', {
Kode lerroa:         source: this,
Kode lerroa:         tool: this.active
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_addEventListeners',
Kode lerroa:     value: function _addEventListeners() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       this.eventBus.on('switchcursortool', function (evt) {
Kode lerroa:         _this3.switchTool(evt.tool);
Kode lerroa:       });
Kode lerroa:       this.eventBus.on('presentationmodechanged', function (evt) {
Kode lerroa:         if (evt.switchInProgress) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var previouslyActive = void 0;
Kode lerroa:         if (evt.active) {
Kode lerroa:           previouslyActive = _this3.active;
Kode lerroa:           _this3.switchTool(CursorTool.SELECT);
Kode lerroa:           _this3.activeBeforePresentationMode = previouslyActive;
Kode lerroa:         } else {
Kode lerroa:           previouslyActive = _this3.activeBeforePresentationMode;
Kode lerroa:           _this3.activeBeforePresentationMode = null;
Kode lerroa:           _this3.switchTool(previouslyActive);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'activeTool',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.active;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFCursorTools;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.CursorTool = CursorTool;
Kode lerroa: exports.PDFCursorTools = PDFCursorTools;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 7 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFFindController = exports.FindState = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var FindState = {
Kode lerroa:   FOUND: 0,
Kode lerroa:   NOT_FOUND: 1,
Kode lerroa:   WRAPPED: 2,
Kode lerroa:   PENDING: 3
Kode lerroa: };
Kode lerroa: var FIND_SCROLL_OFFSET_TOP = -50;
Kode lerroa: var FIND_SCROLL_OFFSET_LEFT = -400;
Kode lerroa: var FIND_TIMEOUT = 250;
Kode lerroa: var CHARACTERS_TO_NORMALIZE = {
Kode lerroa:   '\u2018': '\'',
Kode lerroa:   '\u2019': '\'',
Kode lerroa:   '\u201A': '\'',
Kode lerroa:   '\u201B': '\'',
Kode lerroa:   '\u201C': '"',
Kode lerroa:   '\u201D': '"',
Kode lerroa:   '\u201E': '"',
Kode lerroa:   '\u201F': '"',
Kode lerroa:   '\xBC': '1/4',
Kode lerroa:   '\xBD': '1/2',
Kode lerroa:   '\xBE': '3/4'
Kode lerroa: };
Kode lerroa: 
Kode lerroa: var PDFFindController = function () {
Kode lerroa:   function PDFFindController(_ref) {
Kode lerroa:     var pdfViewer = _ref.pdfViewer;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFFindController);
Kode lerroa: 
Kode lerroa:     this.pdfViewer = pdfViewer;
Kode lerroa:     this.onUpdateResultsCount = null;
Kode lerroa:     this.onUpdateState = null;
Kode lerroa:     this.reset();
Kode lerroa:     var replace = Object.keys(CHARACTERS_TO_NORMALIZE).join('');
Kode lerroa:     this.normalizationRegex = new RegExp('[' + replace + ']', 'g');
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFFindController, [{
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       this.startedTextExtraction = false;
Kode lerroa:       this.extractTextPromises = [];
Kode lerroa:       this.pendingFindMatches = Object.create(null);
Kode lerroa:       this.active = false;
Kode lerroa:       this.pageContents = [];
Kode lerroa:       this.pageMatches = [];
Kode lerroa:       this.pageMatchesLength = null;
Kode lerroa:       this.matchCount = 0;
Kode lerroa:       this.selected = {
Kode lerroa:         pageIdx: -1,
Kode lerroa:         matchIdx: -1
Kode lerroa:       };
Kode lerroa:       this.offset = {
Kode lerroa:         pageIdx: null,
Kode lerroa:         matchIdx: null
Kode lerroa:       };
Kode lerroa:       this.pagesToSearch = null;
Kode lerroa:       this.resumePageIdx = null;
Kode lerroa:       this.state = null;
Kode lerroa:       this.dirtyMatch = false;
Kode lerroa:       this.findTimeout = null;
Kode lerroa:       this._firstPagePromise = new Promise(function (resolve) {
Kode lerroa:         _this.resolveFirstPage = resolve;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'normalize',
Kode lerroa:     value: function normalize(text) {
Kode lerroa:       return text.replace(this.normalizationRegex, function (ch) {
Kode lerroa:         return CHARACTERS_TO_NORMALIZE[ch];
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_prepareMatches',
Kode lerroa:     value: function _prepareMatches(matchesWithLength, matches, matchesLength) {
Kode lerroa:       function isSubTerm(matchesWithLength, currentIndex) {
Kode lerroa:         var currentElem = matchesWithLength[currentIndex];
Kode lerroa:         var nextElem = matchesWithLength[currentIndex + 1];
Kode lerroa:         if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {
Kode lerroa:           currentElem.skipped = true;
Kode lerroa:           return true;
Kode lerroa:         }
Kode lerroa:         for (var i = currentIndex - 1; i >= 0; i--) {
Kode lerroa:           var prevElem = matchesWithLength[i];
Kode lerroa:           if (prevElem.skipped) {
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           if (prevElem.match + prevElem.matchLength < currentElem.match) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {
Kode lerroa:             currentElem.skipped = true;
Kode lerroa:             return true;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       matchesWithLength.sort(function (a, b) {
Kode lerroa:         return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;
Kode lerroa:       });
Kode lerroa:       for (var i = 0, len = matchesWithLength.length; i < len; i++) {
Kode lerroa:         if (isSubTerm(matchesWithLength, i)) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         matches.push(matchesWithLength[i].match);
Kode lerroa:         matchesLength.push(matchesWithLength[i].matchLength);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'calcFindPhraseMatch',
Kode lerroa:     value: function calcFindPhraseMatch(query, pageIndex, pageContent) {
Kode lerroa:       var matches = [];
Kode lerroa:       var queryLen = query.length;
Kode lerroa:       var matchIdx = -queryLen;
Kode lerroa:       while (true) {
Kode lerroa:         matchIdx = pageContent.indexOf(query, matchIdx + queryLen);
Kode lerroa:         if (matchIdx === -1) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         matches.push(matchIdx);
Kode lerroa:       }
Kode lerroa:       this.pageMatches[pageIndex] = matches;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'calcFindWordMatch',
Kode lerroa:     value: function calcFindWordMatch(query, pageIndex, pageContent) {
Kode lerroa:       var matchesWithLength = [];
Kode lerroa:       var queryArray = query.match(/\S+/g);
Kode lerroa:       for (var i = 0, len = queryArray.length; i < len; i++) {
Kode lerroa:         var subquery = queryArray[i];
Kode lerroa:         var subqueryLen = subquery.length;
Kode lerroa:         var matchIdx = -subqueryLen;
Kode lerroa:         while (true) {
Kode lerroa:           matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);
Kode lerroa:           if (matchIdx === -1) {
Kode lerroa:             break;
Kode lerroa:           }
Kode lerroa:           matchesWithLength.push({
Kode lerroa:             match: matchIdx,
Kode lerroa:             matchLength: subqueryLen,
Kode lerroa:             skipped: false
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (!this.pageMatchesLength) {
Kode lerroa:         this.pageMatchesLength = [];
Kode lerroa:       }
Kode lerroa:       this.pageMatchesLength[pageIndex] = [];
Kode lerroa:       this.pageMatches[pageIndex] = [];
Kode lerroa:       this._prepareMatches(matchesWithLength, this.pageMatches[pageIndex], this.pageMatchesLength[pageIndex]);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'calcFindMatch',
Kode lerroa:     value: function calcFindMatch(pageIndex) {
Kode lerroa:       var pageContent = this.normalize(this.pageContents[pageIndex]);
Kode lerroa:       var query = this.normalize(this.state.query);
Kode lerroa:       var caseSensitive = this.state.caseSensitive;
Kode lerroa:       var phraseSearch = this.state.phraseSearch;
Kode lerroa:       var queryLen = query.length;
Kode lerroa:       if (queryLen === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!caseSensitive) {
Kode lerroa:         pageContent = pageContent.toLowerCase();
Kode lerroa:         query = query.toLowerCase();
Kode lerroa:       }
Kode lerroa:       if (phraseSearch) {
Kode lerroa:         this.calcFindPhraseMatch(query, pageIndex, pageContent);
Kode lerroa:       } else {
Kode lerroa:         this.calcFindWordMatch(query, pageIndex, pageContent);
Kode lerroa:       }
Kode lerroa:       this.updatePage(pageIndex);
Kode lerroa:       if (this.resumePageIdx === pageIndex) {
Kode lerroa:         this.resumePageIdx = null;
Kode lerroa:         this.nextPageMatch();
Kode lerroa:       }
Kode lerroa:       if (this.pageMatches[pageIndex].length > 0) {
Kode lerroa:         this.matchCount += this.pageMatches[pageIndex].length;
Kode lerroa:         this.updateUIResultsCount();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'extractText',
Kode lerroa:     value: function extractText() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (this.startedTextExtraction) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.startedTextExtraction = true;
Kode lerroa:       this.pageContents.length = 0;
Kode lerroa:       var promise = Promise.resolve();
Kode lerroa: 
Kode lerroa:       var _loop = function _loop(i, ii) {
Kode lerroa:         var extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:         _this2.extractTextPromises[i] = extractTextCapability.promise;
Kode lerroa:         promise = promise.then(function () {
Kode lerroa:           return _this2.pdfViewer.getPageTextContent(i).then(function (textContent) {
Kode lerroa:             var textItems = textContent.items;
Kode lerroa:             var strBuf = [];
Kode lerroa:             for (var j = 0, jj = textItems.length; j < jj; j++) {
Kode lerroa:               strBuf.push(textItems[j].str);
Kode lerroa:             }
Kode lerroa:             _this2.pageContents[i] = strBuf.join('');
Kode lerroa:             extractTextCapability.resolve(i);
Kode lerroa:           }, function (reason) {
Kode lerroa:             console.error('Unable to get page ' + (i + 1) + ' text content', reason);
Kode lerroa:             _this2.pageContents[i] = '';
Kode lerroa:             extractTextCapability.resolve(i);
Kode lerroa:           });
Kode lerroa:         });
Kode lerroa:       };
Kode lerroa: 
Kode lerroa:       for (var i = 0, ii = this.pdfViewer.pagesCount; i < ii; i++) {
Kode lerroa:         _loop(i, ii);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'executeCommand',
Kode lerroa:     value: function executeCommand(cmd, state) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       if (this.state === null || cmd !== 'findagain') {
Kode lerroa:         this.dirtyMatch = true;
Kode lerroa:       }
Kode lerroa:       this.state = state;
Kode lerroa:       this.updateUIState(FindState.PENDING);
Kode lerroa:       this._firstPagePromise.then(function () {
Kode lerroa:         _this3.extractText();
Kode lerroa:         clearTimeout(_this3.findTimeout);
Kode lerroa:         if (cmd === 'find') {
Kode lerroa:           _this3.findTimeout = setTimeout(_this3.nextMatch.bind(_this3), FIND_TIMEOUT);
Kode lerroa:         } else {
Kode lerroa:           _this3.nextMatch();
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updatePage',
Kode lerroa:     value: function updatePage(index) {
Kode lerroa:       if (this.selected.pageIdx === index) {
Kode lerroa:         this.pdfViewer.currentPageNumber = index + 1;
Kode lerroa:       }
Kode lerroa:       var page = this.pdfViewer.getPageView(index);
Kode lerroa:       if (page.textLayer) {
Kode lerroa:         page.textLayer.updateMatches();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'nextMatch',
Kode lerroa:     value: function nextMatch() {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       var previous = this.state.findPrevious;
Kode lerroa:       var currentPageIndex = this.pdfViewer.currentPageNumber - 1;
Kode lerroa:       var numPages = this.pdfViewer.pagesCount;
Kode lerroa:       this.active = true;
Kode lerroa:       if (this.dirtyMatch) {
Kode lerroa:         this.dirtyMatch = false;
Kode lerroa:         this.selected.pageIdx = this.selected.matchIdx = -1;
Kode lerroa:         this.offset.pageIdx = currentPageIndex;
Kode lerroa:         this.offset.matchIdx = null;
Kode lerroa:         this.hadMatch = false;
Kode lerroa:         this.resumePageIdx = null;
Kode lerroa:         this.pageMatches = [];
Kode lerroa:         this.matchCount = 0;
Kode lerroa:         this.pageMatchesLength = null;
Kode lerroa:         for (var i = 0; i < numPages; i++) {
Kode lerroa:           this.updatePage(i);
Kode lerroa:           if (!(i in this.pendingFindMatches)) {
Kode lerroa:             this.pendingFindMatches[i] = true;
Kode lerroa:             this.extractTextPromises[i].then(function (pageIdx) {
Kode lerroa:               delete _this4.pendingFindMatches[pageIdx];
Kode lerroa:               _this4.calcFindMatch(pageIdx);
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (this.state.query === '') {
Kode lerroa:         this.updateUIState(FindState.FOUND);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.resumePageIdx) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var offset = this.offset;
Kode lerroa:       this.pagesToSearch = numPages;
Kode lerroa:       if (offset.matchIdx !== null) {
Kode lerroa:         var numPageMatches = this.pageMatches[offset.pageIdx].length;
Kode lerroa:         if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
Kode lerroa:           this.hadMatch = true;
Kode lerroa:           offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
Kode lerroa:           this.updateMatch(true);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this.advanceOffsetPage(previous);
Kode lerroa:       }
Kode lerroa:       this.nextPageMatch();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'matchesReady',
Kode lerroa:     value: function matchesReady(matches) {
Kode lerroa:       var offset = this.offset;
Kode lerroa:       var numMatches = matches.length;
Kode lerroa:       var previous = this.state.findPrevious;
Kode lerroa:       if (numMatches) {
Kode lerroa:         this.hadMatch = true;
Kode lerroa:         offset.matchIdx = previous ? numMatches - 1 : 0;
Kode lerroa:         this.updateMatch(true);
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:       this.advanceOffsetPage(previous);
Kode lerroa:       if (offset.wrapped) {
Kode lerroa:         offset.matchIdx = null;
Kode lerroa:         if (this.pagesToSearch < 0) {
Kode lerroa:           this.updateMatch(false);
Kode lerroa:           return true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateMatchPosition',
Kode lerroa:     value: function updateMatchPosition(pageIndex, matchIndex, elements, beginIdx) {
Kode lerroa:       if (this.selected.matchIdx === matchIndex && this.selected.pageIdx === pageIndex) {
Kode lerroa:         var spot = {
Kode lerroa:           top: FIND_SCROLL_OFFSET_TOP,
Kode lerroa:           left: FIND_SCROLL_OFFSET_LEFT
Kode lerroa:         };
Kode lerroa:         (0, _ui_utils.scrollIntoView)(elements[beginIdx], spot, true);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'nextPageMatch',
Kode lerroa:     value: function nextPageMatch() {
Kode lerroa:       if (this.resumePageIdx !== null) {
Kode lerroa:         console.error('There can only be one pending page.');
Kode lerroa:       }
Kode lerroa:       var matches = null;
Kode lerroa:       do {
Kode lerroa:         var pageIdx = this.offset.pageIdx;
Kode lerroa:         matches = this.pageMatches[pageIdx];
Kode lerroa:         if (!matches) {
Kode lerroa:           this.resumePageIdx = pageIdx;
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       } while (!this.matchesReady(matches));
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'advanceOffsetPage',
Kode lerroa:     value: function advanceOffsetPage(previous) {
Kode lerroa:       var offset = this.offset;
Kode lerroa:       var numPages = this.extractTextPromises.length;
Kode lerroa:       offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
Kode lerroa:       offset.matchIdx = null;
Kode lerroa:       this.pagesToSearch--;
Kode lerroa:       if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
Kode lerroa:         offset.pageIdx = previous ? numPages - 1 : 0;
Kode lerroa:         offset.wrapped = true;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateMatch',
Kode lerroa:     value: function updateMatch() {
Kode lerroa:       var found = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       var state = FindState.NOT_FOUND;
Kode lerroa:       var wrapped = this.offset.wrapped;
Kode lerroa:       this.offset.wrapped = false;
Kode lerroa:       if (found) {
Kode lerroa:         var previousPage = this.selected.pageIdx;
Kode lerroa:         this.selected.pageIdx = this.offset.pageIdx;
Kode lerroa:         this.selected.matchIdx = this.offset.matchIdx;
Kode lerroa:         state = wrapped ? FindState.WRAPPED : FindState.FOUND;
Kode lerroa:         if (previousPage !== -1 && previousPage !== this.selected.pageIdx) {
Kode lerroa:           this.updatePage(previousPage);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.updateUIState(state, this.state.findPrevious);
Kode lerroa:       if (this.selected.pageIdx !== -1) {
Kode lerroa:         this.updatePage(this.selected.pageIdx);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateUIResultsCount',
Kode lerroa:     value: function updateUIResultsCount() {
Kode lerroa:       if (this.onUpdateResultsCount) {
Kode lerroa:         this.onUpdateResultsCount(this.matchCount);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateUIState',
Kode lerroa:     value: function updateUIState(state, previous) {
Kode lerroa:       if (this.onUpdateState) {
Kode lerroa:         this.onUpdateState(state, previous, this.matchCount);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFFindController;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.FindState = FindState;
Kode lerroa: exports.PDFFindController = PDFFindController;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 8 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: var DEFAULT_URL = 'compressed.tracemonkey-pldi-09.pdf';
Kode lerroa: ;
Kode lerroa: var pdfjsWebApp = void 0;
Kode lerroa: {
Kode lerroa:   pdfjsWebApp = __webpack_require__(4);
Kode lerroa: }
Kode lerroa: ;
Kode lerroa: {
Kode lerroa:   __webpack_require__(29);
Kode lerroa: }
Kode lerroa: ;
Kode lerroa: {
Kode lerroa:   __webpack_require__(34);
Kode lerroa: }
Kode lerroa: function getViewerConfiguration() {
Kode lerroa:   return {
Kode lerroa:     appContainer: document.body,
Kode lerroa:     mainContainer: document.getElementById('viewerContainer'),
Kode lerroa:     viewerContainer: document.getElementById('viewer'),
Kode lerroa:     eventBus: null,
Kode lerroa:     toolbar: {
Kode lerroa:       container: document.getElementById('toolbarViewer'),
Kode lerroa:       numPages: document.getElementById('numPages'),
Kode lerroa:       pageNumber: document.getElementById('pageNumber'),
Kode lerroa:       scaleSelectContainer: document.getElementById('scaleSelectContainer'),
Kode lerroa:       scaleSelect: document.getElementById('scaleSelect'),
Kode lerroa:       customScaleOption: document.getElementById('customScaleOption'),
Kode lerroa:       previous: document.getElementById('previous'),
Kode lerroa:       next: document.getElementById('next'),
Kode lerroa:       zoomIn: document.getElementById('zoomIn'),
Kode lerroa:       zoomOut: document.getElementById('zoomOut'),
Kode lerroa:       viewFind: document.getElementById('viewFind'),
Kode lerroa:       openFile: document.getElementById('openFile'),
Kode lerroa:       print: document.getElementById('print'),
Kode lerroa:       presentationModeButton: document.getElementById('presentationMode'),
Kode lerroa:       download: document.getElementById('download'),
Kode lerroa:       viewBookmark: document.getElementById('viewBookmark')
Kode lerroa:     },
Kode lerroa:     secondaryToolbar: {
Kode lerroa:       toolbar: document.getElementById('secondaryToolbar'),
Kode lerroa:       toggleButton: document.getElementById('secondaryToolbarToggle'),
Kode lerroa:       toolbarButtonContainer: document.getElementById('secondaryToolbarButtonContainer'),
Kode lerroa:       presentationModeButton: document.getElementById('secondaryPresentationMode'),
Kode lerroa:       openFileButton: document.getElementById('secondaryOpenFile'),
Kode lerroa:       printButton: document.getElementById('secondaryPrint'),
Kode lerroa:       downloadButton: document.getElementById('secondaryDownload'),
Kode lerroa:       viewBookmarkButton: document.getElementById('secondaryViewBookmark'),
Kode lerroa:       firstPageButton: document.getElementById('firstPage'),
Kode lerroa:       lastPageButton: document.getElementById('lastPage'),
Kode lerroa:       pageRotateCwButton: document.getElementById('pageRotateCw'),
Kode lerroa:       pageRotateCcwButton: document.getElementById('pageRotateCcw'),
Kode lerroa:       cursorSelectToolButton: document.getElementById('cursorSelectTool'),
Kode lerroa:       cursorHandToolButton: document.getElementById('cursorHandTool'),
Kode lerroa:       documentPropertiesButton: document.getElementById('documentProperties')
Kode lerroa:     },
Kode lerroa:     fullscreen: {
Kode lerroa:       contextFirstPage: document.getElementById('contextFirstPage'),
Kode lerroa:       contextLastPage: document.getElementById('contextLastPage'),
Kode lerroa:       contextPageRotateCw: document.getElementById('contextPageRotateCw'),
Kode lerroa:       contextPageRotateCcw: document.getElementById('contextPageRotateCcw')
Kode lerroa:     },
Kode lerroa:     sidebar: {
Kode lerroa:       mainContainer: document.getElementById('mainContainer'),
Kode lerroa:       outerContainer: document.getElementById('outerContainer'),
Kode lerroa:       toggleButton: document.getElementById('sidebarToggle'),
Kode lerroa:       thumbnailButton: document.getElementById('viewThumbnail'),
Kode lerroa:       outlineButton: document.getElementById('viewOutline'),
Kode lerroa:       attachmentsButton: document.getElementById('viewAttachments'),
Kode lerroa:       thumbnailView: document.getElementById('thumbnailView'),
Kode lerroa:       outlineView: document.getElementById('outlineView'),
Kode lerroa:       attachmentsView: document.getElementById('attachmentsView')
Kode lerroa:     },
Kode lerroa:     findBar: {
Kode lerroa:       bar: document.getElementById('findbar'),
Kode lerroa:       toggleButton: document.getElementById('viewFind'),
Kode lerroa:       findField: document.getElementById('findInput'),
Kode lerroa:       highlightAllCheckbox: document.getElementById('findHighlightAll'),
Kode lerroa:       caseSensitiveCheckbox: document.getElementById('findMatchCase'),
Kode lerroa:       findMsg: document.getElementById('findMsg'),
Kode lerroa:       findResultsCount: document.getElementById('findResultsCount'),
Kode lerroa:       findStatusIcon: document.getElementById('findStatusIcon'),
Kode lerroa:       findPreviousButton: document.getElementById('findPrevious'),
Kode lerroa:       findNextButton: document.getElementById('findNext')
Kode lerroa:     },
Kode lerroa:     passwordOverlay: {
Kode lerroa:       overlayName: 'passwordOverlay',
Kode lerroa:       container: document.getElementById('passwordOverlay'),
Kode lerroa:       label: document.getElementById('passwordText'),
Kode lerroa:       input: document.getElementById('password'),
Kode lerroa:       submitButton: document.getElementById('passwordSubmit'),
Kode lerroa:       cancelButton: document.getElementById('passwordCancel')
Kode lerroa:     },
Kode lerroa:     documentProperties: {
Kode lerroa:       overlayName: 'documentPropertiesOverlay',
Kode lerroa:       container: document.getElementById('documentPropertiesOverlay'),
Kode lerroa:       closeButton: document.getElementById('documentPropertiesClose'),
Kode lerroa:       fields: {
Kode lerroa:         'fileName': document.getElementById('fileNameField'),
Kode lerroa:         'fileSize': document.getElementById('fileSizeField'),
Kode lerroa:         'title': document.getElementById('titleField'),
Kode lerroa:         'author': document.getElementById('authorField'),
Kode lerroa:         'subject': document.getElementById('subjectField'),
Kode lerroa:         'keywords': document.getElementById('keywordsField'),
Kode lerroa:         'creationDate': document.getElementById('creationDateField'),
Kode lerroa:         'modificationDate': document.getElementById('modificationDateField'),
Kode lerroa:         'creator': document.getElementById('creatorField'),
Kode lerroa:         'producer': document.getElementById('producerField'),
Kode lerroa:         'version': document.getElementById('versionField'),
Kode lerroa:         'pageCount': document.getElementById('pageCountField')
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     errorWrapper: {
Kode lerroa:       container: document.getElementById('errorWrapper'),
Kode lerroa:       errorMessage: document.getElementById('errorMessage'),
Kode lerroa:       closeButton: document.getElementById('errorClose'),
Kode lerroa:       errorMoreInfo: document.getElementById('errorMoreInfo'),
Kode lerroa:       moreInfoButton: document.getElementById('errorShowMore'),
Kode lerroa:       lessInfoButton: document.getElementById('errorShowLess')
Kode lerroa:     },
Kode lerroa:     printContainer: document.getElementById('printContainer'),
Kode lerroa:     openFileInputName: 'fileInput',
Kode lerroa:     debuggerScriptPath: './debugger.js',
Kode lerroa:     defaultUrl: DEFAULT_URL
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function webViewerLoad() {
Kode lerroa:   var config = getViewerConfiguration();
Kode lerroa:   window.PDFViewerApplication = pdfjsWebApp.PDFViewerApplication;
Kode lerroa:   pdfjsWebApp.PDFViewerApplication.run(config);
Kode lerroa: }
Kode lerroa: if (document.readyState === 'interactive' || document.readyState === 'complete') {
Kode lerroa:   webViewerLoad();
Kode lerroa: } else {
Kode lerroa:   document.addEventListener('DOMContentLoaded', webViewerLoad, true);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 9 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: function GrabToPan(options) {
Kode lerroa:   this.element = options.element;
Kode lerroa:   this.document = options.element.ownerDocument;
Kode lerroa:   if (typeof options.ignoreTarget === 'function') {
Kode lerroa:     this.ignoreTarget = options.ignoreTarget;
Kode lerroa:   }
Kode lerroa:   this.onActiveChanged = options.onActiveChanged;
Kode lerroa:   this.activate = this.activate.bind(this);
Kode lerroa:   this.deactivate = this.deactivate.bind(this);
Kode lerroa:   this.toggle = this.toggle.bind(this);
Kode lerroa:   this._onmousedown = this._onmousedown.bind(this);
Kode lerroa:   this._onmousemove = this._onmousemove.bind(this);
Kode lerroa:   this._endPan = this._endPan.bind(this);
Kode lerroa:   var overlay = this.overlay = document.createElement('div');
Kode lerroa:   overlay.className = 'grab-to-pan-grabbing';
Kode lerroa: }
Kode lerroa: GrabToPan.prototype = {
Kode lerroa:   CSS_CLASS_GRAB: 'grab-to-pan-grab',
Kode lerroa:   activate: function GrabToPan_activate() {
Kode lerroa:     if (!this.active) {
Kode lerroa:       this.active = true;
Kode lerroa:       this.element.addEventListener('mousedown', this._onmousedown, true);
Kode lerroa:       this.element.classList.add(this.CSS_CLASS_GRAB);
Kode lerroa:       if (this.onActiveChanged) {
Kode lerroa:         this.onActiveChanged(true);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   deactivate: function GrabToPan_deactivate() {
Kode lerroa:     if (this.active) {
Kode lerroa:       this.active = false;
Kode lerroa:       this.element.removeEventListener('mousedown', this._onmousedown, true);
Kode lerroa:       this._endPan();
Kode lerroa:       this.element.classList.remove(this.CSS_CLASS_GRAB);
Kode lerroa:       if (this.onActiveChanged) {
Kode lerroa:         this.onActiveChanged(false);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   toggle: function GrabToPan_toggle() {
Kode lerroa:     if (this.active) {
Kode lerroa:       this.deactivate();
Kode lerroa:     } else {
Kode lerroa:       this.activate();
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   ignoreTarget: function GrabToPan_ignoreTarget(node) {
Kode lerroa:     return node[matchesSelector]('a[href], a[href] *, input, textarea, button, button *, select, option');
Kode lerroa:   },
Kode lerroa:   _onmousedown: function GrabToPan__onmousedown(event) {
Kode lerroa:     if (event.button !== 0 || this.ignoreTarget(event.target)) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (event.originalTarget) {
Kode lerroa:       try {
Kode lerroa:         event.originalTarget.tagName;
Kode lerroa:       } catch (e) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     this.scrollLeftStart = this.element.scrollLeft;
Kode lerroa:     this.scrollTopStart = this.element.scrollTop;
Kode lerroa:     this.clientXStart = event.clientX;
Kode lerroa:     this.clientYStart = event.clientY;
Kode lerroa:     this.document.addEventListener('mousemove', this._onmousemove, true);
Kode lerroa:     this.document.addEventListener('mouseup', this._endPan, true);
Kode lerroa:     this.element.addEventListener('scroll', this._endPan, true);
Kode lerroa:     event.preventDefault();
Kode lerroa:     event.stopPropagation();
Kode lerroa:     var focusedElement = document.activeElement;
Kode lerroa:     if (focusedElement && !focusedElement.contains(event.target)) {
Kode lerroa:       focusedElement.blur();
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   _onmousemove: function GrabToPan__onmousemove(event) {
Kode lerroa:     this.element.removeEventListener('scroll', this._endPan, true);
Kode lerroa:     if (isLeftMouseReleased(event)) {
Kode lerroa:       this._endPan();
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var xDiff = event.clientX - this.clientXStart;
Kode lerroa:     var yDiff = event.clientY - this.clientYStart;
Kode lerroa:     var scrollTop = this.scrollTopStart - yDiff;
Kode lerroa:     var scrollLeft = this.scrollLeftStart - xDiff;
Kode lerroa:     if (this.element.scrollTo) {
Kode lerroa:       this.element.scrollTo({
Kode lerroa:         top: scrollTop,
Kode lerroa:         left: scrollLeft,
Kode lerroa:         behavior: 'instant'
Kode lerroa:       });
Kode lerroa:     } else {
Kode lerroa:       this.element.scrollTop = scrollTop;
Kode lerroa:       this.element.scrollLeft = scrollLeft;
Kode lerroa:     }
Kode lerroa:     if (!this.overlay.parentNode) {
Kode lerroa:       document.body.appendChild(this.overlay);
Kode lerroa:     }
Kode lerroa:   },
Kode lerroa:   _endPan: function GrabToPan__endPan() {
Kode lerroa:     this.element.removeEventListener('scroll', this._endPan, true);
Kode lerroa:     this.document.removeEventListener('mousemove', this._onmousemove, true);
Kode lerroa:     this.document.removeEventListener('mouseup', this._endPan, true);
Kode lerroa:     this.overlay.remove();
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var matchesSelector;
Kode lerroa: ['webkitM', 'mozM', 'msM', 'oM', 'm'].some(function (prefix) {
Kode lerroa:   var name = prefix + 'atches';
Kode lerroa:   if (name in document.documentElement) {
Kode lerroa:     matchesSelector = name;
Kode lerroa:   }
Kode lerroa:   name += 'Selector';
Kode lerroa:   if (name in document.documentElement) {
Kode lerroa:     matchesSelector = name;
Kode lerroa:   }
Kode lerroa:   return matchesSelector;
Kode lerroa: });
Kode lerroa: var isNotIEorIsIE10plus = !document.documentMode || document.documentMode > 9;
Kode lerroa: var chrome = window.chrome;
Kode lerroa: var isChrome15OrOpera15plus = chrome && (chrome.webstore || chrome.app);
Kode lerroa: var isSafari6plus = /Apple/.test(navigator.vendor) && /Version\/([6-9]\d*|[1-5]\d+)/.test(navigator.userAgent);
Kode lerroa: function isLeftMouseReleased(event) {
Kode lerroa:   if ('buttons' in event && isNotIEorIsIE10plus) {
Kode lerroa:     return !(event.buttons & 1);
Kode lerroa:   }
Kode lerroa:   if (isChrome15OrOpera15plus || isSafari6plus) {
Kode lerroa:     return event.which === 0;
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: exports.GrabToPan = GrabToPan;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 10 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFSidebar = exports.SidebarView = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdf_rendering_queue = __webpack_require__(3);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var UI_NOTIFICATION_CLASS = 'pdfSidebarNotification';
Kode lerroa: var SidebarView = {
Kode lerroa:   NONE: 0,
Kode lerroa:   THUMBS: 1,
Kode lerroa:   OUTLINE: 2,
Kode lerroa:   ATTACHMENTS: 3
Kode lerroa: };
Kode lerroa: 
Kode lerroa: var PDFSidebar = function () {
Kode lerroa:   function PDFSidebar(options) {
Kode lerroa:     var l10n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFSidebar);
Kode lerroa: 
Kode lerroa:     this.isOpen = false;
Kode lerroa:     this.active = SidebarView.THUMBS;
Kode lerroa:     this.isInitialViewSet = false;
Kode lerroa:     this.onToggled = null;
Kode lerroa:     this.pdfViewer = options.pdfViewer;
Kode lerroa:     this.pdfThumbnailViewer = options.pdfThumbnailViewer;
Kode lerroa:     this.pdfOutlineViewer = options.pdfOutlineViewer;
Kode lerroa:     this.mainContainer = options.mainContainer;
Kode lerroa:     this.outerContainer = options.outerContainer;
Kode lerroa:     this.eventBus = options.eventBus;
Kode lerroa:     this.toggleButton = options.toggleButton;
Kode lerroa:     this.thumbnailButton = options.thumbnailButton;
Kode lerroa:     this.outlineButton = options.outlineButton;
Kode lerroa:     this.attachmentsButton = options.attachmentsButton;
Kode lerroa:     this.thumbnailView = options.thumbnailView;
Kode lerroa:     this.outlineView = options.outlineView;
Kode lerroa:     this.attachmentsView = options.attachmentsView;
Kode lerroa:     this.disableNotification = options.disableNotification || false;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     this._addEventListeners();
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFSidebar, [{
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       this.isInitialViewSet = false;
Kode lerroa:       this._hideUINotification(null);
Kode lerroa:       this.switchView(SidebarView.THUMBS);
Kode lerroa:       this.outlineButton.disabled = false;
Kode lerroa:       this.attachmentsButton.disabled = false;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setInitialView',
Kode lerroa:     value: function setInitialView() {
Kode lerroa:       var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SidebarView.NONE;
Kode lerroa: 
Kode lerroa:       if (this.isInitialViewSet) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.isInitialViewSet = true;
Kode lerroa:       if (this.isOpen && view === SidebarView.NONE) {
Kode lerroa:         this._dispatchEvent();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var isViewPreserved = view === this.visibleView;
Kode lerroa:       this.switchView(view, true);
Kode lerroa:       if (isViewPreserved) {
Kode lerroa:         this._dispatchEvent();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'switchView',
Kode lerroa:     value: function switchView(view) {
Kode lerroa:       var forceOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       if (view === SidebarView.NONE) {
Kode lerroa:         this.close();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var isViewChanged = view !== this.active;
Kode lerroa:       var shouldForceRendering = false;
Kode lerroa:       switch (view) {
Kode lerroa:         case SidebarView.THUMBS:
Kode lerroa:           this.thumbnailButton.classList.add('toggled');
Kode lerroa:           this.outlineButton.classList.remove('toggled');
Kode lerroa:           this.attachmentsButton.classList.remove('toggled');
Kode lerroa:           this.thumbnailView.classList.remove('hidden');
Kode lerroa:           this.outlineView.classList.add('hidden');
Kode lerroa:           this.attachmentsView.classList.add('hidden');
Kode lerroa:           if (this.isOpen && isViewChanged) {
Kode lerroa:             this._updateThumbnailViewer();
Kode lerroa:             shouldForceRendering = true;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case SidebarView.OUTLINE:
Kode lerroa:           if (this.outlineButton.disabled) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           this.thumbnailButton.classList.remove('toggled');
Kode lerroa:           this.outlineButton.classList.add('toggled');
Kode lerroa:           this.attachmentsButton.classList.remove('toggled');
Kode lerroa:           this.thumbnailView.classList.add('hidden');
Kode lerroa:           this.outlineView.classList.remove('hidden');
Kode lerroa:           this.attachmentsView.classList.add('hidden');
Kode lerroa:           break;
Kode lerroa:         case SidebarView.ATTACHMENTS:
Kode lerroa:           if (this.attachmentsButton.disabled) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           this.thumbnailButton.classList.remove('toggled');
Kode lerroa:           this.outlineButton.classList.remove('toggled');
Kode lerroa:           this.attachmentsButton.classList.add('toggled');
Kode lerroa:           this.thumbnailView.classList.add('hidden');
Kode lerroa:           this.outlineView.classList.add('hidden');
Kode lerroa:           this.attachmentsView.classList.remove('hidden');
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           console.error('PDFSidebar_switchView: "' + view + '" is an unsupported value.');
Kode lerroa:           return;
Kode lerroa:       }
Kode lerroa:       this.active = view | 0;
Kode lerroa:       if (forceOpen && !this.isOpen) {
Kode lerroa:         this.open();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (shouldForceRendering) {
Kode lerroa:         this._forceRendering();
Kode lerroa:       }
Kode lerroa:       if (isViewChanged) {
Kode lerroa:         this._dispatchEvent();
Kode lerroa:       }
Kode lerroa:       this._hideUINotification(this.active);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'open',
Kode lerroa:     value: function open() {
Kode lerroa:       if (this.isOpen) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.isOpen = true;
Kode lerroa:       this.toggleButton.classList.add('toggled');
Kode lerroa:       this.outerContainer.classList.add('sidebarMoving');
Kode lerroa:       this.outerContainer.classList.add('sidebarOpen');
Kode lerroa:       if (this.active === SidebarView.THUMBS) {
Kode lerroa:         this._updateThumbnailViewer();
Kode lerroa:       }
Kode lerroa:       this._forceRendering();
Kode lerroa:       this._dispatchEvent();
Kode lerroa:       this._hideUINotification(this.active);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'close',
Kode lerroa:     value: function close() {
Kode lerroa:       if (!this.isOpen) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.isOpen = false;
Kode lerroa:       this.toggleButton.classList.remove('toggled');
Kode lerroa:       this.outerContainer.classList.add('sidebarMoving');
Kode lerroa:       this.outerContainer.classList.remove('sidebarOpen');
Kode lerroa:       this._forceRendering();
Kode lerroa:       this._dispatchEvent();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'toggle',
Kode lerroa:     value: function toggle() {
Kode lerroa:       if (this.isOpen) {
Kode lerroa:         this.close();
Kode lerroa:       } else {
Kode lerroa:         this.open();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_dispatchEvent',
Kode lerroa:     value: function _dispatchEvent() {
Kode lerroa:       this.eventBus.dispatch('sidebarviewchanged', {
Kode lerroa:         source: this,
Kode lerroa:         view: this.visibleView
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_forceRendering',
Kode lerroa:     value: function _forceRendering() {
Kode lerroa:       if (this.onToggled) {
Kode lerroa:         this.onToggled();
Kode lerroa:       } else {
Kode lerroa:         this.pdfViewer.forceRendering();
Kode lerroa:         this.pdfThumbnailViewer.forceRendering();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateThumbnailViewer',
Kode lerroa:     value: function _updateThumbnailViewer() {
Kode lerroa:       var pdfViewer = this.pdfViewer,
Kode lerroa:           pdfThumbnailViewer = this.pdfThumbnailViewer;
Kode lerroa: 
Kode lerroa:       var pagesCount = pdfViewer.pagesCount;
Kode lerroa:       for (var pageIndex = 0; pageIndex < pagesCount; pageIndex++) {
Kode lerroa:         var pageView = pdfViewer.getPageView(pageIndex);
Kode lerroa:         if (pageView && pageView.renderingState === _pdf_rendering_queue.RenderingStates.FINISHED) {
Kode lerroa:           var thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex);
Kode lerroa:           thumbnailView.setImage(pageView);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_showUINotification',
Kode lerroa:     value: function _showUINotification(view) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       if (this.disableNotification) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.l10n.get('toggle_sidebar_notification.title', null, 'Toggle Sidebar (document contains outline/attachments)').then(function (msg) {
Kode lerroa:         _this.toggleButton.title = msg;
Kode lerroa:       });
Kode lerroa:       if (!this.isOpen) {
Kode lerroa:         this.toggleButton.classList.add(UI_NOTIFICATION_CLASS);
Kode lerroa:       } else if (view === this.active) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       switch (view) {
Kode lerroa:         case SidebarView.OUTLINE:
Kode lerroa:           this.outlineButton.classList.add(UI_NOTIFICATION_CLASS);
Kode lerroa:           break;
Kode lerroa:         case SidebarView.ATTACHMENTS:
Kode lerroa:           this.attachmentsButton.classList.add(UI_NOTIFICATION_CLASS);
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_hideUINotification',
Kode lerroa:     value: function _hideUINotification(view) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (this.disableNotification) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var removeNotification = function removeNotification(view) {
Kode lerroa:         switch (view) {
Kode lerroa:           case SidebarView.OUTLINE:
Kode lerroa:             _this2.outlineButton.classList.remove(UI_NOTIFICATION_CLASS);
Kode lerroa:             break;
Kode lerroa:           case SidebarView.ATTACHMENTS:
Kode lerroa:             _this2.attachmentsButton.classList.remove(UI_NOTIFICATION_CLASS);
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       if (!this.isOpen && view !== null) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS);
Kode lerroa:       if (view !== null) {
Kode lerroa:         removeNotification(view);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       for (view in SidebarView) {
Kode lerroa:         removeNotification(SidebarView[view]);
Kode lerroa:       }
Kode lerroa:       this.l10n.get('toggle_sidebar.title', null, 'Toggle Sidebar').then(function (msg) {
Kode lerroa:         _this2.toggleButton.title = msg;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_addEventListeners',
Kode lerroa:     value: function _addEventListeners() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       this.mainContainer.addEventListener('transitionend', function (evt) {
Kode lerroa:         if (evt.target === _this3.mainContainer) {
Kode lerroa:           _this3.outerContainer.classList.remove('sidebarMoving');
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       this.thumbnailButton.addEventListener('click', function () {
Kode lerroa:         _this3.switchView(SidebarView.THUMBS);
Kode lerroa:       });
Kode lerroa:       this.outlineButton.addEventListener('click', function () {
Kode lerroa:         _this3.switchView(SidebarView.OUTLINE);
Kode lerroa:       });
Kode lerroa:       this.outlineButton.addEventListener('dblclick', function () {
Kode lerroa:         _this3.pdfOutlineViewer.toggleOutlineTree();
Kode lerroa:       });
Kode lerroa:       this.attachmentsButton.addEventListener('click', function () {
Kode lerroa:         _this3.switchView(SidebarView.ATTACHMENTS);
Kode lerroa:       });
Kode lerroa:       this.eventBus.on('outlineloaded', function (evt) {
Kode lerroa:         var outlineCount = evt.outlineCount;
Kode lerroa:         _this3.outlineButton.disabled = !outlineCount;
Kode lerroa:         if (outlineCount) {
Kode lerroa:           _this3._showUINotification(SidebarView.OUTLINE);
Kode lerroa:         } else if (_this3.active === SidebarView.OUTLINE) {
Kode lerroa:           _this3.switchView(SidebarView.THUMBS);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       this.eventBus.on('attachmentsloaded', function (evt) {
Kode lerroa:         if (evt.attachmentsCount) {
Kode lerroa:           _this3.attachmentsButton.disabled = false;
Kode lerroa:           _this3._showUINotification(SidebarView.ATTACHMENTS);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         Promise.resolve().then(function () {
Kode lerroa:           if (_this3.attachmentsView.hasChildNodes()) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           _this3.attachmentsButton.disabled = true;
Kode lerroa:           if (_this3.active === SidebarView.ATTACHMENTS) {
Kode lerroa:             _this3.switchView(SidebarView.THUMBS);
Kode lerroa:           }
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       this.eventBus.on('presentationmodechanged', function (evt) {
Kode lerroa:         if (!evt.active && !evt.switchInProgress && _this3.isThumbnailViewVisible) {
Kode lerroa:           _this3._updateThumbnailViewer();
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'visibleView',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.isOpen ? this.active : SidebarView.NONE;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isThumbnailViewVisible',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.isOpen && this.active === SidebarView.THUMBS;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isOutlineViewVisible',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.isOpen && this.active === SidebarView.OUTLINE;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isAttachmentsViewVisible',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.isOpen && this.active === SidebarView.ATTACHMENTS;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFSidebar;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.SidebarView = SidebarView;
Kode lerroa: exports.PDFSidebar = PDFSidebar;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 11 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var OverlayManager = function () {
Kode lerroa:   function OverlayManager() {
Kode lerroa:     _classCallCheck(this, OverlayManager);
Kode lerroa: 
Kode lerroa:     this._overlays = {};
Kode lerroa:     this._active = null;
Kode lerroa:     this._keyDownBound = this._keyDown.bind(this);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(OverlayManager, [{
Kode lerroa:     key: 'register',
Kode lerroa:     value: function register(name, element) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var callerCloseMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
Kode lerroa:       var canForceClose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
Kode lerroa: 
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         var container = void 0;
Kode lerroa:         if (!name || !element || !(container = element.parentNode)) {
Kode lerroa:           throw new Error('Not enough parameters.');
Kode lerroa:         } else if (_this._overlays[name]) {
Kode lerroa:           throw new Error('The overlay is already registered.');
Kode lerroa:         }
Kode lerroa:         _this._overlays[name] = {
Kode lerroa:           element: element,
Kode lerroa:           container: container,
Kode lerroa:           callerCloseMethod: callerCloseMethod,
Kode lerroa:           canForceClose: canForceClose
Kode lerroa:         };
Kode lerroa:         resolve();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'unregister',
Kode lerroa:     value: function unregister(name) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         if (!_this2._overlays[name]) {
Kode lerroa:           throw new Error('The overlay does not exist.');
Kode lerroa:         } else if (_this2._active === name) {
Kode lerroa:           throw new Error('The overlay cannot be removed while it is active.');
Kode lerroa:         }
Kode lerroa:         delete _this2._overlays[name];
Kode lerroa:         resolve();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'open',
Kode lerroa:     value: function open(name) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         if (!_this3._overlays[name]) {
Kode lerroa:           throw new Error('The overlay does not exist.');
Kode lerroa:         } else if (_this3._active) {
Kode lerroa:           if (_this3._overlays[name].canForceClose) {
Kode lerroa:             _this3._closeThroughCaller();
Kode lerroa:           } else if (_this3._active === name) {
Kode lerroa:             throw new Error('The overlay is already active.');
Kode lerroa:           } else {
Kode lerroa:             throw new Error('Another overlay is currently active.');
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         _this3._active = name;
Kode lerroa:         _this3._overlays[_this3._active].element.classList.remove('hidden');
Kode lerroa:         _this3._overlays[_this3._active].container.classList.remove('hidden');
Kode lerroa:         window.addEventListener('keydown', _this3._keyDownBound);
Kode lerroa:         resolve();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'close',
Kode lerroa:     value: function close(name) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         if (!_this4._overlays[name]) {
Kode lerroa:           throw new Error('The overlay does not exist.');
Kode lerroa:         } else if (!_this4._active) {
Kode lerroa:           throw new Error('The overlay is currently not active.');
Kode lerroa:         } else if (_this4._active !== name) {
Kode lerroa:           throw new Error('Another overlay is currently active.');
Kode lerroa:         }
Kode lerroa:         _this4._overlays[_this4._active].container.classList.add('hidden');
Kode lerroa:         _this4._overlays[_this4._active].element.classList.add('hidden');
Kode lerroa:         _this4._active = null;
Kode lerroa:         window.removeEventListener('keydown', _this4._keyDownBound);
Kode lerroa:         resolve();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_keyDown',
Kode lerroa:     value: function _keyDown(evt) {
Kode lerroa:       if (this._active && evt.keyCode === 27) {
Kode lerroa:         this._closeThroughCaller();
Kode lerroa:         evt.preventDefault();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_closeThroughCaller',
Kode lerroa:     value: function _closeThroughCaller() {
Kode lerroa:       if (this._overlays[this._active].callerCloseMethod) {
Kode lerroa:         this._overlays[this._active].callerCloseMethod();
Kode lerroa:       }
Kode lerroa:       if (this._active) {
Kode lerroa:         this.close(this._active);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'active',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._active;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return OverlayManager;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.OverlayManager = OverlayManager;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 12 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PasswordPrompt = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var PasswordPrompt = function () {
Kode lerroa:   function PasswordPrompt(options, overlayManager) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var l10n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PasswordPrompt);
Kode lerroa: 
Kode lerroa:     this.overlayName = options.overlayName;
Kode lerroa:     this.container = options.container;
Kode lerroa:     this.label = options.label;
Kode lerroa:     this.input = options.input;
Kode lerroa:     this.submitButton = options.submitButton;
Kode lerroa:     this.cancelButton = options.cancelButton;
Kode lerroa:     this.overlayManager = overlayManager;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     this.updateCallback = null;
Kode lerroa:     this.reason = null;
Kode lerroa:     this.submitButton.addEventListener('click', this.verify.bind(this));
Kode lerroa:     this.cancelButton.addEventListener('click', this.close.bind(this));
Kode lerroa:     this.input.addEventListener('keydown', function (e) {
Kode lerroa:       if (e.keyCode === 13) {
Kode lerroa:         _this.verify();
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     this.overlayManager.register(this.overlayName, this.container, this.close.bind(this), true);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PasswordPrompt, [{
Kode lerroa:     key: 'open',
Kode lerroa:     value: function open() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       this.overlayManager.open(this.overlayName).then(function () {
Kode lerroa:         _this2.input.focus();
Kode lerroa:         var promptString = void 0;
Kode lerroa:         if (_this2.reason === _pdfjsLib.PasswordResponses.INCORRECT_PASSWORD) {
Kode lerroa:           promptString = _this2.l10n.get('password_invalid', null, 'Invalid password. Please try again.');
Kode lerroa:         } else {
Kode lerroa:           promptString = _this2.l10n.get('password_label', null, 'Enter the password to open this PDF file.');
Kode lerroa:         }
Kode lerroa:         promptString.then(function (msg) {
Kode lerroa:           _this2.label.textContent = msg;
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'close',
Kode lerroa:     value: function close() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       this.overlayManager.close(this.overlayName).then(function () {
Kode lerroa:         _this3.input.value = '';
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'verify',
Kode lerroa:     value: function verify() {
Kode lerroa:       var password = this.input.value;
Kode lerroa:       if (password && password.length > 0) {
Kode lerroa:         this.close();
Kode lerroa:         return this.updateCallback(password);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setUpdateCallback',
Kode lerroa:     value: function setUpdateCallback(updateCallback, reason) {
Kode lerroa:       this.updateCallback = updateCallback;
Kode lerroa:       this.reason = reason;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PasswordPrompt;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PasswordPrompt = PasswordPrompt;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 13 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFAttachmentViewer = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var PDFAttachmentViewer = function () {
Kode lerroa:   function PDFAttachmentViewer(_ref) {
Kode lerroa:     var container = _ref.container,
Kode lerroa:         eventBus = _ref.eventBus,
Kode lerroa:         downloadManager = _ref.downloadManager;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFAttachmentViewer);
Kode lerroa: 
Kode lerroa:     this.container = container;
Kode lerroa:     this.eventBus = eventBus;
Kode lerroa:     this.downloadManager = downloadManager;
Kode lerroa:     this.reset();
Kode lerroa:     this.eventBus.on('fileattachmentannotation', this._appendAttachment.bind(this));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFAttachmentViewer, [{
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       var keepRenderedCapability = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       this.attachments = null;
Kode lerroa:       this.container.textContent = '';
Kode lerroa:       if (!keepRenderedCapability) {
Kode lerroa:         this._renderedCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_dispatchEvent',
Kode lerroa:     value: function _dispatchEvent(attachmentsCount) {
Kode lerroa:       this._renderedCapability.resolve();
Kode lerroa:       this.eventBus.dispatch('attachmentsloaded', {
Kode lerroa:         source: this,
Kode lerroa:         attachmentsCount: attachmentsCount
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindPdfLink',
Kode lerroa:     value: function _bindPdfLink(button, content, filename) {
Kode lerroa:       if (_pdfjsLib.PDFJS.disableCreateObjectURL) {
Kode lerroa:         throw new Error('bindPdfLink: ' + 'Unsupported "PDFJS.disableCreateObjectURL" value.');
Kode lerroa:       }
Kode lerroa:       var blobUrl = void 0;
Kode lerroa:       button.onclick = function () {
Kode lerroa:         if (!blobUrl) {
Kode lerroa:           blobUrl = (0, _pdfjsLib.createObjectURL)(content, 'application/pdf');
Kode lerroa:         }
Kode lerroa:         var viewerUrl = void 0;
Kode lerroa:         viewerUrl = '?file=' + encodeURIComponent(blobUrl + '#' + filename);
Kode lerroa:         window.open(viewerUrl);
Kode lerroa:         return false;
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindLink',
Kode lerroa:     value: function _bindLink(button, content, filename) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       button.onclick = function () {
Kode lerroa:         _this.downloadManager.downloadData(content, filename, '');
Kode lerroa:         return false;
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render(_ref2) {
Kode lerroa:       var attachments = _ref2.attachments,
Kode lerroa:           _ref2$keepRenderedCap = _ref2.keepRenderedCapability,
Kode lerroa:           keepRenderedCapability = _ref2$keepRenderedCap === undefined ? false : _ref2$keepRenderedCap;
Kode lerroa: 
Kode lerroa:       var attachmentsCount = 0;
Kode lerroa:       if (this.attachments) {
Kode lerroa:         this.reset(keepRenderedCapability === true);
Kode lerroa:       }
Kode lerroa:       this.attachments = attachments || null;
Kode lerroa:       if (!attachments) {
Kode lerroa:         this._dispatchEvent(attachmentsCount);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var names = Object.keys(attachments).sort(function (a, b) {
Kode lerroa:         return a.toLowerCase().localeCompare(b.toLowerCase());
Kode lerroa:       });
Kode lerroa:       attachmentsCount = names.length;
Kode lerroa:       for (var i = 0; i < attachmentsCount; i++) {
Kode lerroa:         var item = attachments[names[i]];
Kode lerroa:         var filename = (0, _pdfjsLib.removeNullCharacters)((0, _pdfjsLib.getFilenameFromUrl)(item.filename));
Kode lerroa:         var div = document.createElement('div');
Kode lerroa:         div.className = 'attachmentsItem';
Kode lerroa:         var button = document.createElement('button');
Kode lerroa:         button.textContent = filename;
Kode lerroa:         if (/\.pdf$/i.test(filename) && !_pdfjsLib.PDFJS.disableCreateObjectURL) {
Kode lerroa:           this._bindPdfLink(button, item.content, filename);
Kode lerroa:         } else {
Kode lerroa:           this._bindLink(button, item.content, filename);
Kode lerroa:         }
Kode lerroa:         div.appendChild(button);
Kode lerroa:         this.container.appendChild(div);
Kode lerroa:       }
Kode lerroa:       this._dispatchEvent(attachmentsCount);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_appendAttachment',
Kode lerroa:     value: function _appendAttachment(_ref3) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var id = _ref3.id,
Kode lerroa:           filename = _ref3.filename,
Kode lerroa:           content = _ref3.content;
Kode lerroa: 
Kode lerroa:       this._renderedCapability.promise.then(function () {
Kode lerroa:         var attachments = _this2.attachments;
Kode lerroa:         if (!attachments) {
Kode lerroa:           attachments = Object.create(null);
Kode lerroa:         } else {
Kode lerroa:           for (var name in attachments) {
Kode lerroa:             if (id === name) {
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         attachments[id] = {
Kode lerroa:           filename: filename,
Kode lerroa:           content: content
Kode lerroa:         };
Kode lerroa:         _this2.render({
Kode lerroa:           attachments: attachments,
Kode lerroa:           keepRenderedCapability: true
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFAttachmentViewer;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFAttachmentViewer = PDFAttachmentViewer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 14 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFDocumentProperties = undefined;
Kode lerroa: 
Kode lerroa: var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DEFAULT_FIELD_CONTENT = '-';
Kode lerroa: 
Kode lerroa: var PDFDocumentProperties = function () {
Kode lerroa:   function PDFDocumentProperties(_ref, overlayManager) {
Kode lerroa:     var overlayName = _ref.overlayName,
Kode lerroa:         fields = _ref.fields,
Kode lerroa:         container = _ref.container,
Kode lerroa:         closeButton = _ref.closeButton;
Kode lerroa:     var l10n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFDocumentProperties);
Kode lerroa: 
Kode lerroa:     this.overlayName = overlayName;
Kode lerroa:     this.fields = fields;
Kode lerroa:     this.container = container;
Kode lerroa:     this.overlayManager = overlayManager;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     this._reset();
Kode lerroa:     if (closeButton) {
Kode lerroa:       closeButton.addEventListener('click', this.close.bind(this));
Kode lerroa:     }
Kode lerroa:     this.overlayManager.register(this.overlayName, this.container, this.close.bind(this));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFDocumentProperties, [{
Kode lerroa:     key: 'open',
Kode lerroa:     value: function open() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var freezeFieldData = function freezeFieldData(data) {
Kode lerroa:         Object.defineProperty(_this, 'fieldData', {
Kode lerroa:           value: Object.freeze(data),
Kode lerroa:           writable: false,
Kode lerroa:           enumerable: true,
Kode lerroa:           configurable: true
Kode lerroa:         });
Kode lerroa:       };
Kode lerroa:       Promise.all([this.overlayManager.open(this.overlayName), this._dataAvailableCapability.promise]).then(function () {
Kode lerroa:         if (_this.fieldData) {
Kode lerroa:           _this._updateUI();
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         _this.pdfDocument.getMetadata().then(function (_ref2) {
Kode lerroa:           var info = _ref2.info,
Kode lerroa:               metadata = _ref2.metadata;
Kode lerroa: 
Kode lerroa:           return Promise.all([info, metadata, _this._parseFileSize(_this.maybeFileSize), _this._parseDate(info.CreationDate), _this._parseDate(info.ModDate)]);
Kode lerroa:         }).then(function (_ref3) {
Kode lerroa:           var _ref4 = _slicedToArray(_ref3, 5),
Kode lerroa:               info = _ref4[0],
Kode lerroa:               metadata = _ref4[1],
Kode lerroa:               fileSize = _ref4[2],
Kode lerroa:               creationDate = _ref4[3],
Kode lerroa:               modificationDate = _ref4[4];
Kode lerroa: 
Kode lerroa:           freezeFieldData({
Kode lerroa:             'fileName': (0, _ui_utils.getPDFFileNameFromURL)(_this.url),
Kode lerroa:             'fileSize': fileSize,
Kode lerroa:             'title': info.Title,
Kode lerroa:             'author': info.Author,
Kode lerroa:             'subject': info.Subject,
Kode lerroa:             'keywords': info.Keywords,
Kode lerroa:             'creationDate': creationDate,
Kode lerroa:             'modificationDate': modificationDate,
Kode lerroa:             'creator': info.Creator,
Kode lerroa:             'producer': info.Producer,
Kode lerroa:             'version': info.PDFFormatVersion,
Kode lerroa:             'pageCount': _this.pdfDocument.numPages
Kode lerroa:           });
Kode lerroa:           _this._updateUI();
Kode lerroa:           return _this.pdfDocument.getDownloadInfo();
Kode lerroa:         }).then(function (_ref5) {
Kode lerroa:           var length = _ref5.length;
Kode lerroa: 
Kode lerroa:           return _this._parseFileSize(length);
Kode lerroa:         }).then(function (fileSize) {
Kode lerroa:           var data = (0, _ui_utils.cloneObj)(_this.fieldData);
Kode lerroa:           data['fileSize'] = fileSize;
Kode lerroa:           freezeFieldData(data);
Kode lerroa:           _this._updateUI();
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'close',
Kode lerroa:     value: function close() {
Kode lerroa:       this.overlayManager.close(this.overlayName);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setDocument',
Kode lerroa:     value: function setDocument(pdfDocument, url) {
Kode lerroa:       if (this.pdfDocument) {
Kode lerroa:         this._reset();
Kode lerroa:         this._updateUI(true);
Kode lerroa:       }
Kode lerroa:       if (!pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.pdfDocument = pdfDocument;
Kode lerroa:       this.url = url;
Kode lerroa:       this._dataAvailableCapability.resolve();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setFileSize',
Kode lerroa:     value: function setFileSize(fileSize) {
Kode lerroa:       if (typeof fileSize === 'number' && fileSize > 0) {
Kode lerroa:         this.maybeFileSize = fileSize;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_reset',
Kode lerroa:     value: function _reset() {
Kode lerroa:       this.pdfDocument = null;
Kode lerroa:       this.url = null;
Kode lerroa:       this.maybeFileSize = 0;
Kode lerroa:       delete this.fieldData;
Kode lerroa:       this._dataAvailableCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateUI',
Kode lerroa:     value: function _updateUI() {
Kode lerroa:       var reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       if (reset || !this.fieldData) {
Kode lerroa:         for (var id in this.fields) {
Kode lerroa:           this.fields[id].textContent = DEFAULT_FIELD_CONTENT;
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.overlayManager.active !== this.overlayName) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       for (var _id in this.fields) {
Kode lerroa:         var content = this.fieldData[_id];
Kode lerroa:         this.fields[_id].textContent = content || content === 0 ? content : DEFAULT_FIELD_CONTENT;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_parseFileSize',
Kode lerroa:     value: function _parseFileSize() {
Kode lerroa:       var fileSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
Kode lerroa: 
Kode lerroa:       var kb = fileSize / 1024;
Kode lerroa:       if (!kb) {
Kode lerroa:         return Promise.resolve(undefined);
Kode lerroa:       } else if (kb < 1024) {
Kode lerroa:         return this.l10n.get('document_properties_kb', {
Kode lerroa:           size_kb: (+kb.toPrecision(3)).toLocaleString(),
Kode lerroa:           size_b: fileSize.toLocaleString()
Kode lerroa:         }, '{{size_kb}} KB ({{size_b}} bytes)');
Kode lerroa:       }
Kode lerroa:       return this.l10n.get('document_properties_mb', {
Kode lerroa:         size_mb: (+(kb / 1024).toPrecision(3)).toLocaleString(),
Kode lerroa:         size_b: fileSize.toLocaleString()
Kode lerroa:       }, '{{size_mb}} MB ({{size_b}} bytes)');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_parseDate',
Kode lerroa:     value: function _parseDate(inputDate) {
Kode lerroa:       if (!inputDate) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var dateToParse = inputDate;
Kode lerroa:       if (dateToParse.substring(0, 2) === 'D:') {
Kode lerroa:         dateToParse = dateToParse.substring(2);
Kode lerroa:       }
Kode lerroa:       var year = parseInt(dateToParse.substring(0, 4), 10);
Kode lerroa:       var month = parseInt(dateToParse.substring(4, 6), 10) - 1;
Kode lerroa:       var day = parseInt(dateToParse.substring(6, 8), 10);
Kode lerroa:       var hours = parseInt(dateToParse.substring(8, 10), 10);
Kode lerroa:       var minutes = parseInt(dateToParse.substring(10, 12), 10);
Kode lerroa:       var seconds = parseInt(dateToParse.substring(12, 14), 10);
Kode lerroa:       var utRel = dateToParse.substring(14, 15);
Kode lerroa:       var offsetHours = parseInt(dateToParse.substring(15, 17), 10);
Kode lerroa:       var offsetMinutes = parseInt(dateToParse.substring(18, 20), 10);
Kode lerroa:       if (utRel === '-') {
Kode lerroa:         hours += offsetHours;
Kode lerroa:         minutes += offsetMinutes;
Kode lerroa:       } else if (utRel === '+') {
Kode lerroa:         hours -= offsetHours;
Kode lerroa:         minutes -= offsetMinutes;
Kode lerroa:       }
Kode lerroa:       var date = new Date(Date.UTC(year, month, day, hours, minutes, seconds));
Kode lerroa:       var dateString = date.toLocaleDateString();
Kode lerroa:       var timeString = date.toLocaleTimeString();
Kode lerroa:       return this.l10n.get('document_properties_date_string', {
Kode lerroa:         date: dateString,
Kode lerroa:         time: timeString
Kode lerroa:       }, '{{date}}, {{time}}');
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFDocumentProperties;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFDocumentProperties = PDFDocumentProperties;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 15 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFFindBar = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdf_find_controller = __webpack_require__(7);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var PDFFindBar = function () {
Kode lerroa:   function PDFFindBar(options) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var l10n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFFindBar);
Kode lerroa: 
Kode lerroa:     this.opened = false;
Kode lerroa:     this.bar = options.bar || null;
Kode lerroa:     this.toggleButton = options.toggleButton || null;
Kode lerroa:     this.findField = options.findField || null;
Kode lerroa:     this.highlightAll = options.highlightAllCheckbox || null;
Kode lerroa:     this.caseSensitive = options.caseSensitiveCheckbox || null;
Kode lerroa:     this.findMsg = options.findMsg || null;
Kode lerroa:     this.findResultsCount = options.findResultsCount || null;
Kode lerroa:     this.findStatusIcon = options.findStatusIcon || null;
Kode lerroa:     this.findPreviousButton = options.findPreviousButton || null;
Kode lerroa:     this.findNextButton = options.findNextButton || null;
Kode lerroa:     this.findController = options.findController || null;
Kode lerroa:     this.eventBus = options.eventBus;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     if (this.findController === null) {
Kode lerroa:       throw new Error('PDFFindBar cannot be used without a ' + 'PDFFindController instance.');
Kode lerroa:     }
Kode lerroa:     this.toggleButton.addEventListener('click', function () {
Kode lerroa:       _this.toggle();
Kode lerroa:     });
Kode lerroa:     this.findField.addEventListener('input', function () {
Kode lerroa:       _this.dispatchEvent('');
Kode lerroa:     });
Kode lerroa:     this.bar.addEventListener('keydown', function (e) {
Kode lerroa:       switch (e.keyCode) {
Kode lerroa:         case 13:
Kode lerroa:           if (e.target === _this.findField) {
Kode lerroa:             _this.dispatchEvent('again', e.shiftKey);
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 27:
Kode lerroa:           _this.close();
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:     this.findPreviousButton.addEventListener('click', function () {
Kode lerroa:       _this.dispatchEvent('again', true);
Kode lerroa:     });
Kode lerroa:     this.findNextButton.addEventListener('click', function () {
Kode lerroa:       _this.dispatchEvent('again', false);
Kode lerroa:     });
Kode lerroa:     this.highlightAll.addEventListener('click', function () {
Kode lerroa:       _this.dispatchEvent('highlightallchange');
Kode lerroa:     });
Kode lerroa:     this.caseSensitive.addEventListener('click', function () {
Kode lerroa:       _this.dispatchEvent('casesensitivitychange');
Kode lerroa:     });
Kode lerroa:     this.eventBus.on('resize', this._adjustWidth.bind(this));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFFindBar, [{
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       this.updateUIState();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'dispatchEvent',
Kode lerroa:     value: function dispatchEvent(type, findPrev) {
Kode lerroa:       this.eventBus.dispatch('find', {
Kode lerroa:         source: this,
Kode lerroa:         type: type,
Kode lerroa:         query: this.findField.value,
Kode lerroa:         caseSensitive: this.caseSensitive.checked,
Kode lerroa:         phraseSearch: true,
Kode lerroa:         highlightAll: this.highlightAll.checked,
Kode lerroa:         findPrevious: findPrev
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateUIState',
Kode lerroa:     value: function updateUIState(state, previous, matchCount) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var notFound = false;
Kode lerroa:       var findMsg = '';
Kode lerroa:       var status = '';
Kode lerroa:       switch (state) {
Kode lerroa:         case _pdf_find_controller.FindState.FOUND:
Kode lerroa:           break;
Kode lerroa:         case _pdf_find_controller.FindState.PENDING:
Kode lerroa:           status = 'pending';
Kode lerroa:           break;
Kode lerroa:         case _pdf_find_controller.FindState.NOT_FOUND:
Kode lerroa:           findMsg = this.l10n.get('find_not_found', null, 'Phrase not found');
Kode lerroa:           notFound = true;
Kode lerroa:           break;
Kode lerroa:         case _pdf_find_controller.FindState.WRAPPED:
Kode lerroa:           if (previous) {
Kode lerroa:             findMsg = this.l10n.get('find_reached_top', null, 'Reached top of document, continued from bottom');
Kode lerroa:           } else {
Kode lerroa:             findMsg = this.l10n.get('find_reached_bottom', null, 'Reached end of document, continued from top');
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:       if (notFound) {
Kode lerroa:         this.findField.classList.add('notFound');
Kode lerroa:       } else {
Kode lerroa:         this.findField.classList.remove('notFound');
Kode lerroa:       }
Kode lerroa:       this.findField.setAttribute('data-status', status);
Kode lerroa:       Promise.resolve(findMsg).then(function (msg) {
Kode lerroa:         _this2.findMsg.textContent = msg;
Kode lerroa:         _this2._adjustWidth();
Kode lerroa:       });
Kode lerroa:       this.updateResultsCount(matchCount);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateResultsCount',
Kode lerroa:     value: function updateResultsCount(matchCount) {
Kode lerroa:       if (!this.findResultsCount) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!matchCount) {
Kode lerroa:         this.findResultsCount.classList.add('hidden');
Kode lerroa:         this.findResultsCount.textContent = '';
Kode lerroa:       } else {
Kode lerroa:         this.findResultsCount.textContent = matchCount.toLocaleString();
Kode lerroa:         this.findResultsCount.classList.remove('hidden');
Kode lerroa:       }
Kode lerroa:       this._adjustWidth();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'open',
Kode lerroa:     value: function open() {
Kode lerroa:       if (!this.opened) {
Kode lerroa:         this.opened = true;
Kode lerroa:         this.toggleButton.classList.add('toggled');
Kode lerroa:         this.bar.classList.remove('hidden');
Kode lerroa:       }
Kode lerroa:       this.findField.select();
Kode lerroa:       this.findField.focus();
Kode lerroa:       this._adjustWidth();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'close',
Kode lerroa:     value: function close() {
Kode lerroa:       if (!this.opened) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.opened = false;
Kode lerroa:       this.toggleButton.classList.remove('toggled');
Kode lerroa:       this.bar.classList.add('hidden');
Kode lerroa:       this.findController.active = false;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'toggle',
Kode lerroa:     value: function toggle() {
Kode lerroa:       if (this.opened) {
Kode lerroa:         this.close();
Kode lerroa:       } else {
Kode lerroa:         this.open();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_adjustWidth',
Kode lerroa:     value: function _adjustWidth() {
Kode lerroa:       if (!this.opened) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.bar.classList.remove('wrapContainers');
Kode lerroa:       var findbarHeight = this.bar.clientHeight;
Kode lerroa:       var inputContainerHeight = this.bar.firstElementChild.clientHeight;
Kode lerroa:       if (findbarHeight > inputContainerHeight) {
Kode lerroa:         this.bar.classList.add('wrapContainers');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFFindBar;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFFindBar = PDFFindBar;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 16 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.isDestArraysEqual = exports.isDestHashesEqual = exports.PDFHistory = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _dom_events = __webpack_require__(2);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var HASH_CHANGE_TIMEOUT = 1000;
Kode lerroa: var POSITION_UPDATED_THRESHOLD = 50;
Kode lerroa: var UPDATE_VIEWAREA_TIMEOUT = 1000;
Kode lerroa: function getCurrentHash() {
Kode lerroa:   return document.location.hash;
Kode lerroa: }
Kode lerroa: function parseCurrentHash(linkService) {
Kode lerroa:   var hash = unescape(getCurrentHash()).substring(1);
Kode lerroa:   var params = (0, _ui_utils.parseQueryString)(hash);
Kode lerroa:   var page = params.page | 0;
Kode lerroa:   if (!(Number.isInteger(page) && page > 0 && page <= linkService.pagesCount)) {
Kode lerroa:     page = null;
Kode lerroa:   }
Kode lerroa:   return {
Kode lerroa:     hash: hash,
Kode lerroa:     page: page,
Kode lerroa:     rotation: linkService.rotation
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var PDFHistory = function () {
Kode lerroa:   function PDFHistory(_ref) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var linkService = _ref.linkService,
Kode lerroa:         eventBus = _ref.eventBus;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFHistory);
Kode lerroa: 
Kode lerroa:     this.linkService = linkService;
Kode lerroa:     this.eventBus = eventBus || (0, _dom_events.getGlobalEventBus)();
Kode lerroa:     this.initialized = false;
Kode lerroa:     this.initialBookmark = null;
Kode lerroa:     this.initialRotation = null;
Kode lerroa:     this._boundEvents = Object.create(null);
Kode lerroa:     this._isViewerInPresentationMode = false;
Kode lerroa:     this._isPagesLoaded = false;
Kode lerroa:     this.eventBus.on('presentationmodechanged', function (evt) {
Kode lerroa:       _this._isViewerInPresentationMode = evt.active || evt.switchInProgress;
Kode lerroa:     });
Kode lerroa:     this.eventBus.on('pagesloaded', function (evt) {
Kode lerroa:       _this._isPagesLoaded = !!evt.pagesCount;
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFHistory, [{
Kode lerroa:     key: 'initialize',
Kode lerroa:     value: function initialize(fingerprint) {
Kode lerroa:       var resetHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       if (!fingerprint || typeof fingerprint !== 'string') {
Kode lerroa:         console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var reInitialized = this.initialized && this.fingerprint !== fingerprint;
Kode lerroa:       this.fingerprint = fingerprint;
Kode lerroa:       if (!this.initialized) {
Kode lerroa:         this._bindEvents();
Kode lerroa:       }
Kode lerroa:       var state = window.history.state;
Kode lerroa:       this.initialized = true;
Kode lerroa:       this.initialBookmark = null;
Kode lerroa:       this.initialRotation = null;
Kode lerroa:       this._popStateInProgress = false;
Kode lerroa:       this._blockHashChange = 0;
Kode lerroa:       this._currentHash = getCurrentHash();
Kode lerroa:       this._numPositionUpdates = 0;
Kode lerroa:       this._uid = this._maxUid = 0;
Kode lerroa:       this._destination = null;
Kode lerroa:       this._position = null;
Kode lerroa:       if (!this._isValidState(state) || resetHistory) {
Kode lerroa:         var _parseCurrentHash = parseCurrentHash(this.linkService),
Kode lerroa:             hash = _parseCurrentHash.hash,
Kode lerroa:             page = _parseCurrentHash.page,
Kode lerroa:             rotation = _parseCurrentHash.rotation;
Kode lerroa: 
Kode lerroa:         if (!hash || reInitialized || resetHistory) {
Kode lerroa:           this._pushOrReplaceState(null, true);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         this._pushOrReplaceState({
Kode lerroa:           hash: hash,
Kode lerroa:           page: page,
Kode lerroa:           rotation: rotation
Kode lerroa:         }, true);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var destination = state.destination;
Kode lerroa:       this._updateInternalState(destination, state.uid, true);
Kode lerroa:       if (destination.rotation !== undefined) {
Kode lerroa:         this.initialRotation = destination.rotation;
Kode lerroa:       }
Kode lerroa:       if (destination.dest) {
Kode lerroa:         this.initialBookmark = JSON.stringify(destination.dest);
Kode lerroa:         this._destination.page = null;
Kode lerroa:       } else if (destination.hash) {
Kode lerroa:         this.initialBookmark = destination.hash;
Kode lerroa:       } else if (destination.page) {
Kode lerroa:         this.initialBookmark = 'page=' + destination.page;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'push',
Kode lerroa:     value: function push(_ref2) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var namedDest = _ref2.namedDest,
Kode lerroa:           explicitDest = _ref2.explicitDest,
Kode lerroa:           pageNumber = _ref2.pageNumber;
Kode lerroa: 
Kode lerroa:       if (!this.initialized) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (namedDest && typeof namedDest !== 'string' || !(explicitDest instanceof Array) || !(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) {
Kode lerroa:         console.error('PDFHistory.push: Invalid parameters.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var hash = namedDest || JSON.stringify(explicitDest);
Kode lerroa:       if (!hash) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var forceReplace = false;
Kode lerroa:       if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
Kode lerroa:         if (this._destination.page) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         forceReplace = true;
Kode lerroa:       }
Kode lerroa:       if (this._popStateInProgress && !forceReplace) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._pushOrReplaceState({
Kode lerroa:         dest: explicitDest,
Kode lerroa:         hash: hash,
Kode lerroa:         page: pageNumber,
Kode lerroa:         rotation: this.linkService.rotation
Kode lerroa:       }, forceReplace);
Kode lerroa:       if (!this._popStateInProgress) {
Kode lerroa:         this._popStateInProgress = true;
Kode lerroa:         Promise.resolve().then(function () {
Kode lerroa:           _this2._popStateInProgress = false;
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pushCurrentPosition',
Kode lerroa:     value: function pushCurrentPosition() {
Kode lerroa:       if (!this.initialized || this._popStateInProgress) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._tryPushCurrentPosition();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'back',
Kode lerroa:     value: function back() {
Kode lerroa:       if (!this.initialized || this._popStateInProgress) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var state = window.history.state;
Kode lerroa:       if (this._isValidState(state) && state.uid > 0) {
Kode lerroa:         window.history.back();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'forward',
Kode lerroa:     value: function forward() {
Kode lerroa:       if (!this.initialized || this._popStateInProgress) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var state = window.history.state;
Kode lerroa:       if (this._isValidState(state) && state.uid < this._maxUid) {
Kode lerroa:         window.history.forward();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_pushOrReplaceState',
Kode lerroa:     value: function _pushOrReplaceState(destination) {
Kode lerroa:       var forceReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       var shouldReplace = forceReplace || !this._destination;
Kode lerroa:       var newState = {
Kode lerroa:         fingerprint: this.fingerprint,
Kode lerroa:         uid: shouldReplace ? this._uid : this._uid + 1,
Kode lerroa:         destination: destination
Kode lerroa:       };
Kode lerroa:       this._updateInternalState(destination, newState.uid);
Kode lerroa:       if (shouldReplace) {
Kode lerroa:         window.history.replaceState(newState, '', document.URL);
Kode lerroa:       } else {
Kode lerroa:         this._maxUid = this._uid;
Kode lerroa:         window.history.pushState(newState, '', document.URL);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_tryPushCurrentPosition',
Kode lerroa:     value: function _tryPushCurrentPosition() {
Kode lerroa:       var temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       if (!this._position) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var position = this._position;
Kode lerroa:       if (temporary) {
Kode lerroa:         position = (0, _ui_utils.cloneObj)(this._position);
Kode lerroa:         position.temporary = true;
Kode lerroa:       }
Kode lerroa:       if (!this._destination) {
Kode lerroa:         this._pushOrReplaceState(position);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._destination.temporary) {
Kode lerroa:         this._pushOrReplaceState(position, true);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._destination.hash === position.hash) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var forceReplace = false;
Kode lerroa:       if (this._destination.page === position.first || this._destination.page === position.page) {
Kode lerroa:         if (this._destination.dest || !this._destination.first) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         forceReplace = true;
Kode lerroa:       }
Kode lerroa:       this._pushOrReplaceState(position, forceReplace);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_isValidState',
Kode lerroa:     value: function _isValidState(state) {
Kode lerroa:       if (!state) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       if (state.fingerprint !== this.fingerprint) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       if (!Number.isInteger(state.uid) || state.uid < 0) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       if (state.destination === null || _typeof(state.destination) !== 'object') {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateInternalState',
Kode lerroa:     value: function _updateInternalState(destination, uid) {
Kode lerroa:       var removeTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:       if (this._updateViewareaTimeout) {
Kode lerroa:         clearTimeout(this._updateViewareaTimeout);
Kode lerroa:         this._updateViewareaTimeout = null;
Kode lerroa:       }
Kode lerroa:       if (removeTemporary && destination && destination.temporary) {
Kode lerroa:         delete destination.temporary;
Kode lerroa:       }
Kode lerroa:       this._destination = destination;
Kode lerroa:       this._uid = uid;
Kode lerroa:       this._numPositionUpdates = 0;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateViewarea',
Kode lerroa:     value: function _updateViewarea(_ref3) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       var location = _ref3.location;
Kode lerroa: 
Kode lerroa:       if (this._updateViewareaTimeout) {
Kode lerroa:         clearTimeout(this._updateViewareaTimeout);
Kode lerroa:         this._updateViewareaTimeout = null;
Kode lerroa:       }
Kode lerroa:       this._position = {
Kode lerroa:         hash: this._isViewerInPresentationMode ? 'page=' + location.pageNumber : location.pdfOpenParams.substring(1),
Kode lerroa:         page: this.linkService.page,
Kode lerroa:         first: location.pageNumber,
Kode lerroa:         rotation: location.rotation
Kode lerroa:       };
Kode lerroa:       if (this._popStateInProgress) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
Kode lerroa:         this._numPositionUpdates++;
Kode lerroa:       }
Kode lerroa:       if (UPDATE_VIEWAREA_TIMEOUT > 0) {
Kode lerroa:         this._updateViewareaTimeout = setTimeout(function () {
Kode lerroa:           if (!_this3._popStateInProgress) {
Kode lerroa:             _this3._tryPushCurrentPosition(true);
Kode lerroa:           }
Kode lerroa:           _this3._updateViewareaTimeout = null;
Kode lerroa:         }, UPDATE_VIEWAREA_TIMEOUT);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_popState',
Kode lerroa:     value: function _popState(_ref4) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       var state = _ref4.state;
Kode lerroa: 
Kode lerroa:       var newHash = getCurrentHash(),
Kode lerroa:           hashChanged = this._currentHash !== newHash;
Kode lerroa:       this._currentHash = newHash;
Kode lerroa:       if (!state || false) {
Kode lerroa:         this._uid++;
Kode lerroa: 
Kode lerroa:         var _parseCurrentHash2 = parseCurrentHash(this.linkService),
Kode lerroa:             hash = _parseCurrentHash2.hash,
Kode lerroa:             page = _parseCurrentHash2.page,
Kode lerroa:             rotation = _parseCurrentHash2.rotation;
Kode lerroa: 
Kode lerroa:         this._pushOrReplaceState({
Kode lerroa:           hash: hash,
Kode lerroa:           page: page,
Kode lerroa:           rotation: rotation
Kode lerroa:         }, true);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!this._isValidState(state)) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._popStateInProgress = true;
Kode lerroa:       if (hashChanged) {
Kode lerroa:         this._blockHashChange++;
Kode lerroa:         (0, _ui_utils.waitOnEventOrTimeout)({
Kode lerroa:           target: window,
Kode lerroa:           name: 'hashchange',
Kode lerroa:           delay: HASH_CHANGE_TIMEOUT
Kode lerroa:         }).then(function () {
Kode lerroa:           _this4._blockHashChange--;
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       var destination = state.destination;
Kode lerroa:       this._updateInternalState(destination, state.uid, true);
Kode lerroa:       if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
Kode lerroa:         this.linkService.rotation = destination.rotation;
Kode lerroa:       }
Kode lerroa:       if (destination.dest) {
Kode lerroa:         this.linkService.navigateTo(destination.dest);
Kode lerroa:       } else if (destination.hash) {
Kode lerroa:         this.linkService.setHash(destination.hash);
Kode lerroa:       } else if (destination.page) {
Kode lerroa:         this.linkService.page = destination.page;
Kode lerroa:       }
Kode lerroa:       Promise.resolve().then(function () {
Kode lerroa:         _this4._popStateInProgress = false;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindEvents',
Kode lerroa:     value: function _bindEvents() {
Kode lerroa:       var _this5 = this;
Kode lerroa: 
Kode lerroa:       var _boundEvents = this._boundEvents,
Kode lerroa:           eventBus = this.eventBus;
Kode lerroa: 
Kode lerroa:       _boundEvents.updateViewarea = this._updateViewarea.bind(this);
Kode lerroa:       _boundEvents.popState = this._popState.bind(this);
Kode lerroa:       _boundEvents.pageHide = function (evt) {
Kode lerroa:         if (!_this5._destination) {
Kode lerroa:           _this5._tryPushCurrentPosition();
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       eventBus.on('updateviewarea', _boundEvents.updateViewarea);
Kode lerroa:       window.addEventListener('popstate', _boundEvents.popState);
Kode lerroa:       window.addEventListener('pagehide', _boundEvents.pageHide);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'popStateInProgress',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.initialized && (this._popStateInProgress || this._blockHashChange > 0);
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFHistory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: function isDestHashesEqual(destHash, pushHash) {
Kode lerroa:   if (typeof destHash !== 'string' || typeof pushHash !== 'string') {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   if (destHash === pushHash) {
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   var _parseQueryString = (0, _ui_utils.parseQueryString)(destHash),
Kode lerroa:       nameddest = _parseQueryString.nameddest;
Kode lerroa: 
Kode lerroa:   if (nameddest === pushHash) {
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   return false;
Kode lerroa: }
Kode lerroa: function isDestArraysEqual(firstDest, secondDest) {
Kode lerroa:   function isEntryEqual(first, second) {
Kode lerroa:     if ((typeof first === 'undefined' ? 'undefined' : _typeof(first)) !== (typeof second === 'undefined' ? 'undefined' : _typeof(second))) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (first instanceof Array || second instanceof Array) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:     if (first !== null && (typeof first === 'undefined' ? 'undefined' : _typeof(first)) === 'object' && second !== null) {
Kode lerroa:       if (Object.keys(first).length !== Object.keys(second).length) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       for (var key in first) {
Kode lerroa:         if (!isEntryEqual(first[key], second[key])) {
Kode lerroa:           return false;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:     return first === second || Number.isNaN(first) && Number.isNaN(second);
Kode lerroa:   }
Kode lerroa:   if (!(firstDest instanceof Array && secondDest instanceof Array)) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   if (firstDest.length !== secondDest.length) {
Kode lerroa:     return false;
Kode lerroa:   }
Kode lerroa:   for (var i = 0, ii = firstDest.length; i < ii; i++) {
Kode lerroa:     if (!isEntryEqual(firstDest[i], secondDest[i])) {
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return true;
Kode lerroa: }
Kode lerroa: exports.PDFHistory = PDFHistory;
Kode lerroa: exports.isDestHashesEqual = isDestHashesEqual;
Kode lerroa: exports.isDestArraysEqual = isDestArraysEqual;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 17 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFOutlineViewer = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DEFAULT_TITLE = '\u2013';
Kode lerroa: 
Kode lerroa: var PDFOutlineViewer = function () {
Kode lerroa:   function PDFOutlineViewer(_ref) {
Kode lerroa:     var container = _ref.container,
Kode lerroa:         linkService = _ref.linkService,
Kode lerroa:         eventBus = _ref.eventBus;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFOutlineViewer);
Kode lerroa: 
Kode lerroa:     this.container = container;
Kode lerroa:     this.linkService = linkService;
Kode lerroa:     this.eventBus = eventBus;
Kode lerroa:     this.reset();
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFOutlineViewer, [{
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       this.outline = null;
Kode lerroa:       this.lastToggleIsShow = true;
Kode lerroa:       this.container.textContent = '';
Kode lerroa:       this.container.classList.remove('outlineWithDeepNesting');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_dispatchEvent',
Kode lerroa:     value: function _dispatchEvent(outlineCount) {
Kode lerroa:       this.eventBus.dispatch('outlineloaded', {
Kode lerroa:         source: this,
Kode lerroa:         outlineCount: outlineCount
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindLink',
Kode lerroa:     value: function _bindLink(element, item) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       if (item.url) {
Kode lerroa:         (0, _pdfjsLib.addLinkAttributes)(element, {
Kode lerroa:           url: item.url,
Kode lerroa:           target: item.newWindow ? _pdfjsLib.PDFJS.LinkTarget.BLANK : undefined
Kode lerroa:         });
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var destination = item.dest;
Kode lerroa:       element.href = this.linkService.getDestinationHash(destination);
Kode lerroa:       element.onclick = function () {
Kode lerroa:         if (destination) {
Kode lerroa:           _this.linkService.navigateTo(destination);
Kode lerroa:         }
Kode lerroa:         return false;
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setStyles',
Kode lerroa:     value: function _setStyles(element, item) {
Kode lerroa:       var styleStr = '';
Kode lerroa:       if (item.bold) {
Kode lerroa:         styleStr += 'font-weight: bold;';
Kode lerroa:       }
Kode lerroa:       if (item.italic) {
Kode lerroa:         styleStr += 'font-style: italic;';
Kode lerroa:       }
Kode lerroa:       if (styleStr) {
Kode lerroa:         element.setAttribute('style', styleStr);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_addToggleButton',
Kode lerroa:     value: function _addToggleButton(div) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var toggler = document.createElement('div');
Kode lerroa:       toggler.className = 'outlineItemToggler';
Kode lerroa:       toggler.onclick = function (evt) {
Kode lerroa:         evt.stopPropagation();
Kode lerroa:         toggler.classList.toggle('outlineItemsHidden');
Kode lerroa:         if (evt.shiftKey) {
Kode lerroa:           var shouldShowAll = !toggler.classList.contains('outlineItemsHidden');
Kode lerroa:           _this2._toggleOutlineItem(div, shouldShowAll);
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       div.insertBefore(toggler, div.firstChild);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_toggleOutlineItem',
Kode lerroa:     value: function _toggleOutlineItem(root, show) {
Kode lerroa:       this.lastToggleIsShow = show;
Kode lerroa:       var togglers = root.querySelectorAll('.outlineItemToggler');
Kode lerroa:       for (var i = 0, ii = togglers.length; i < ii; ++i) {
Kode lerroa:         togglers[i].classList[show ? 'remove' : 'add']('outlineItemsHidden');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'toggleOutlineTree',
Kode lerroa:     value: function toggleOutlineTree() {
Kode lerroa:       if (!this.outline) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._toggleOutlineItem(this.container, !this.lastToggleIsShow);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render(_ref2) {
Kode lerroa:       var outline = _ref2.outline;
Kode lerroa: 
Kode lerroa:       var outlineCount = 0;
Kode lerroa:       if (this.outline) {
Kode lerroa:         this.reset();
Kode lerroa:       }
Kode lerroa:       this.outline = outline || null;
Kode lerroa:       if (!outline) {
Kode lerroa:         this._dispatchEvent(outlineCount);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var fragment = document.createDocumentFragment();
Kode lerroa:       var queue = [{
Kode lerroa:         parent: fragment,
Kode lerroa:         items: this.outline
Kode lerroa:       }];
Kode lerroa:       var hasAnyNesting = false;
Kode lerroa:       while (queue.length > 0) {
Kode lerroa:         var levelData = queue.shift();
Kode lerroa:         for (var i = 0, len = levelData.items.length; i < len; i++) {
Kode lerroa:           var item = levelData.items[i];
Kode lerroa:           var div = document.createElement('div');
Kode lerroa:           div.className = 'outlineItem';
Kode lerroa:           var element = document.createElement('a');
Kode lerroa:           this._bindLink(element, item);
Kode lerroa:           this._setStyles(element, item);
Kode lerroa:           element.textContent = (0, _pdfjsLib.removeNullCharacters)(item.title) || DEFAULT_TITLE;
Kode lerroa:           div.appendChild(element);
Kode lerroa:           if (item.items.length > 0) {
Kode lerroa:             hasAnyNesting = true;
Kode lerroa:             this._addToggleButton(div);
Kode lerroa:             var itemsDiv = document.createElement('div');
Kode lerroa:             itemsDiv.className = 'outlineItems';
Kode lerroa:             div.appendChild(itemsDiv);
Kode lerroa:             queue.push({
Kode lerroa:               parent: itemsDiv,
Kode lerroa:               items: item.items
Kode lerroa:             });
Kode lerroa:           }
Kode lerroa:           levelData.parent.appendChild(div);
Kode lerroa:           outlineCount++;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (hasAnyNesting) {
Kode lerroa:         this.container.classList.add('outlineWithDeepNesting');
Kode lerroa:       }
Kode lerroa:       this.container.appendChild(fragment);
Kode lerroa:       this._dispatchEvent(outlineCount);
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFOutlineViewer;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFOutlineViewer = PDFOutlineViewer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 18 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFPresentationMode = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500;
Kode lerroa: var DELAY_BEFORE_HIDING_CONTROLS = 3000;
Kode lerroa: var ACTIVE_SELECTOR = 'pdfPresentationMode';
Kode lerroa: var CONTROLS_SELECTOR = 'pdfPresentationModeControls';
Kode lerroa: var MOUSE_SCROLL_COOLDOWN_TIME = 50;
Kode lerroa: var PAGE_SWITCH_THRESHOLD = 0.1;
Kode lerroa: var SWIPE_MIN_DISTANCE_THRESHOLD = 50;
Kode lerroa: var SWIPE_ANGLE_THRESHOLD = Math.PI / 6;
Kode lerroa: 
Kode lerroa: var PDFPresentationMode = function () {
Kode lerroa:   function PDFPresentationMode(_ref) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var container = _ref.container,
Kode lerroa:         _ref$viewer = _ref.viewer,
Kode lerroa:         viewer = _ref$viewer === undefined ? null : _ref$viewer,
Kode lerroa:         pdfViewer = _ref.pdfViewer,
Kode lerroa:         eventBus = _ref.eventBus,
Kode lerroa:         _ref$contextMenuItems = _ref.contextMenuItems,
Kode lerroa:         contextMenuItems = _ref$contextMenuItems === undefined ? null : _ref$contextMenuItems;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFPresentationMode);
Kode lerroa: 
Kode lerroa:     this.container = container;
Kode lerroa:     this.viewer = viewer || container.firstElementChild;
Kode lerroa:     this.pdfViewer = pdfViewer;
Kode lerroa:     this.eventBus = eventBus;
Kode lerroa:     this.active = false;
Kode lerroa:     this.args = null;
Kode lerroa:     this.contextMenuOpen = false;
Kode lerroa:     this.mouseScrollTimeStamp = 0;
Kode lerroa:     this.mouseScrollDelta = 0;
Kode lerroa:     this.touchSwipeState = null;
Kode lerroa:     if (contextMenuItems) {
Kode lerroa:       contextMenuItems.contextFirstPage.addEventListener('click', function () {
Kode lerroa:         _this.contextMenuOpen = false;
Kode lerroa:         _this.eventBus.dispatch('firstpage');
Kode lerroa:       });
Kode lerroa:       contextMenuItems.contextLastPage.addEventListener('click', function () {
Kode lerroa:         _this.contextMenuOpen = false;
Kode lerroa:         _this.eventBus.dispatch('lastpage');
Kode lerroa:       });
Kode lerroa:       contextMenuItems.contextPageRotateCw.addEventListener('click', function () {
Kode lerroa:         _this.contextMenuOpen = false;
Kode lerroa:         _this.eventBus.dispatch('rotatecw');
Kode lerroa:       });
Kode lerroa:       contextMenuItems.contextPageRotateCcw.addEventListener('click', function () {
Kode lerroa:         _this.contextMenuOpen = false;
Kode lerroa:         _this.eventBus.dispatch('rotateccw');
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFPresentationMode, [{
Kode lerroa:     key: 'request',
Kode lerroa:     value: function request() {
Kode lerroa:       if (this.switchInProgress || this.active || !this.viewer.hasChildNodes()) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       this._addFullscreenChangeListeners();
Kode lerroa:       this._setSwitchInProgress();
Kode lerroa:       this._notifyStateChange();
Kode lerroa:       if (this.container.requestFullscreen) {
Kode lerroa:         this.container.requestFullscreen();
Kode lerroa:       } else if (this.container.mozRequestFullScreen) {
Kode lerroa:         this.container.mozRequestFullScreen();
Kode lerroa:       } else if (this.container.webkitRequestFullscreen) {
Kode lerroa:         this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
Kode lerroa:       } else if (this.container.msRequestFullscreen) {
Kode lerroa:         this.container.msRequestFullscreen();
Kode lerroa:       } else {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       this.args = {
Kode lerroa:         page: this.pdfViewer.currentPageNumber,
Kode lerroa:         previousScale: this.pdfViewer.currentScaleValue
Kode lerroa:       };
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_mouseWheel',
Kode lerroa:     value: function _mouseWheel(evt) {
Kode lerroa:       if (!this.active) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       evt.preventDefault();
Kode lerroa:       var delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
Kode lerroa:       var currentTime = new Date().getTime();
Kode lerroa:       var storedTime = this.mouseScrollTimeStamp;
Kode lerroa:       if (currentTime > storedTime && currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.mouseScrollDelta > 0 && delta < 0 || this.mouseScrollDelta < 0 && delta > 0) {
Kode lerroa:         this._resetMouseScrollState();
Kode lerroa:       }
Kode lerroa:       this.mouseScrollDelta += delta;
Kode lerroa:       if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) {
Kode lerroa:         var totalDelta = this.mouseScrollDelta;
Kode lerroa:         this._resetMouseScrollState();
Kode lerroa:         var success = totalDelta > 0 ? this._goToPreviousPage() : this._goToNextPage();
Kode lerroa:         if (success) {
Kode lerroa:           this.mouseScrollTimeStamp = currentTime;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_goToPreviousPage',
Kode lerroa:     value: function _goToPreviousPage() {
Kode lerroa:       var page = this.pdfViewer.currentPageNumber;
Kode lerroa:       if (page <= 1) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       this.pdfViewer.currentPageNumber = page - 1;
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_goToNextPage',
Kode lerroa:     value: function _goToNextPage() {
Kode lerroa:       var page = this.pdfViewer.currentPageNumber;
Kode lerroa:       if (page >= this.pdfViewer.pagesCount) {
Kode lerroa:         return false;
Kode lerroa:       }
Kode lerroa:       this.pdfViewer.currentPageNumber = page + 1;
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_notifyStateChange',
Kode lerroa:     value: function _notifyStateChange() {
Kode lerroa:       this.eventBus.dispatch('presentationmodechanged', {
Kode lerroa:         source: this,
Kode lerroa:         active: this.active,
Kode lerroa:         switchInProgress: !!this.switchInProgress
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setSwitchInProgress',
Kode lerroa:     value: function _setSwitchInProgress() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (this.switchInProgress) {
Kode lerroa:         clearTimeout(this.switchInProgress);
Kode lerroa:       }
Kode lerroa:       this.switchInProgress = setTimeout(function () {
Kode lerroa:         _this2._removeFullscreenChangeListeners();
Kode lerroa:         delete _this2.switchInProgress;
Kode lerroa:         _this2._notifyStateChange();
Kode lerroa:       }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resetSwitchInProgress',
Kode lerroa:     value: function _resetSwitchInProgress() {
Kode lerroa:       if (this.switchInProgress) {
Kode lerroa:         clearTimeout(this.switchInProgress);
Kode lerroa:         delete this.switchInProgress;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_enter',
Kode lerroa:     value: function _enter() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       this.active = true;
Kode lerroa:       this._resetSwitchInProgress();
Kode lerroa:       this._notifyStateChange();
Kode lerroa:       this.container.classList.add(ACTIVE_SELECTOR);
Kode lerroa:       setTimeout(function () {
Kode lerroa:         _this3.pdfViewer.currentPageNumber = _this3.args.page;
Kode lerroa:         _this3.pdfViewer.currentScaleValue = 'page-fit';
Kode lerroa:       }, 0);
Kode lerroa:       this._addWindowListeners();
Kode lerroa:       this._showControls();
Kode lerroa:       this.contextMenuOpen = false;
Kode lerroa:       this.container.setAttribute('contextmenu', 'viewerContextMenu');
Kode lerroa:       window.getSelection().removeAllRanges();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_exit',
Kode lerroa:     value: function _exit() {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       var page = this.pdfViewer.currentPageNumber;
Kode lerroa:       this.container.classList.remove(ACTIVE_SELECTOR);
Kode lerroa:       setTimeout(function () {
Kode lerroa:         _this4.active = false;
Kode lerroa:         _this4._removeFullscreenChangeListeners();
Kode lerroa:         _this4._notifyStateChange();
Kode lerroa:         _this4.pdfViewer.currentScaleValue = _this4.args.previousScale;
Kode lerroa:         _this4.pdfViewer.currentPageNumber = page;
Kode lerroa:         _this4.args = null;
Kode lerroa:       }, 0);
Kode lerroa:       this._removeWindowListeners();
Kode lerroa:       this._hideControls();
Kode lerroa:       this._resetMouseScrollState();
Kode lerroa:       this.container.removeAttribute('contextmenu');
Kode lerroa:       this.contextMenuOpen = false;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_mouseDown',
Kode lerroa:     value: function _mouseDown(evt) {
Kode lerroa:       if (this.contextMenuOpen) {
Kode lerroa:         this.contextMenuOpen = false;
Kode lerroa:         evt.preventDefault();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (evt.button === 0) {
Kode lerroa:         var isInternalLink = evt.target.href && evt.target.classList.contains('internalLink');
Kode lerroa:         if (!isInternalLink) {
Kode lerroa:           evt.preventDefault();
Kode lerroa:           if (evt.shiftKey) {
Kode lerroa:             this._goToPreviousPage();
Kode lerroa:           } else {
Kode lerroa:             this._goToNextPage();
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_contextMenu',
Kode lerroa:     value: function _contextMenu() {
Kode lerroa:       this.contextMenuOpen = true;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_showControls',
Kode lerroa:     value: function _showControls() {
Kode lerroa:       var _this5 = this;
Kode lerroa: 
Kode lerroa:       if (this.controlsTimeout) {
Kode lerroa:         clearTimeout(this.controlsTimeout);
Kode lerroa:       } else {
Kode lerroa:         this.container.classList.add(CONTROLS_SELECTOR);
Kode lerroa:       }
Kode lerroa:       this.controlsTimeout = setTimeout(function () {
Kode lerroa:         _this5.container.classList.remove(CONTROLS_SELECTOR);
Kode lerroa:         delete _this5.controlsTimeout;
Kode lerroa:       }, DELAY_BEFORE_HIDING_CONTROLS);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_hideControls',
Kode lerroa:     value: function _hideControls() {
Kode lerroa:       if (!this.controlsTimeout) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       clearTimeout(this.controlsTimeout);
Kode lerroa:       this.container.classList.remove(CONTROLS_SELECTOR);
Kode lerroa:       delete this.controlsTimeout;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resetMouseScrollState',
Kode lerroa:     value: function _resetMouseScrollState() {
Kode lerroa:       this.mouseScrollTimeStamp = 0;
Kode lerroa:       this.mouseScrollDelta = 0;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_touchSwipe',
Kode lerroa:     value: function _touchSwipe(evt) {
Kode lerroa:       if (!this.active) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (evt.touches.length > 1) {
Kode lerroa:         this.touchSwipeState = null;
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       switch (evt.type) {
Kode lerroa:         case 'touchstart':
Kode lerroa:           this.touchSwipeState = {
Kode lerroa:             startX: evt.touches[0].pageX,
Kode lerroa:             startY: evt.touches[0].pageY,
Kode lerroa:             endX: evt.touches[0].pageX,
Kode lerroa:             endY: evt.touches[0].pageY
Kode lerroa:           };
Kode lerroa:           break;
Kode lerroa:         case 'touchmove':
Kode lerroa:           if (this.touchSwipeState === null) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           this.touchSwipeState.endX = evt.touches[0].pageX;
Kode lerroa:           this.touchSwipeState.endY = evt.touches[0].pageY;
Kode lerroa:           evt.preventDefault();
Kode lerroa:           break;
Kode lerroa:         case 'touchend':
Kode lerroa:           if (this.touchSwipeState === null) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           var delta = 0;
Kode lerroa:           var dx = this.touchSwipeState.endX - this.touchSwipeState.startX;
Kode lerroa:           var dy = this.touchSwipeState.endY - this.touchSwipeState.startY;
Kode lerroa:           var absAngle = Math.abs(Math.atan2(dy, dx));
Kode lerroa:           if (Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD && (absAngle <= SWIPE_ANGLE_THRESHOLD || absAngle >= Math.PI - SWIPE_ANGLE_THRESHOLD)) {
Kode lerroa:             delta = dx;
Kode lerroa:           } else if (Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD && Math.abs(absAngle - Math.PI / 2) <= SWIPE_ANGLE_THRESHOLD) {
Kode lerroa:             delta = dy;
Kode lerroa:           }
Kode lerroa:           if (delta > 0) {
Kode lerroa:             this._goToPreviousPage();
Kode lerroa:           } else if (delta < 0) {
Kode lerroa:             this._goToNextPage();
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_addWindowListeners',
Kode lerroa:     value: function _addWindowListeners() {
Kode lerroa:       this.showControlsBind = this._showControls.bind(this);
Kode lerroa:       this.mouseDownBind = this._mouseDown.bind(this);
Kode lerroa:       this.mouseWheelBind = this._mouseWheel.bind(this);
Kode lerroa:       this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this);
Kode lerroa:       this.contextMenuBind = this._contextMenu.bind(this);
Kode lerroa:       this.touchSwipeBind = this._touchSwipe.bind(this);
Kode lerroa:       window.addEventListener('mousemove', this.showControlsBind);
Kode lerroa:       window.addEventListener('mousedown', this.mouseDownBind);
Kode lerroa:       window.addEventListener('wheel', this.mouseWheelBind);
Kode lerroa:       window.addEventListener('keydown', this.resetMouseScrollStateBind);
Kode lerroa:       window.addEventListener('contextmenu', this.contextMenuBind);
Kode lerroa:       window.addEventListener('touchstart', this.touchSwipeBind);
Kode lerroa:       window.addEventListener('touchmove', this.touchSwipeBind);
Kode lerroa:       window.addEventListener('touchend', this.touchSwipeBind);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_removeWindowListeners',
Kode lerroa:     value: function _removeWindowListeners() {
Kode lerroa:       window.removeEventListener('mousemove', this.showControlsBind);
Kode lerroa:       window.removeEventListener('mousedown', this.mouseDownBind);
Kode lerroa:       window.removeEventListener('wheel', this.mouseWheelBind);
Kode lerroa:       window.removeEventListener('keydown', this.resetMouseScrollStateBind);
Kode lerroa:       window.removeEventListener('contextmenu', this.contextMenuBind);
Kode lerroa:       window.removeEventListener('touchstart', this.touchSwipeBind);
Kode lerroa:       window.removeEventListener('touchmove', this.touchSwipeBind);
Kode lerroa:       window.removeEventListener('touchend', this.touchSwipeBind);
Kode lerroa:       delete this.showControlsBind;
Kode lerroa:       delete this.mouseDownBind;
Kode lerroa:       delete this.mouseWheelBind;
Kode lerroa:       delete this.resetMouseScrollStateBind;
Kode lerroa:       delete this.contextMenuBind;
Kode lerroa:       delete this.touchSwipeBind;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_fullscreenChange',
Kode lerroa:     value: function _fullscreenChange() {
Kode lerroa:       if (this.isFullscreen) {
Kode lerroa:         this._enter();
Kode lerroa:       } else {
Kode lerroa:         this._exit();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_addFullscreenChangeListeners',
Kode lerroa:     value: function _addFullscreenChangeListeners() {
Kode lerroa:       this.fullscreenChangeBind = this._fullscreenChange.bind(this);
Kode lerroa:       window.addEventListener('fullscreenchange', this.fullscreenChangeBind);
Kode lerroa:       window.addEventListener('mozfullscreenchange', this.fullscreenChangeBind);
Kode lerroa:       window.addEventListener('webkitfullscreenchange', this.fullscreenChangeBind);
Kode lerroa:       window.addEventListener('MSFullscreenChange', this.fullscreenChangeBind);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_removeFullscreenChangeListeners',
Kode lerroa:     value: function _removeFullscreenChangeListeners() {
Kode lerroa:       window.removeEventListener('fullscreenchange', this.fullscreenChangeBind);
Kode lerroa:       window.removeEventListener('mozfullscreenchange', this.fullscreenChangeBind);
Kode lerroa:       window.removeEventListener('webkitfullscreenchange', this.fullscreenChangeBind);
Kode lerroa:       window.removeEventListener('MSFullscreenChange', this.fullscreenChangeBind);
Kode lerroa:       delete this.fullscreenChangeBind;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isFullscreen',
Kode lerroa:     get: function get() {
Kode lerroa:       return !!(document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement);
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFPresentationMode;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFPresentationMode = PDFPresentationMode;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 19 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFThumbnailViewer = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdf_thumbnail_view = __webpack_require__(20);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var THUMBNAIL_SCROLL_MARGIN = -19;
Kode lerroa: 
Kode lerroa: var PDFThumbnailViewer = function () {
Kode lerroa:   function PDFThumbnailViewer(_ref) {
Kode lerroa:     var container = _ref.container,
Kode lerroa:         linkService = _ref.linkService,
Kode lerroa:         renderingQueue = _ref.renderingQueue,
Kode lerroa:         _ref$l10n = _ref.l10n,
Kode lerroa:         l10n = _ref$l10n === undefined ? _ui_utils.NullL10n : _ref$l10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFThumbnailViewer);
Kode lerroa: 
Kode lerroa:     this.container = container;
Kode lerroa:     this.linkService = linkService;
Kode lerroa:     this.renderingQueue = renderingQueue;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdated.bind(this));
Kode lerroa:     this._resetView();
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFThumbnailViewer, [{
Kode lerroa:     key: '_scrollUpdated',
Kode lerroa:     value: function _scrollUpdated() {
Kode lerroa:       this.renderingQueue.renderHighestPriority();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getThumbnail',
Kode lerroa:     value: function getThumbnail(index) {
Kode lerroa:       return this._thumbnails[index];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_getVisibleThumbs',
Kode lerroa:     value: function _getVisibleThumbs() {
Kode lerroa:       return (0, _ui_utils.getVisibleElements)(this.container, this._thumbnails);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'scrollThumbnailIntoView',
Kode lerroa:     value: function scrollThumbnailIntoView(page) {
Kode lerroa:       var selected = document.querySelector('.thumbnail.selected');
Kode lerroa:       if (selected) {
Kode lerroa:         selected.classList.remove('selected');
Kode lerroa:       }
Kode lerroa:       var thumbnail = document.querySelector('div.thumbnail[data-page-number="' + page + '"]');
Kode lerroa:       if (thumbnail) {
Kode lerroa:         thumbnail.classList.add('selected');
Kode lerroa:       }
Kode lerroa:       var visibleThumbs = this._getVisibleThumbs();
Kode lerroa:       var numVisibleThumbs = visibleThumbs.views.length;
Kode lerroa:       if (numVisibleThumbs > 0) {
Kode lerroa:         var first = visibleThumbs.first.id;
Kode lerroa:         var last = numVisibleThumbs > 1 ? visibleThumbs.last.id : first;
Kode lerroa:         if (page <= first || page >= last) {
Kode lerroa:           (0, _ui_utils.scrollIntoView)(thumbnail, { top: THUMBNAIL_SCROLL_MARGIN });
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cleanup',
Kode lerroa:     value: function cleanup() {
Kode lerroa:       _pdf_thumbnail_view.PDFThumbnailView.cleanup();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resetView',
Kode lerroa:     value: function _resetView() {
Kode lerroa:       this._thumbnails = [];
Kode lerroa:       this._pageLabels = null;
Kode lerroa:       this._pagesRotation = 0;
Kode lerroa:       this._pagesRequests = [];
Kode lerroa:       this.container.textContent = '';
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setDocument',
Kode lerroa:     value: function setDocument(pdfDocument) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       if (this.pdfDocument) {
Kode lerroa:         this._cancelRendering();
Kode lerroa:         this._resetView();
Kode lerroa:       }
Kode lerroa:       this.pdfDocument = pdfDocument;
Kode lerroa:       if (!pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       pdfDocument.getPage(1).then(function (firstPage) {
Kode lerroa:         var pagesCount = pdfDocument.numPages;
Kode lerroa:         var viewport = firstPage.getViewport(1.0);
Kode lerroa:         for (var pageNum = 1; pageNum <= pagesCount; ++pageNum) {
Kode lerroa:           var thumbnail = new _pdf_thumbnail_view.PDFThumbnailView({
Kode lerroa:             container: _this.container,
Kode lerroa:             id: pageNum,
Kode lerroa:             defaultViewport: viewport.clone(),
Kode lerroa:             linkService: _this.linkService,
Kode lerroa:             renderingQueue: _this.renderingQueue,
Kode lerroa:             disableCanvasToImageConversion: false,
Kode lerroa:             l10n: _this.l10n
Kode lerroa:           });
Kode lerroa:           _this._thumbnails.push(thumbnail);
Kode lerroa:         }
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         console.error('Unable to initialize thumbnail viewer', reason);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_cancelRendering',
Kode lerroa:     value: function _cancelRendering() {
Kode lerroa:       for (var i = 0, ii = this._thumbnails.length; i < ii; i++) {
Kode lerroa:         if (this._thumbnails[i]) {
Kode lerroa:           this._thumbnails[i].cancelRendering();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPageLabels',
Kode lerroa:     value: function setPageLabels(labels) {
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!labels) {
Kode lerroa:         this._pageLabels = null;
Kode lerroa:       } else if (!(labels instanceof Array && this.pdfDocument.numPages === labels.length)) {
Kode lerroa:         this._pageLabels = null;
Kode lerroa:         console.error('PDFThumbnailViewer_setPageLabels: Invalid page labels.');
Kode lerroa:       } else {
Kode lerroa:         this._pageLabels = labels;
Kode lerroa:       }
Kode lerroa:       for (var i = 0, ii = this._thumbnails.length; i < ii; i++) {
Kode lerroa:         var label = this._pageLabels && this._pageLabels[i];
Kode lerroa:         this._thumbnails[i].setPageLabel(label);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_ensurePdfPageLoaded',
Kode lerroa:     value: function _ensurePdfPageLoaded(thumbView) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (thumbView.pdfPage) {
Kode lerroa:         return Promise.resolve(thumbView.pdfPage);
Kode lerroa:       }
Kode lerroa:       var pageNumber = thumbView.id;
Kode lerroa:       if (this._pagesRequests[pageNumber]) {
Kode lerroa:         return this._pagesRequests[pageNumber];
Kode lerroa:       }
Kode lerroa:       var promise = this.pdfDocument.getPage(pageNumber).then(function (pdfPage) {
Kode lerroa:         thumbView.setPdfPage(pdfPage);
Kode lerroa:         _this2._pagesRequests[pageNumber] = null;
Kode lerroa:         return pdfPage;
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         console.error('Unable to get page for thumb view', reason);
Kode lerroa:         _this2._pagesRequests[pageNumber] = null;
Kode lerroa:       });
Kode lerroa:       this._pagesRequests[pageNumber] = promise;
Kode lerroa:       return promise;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'forceRendering',
Kode lerroa:     value: function forceRendering() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       var visibleThumbs = this._getVisibleThumbs();
Kode lerroa:       var thumbView = this.renderingQueue.getHighestPriority(visibleThumbs, this._thumbnails, this.scroll.down);
Kode lerroa:       if (thumbView) {
Kode lerroa:         this._ensurePdfPageLoaded(thumbView).then(function () {
Kode lerroa:           _this3.renderingQueue.renderView(thumbView);
Kode lerroa:         });
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pagesRotation',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._pagesRotation;
Kode lerroa:     },
Kode lerroa:     set: function set(rotation) {
Kode lerroa:       if (!(0, _ui_utils.isValidRotation)(rotation)) {
Kode lerroa:         throw new Error('Invalid thumbnails rotation angle.');
Kode lerroa:       }
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._pagesRotation === rotation) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._pagesRotation = rotation;
Kode lerroa:       for (var i = 0, ii = this._thumbnails.length; i < ii; i++) {
Kode lerroa:         this._thumbnails[i].update(rotation);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFThumbnailViewer;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFThumbnailViewer = PDFThumbnailViewer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 20 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFThumbnailView = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdf_rendering_queue = __webpack_require__(3);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var MAX_NUM_SCALING_STEPS = 3;
Kode lerroa: var THUMBNAIL_CANVAS_BORDER_WIDTH = 1;
Kode lerroa: var THUMBNAIL_WIDTH = 98;
Kode lerroa: var TempImageFactory = function TempImageFactoryClosure() {
Kode lerroa:   var tempCanvasCache = null;
Kode lerroa:   return {
Kode lerroa:     getCanvas: function getCanvas(width, height) {
Kode lerroa:       var tempCanvas = tempCanvasCache;
Kode lerroa:       if (!tempCanvas) {
Kode lerroa:         tempCanvas = document.createElement('canvas');
Kode lerroa:         tempCanvasCache = tempCanvas;
Kode lerroa:       }
Kode lerroa:       tempCanvas.width = width;
Kode lerroa:       tempCanvas.height = height;
Kode lerroa:       tempCanvas.mozOpaque = true;
Kode lerroa:       var ctx = tempCanvas.getContext('2d', { alpha: false });
Kode lerroa:       ctx.save();
Kode lerroa:       ctx.fillStyle = 'rgb(255, 255, 255)';
Kode lerroa:       ctx.fillRect(0, 0, width, height);
Kode lerroa:       ctx.restore();
Kode lerroa:       return tempCanvas;
Kode lerroa:     },
Kode lerroa:     destroyCanvas: function destroyCanvas() {
Kode lerroa:       var tempCanvas = tempCanvasCache;
Kode lerroa:       if (tempCanvas) {
Kode lerroa:         tempCanvas.width = 0;
Kode lerroa:         tempCanvas.height = 0;
Kode lerroa:       }
Kode lerroa:       tempCanvasCache = null;
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var PDFThumbnailView = function () {
Kode lerroa:   function PDFThumbnailView(_ref) {
Kode lerroa:     var container = _ref.container,
Kode lerroa:         id = _ref.id,
Kode lerroa:         defaultViewport = _ref.defaultViewport,
Kode lerroa:         linkService = _ref.linkService,
Kode lerroa:         renderingQueue = _ref.renderingQueue,
Kode lerroa:         _ref$disableCanvasToI = _ref.disableCanvasToImageConversion,
Kode lerroa:         disableCanvasToImageConversion = _ref$disableCanvasToI === undefined ? false : _ref$disableCanvasToI,
Kode lerroa:         _ref$l10n = _ref.l10n,
Kode lerroa:         l10n = _ref$l10n === undefined ? _ui_utils.NullL10n : _ref$l10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, PDFThumbnailView);
Kode lerroa: 
Kode lerroa:     this.id = id;
Kode lerroa:     this.renderingId = 'thumbnail' + id;
Kode lerroa:     this.pageLabel = null;
Kode lerroa:     this.pdfPage = null;
Kode lerroa:     this.rotation = 0;
Kode lerroa:     this.viewport = defaultViewport;
Kode lerroa:     this.pdfPageRotate = defaultViewport.rotation;
Kode lerroa:     this.linkService = linkService;
Kode lerroa:     this.renderingQueue = renderingQueue;
Kode lerroa:     this.renderTask = null;
Kode lerroa:     this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
Kode lerroa:     this.resume = null;
Kode lerroa:     this.disableCanvasToImageConversion = disableCanvasToImageConversion;
Kode lerroa:     this.pageWidth = this.viewport.width;
Kode lerroa:     this.pageHeight = this.viewport.height;
Kode lerroa:     this.pageRatio = this.pageWidth / this.pageHeight;
Kode lerroa:     this.canvasWidth = THUMBNAIL_WIDTH;
Kode lerroa:     this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
Kode lerroa:     this.scale = this.canvasWidth / this.pageWidth;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     var anchor = document.createElement('a');
Kode lerroa:     anchor.href = linkService.getAnchorUrl('#page=' + id);
Kode lerroa:     this.l10n.get('thumb_page_title', { page: id }, 'Page {{page}}').then(function (msg) {
Kode lerroa:       anchor.title = msg;
Kode lerroa:     });
Kode lerroa:     anchor.onclick = function () {
Kode lerroa:       linkService.page = id;
Kode lerroa:       return false;
Kode lerroa:     };
Kode lerroa:     this.anchor = anchor;
Kode lerroa:     var div = document.createElement('div');
Kode lerroa:     div.className = 'thumbnail';
Kode lerroa:     div.setAttribute('data-page-number', this.id);
Kode lerroa:     this.div = div;
Kode lerroa:     if (id === 1) {
Kode lerroa:       div.classList.add('selected');
Kode lerroa:     }
Kode lerroa:     var ring = document.createElement('div');
Kode lerroa:     ring.className = 'thumbnailSelectionRing';
Kode lerroa:     var borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
Kode lerroa:     ring.style.width = this.canvasWidth + borderAdjustment + 'px';
Kode lerroa:     ring.style.height = this.canvasHeight + borderAdjustment + 'px';
Kode lerroa:     this.ring = ring;
Kode lerroa:     div.appendChild(ring);
Kode lerroa:     anchor.appendChild(div);
Kode lerroa:     container.appendChild(anchor);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFThumbnailView, [{
Kode lerroa:     key: 'setPdfPage',
Kode lerroa:     value: function setPdfPage(pdfPage) {
Kode lerroa:       this.pdfPage = pdfPage;
Kode lerroa:       this.pdfPageRotate = pdfPage.rotate;
Kode lerroa:       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
Kode lerroa:       this.viewport = pdfPage.getViewport(1, totalRotation);
Kode lerroa:       this.reset();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       this.cancelRendering();
Kode lerroa:       this.pageWidth = this.viewport.width;
Kode lerroa:       this.pageHeight = this.viewport.height;
Kode lerroa:       this.pageRatio = this.pageWidth / this.pageHeight;
Kode lerroa:       this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
Kode lerroa:       this.scale = this.canvasWidth / this.pageWidth;
Kode lerroa:       this.div.removeAttribute('data-loaded');
Kode lerroa:       var ring = this.ring;
Kode lerroa:       var childNodes = ring.childNodes;
Kode lerroa:       for (var i = childNodes.length - 1; i >= 0; i--) {
Kode lerroa:         ring.removeChild(childNodes[i]);
Kode lerroa:       }
Kode lerroa:       var borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
Kode lerroa:       ring.style.width = this.canvasWidth + borderAdjustment + 'px';
Kode lerroa:       ring.style.height = this.canvasHeight + borderAdjustment + 'px';
Kode lerroa:       if (this.canvas) {
Kode lerroa:         this.canvas.width = 0;
Kode lerroa:         this.canvas.height = 0;
Kode lerroa:         delete this.canvas;
Kode lerroa:       }
Kode lerroa:       if (this.image) {
Kode lerroa:         this.image.removeAttribute('src');
Kode lerroa:         delete this.image;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'update',
Kode lerroa:     value: function update(rotation) {
Kode lerroa:       if (typeof rotation !== 'undefined') {
Kode lerroa:         this.rotation = rotation;
Kode lerroa:       }
Kode lerroa:       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
Kode lerroa:       this.viewport = this.viewport.clone({
Kode lerroa:         scale: 1,
Kode lerroa:         rotation: totalRotation
Kode lerroa:       });
Kode lerroa:       this.reset();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancelRendering',
Kode lerroa:     value: function cancelRendering() {
Kode lerroa:       if (this.renderTask) {
Kode lerroa:         this.renderTask.cancel();
Kode lerroa:         this.renderTask = null;
Kode lerroa:       }
Kode lerroa:       this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
Kode lerroa:       this.resume = null;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_getPageDrawContext',
Kode lerroa:     value: function _getPageDrawContext() {
Kode lerroa:       var noCtxScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       var canvas = document.createElement('canvas');
Kode lerroa:       this.canvas = canvas;
Kode lerroa:       canvas.mozOpaque = true;
Kode lerroa:       var ctx = canvas.getContext('2d', { alpha: false });
Kode lerroa:       var outputScale = (0, _ui_utils.getOutputScale)(ctx);
Kode lerroa:       canvas.width = this.canvasWidth * outputScale.sx | 0;
Kode lerroa:       canvas.height = this.canvasHeight * outputScale.sy | 0;
Kode lerroa:       canvas.style.width = this.canvasWidth + 'px';
Kode lerroa:       canvas.style.height = this.canvasHeight + 'px';
Kode lerroa:       if (!noCtxScale && outputScale.scaled) {
Kode lerroa:         ctx.scale(outputScale.sx, outputScale.sy);
Kode lerroa:       }
Kode lerroa:       return ctx;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_convertCanvasToImage',
Kode lerroa:     value: function _convertCanvasToImage() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       if (!this.canvas) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var id = this.renderingId;
Kode lerroa:       var className = 'thumbnailImage';
Kode lerroa:       if (this.disableCanvasToImageConversion) {
Kode lerroa:         this.canvas.id = id;
Kode lerroa:         this.canvas.className = className;
Kode lerroa:         this.l10n.get('thumb_page_canvas', { page: this.pageId }, 'Thumbnail of Page {{page}}').then(function (msg) {
Kode lerroa:           _this.canvas.setAttribute('aria-label', msg);
Kode lerroa:         });
Kode lerroa:         this.div.setAttribute('data-loaded', true);
Kode lerroa:         this.ring.appendChild(this.canvas);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var image = document.createElement('img');
Kode lerroa:       image.id = id;
Kode lerroa:       image.className = className;
Kode lerroa:       this.l10n.get('thumb_page_canvas', { page: this.pageId }, 'Thumbnail of Page {{page}}').then(function (msg) {
Kode lerroa:         image.setAttribute('aria-label', msg);
Kode lerroa:       });
Kode lerroa:       image.style.width = this.canvasWidth + 'px';
Kode lerroa:       image.style.height = this.canvasHeight + 'px';
Kode lerroa:       image.src = this.canvas.toDataURL();
Kode lerroa:       this.image = image;
Kode lerroa:       this.div.setAttribute('data-loaded', true);
Kode lerroa:       this.ring.appendChild(image);
Kode lerroa:       this.canvas.width = 0;
Kode lerroa:       this.canvas.height = 0;
Kode lerroa:       delete this.canvas;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'draw',
Kode lerroa:     value: function draw() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
Kode lerroa:         console.error('Must be in new state before drawing');
Kode lerroa:         return Promise.resolve(undefined);
Kode lerroa:       }
Kode lerroa:       this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
Kode lerroa:       var renderCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:       var finishRenderTask = function finishRenderTask(error) {
Kode lerroa:         if (renderTask === _this2.renderTask) {
Kode lerroa:           _this2.renderTask = null;
Kode lerroa:         }
Kode lerroa:         if (error === 'cancelled' || error instanceof _pdfjsLib.RenderingCancelledException) {
Kode lerroa:           renderCapability.resolve(undefined);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         _this2.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
Kode lerroa:         _this2._convertCanvasToImage();
Kode lerroa:         if (!error) {
Kode lerroa:           renderCapability.resolve(undefined);
Kode lerroa:         } else {
Kode lerroa:           renderCapability.reject(error);
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       var ctx = this._getPageDrawContext();
Kode lerroa:       var drawViewport = this.viewport.clone({ scale: this.scale });
Kode lerroa:       var renderContinueCallback = function renderContinueCallback(cont) {
Kode lerroa:         if (!_this2.renderingQueue.isHighestPriority(_this2)) {
Kode lerroa:           _this2.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;
Kode lerroa:           _this2.resume = function () {
Kode lerroa:             _this2.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
Kode lerroa:             cont();
Kode lerroa:           };
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         cont();
Kode lerroa:       };
Kode lerroa:       var renderContext = {
Kode lerroa:         canvasContext: ctx,
Kode lerroa:         viewport: drawViewport
Kode lerroa:       };
Kode lerroa:       var renderTask = this.renderTask = this.pdfPage.render(renderContext);
Kode lerroa:       renderTask.onContinue = renderContinueCallback;
Kode lerroa:       renderTask.promise.then(function () {
Kode lerroa:         finishRenderTask(null);
Kode lerroa:       }, function (error) {
Kode lerroa:         finishRenderTask(error);
Kode lerroa:       });
Kode lerroa:       return renderCapability.promise;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setImage',
Kode lerroa:     value: function setImage(pageView) {
Kode lerroa:       if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var img = pageView.canvas;
Kode lerroa:       if (!img) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!this.pdfPage) {
Kode lerroa:         this.setPdfPage(pageView.pdfPage);
Kode lerroa:       }
Kode lerroa:       this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
Kode lerroa:       var ctx = this._getPageDrawContext(true);
Kode lerroa:       var canvas = ctx.canvas;
Kode lerroa:       if (img.width <= 2 * canvas.width) {
Kode lerroa:         ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
Kode lerroa:         this._convertCanvasToImage();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var reducedWidth = canvas.width << MAX_NUM_SCALING_STEPS;
Kode lerroa:       var reducedHeight = canvas.height << MAX_NUM_SCALING_STEPS;
Kode lerroa:       var reducedImage = TempImageFactory.getCanvas(reducedWidth, reducedHeight);
Kode lerroa:       var reducedImageCtx = reducedImage.getContext('2d');
Kode lerroa:       while (reducedWidth > img.width || reducedHeight > img.height) {
Kode lerroa:         reducedWidth >>= 1;
Kode lerroa:         reducedHeight >>= 1;
Kode lerroa:       }
Kode lerroa:       reducedImageCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, reducedWidth, reducedHeight);
Kode lerroa:       while (reducedWidth > 2 * canvas.width) {
Kode lerroa:         reducedImageCtx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, reducedWidth >> 1, reducedHeight >> 1);
Kode lerroa:         reducedWidth >>= 1;
Kode lerroa:         reducedHeight >>= 1;
Kode lerroa:       }
Kode lerroa:       ctx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, canvas.width, canvas.height);
Kode lerroa:       this._convertCanvasToImage();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPageLabel',
Kode lerroa:     value: function setPageLabel(label) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       this.pageLabel = typeof label === 'string' ? label : null;
Kode lerroa:       this.l10n.get('thumb_page_title', { page: this.pageId }, 'Page {{page}}').then(function (msg) {
Kode lerroa:         _this3.anchor.title = msg;
Kode lerroa:       });
Kode lerroa:       if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.l10n.get('thumb_page_canvas', { page: this.pageId }, 'Thumbnail of Page {{page}}').then(function (ariaLabel) {
Kode lerroa:         if (_this3.image) {
Kode lerroa:           _this3.image.setAttribute('aria-label', ariaLabel);
Kode lerroa:         } else if (_this3.disableCanvasToImageConversion && _this3.canvas) {
Kode lerroa:           _this3.canvas.setAttribute('aria-label', ariaLabel);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pageId',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.pageLabel !== null ? this.pageLabel : this.id;
Kode lerroa:     }
Kode lerroa:   }], [{
Kode lerroa:     key: 'cleanup',
Kode lerroa:     value: function cleanup() {
Kode lerroa:       TempImageFactory.destroyCanvas();
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFThumbnailView;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFThumbnailView = PDFThumbnailView;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 21 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFViewer = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _base_viewer = __webpack_require__(22);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
Kode lerroa: 
Kode lerroa: function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
Kode lerroa: 
Kode lerroa: var PDFViewer = function (_BaseViewer) {
Kode lerroa:   _inherits(PDFViewer, _BaseViewer);
Kode lerroa: 
Kode lerroa:   function PDFViewer() {
Kode lerroa:     _classCallCheck(this, PDFViewer);
Kode lerroa: 
Kode lerroa:     return _possibleConstructorReturn(this, (PDFViewer.__proto__ || Object.getPrototypeOf(PDFViewer)).apply(this, arguments));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFViewer, [{
Kode lerroa:     key: '_scrollIntoView',
Kode lerroa:     value: function _scrollIntoView(_ref) {
Kode lerroa:       var pageDiv = _ref.pageDiv,
Kode lerroa:           _ref$pageSpot = _ref.pageSpot,
Kode lerroa:           pageSpot = _ref$pageSpot === undefined ? null : _ref$pageSpot;
Kode lerroa: 
Kode lerroa:       (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_getVisiblePages',
Kode lerroa:     value: function _getVisiblePages() {
Kode lerroa:       if (!this.isInPresentationMode) {
Kode lerroa:         return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true);
Kode lerroa:       }
Kode lerroa:       var currentPage = this._pages[this._currentPageNumber - 1];
Kode lerroa:       var visible = [{
Kode lerroa:         id: currentPage.id,
Kode lerroa:         view: currentPage
Kode lerroa:       }];
Kode lerroa:       return {
Kode lerroa:         first: currentPage,
Kode lerroa:         last: currentPage,
Kode lerroa:         views: visible
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'update',
Kode lerroa:     value: function update() {
Kode lerroa:       var visible = this._getVisiblePages();
Kode lerroa:       var visiblePages = visible.views,
Kode lerroa:           numVisiblePages = visiblePages.length;
Kode lerroa:       if (numVisiblePages === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._resizeBuffer(numVisiblePages);
Kode lerroa:       this.renderingQueue.renderHighestPriority(visible);
Kode lerroa:       var currentId = this._currentPageNumber;
Kode lerroa:       var stillFullyVisible = false;
Kode lerroa:       for (var i = 0; i < numVisiblePages; ++i) {
Kode lerroa:         var page = visiblePages[i];
Kode lerroa:         if (page.percent < 100) {
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:         if (page.id === currentId) {
Kode lerroa:           stillFullyVisible = true;
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (!stillFullyVisible) {
Kode lerroa:         currentId = visiblePages[0].id;
Kode lerroa:       }
Kode lerroa:       if (!this.isInPresentationMode) {
Kode lerroa:         this._setCurrentPageNumber(currentId);
Kode lerroa:       }
Kode lerroa:       this._updateLocation(visible.first);
Kode lerroa:       this.eventBus.dispatch('updateviewarea', {
Kode lerroa:         source: this,
Kode lerroa:         location: this._location
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setDocumentViewerElement',
Kode lerroa:     get: function get() {
Kode lerroa:       return (0, _pdfjsLib.shadow)(this, '_setDocumentViewerElement', this.viewer);
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFViewer;
Kode lerroa: }(_base_viewer.BaseViewer);
Kode lerroa: 
Kode lerroa: exports.PDFViewer = PDFViewer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 22 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.BaseViewer = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdf_rendering_queue = __webpack_require__(3);
Kode lerroa: 
Kode lerroa: var _annotation_layer_builder = __webpack_require__(23);
Kode lerroa: 
Kode lerroa: var _dom_events = __webpack_require__(2);
Kode lerroa: 
Kode lerroa: var _pdf_page_view = __webpack_require__(24);
Kode lerroa: 
Kode lerroa: var _pdf_link_service = __webpack_require__(5);
Kode lerroa: 
Kode lerroa: var _text_layer_builder = __webpack_require__(25);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DEFAULT_CACHE_SIZE = 10;
Kode lerroa: function PDFPageViewBuffer(size) {
Kode lerroa:   var data = [];
Kode lerroa:   this.push = function (view) {
Kode lerroa:     var i = data.indexOf(view);
Kode lerroa:     if (i >= 0) {
Kode lerroa:       data.splice(i, 1);
Kode lerroa:     }
Kode lerroa:     data.push(view);
Kode lerroa:     if (data.length > size) {
Kode lerroa:       data.shift().destroy();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   this.resize = function (newSize) {
Kode lerroa:     size = newSize;
Kode lerroa:     while (data.length > size) {
Kode lerroa:       data.shift().destroy();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }
Kode lerroa: function isSameScale(oldScale, newScale) {
Kode lerroa:   if (newScale === oldScale) {
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   if (Math.abs(newScale - oldScale) < 1e-15) {
Kode lerroa:     return true;
Kode lerroa:   }
Kode lerroa:   return false;
Kode lerroa: }
Kode lerroa: function isPortraitOrientation(size) {
Kode lerroa:   return size.width <= size.height;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var BaseViewer = function () {
Kode lerroa:   function BaseViewer(options) {
Kode lerroa:     _classCallCheck(this, BaseViewer);
Kode lerroa: 
Kode lerroa:     if (this.constructor === BaseViewer) {
Kode lerroa:       throw new Error('Cannot initialize BaseViewer.');
Kode lerroa:     }
Kode lerroa:     this._name = this.constructor.name;
Kode lerroa:     this.container = options.container;
Kode lerroa:     this.viewer = options.viewer || options.container.firstElementChild;
Kode lerroa:     this.eventBus = options.eventBus || (0, _dom_events.getGlobalEventBus)();
Kode lerroa:     this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
Kode lerroa:     this.downloadManager = options.downloadManager || null;
Kode lerroa:     this.removePageBorders = options.removePageBorders || false;
Kode lerroa:     this.enhanceTextSelection = options.enhanceTextSelection || false;
Kode lerroa:     this.renderInteractiveForms = options.renderInteractiveForms || false;
Kode lerroa:     this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
Kode lerroa:     this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
Kode lerroa:     this.l10n = options.l10n || _ui_utils.NullL10n;
Kode lerroa:     this.defaultRenderingQueue = !options.renderingQueue;
Kode lerroa:     if (this.defaultRenderingQueue) {
Kode lerroa:       this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
Kode lerroa:       this.renderingQueue.setViewer(this);
Kode lerroa:     } else {
Kode lerroa:       this.renderingQueue = options.renderingQueue;
Kode lerroa:     }
Kode lerroa:     this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
Kode lerroa:     this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
Kode lerroa:     this._resetView();
Kode lerroa:     if (this.removePageBorders) {
Kode lerroa:       this.viewer.classList.add('removePageBorders');
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(BaseViewer, [{
Kode lerroa:     key: 'getPageView',
Kode lerroa:     value: function getPageView(index) {
Kode lerroa:       return this._pages[index];
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setCurrentPageNumber',
Kode lerroa:     value: function _setCurrentPageNumber(val) {
Kode lerroa:       var resetCurrentPageView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       if (this._currentPageNumber === val) {
Kode lerroa:         if (resetCurrentPageView) {
Kode lerroa:           this._resetCurrentPageView();
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!(0 < val && val <= this.pagesCount)) {
Kode lerroa:         console.error(this._name + '._setCurrentPageNumber: "' + val + '" is out of bounds.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var arg = {
Kode lerroa:         source: this,
Kode lerroa:         pageNumber: val,
Kode lerroa:         pageLabel: this._pageLabels && this._pageLabels[val - 1]
Kode lerroa:       };
Kode lerroa:       this._currentPageNumber = val;
Kode lerroa:       this.eventBus.dispatch('pagechanging', arg);
Kode lerroa:       this.eventBus.dispatch('pagechange', arg);
Kode lerroa:       if (resetCurrentPageView) {
Kode lerroa:         this._resetCurrentPageView();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setDocument',
Kode lerroa:     value: function setDocument(pdfDocument) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       if (this.pdfDocument) {
Kode lerroa:         this._cancelRendering();
Kode lerroa:         this._resetView();
Kode lerroa:       }
Kode lerroa:       this.pdfDocument = pdfDocument;
Kode lerroa:       if (!pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var pagesCount = pdfDocument.numPages;
Kode lerroa:       var pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:       this.pagesPromise = pagesCapability.promise;
Kode lerroa:       pagesCapability.promise.then(function () {
Kode lerroa:         _this._pageViewsReady = true;
Kode lerroa:         _this.eventBus.dispatch('pagesloaded', {
Kode lerroa:           source: _this,
Kode lerroa:           pagesCount: pagesCount
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       var isOnePageRenderedResolved = false;
Kode lerroa:       var onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:       this.onePageRendered = onePageRenderedCapability.promise;
Kode lerroa:       var bindOnAfterAndBeforeDraw = function bindOnAfterAndBeforeDraw(pageView) {
Kode lerroa:         pageView.onBeforeDraw = function () {
Kode lerroa:           _this._buffer.push(pageView);
Kode lerroa:         };
Kode lerroa:         pageView.onAfterDraw = function () {
Kode lerroa:           if (!isOnePageRenderedResolved) {
Kode lerroa:             isOnePageRenderedResolved = true;
Kode lerroa:             onePageRenderedCapability.resolve();
Kode lerroa:           }
Kode lerroa:         };
Kode lerroa:       };
Kode lerroa:       var firstPagePromise = pdfDocument.getPage(1);
Kode lerroa:       this.firstPagePromise = firstPagePromise;
Kode lerroa:       firstPagePromise.then(function (pdfPage) {
Kode lerroa:         var scale = _this.currentScale;
Kode lerroa:         var viewport = pdfPage.getViewport(scale * _ui_utils.CSS_UNITS);
Kode lerroa:         for (var pageNum = 1; pageNum <= pagesCount; ++pageNum) {
Kode lerroa:           var textLayerFactory = null;
Kode lerroa:           if (!_pdfjsLib.PDFJS.disableTextLayer) {
Kode lerroa:             textLayerFactory = _this;
Kode lerroa:           }
Kode lerroa:           var pageView = new _pdf_page_view.PDFPageView({
Kode lerroa:             container: _this._setDocumentViewerElement,
Kode lerroa:             eventBus: _this.eventBus,
Kode lerroa:             id: pageNum,
Kode lerroa:             scale: scale,
Kode lerroa:             defaultViewport: viewport.clone(),
Kode lerroa:             renderingQueue: _this.renderingQueue,
Kode lerroa:             textLayerFactory: textLayerFactory,
Kode lerroa:             annotationLayerFactory: _this,
Kode lerroa:             enhanceTextSelection: _this.enhanceTextSelection,
Kode lerroa:             renderInteractiveForms: _this.renderInteractiveForms,
Kode lerroa:             renderer: _this.renderer,
Kode lerroa:             l10n: _this.l10n
Kode lerroa:           });
Kode lerroa:           bindOnAfterAndBeforeDraw(pageView);
Kode lerroa:           _this._pages.push(pageView);
Kode lerroa:         }
Kode lerroa:         onePageRenderedCapability.promise.then(function () {
Kode lerroa:           if (_pdfjsLib.PDFJS.disableAutoFetch) {
Kode lerroa:             pagesCapability.resolve();
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           var getPagesLeft = pagesCount;
Kode lerroa: 
Kode lerroa:           var _loop = function _loop(_pageNum) {
Kode lerroa:             pdfDocument.getPage(_pageNum).then(function (pdfPage) {
Kode lerroa:               var pageView = _this._pages[_pageNum - 1];
Kode lerroa:               if (!pageView.pdfPage) {
Kode lerroa:                 pageView.setPdfPage(pdfPage);
Kode lerroa:               }
Kode lerroa:               _this.linkService.cachePageRef(_pageNum, pdfPage.ref);
Kode lerroa:               if (--getPagesLeft === 0) {
Kode lerroa:                 pagesCapability.resolve();
Kode lerroa:               }
Kode lerroa:             }, function (reason) {
Kode lerroa:               console.error('Unable to get page ' + _pageNum + ' to initialize viewer', reason);
Kode lerroa:               if (--getPagesLeft === 0) {
Kode lerroa:                 pagesCapability.resolve();
Kode lerroa:               }
Kode lerroa:             });
Kode lerroa:           };
Kode lerroa: 
Kode lerroa:           for (var _pageNum = 1; _pageNum <= pagesCount; ++_pageNum) {
Kode lerroa:             _loop(_pageNum);
Kode lerroa:           }
Kode lerroa:         });
Kode lerroa:         _this.eventBus.dispatch('pagesinit', { source: _this });
Kode lerroa:         if (_this.defaultRenderingQueue) {
Kode lerroa:           _this.update();
Kode lerroa:         }
Kode lerroa:         if (_this.findController) {
Kode lerroa:           _this.findController.resolveFirstPage();
Kode lerroa:         }
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         console.error('Unable to initialize viewer', reason);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPageLabels',
Kode lerroa:     value: function setPageLabels(labels) {
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!labels) {
Kode lerroa:         this._pageLabels = null;
Kode lerroa:       } else if (!(labels instanceof Array && this.pdfDocument.numPages === labels.length)) {
Kode lerroa:         this._pageLabels = null;
Kode lerroa:         console.error(this._name + '.setPageLabels: Invalid page labels.');
Kode lerroa:       } else {
Kode lerroa:         this._pageLabels = labels;
Kode lerroa:       }
Kode lerroa:       for (var i = 0, ii = this._pages.length; i < ii; i++) {
Kode lerroa:         var pageView = this._pages[i];
Kode lerroa:         var label = this._pageLabels && this._pageLabels[i];
Kode lerroa:         pageView.setPageLabel(label);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resetView',
Kode lerroa:     value: function _resetView() {
Kode lerroa:       this._pages = [];
Kode lerroa:       this._currentPageNumber = 1;
Kode lerroa:       this._currentScale = _ui_utils.UNKNOWN_SCALE;
Kode lerroa:       this._currentScaleValue = null;
Kode lerroa:       this._pageLabels = null;
Kode lerroa:       this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
Kode lerroa:       this._location = null;
Kode lerroa:       this._pagesRotation = 0;
Kode lerroa:       this._pagesRequests = [];
Kode lerroa:       this._pageViewsReady = false;
Kode lerroa:       this.viewer.textContent = '';
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_scrollUpdate',
Kode lerroa:     value: function _scrollUpdate() {
Kode lerroa:       if (this.pagesCount === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.update();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_scrollIntoView',
Kode lerroa:     value: function _scrollIntoView(_ref) {
Kode lerroa:       var pageDiv = _ref.pageDiv,
Kode lerroa:           _ref$pageSpot = _ref.pageSpot,
Kode lerroa:           pageSpot = _ref$pageSpot === undefined ? null : _ref$pageSpot,
Kode lerroa:           _ref$pageNumber = _ref.pageNumber,
Kode lerroa:           pageNumber = _ref$pageNumber === undefined ? null : _ref$pageNumber;
Kode lerroa: 
Kode lerroa:       throw new Error('Not implemented: _scrollIntoView');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setScaleDispatchEvent',
Kode lerroa:     value: function _setScaleDispatchEvent(newScale, newValue) {
Kode lerroa:       var preset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa: 
Kode lerroa:       var arg = {
Kode lerroa:         source: this,
Kode lerroa:         scale: newScale,
Kode lerroa:         presetValue: preset ? newValue : undefined
Kode lerroa:       };
Kode lerroa:       this.eventBus.dispatch('scalechanging', arg);
Kode lerroa:       this.eventBus.dispatch('scalechange', arg);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setScaleUpdatePages',
Kode lerroa:     value: function _setScaleUpdatePages(newScale, newValue) {
Kode lerroa:       var noScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa:       var preset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
Kode lerroa: 
Kode lerroa:       this._currentScaleValue = newValue.toString();
Kode lerroa:       if (isSameScale(this._currentScale, newScale)) {
Kode lerroa:         if (preset) {
Kode lerroa:           this._setScaleDispatchEvent(newScale, newValue, true);
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       for (var i = 0, ii = this._pages.length; i < ii; i++) {
Kode lerroa:         this._pages[i].update(newScale);
Kode lerroa:       }
Kode lerroa:       this._currentScale = newScale;
Kode lerroa:       if (!noScroll) {
Kode lerroa:         var page = this._currentPageNumber,
Kode lerroa:             dest = void 0;
Kode lerroa:         if (this._location && !_pdfjsLib.PDFJS.ignoreCurrentPositionOnZoom && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
Kode lerroa:           page = this._location.pageNumber;
Kode lerroa:           dest = [null, { name: 'XYZ' }, this._location.left, this._location.top, null];
Kode lerroa:         }
Kode lerroa:         this.scrollPageIntoView({
Kode lerroa:           pageNumber: page,
Kode lerroa:           destArray: dest,
Kode lerroa:           allowNegativeOffset: true
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       this._setScaleDispatchEvent(newScale, newValue, preset);
Kode lerroa:       if (this.defaultRenderingQueue) {
Kode lerroa:         this.update();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setScale',
Kode lerroa:     value: function _setScale(value) {
Kode lerroa:       var noScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       var scale = parseFloat(value);
Kode lerroa:       if (scale > 0) {
Kode lerroa:         this._setScaleUpdatePages(scale, value, noScroll, false);
Kode lerroa:       } else {
Kode lerroa:         var currentPage = this._pages[this._currentPageNumber - 1];
Kode lerroa:         if (!currentPage) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var hPadding = this.isInPresentationMode || this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
Kode lerroa:         var vPadding = this.isInPresentationMode || this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
Kode lerroa:         var pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale;
Kode lerroa:         var pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
Kode lerroa:         switch (value) {
Kode lerroa:           case 'page-actual':
Kode lerroa:             scale = 1;
Kode lerroa:             break;
Kode lerroa:           case 'page-width':
Kode lerroa:             scale = pageWidthScale;
Kode lerroa:             break;
Kode lerroa:           case 'page-height':
Kode lerroa:             scale = pageHeightScale;
Kode lerroa:             break;
Kode lerroa:           case 'page-fit':
Kode lerroa:             scale = Math.min(pageWidthScale, pageHeightScale);
Kode lerroa:             break;
Kode lerroa:           case 'auto':
Kode lerroa:             var isLandscape = currentPage.width > currentPage.height;
Kode lerroa:             var horizontalScale = isLandscape ? Math.min(pageHeightScale, pageWidthScale) : pageWidthScale;
Kode lerroa:             scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             console.error(this._name + '._setScale: "' + value + '" is an unknown zoom value.');
Kode lerroa:             return;
Kode lerroa:         }
Kode lerroa:         this._setScaleUpdatePages(scale, value, noScroll, true);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resetCurrentPageView',
Kode lerroa:     value: function _resetCurrentPageView() {
Kode lerroa:       if (this.isInPresentationMode) {
Kode lerroa:         this._setScale(this._currentScaleValue, true);
Kode lerroa:       }
Kode lerroa:       var pageView = this._pages[this._currentPageNumber - 1];
Kode lerroa:       this._scrollIntoView({ pageDiv: pageView.div });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'scrollPageIntoView',
Kode lerroa:     value: function scrollPageIntoView(params) {
Kode lerroa:       if (arguments.length > 1 || typeof params === 'number') {
Kode lerroa:         console.error('Call of scrollPageIntoView() with obsolete signature.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var pageNumber = params.pageNumber || 0;
Kode lerroa:       var dest = params.destArray || null;
Kode lerroa:       var allowNegativeOffset = params.allowNegativeOffset || false;
Kode lerroa:       if (this.isInPresentationMode || !dest) {
Kode lerroa:         this._setCurrentPageNumber(pageNumber, true);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var pageView = this._pages[pageNumber - 1];
Kode lerroa:       if (!pageView) {
Kode lerroa:         console.error(this._name + '.scrollPageIntoView: Invalid "pageNumber" parameter.');
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var x = 0,
Kode lerroa:           y = 0;
Kode lerroa:       var width = 0,
Kode lerroa:           height = 0,
Kode lerroa:           widthScale = void 0,
Kode lerroa:           heightScale = void 0;
Kode lerroa:       var changeOrientation = pageView.rotation % 180 === 0 ? false : true;
Kode lerroa:       var pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS;
Kode lerroa:       var pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS;
Kode lerroa:       var scale = 0;
Kode lerroa:       switch (dest[1].name) {
Kode lerroa:         case 'XYZ':
Kode lerroa:           x = dest[2];
Kode lerroa:           y = dest[3];
Kode lerroa:           scale = dest[4];
Kode lerroa:           x = x !== null ? x : 0;
Kode lerroa:           y = y !== null ? y : pageHeight;
Kode lerroa:           break;
Kode lerroa:         case 'Fit':
Kode lerroa:         case 'FitB':
Kode lerroa:           scale = 'page-fit';
Kode lerroa:           break;
Kode lerroa:         case 'FitH':
Kode lerroa:         case 'FitBH':
Kode lerroa:           y = dest[2];
Kode lerroa:           scale = 'page-width';
Kode lerroa:           if (y === null && this._location) {
Kode lerroa:             x = this._location.left;
Kode lerroa:             y = this._location.top;
Kode lerroa:           }
Kode lerroa:           break;
Kode lerroa:         case 'FitV':
Kode lerroa:         case 'FitBV':
Kode lerroa:           x = dest[2];
Kode lerroa:           width = pageWidth;
Kode lerroa:           height = pageHeight;
Kode lerroa:           scale = 'page-height';
Kode lerroa:           break;
Kode lerroa:         case 'FitR':
Kode lerroa:           x = dest[2];
Kode lerroa:           y = dest[3];
Kode lerroa:           width = dest[4] - x;
Kode lerroa:           height = dest[5] - y;
Kode lerroa:           var hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
Kode lerroa:           var vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
Kode lerroa:           widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS;
Kode lerroa:           heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS;
Kode lerroa:           scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           console.error(this._name + '.scrollPageIntoView: "' + dest[1].name + '" ' + 'is not a valid destination type.');
Kode lerroa:           return;
Kode lerroa:       }
Kode lerroa:       if (scale && scale !== this._currentScale) {
Kode lerroa:         this.currentScaleValue = scale;
Kode lerroa:       } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
Kode lerroa:         this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
Kode lerroa:       }
Kode lerroa:       if (scale === 'page-fit' && !dest[4]) {
Kode lerroa:         this._scrollIntoView({
Kode lerroa:           pageDiv: pageView.div,
Kode lerroa:           pageNumber: pageNumber
Kode lerroa:         });
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
Kode lerroa:       var left = Math.min(boundingRect[0][0], boundingRect[1][0]);
Kode lerroa:       var top = Math.min(boundingRect[0][1], boundingRect[1][1]);
Kode lerroa:       if (!allowNegativeOffset) {
Kode lerroa:         left = Math.max(left, 0);
Kode lerroa:         top = Math.max(top, 0);
Kode lerroa:       }
Kode lerroa:       this._scrollIntoView({
Kode lerroa:         pageDiv: pageView.div,
Kode lerroa:         pageSpot: {
Kode lerroa:           left: left,
Kode lerroa:           top: top
Kode lerroa:         },
Kode lerroa:         pageNumber: pageNumber
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resizeBuffer',
Kode lerroa:     value: function _resizeBuffer(numVisiblePages) {
Kode lerroa:       var suggestedCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
Kode lerroa:       this._buffer.resize(suggestedCacheSize);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateLocation',
Kode lerroa:     value: function _updateLocation(firstPage) {
Kode lerroa:       var currentScale = this._currentScale;
Kode lerroa:       var currentScaleValue = this._currentScaleValue;
Kode lerroa:       var normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
Kode lerroa:       var pageNumber = firstPage.id;
Kode lerroa:       var pdfOpenParams = '#page=' + pageNumber;
Kode lerroa:       pdfOpenParams += '&zoom=' + normalizedScaleValue;
Kode lerroa:       var currentPageView = this._pages[pageNumber - 1];
Kode lerroa:       var container = this.container;
Kode lerroa:       var topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
Kode lerroa:       var intLeft = Math.round(topLeft[0]);
Kode lerroa:       var intTop = Math.round(topLeft[1]);
Kode lerroa:       pdfOpenParams += ',' + intLeft + ',' + intTop;
Kode lerroa:       this._location = {
Kode lerroa:         pageNumber: pageNumber,
Kode lerroa:         scale: normalizedScaleValue,
Kode lerroa:         top: intTop,
Kode lerroa:         left: intLeft,
Kode lerroa:         rotation: this._pagesRotation,
Kode lerroa:         pdfOpenParams: pdfOpenParams
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'update',
Kode lerroa:     value: function update() {
Kode lerroa:       throw new Error('Not implemented: update');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'containsElement',
Kode lerroa:     value: function containsElement(element) {
Kode lerroa:       return this.container.contains(element);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'focus',
Kode lerroa:     value: function focus() {
Kode lerroa:       this.container.focus();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_getVisiblePages',
Kode lerroa:     value: function _getVisiblePages() {
Kode lerroa:       throw new Error('Not implemented: _getVisiblePages');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cleanup',
Kode lerroa:     value: function cleanup() {
Kode lerroa:       for (var i = 0, ii = this._pages.length; i < ii; i++) {
Kode lerroa:         if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
Kode lerroa:           this._pages[i].reset();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_cancelRendering',
Kode lerroa:     value: function _cancelRendering() {
Kode lerroa:       for (var i = 0, ii = this._pages.length; i < ii; i++) {
Kode lerroa:         if (this._pages[i]) {
Kode lerroa:           this._pages[i].cancelRendering();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_ensurePdfPageLoaded',
Kode lerroa:     value: function _ensurePdfPageLoaded(pageView) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       if (pageView.pdfPage) {
Kode lerroa:         return Promise.resolve(pageView.pdfPage);
Kode lerroa:       }
Kode lerroa:       var pageNumber = pageView.id;
Kode lerroa:       if (this._pagesRequests[pageNumber]) {
Kode lerroa:         return this._pagesRequests[pageNumber];
Kode lerroa:       }
Kode lerroa:       var promise = this.pdfDocument.getPage(pageNumber).then(function (pdfPage) {
Kode lerroa:         if (!pageView.pdfPage) {
Kode lerroa:           pageView.setPdfPage(pdfPage);
Kode lerroa:         }
Kode lerroa:         _this2._pagesRequests[pageNumber] = null;
Kode lerroa:         return pdfPage;
Kode lerroa:       }).catch(function (reason) {
Kode lerroa:         console.error('Unable to get page for page view', reason);
Kode lerroa:         _this2._pagesRequests[pageNumber] = null;
Kode lerroa:       });
Kode lerroa:       this._pagesRequests[pageNumber] = promise;
Kode lerroa:       return promise;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'forceRendering',
Kode lerroa:     value: function forceRendering(currentlyVisiblePages) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       var visiblePages = currentlyVisiblePages || this._getVisiblePages();
Kode lerroa:       var pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, this.scroll.down);
Kode lerroa:       if (pageView) {
Kode lerroa:         this._ensurePdfPageLoaded(pageView).then(function () {
Kode lerroa:           _this3.renderingQueue.renderView(pageView);
Kode lerroa:         });
Kode lerroa:         return true;
Kode lerroa:       }
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getPageTextContent',
Kode lerroa:     value: function getPageTextContent(pageIndex) {
Kode lerroa:       return this.pdfDocument.getPage(pageIndex + 1).then(function (page) {
Kode lerroa:         return page.getTextContent({ normalizeWhitespace: true });
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'createTextLayerBuilder',
Kode lerroa:     value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
Kode lerroa:       var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
Kode lerroa: 
Kode lerroa:       return new _text_layer_builder.TextLayerBuilder({
Kode lerroa:         textLayerDiv: textLayerDiv,
Kode lerroa:         eventBus: this.eventBus,
Kode lerroa:         pageIndex: pageIndex,
Kode lerroa:         viewport: viewport,
Kode lerroa:         findController: this.isInPresentationMode ? null : this.findController,
Kode lerroa:         enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'createAnnotationLayerBuilder',
Kode lerroa:     value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {
Kode lerroa:       var renderInteractiveForms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa:       var l10n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:       return new _annotation_layer_builder.AnnotationLayerBuilder({
Kode lerroa:         pageDiv: pageDiv,
Kode lerroa:         pdfPage: pdfPage,
Kode lerroa:         renderInteractiveForms: renderInteractiveForms,
Kode lerroa:         linkService: this.linkService,
Kode lerroa:         downloadManager: this.downloadManager,
Kode lerroa:         l10n: l10n
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setFindController',
Kode lerroa:     value: function setFindController(findController) {
Kode lerroa:       this.findController = findController;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getPagesOverview',
Kode lerroa:     value: function getPagesOverview() {
Kode lerroa:       var pagesOverview = this._pages.map(function (pageView) {
Kode lerroa:         var viewport = pageView.pdfPage.getViewport(1);
Kode lerroa:         return {
Kode lerroa:           width: viewport.width,
Kode lerroa:           height: viewport.height,
Kode lerroa:           rotation: viewport.rotation
Kode lerroa:         };
Kode lerroa:       });
Kode lerroa:       if (!this.enablePrintAutoRotate) {
Kode lerroa:         return pagesOverview;
Kode lerroa:       }
Kode lerroa:       var isFirstPagePortrait = isPortraitOrientation(pagesOverview[0]);
Kode lerroa:       return pagesOverview.map(function (size) {
Kode lerroa:         if (isFirstPagePortrait === isPortraitOrientation(size)) {
Kode lerroa:           return size;
Kode lerroa:         }
Kode lerroa:         return {
Kode lerroa:           width: size.height,
Kode lerroa:           height: size.width,
Kode lerroa:           rotation: (size.rotation + 90) % 360
Kode lerroa:         };
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pagesCount',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._pages.length;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pageViewsReady',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._pageViewsReady;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'currentPageNumber',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._currentPageNumber;
Kode lerroa:     },
Kode lerroa:     set: function set(val) {
Kode lerroa:       if (!Number.isInteger(val)) {
Kode lerroa:         throw new Error('Invalid page number.');
Kode lerroa:       }
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._setCurrentPageNumber(val, true);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'currentPageLabel',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];
Kode lerroa:     },
Kode lerroa:     set: function set(val) {
Kode lerroa:       var pageNumber = val | 0;
Kode lerroa:       if (this._pageLabels) {
Kode lerroa:         var i = this._pageLabels.indexOf(val);
Kode lerroa:         if (i >= 0) {
Kode lerroa:           pageNumber = i + 1;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.currentPageNumber = pageNumber;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'currentScale',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
Kode lerroa:     },
Kode lerroa:     set: function set(val) {
Kode lerroa:       if (isNaN(val)) {
Kode lerroa:         throw new Error('Invalid numeric scale');
Kode lerroa:       }
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._setScale(val, false);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'currentScaleValue',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._currentScaleValue;
Kode lerroa:     },
Kode lerroa:     set: function set(val) {
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._setScale(val, false);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'pagesRotation',
Kode lerroa:     get: function get() {
Kode lerroa:       return this._pagesRotation;
Kode lerroa:     },
Kode lerroa:     set: function set(rotation) {
Kode lerroa:       if (!(0, _ui_utils.isValidRotation)(rotation)) {
Kode lerroa:         throw new Error('Invalid pages rotation angle.');
Kode lerroa:       }
Kode lerroa:       if (!this.pdfDocument) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (this._pagesRotation === rotation) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this._pagesRotation = rotation;
Kode lerroa:       var pageNumber = this._currentPageNumber;
Kode lerroa:       for (var i = 0, ii = this._pages.length; i < ii; i++) {
Kode lerroa:         var pageView = this._pages[i];
Kode lerroa:         pageView.update(pageView.scale, rotation);
Kode lerroa:       }
Kode lerroa:       if (this._currentScaleValue) {
Kode lerroa:         this._setScale(this._currentScaleValue, true);
Kode lerroa:       }
Kode lerroa:       this.eventBus.dispatch('rotationchanging', {
Kode lerroa:         source: this,
Kode lerroa:         pagesRotation: rotation,
Kode lerroa:         pageNumber: pageNumber
Kode lerroa:       });
Kode lerroa:       if (this.defaultRenderingQueue) {
Kode lerroa:         this.update();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setDocumentViewerElement',
Kode lerroa:     get: function get() {
Kode lerroa:       throw new Error('Not implemented: _setDocumentViewerElement');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isInPresentationMode',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isChangingPresentationMode',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isHorizontalScrollbarEnabled',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'hasEqualPageSizes',
Kode lerroa:     get: function get() {
Kode lerroa:       var firstPageView = this._pages[0];
Kode lerroa:       for (var i = 1, ii = this._pages.length; i < ii; ++i) {
Kode lerroa:         var pageView = this._pages[i];
Kode lerroa:         if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
Kode lerroa:           return false;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return true;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return BaseViewer;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.BaseViewer = BaseViewer;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 23 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdf_link_service = __webpack_require__(5);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var AnnotationLayerBuilder = function () {
Kode lerroa:   function AnnotationLayerBuilder(_ref) {
Kode lerroa:     var pageDiv = _ref.pageDiv,
Kode lerroa:         pdfPage = _ref.pdfPage,
Kode lerroa:         linkService = _ref.linkService,
Kode lerroa:         downloadManager = _ref.downloadManager,
Kode lerroa:         _ref$renderInteractiv = _ref.renderInteractiveForms,
Kode lerroa:         renderInteractiveForms = _ref$renderInteractiv === undefined ? false : _ref$renderInteractiv,
Kode lerroa:         _ref$l10n = _ref.l10n,
Kode lerroa:         l10n = _ref$l10n === undefined ? _ui_utils.NullL10n : _ref$l10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, AnnotationLayerBuilder);
Kode lerroa: 
Kode lerroa:     this.pageDiv = pageDiv;
Kode lerroa:     this.pdfPage = pdfPage;
Kode lerroa:     this.linkService = linkService;
Kode lerroa:     this.downloadManager = downloadManager;
Kode lerroa:     this.renderInteractiveForms = renderInteractiveForms;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     this.div = null;
Kode lerroa:     this._cancelled = false;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(AnnotationLayerBuilder, [{
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render(viewport) {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var intent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'display';
Kode lerroa: 
Kode lerroa:       this.pdfPage.getAnnotations({ intent: intent }).then(function (annotations) {
Kode lerroa:         if (_this._cancelled) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var parameters = {
Kode lerroa:           viewport: viewport.clone({ dontFlip: true }),
Kode lerroa:           div: _this.div,
Kode lerroa:           annotations: annotations,
Kode lerroa:           page: _this.pdfPage,
Kode lerroa:           renderInteractiveForms: _this.renderInteractiveForms,
Kode lerroa:           linkService: _this.linkService,
Kode lerroa:           downloadManager: _this.downloadManager
Kode lerroa:         };
Kode lerroa:         if (_this.div) {
Kode lerroa:           _pdfjsLib.AnnotationLayer.update(parameters);
Kode lerroa:         } else {
Kode lerroa:           if (annotations.length === 0) {
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           _this.div = document.createElement('div');
Kode lerroa:           _this.div.className = 'annotationLayer';
Kode lerroa:           _this.pageDiv.appendChild(_this.div);
Kode lerroa:           parameters.div = _this.div;
Kode lerroa:           _pdfjsLib.AnnotationLayer.render(parameters);
Kode lerroa:           _this.l10n.translate(_this.div);
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancel',
Kode lerroa:     value: function cancel() {
Kode lerroa:       this._cancelled = true;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'hide',
Kode lerroa:     value: function hide() {
Kode lerroa:       if (!this.div) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.div.setAttribute('hidden', 'true');
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return AnnotationLayerBuilder;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var DefaultAnnotationLayerFactory = function () {
Kode lerroa:   function DefaultAnnotationLayerFactory() {
Kode lerroa:     _classCallCheck(this, DefaultAnnotationLayerFactory);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(DefaultAnnotationLayerFactory, [{
Kode lerroa:     key: 'createAnnotationLayerBuilder',
Kode lerroa:     value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {
Kode lerroa:       var renderInteractiveForms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
Kode lerroa:       var l10n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:       return new AnnotationLayerBuilder({
Kode lerroa:         pageDiv: pageDiv,
Kode lerroa:         pdfPage: pdfPage,
Kode lerroa:         renderInteractiveForms: renderInteractiveForms,
Kode lerroa:         linkService: new _pdf_link_service.SimpleLinkService(),
Kode lerroa:         l10n: l10n
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return DefaultAnnotationLayerFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.AnnotationLayerBuilder = AnnotationLayerBuilder;
Kode lerroa: exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 24 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFPageView = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var _dom_events = __webpack_require__(2);
Kode lerroa: 
Kode lerroa: var _pdf_rendering_queue = __webpack_require__(3);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var PDFPageView = function () {
Kode lerroa:   function PDFPageView(options) {
Kode lerroa:     _classCallCheck(this, PDFPageView);
Kode lerroa: 
Kode lerroa:     var container = options.container;
Kode lerroa:     var defaultViewport = options.defaultViewport;
Kode lerroa:     this.id = options.id;
Kode lerroa:     this.renderingId = 'page' + this.id;
Kode lerroa:     this.pdfPage = null;
Kode lerroa:     this.pageLabel = null;
Kode lerroa:     this.rotation = 0;
Kode lerroa:     this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
Kode lerroa:     this.viewport = defaultViewport;
Kode lerroa:     this.pdfPageRotate = defaultViewport.rotation;
Kode lerroa:     this.hasRestrictedScaling = false;
Kode lerroa:     this.enhanceTextSelection = options.enhanceTextSelection || false;
Kode lerroa:     this.renderInteractiveForms = options.renderInteractiveForms || false;
Kode lerroa:     this.eventBus = options.eventBus || (0, _dom_events.getGlobalEventBus)();
Kode lerroa:     this.renderingQueue = options.renderingQueue;
Kode lerroa:     this.textLayerFactory = options.textLayerFactory;
Kode lerroa:     this.annotationLayerFactory = options.annotationLayerFactory;
Kode lerroa:     this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
Kode lerroa:     this.l10n = options.l10n || _ui_utils.NullL10n;
Kode lerroa:     this.paintTask = null;
Kode lerroa:     this.paintedViewportMap = new WeakMap();
Kode lerroa:     this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
Kode lerroa:     this.resume = null;
Kode lerroa:     this.error = null;
Kode lerroa:     this.onBeforeDraw = null;
Kode lerroa:     this.onAfterDraw = null;
Kode lerroa:     this.annotationLayer = null;
Kode lerroa:     this.textLayer = null;
Kode lerroa:     this.zoomLayer = null;
Kode lerroa:     var div = document.createElement('div');
Kode lerroa:     div.className = 'page';
Kode lerroa:     div.style.width = Math.floor(this.viewport.width) + 'px';
Kode lerroa:     div.style.height = Math.floor(this.viewport.height) + 'px';
Kode lerroa:     div.setAttribute('data-page-number', this.id);
Kode lerroa:     this.div = div;
Kode lerroa:     container.appendChild(div);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(PDFPageView, [{
Kode lerroa:     key: 'setPdfPage',
Kode lerroa:     value: function setPdfPage(pdfPage) {
Kode lerroa:       this.pdfPage = pdfPage;
Kode lerroa:       this.pdfPageRotate = pdfPage.rotate;
Kode lerroa:       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
Kode lerroa:       this.viewport = pdfPage.getViewport(this.scale * _ui_utils.CSS_UNITS, totalRotation);
Kode lerroa:       this.stats = pdfPage.stats;
Kode lerroa:       this.reset();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'destroy',
Kode lerroa:     value: function destroy() {
Kode lerroa:       this.reset();
Kode lerroa:       if (this.pdfPage) {
Kode lerroa:         this.pdfPage.cleanup();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_resetZoomLayer',
Kode lerroa:     value: function _resetZoomLayer() {
Kode lerroa:       var removeFromDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       if (!this.zoomLayer) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var zoomLayerCanvas = this.zoomLayer.firstChild;
Kode lerroa:       this.paintedViewportMap.delete(zoomLayerCanvas);
Kode lerroa:       zoomLayerCanvas.width = 0;
Kode lerroa:       zoomLayerCanvas.height = 0;
Kode lerroa:       if (removeFromDOM) {
Kode lerroa:         this.zoomLayer.remove();
Kode lerroa:       }
Kode lerroa:       this.zoomLayer = null;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       var keepZoomLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa:       var keepAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       this.cancelRendering(keepAnnotations);
Kode lerroa:       var div = this.div;
Kode lerroa:       div.style.width = Math.floor(this.viewport.width) + 'px';
Kode lerroa:       div.style.height = Math.floor(this.viewport.height) + 'px';
Kode lerroa:       var childNodes = div.childNodes;
Kode lerroa:       var currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;
Kode lerroa:       var currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null;
Kode lerroa:       for (var i = childNodes.length - 1; i >= 0; i--) {
Kode lerroa:         var node = childNodes[i];
Kode lerroa:         if (currentZoomLayerNode === node || currentAnnotationNode === node) {
Kode lerroa:           continue;
Kode lerroa:         }
Kode lerroa:         div.removeChild(node);
Kode lerroa:       }
Kode lerroa:       div.removeAttribute('data-loaded');
Kode lerroa:       if (currentAnnotationNode) {
Kode lerroa:         this.annotationLayer.hide();
Kode lerroa:       } else if (this.annotationLayer) {
Kode lerroa:         this.annotationLayer.cancel();
Kode lerroa:         this.annotationLayer = null;
Kode lerroa:       }
Kode lerroa:       if (!currentZoomLayerNode) {
Kode lerroa:         if (this.canvas) {
Kode lerroa:           this.paintedViewportMap.delete(this.canvas);
Kode lerroa:           this.canvas.width = 0;
Kode lerroa:           this.canvas.height = 0;
Kode lerroa:           delete this.canvas;
Kode lerroa:         }
Kode lerroa:         this._resetZoomLayer();
Kode lerroa:       }
Kode lerroa:       if (this.svg) {
Kode lerroa:         this.paintedViewportMap.delete(this.svg);
Kode lerroa:         delete this.svg;
Kode lerroa:       }
Kode lerroa:       this.loadingIconDiv = document.createElement('div');
Kode lerroa:       this.loadingIconDiv.className = 'loadingIcon';
Kode lerroa:       div.appendChild(this.loadingIconDiv);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'update',
Kode lerroa:     value: function update(scale, rotation) {
Kode lerroa:       this.scale = scale || this.scale;
Kode lerroa:       if (typeof rotation !== 'undefined') {
Kode lerroa:         this.rotation = rotation;
Kode lerroa:       }
Kode lerroa:       var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
Kode lerroa:       this.viewport = this.viewport.clone({
Kode lerroa:         scale: this.scale * _ui_utils.CSS_UNITS,
Kode lerroa:         rotation: totalRotation
Kode lerroa:       });
Kode lerroa:       if (this.svg) {
Kode lerroa:         this.cssTransform(this.svg, true);
Kode lerroa:         this.eventBus.dispatch('pagerendered', {
Kode lerroa:           source: this,
Kode lerroa:           pageNumber: this.id,
Kode lerroa:           cssTransform: true
Kode lerroa:         });
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var isScalingRestricted = false;
Kode lerroa:       if (this.canvas && _pdfjsLib.PDFJS.maxCanvasPixels > 0) {
Kode lerroa:         var outputScale = this.outputScale;
Kode lerroa:         if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > _pdfjsLib.PDFJS.maxCanvasPixels) {
Kode lerroa:           isScalingRestricted = true;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (this.canvas) {
Kode lerroa:         if (_pdfjsLib.PDFJS.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
Kode lerroa:           this.cssTransform(this.canvas, true);
Kode lerroa:           this.eventBus.dispatch('pagerendered', {
Kode lerroa:             source: this,
Kode lerroa:             pageNumber: this.id,
Kode lerroa:             cssTransform: true
Kode lerroa:           });
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         if (!this.zoomLayer && !this.canvas.hasAttribute('hidden')) {
Kode lerroa:           this.zoomLayer = this.canvas.parentNode;
Kode lerroa:           this.zoomLayer.style.position = 'absolute';
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (this.zoomLayer) {
Kode lerroa:         this.cssTransform(this.zoomLayer.firstChild);
Kode lerroa:       }
Kode lerroa:       this.reset(true, true);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancelRendering',
Kode lerroa:     value: function cancelRendering() {
Kode lerroa:       var keepAnnotations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       if (this.paintTask) {
Kode lerroa:         this.paintTask.cancel();
Kode lerroa:         this.paintTask = null;
Kode lerroa:       }
Kode lerroa:       this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
Kode lerroa:       this.resume = null;
Kode lerroa:       if (this.textLayer) {
Kode lerroa:         this.textLayer.cancel();
Kode lerroa:         this.textLayer = null;
Kode lerroa:       }
Kode lerroa:       if (!keepAnnotations && this.annotationLayer) {
Kode lerroa:         this.annotationLayer.cancel();
Kode lerroa:         this.annotationLayer = null;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cssTransform',
Kode lerroa:     value: function cssTransform(target) {
Kode lerroa:       var redrawAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
Kode lerroa: 
Kode lerroa:       var width = this.viewport.width;
Kode lerroa:       var height = this.viewport.height;
Kode lerroa:       var div = this.div;
Kode lerroa:       target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + 'px';
Kode lerroa:       target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + 'px';
Kode lerroa:       var relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
Kode lerroa:       var absRotation = Math.abs(relativeRotation);
Kode lerroa:       var scaleX = 1,
Kode lerroa:           scaleY = 1;
Kode lerroa:       if (absRotation === 90 || absRotation === 270) {
Kode lerroa:         scaleX = height / width;
Kode lerroa:         scaleY = width / height;
Kode lerroa:       }
Kode lerroa:       var cssTransform = 'rotate(' + relativeRotation + 'deg) ' + 'scale(' + scaleX + ',' + scaleY + ')';
Kode lerroa:       _pdfjsLib.CustomStyle.setProp('transform', target, cssTransform);
Kode lerroa:       if (this.textLayer) {
Kode lerroa:         var textLayerViewport = this.textLayer.viewport;
Kode lerroa:         var textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
Kode lerroa:         var textAbsRotation = Math.abs(textRelativeRotation);
Kode lerroa:         var scale = width / textLayerViewport.width;
Kode lerroa:         if (textAbsRotation === 90 || textAbsRotation === 270) {
Kode lerroa:           scale = width / textLayerViewport.height;
Kode lerroa:         }
Kode lerroa:         var textLayerDiv = this.textLayer.textLayerDiv;
Kode lerroa:         var transX = void 0,
Kode lerroa:             transY = void 0;
Kode lerroa:         switch (textAbsRotation) {
Kode lerroa:           case 0:
Kode lerroa:             transX = transY = 0;
Kode lerroa:             break;
Kode lerroa:           case 90:
Kode lerroa:             transX = 0;
Kode lerroa:             transY = '-' + textLayerDiv.style.height;
Kode lerroa:             break;
Kode lerroa:           case 180:
Kode lerroa:             transX = '-' + textLayerDiv.style.width;
Kode lerroa:             transY = '-' + textLayerDiv.style.height;
Kode lerroa:             break;
Kode lerroa:           case 270:
Kode lerroa:             transX = '-' + textLayerDiv.style.width;
Kode lerroa:             transY = 0;
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             console.error('Bad rotation value.');
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         _pdfjsLib.CustomStyle.setProp('transform', textLayerDiv, 'rotate(' + textAbsRotation + 'deg) ' + 'scale(' + scale + ', ' + scale + ') ' + 'translate(' + transX + ', ' + transY + ')');
Kode lerroa:         _pdfjsLib.CustomStyle.setProp('transformOrigin', textLayerDiv, '0% 0%');
Kode lerroa:       }
Kode lerroa:       if (redrawAnnotations && this.annotationLayer) {
Kode lerroa:         this.annotationLayer.render(this.viewport, 'display');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getPagePoint',
Kode lerroa:     value: function getPagePoint(x, y) {
Kode lerroa:       return this.viewport.convertToPdfPoint(x, y);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'draw',
Kode lerroa:     value: function draw() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
Kode lerroa:         console.error('Must be in new state before drawing');
Kode lerroa:         this.reset();
Kode lerroa:       }
Kode lerroa:       if (!this.pdfPage) {
Kode lerroa:         this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
Kode lerroa:         return Promise.reject(new Error('Page is not loaded'));
Kode lerroa:       }
Kode lerroa:       this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
Kode lerroa:       var pdfPage = this.pdfPage;
Kode lerroa:       var div = this.div;
Kode lerroa:       var canvasWrapper = document.createElement('div');
Kode lerroa:       canvasWrapper.style.width = div.style.width;
Kode lerroa:       canvasWrapper.style.height = div.style.height;
Kode lerroa:       canvasWrapper.classList.add('canvasWrapper');
Kode lerroa:       if (this.annotationLayer && this.annotationLayer.div) {
Kode lerroa:         div.insertBefore(canvasWrapper, this.annotationLayer.div);
Kode lerroa:       } else {
Kode lerroa:         div.appendChild(canvasWrapper);
Kode lerroa:       }
Kode lerroa:       var textLayer = null;
Kode lerroa:       if (this.textLayerFactory) {
Kode lerroa:         var textLayerDiv = document.createElement('div');
Kode lerroa:         textLayerDiv.className = 'textLayer';
Kode lerroa:         textLayerDiv.style.width = canvasWrapper.style.width;
Kode lerroa:         textLayerDiv.style.height = canvasWrapper.style.height;
Kode lerroa:         if (this.annotationLayer && this.annotationLayer.div) {
Kode lerroa:           div.insertBefore(textLayerDiv, this.annotationLayer.div);
Kode lerroa:         } else {
Kode lerroa:           div.appendChild(textLayerDiv);
Kode lerroa:         }
Kode lerroa:         textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.enhanceTextSelection);
Kode lerroa:       }
Kode lerroa:       this.textLayer = textLayer;
Kode lerroa:       var renderContinueCallback = null;
Kode lerroa:       if (this.renderingQueue) {
Kode lerroa:         renderContinueCallback = function renderContinueCallback(cont) {
Kode lerroa:           if (!_this.renderingQueue.isHighestPriority(_this)) {
Kode lerroa:             _this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;
Kode lerroa:             _this.resume = function () {
Kode lerroa:               _this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
Kode lerroa:               cont();
Kode lerroa:             };
Kode lerroa:             return;
Kode lerroa:           }
Kode lerroa:           cont();
Kode lerroa:         };
Kode lerroa:       }
Kode lerroa:       var finishPaintTask = function finishPaintTask(error) {
Kode lerroa:         if (paintTask === _this.paintTask) {
Kode lerroa:           _this.paintTask = null;
Kode lerroa:         }
Kode lerroa:         if (error === 'cancelled' || error instanceof _pdfjsLib.RenderingCancelledException) {
Kode lerroa:           _this.error = null;
Kode lerroa:           return Promise.resolve(undefined);
Kode lerroa:         }
Kode lerroa:         _this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
Kode lerroa:         if (_this.loadingIconDiv) {
Kode lerroa:           div.removeChild(_this.loadingIconDiv);
Kode lerroa:           delete _this.loadingIconDiv;
Kode lerroa:         }
Kode lerroa:         _this._resetZoomLayer(true);
Kode lerroa:         _this.error = error;
Kode lerroa:         _this.stats = pdfPage.stats;
Kode lerroa:         if (_this.onAfterDraw) {
Kode lerroa:           _this.onAfterDraw();
Kode lerroa:         }
Kode lerroa:         _this.eventBus.dispatch('pagerendered', {
Kode lerroa:           source: _this,
Kode lerroa:           pageNumber: _this.id,
Kode lerroa:           cssTransform: false
Kode lerroa:         });
Kode lerroa:         if (error) {
Kode lerroa:           return Promise.reject(error);
Kode lerroa:         }
Kode lerroa:         return Promise.resolve(undefined);
Kode lerroa:       };
Kode lerroa:       var paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
Kode lerroa:       paintTask.onRenderContinue = renderContinueCallback;
Kode lerroa:       this.paintTask = paintTask;
Kode lerroa:       var resultPromise = paintTask.promise.then(function () {
Kode lerroa:         return finishPaintTask(null).then(function () {
Kode lerroa:           if (textLayer) {
Kode lerroa:             var readableStream = pdfPage.streamTextContent({ normalizeWhitespace: true });
Kode lerroa:             textLayer.setTextContentStream(readableStream);
Kode lerroa:             textLayer.render();
Kode lerroa:           }
Kode lerroa:         });
Kode lerroa:       }, function (reason) {
Kode lerroa:         return finishPaintTask(reason);
Kode lerroa:       });
Kode lerroa:       if (this.annotationLayerFactory) {
Kode lerroa:         if (!this.annotationLayer) {
Kode lerroa:           this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this.renderInteractiveForms, this.l10n);
Kode lerroa:         }
Kode lerroa:         this.annotationLayer.render(this.viewport, 'display');
Kode lerroa:       }
Kode lerroa:       div.setAttribute('data-loaded', true);
Kode lerroa:       if (this.onBeforeDraw) {
Kode lerroa:         this.onBeforeDraw();
Kode lerroa:       }
Kode lerroa:       return resultPromise;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'paintOnCanvas',
Kode lerroa:     value: function paintOnCanvas(canvasWrapper) {
Kode lerroa:       var renderCapability = (0, _pdfjsLib.createPromiseCapability)();
Kode lerroa:       var result = {
Kode lerroa:         promise: renderCapability.promise,
Kode lerroa:         onRenderContinue: function onRenderContinue(cont) {
Kode lerroa:           cont();
Kode lerroa:         },
Kode lerroa:         cancel: function cancel() {
Kode lerroa:           renderTask.cancel();
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       var viewport = this.viewport;
Kode lerroa:       var canvas = document.createElement('canvas');
Kode lerroa:       canvas.id = this.renderingId;
Kode lerroa:       canvas.setAttribute('hidden', 'hidden');
Kode lerroa:       var isCanvasHidden = true;
Kode lerroa:       var showCanvas = function showCanvas() {
Kode lerroa:         if (isCanvasHidden) {
Kode lerroa:           canvas.removeAttribute('hidden');
Kode lerroa:           isCanvasHidden = false;
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       canvasWrapper.appendChild(canvas);
Kode lerroa:       this.canvas = canvas;
Kode lerroa:       canvas.mozOpaque = true;
Kode lerroa:       var ctx = canvas.getContext('2d', { alpha: false });
Kode lerroa:       var outputScale = (0, _ui_utils.getOutputScale)(ctx);
Kode lerroa:       this.outputScale = outputScale;
Kode lerroa:       if (_pdfjsLib.PDFJS.useOnlyCssZoom) {
Kode lerroa:         var actualSizeViewport = viewport.clone({ scale: _ui_utils.CSS_UNITS });
Kode lerroa:         outputScale.sx *= actualSizeViewport.width / viewport.width;
Kode lerroa:         outputScale.sy *= actualSizeViewport.height / viewport.height;
Kode lerroa:         outputScale.scaled = true;
Kode lerroa:       }
Kode lerroa:       if (_pdfjsLib.PDFJS.maxCanvasPixels > 0) {
Kode lerroa:         var pixelsInViewport = viewport.width * viewport.height;
Kode lerroa:         var maxScale = Math.sqrt(_pdfjsLib.PDFJS.maxCanvasPixels / pixelsInViewport);
Kode lerroa:         if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
Kode lerroa:           outputScale.sx = maxScale;
Kode lerroa:           outputScale.sy = maxScale;
Kode lerroa:           outputScale.scaled = true;
Kode lerroa:           this.hasRestrictedScaling = true;
Kode lerroa:         } else {
Kode lerroa:           this.hasRestrictedScaling = false;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       var sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
Kode lerroa:       var sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
Kode lerroa:       canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
Kode lerroa:       canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
Kode lerroa:       canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + 'px';
Kode lerroa:       canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + 'px';
Kode lerroa:       this.paintedViewportMap.set(canvas, viewport);
Kode lerroa:       var transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
Kode lerroa:       var renderContext = {
Kode lerroa:         canvasContext: ctx,
Kode lerroa:         transform: transform,
Kode lerroa:         viewport: this.viewport,
Kode lerroa:         renderInteractiveForms: this.renderInteractiveForms
Kode lerroa:       };
Kode lerroa:       var renderTask = this.pdfPage.render(renderContext);
Kode lerroa:       renderTask.onContinue = function (cont) {
Kode lerroa:         showCanvas();
Kode lerroa:         if (result.onRenderContinue) {
Kode lerroa:           result.onRenderContinue(cont);
Kode lerroa:         } else {
Kode lerroa:           cont();
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       renderTask.promise.then(function () {
Kode lerroa:         showCanvas();
Kode lerroa:         renderCapability.resolve(undefined);
Kode lerroa:       }, function (error) {
Kode lerroa:         showCanvas();
Kode lerroa:         renderCapability.reject(error);
Kode lerroa:       });
Kode lerroa:       return result;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'paintOnSvg',
Kode lerroa:     value: function paintOnSvg(wrapper) {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var cancelled = false;
Kode lerroa:       var ensureNotCancelled = function ensureNotCancelled() {
Kode lerroa:         if (cancelled) {
Kode lerroa:           if (_pdfjsLib.PDFJS.pdfjsNext) {
Kode lerroa:             throw new _pdfjsLib.RenderingCancelledException('Rendering cancelled, page ' + _this2.id, 'svg');
Kode lerroa:           } else {
Kode lerroa:             throw 'cancelled';
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:       var pdfPage = this.pdfPage;
Kode lerroa:       var actualSizeViewport = this.viewport.clone({ scale: _ui_utils.CSS_UNITS });
Kode lerroa:       var promise = pdfPage.getOperatorList().then(function (opList) {
Kode lerroa:         ensureNotCancelled();
Kode lerroa:         var svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
Kode lerroa:         return svgGfx.getSVG(opList, actualSizeViewport).then(function (svg) {
Kode lerroa:           ensureNotCancelled();
Kode lerroa:           _this2.svg = svg;
Kode lerroa:           _this2.paintedViewportMap.set(svg, actualSizeViewport);
Kode lerroa:           svg.style.width = wrapper.style.width;
Kode lerroa:           svg.style.height = wrapper.style.height;
Kode lerroa:           _this2.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
Kode lerroa:           wrapper.appendChild(svg);
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       return {
Kode lerroa:         promise: promise,
Kode lerroa:         onRenderContinue: function onRenderContinue(cont) {
Kode lerroa:           cont();
Kode lerroa:         },
Kode lerroa:         cancel: function cancel() {
Kode lerroa:           cancelled = true;
Kode lerroa:         }
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPageLabel',
Kode lerroa:     value: function setPageLabel(label) {
Kode lerroa:       this.pageLabel = typeof label === 'string' ? label : null;
Kode lerroa:       if (this.pageLabel !== null) {
Kode lerroa:         this.div.setAttribute('data-page-label', this.pageLabel);
Kode lerroa:       } else {
Kode lerroa:         this.div.removeAttribute('data-page-label');
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'width',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.viewport.width;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'height',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.viewport.height;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return PDFPageView;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.PDFPageView = PDFPageView;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 25 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.DefaultTextLayerFactory = exports.TextLayerBuilder = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _dom_events = __webpack_require__(2);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var EXPAND_DIVS_TIMEOUT = 300;
Kode lerroa: 
Kode lerroa: var TextLayerBuilder = function () {
Kode lerroa:   function TextLayerBuilder(_ref) {
Kode lerroa:     var textLayerDiv = _ref.textLayerDiv,
Kode lerroa:         eventBus = _ref.eventBus,
Kode lerroa:         pageIndex = _ref.pageIndex,
Kode lerroa:         viewport = _ref.viewport,
Kode lerroa:         _ref$findController = _ref.findController,
Kode lerroa:         findController = _ref$findController === undefined ? null : _ref$findController,
Kode lerroa:         _ref$enhanceTextSelec = _ref.enhanceTextSelection,
Kode lerroa:         enhanceTextSelection = _ref$enhanceTextSelec === undefined ? false : _ref$enhanceTextSelec;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, TextLayerBuilder);
Kode lerroa: 
Kode lerroa:     this.textLayerDiv = textLayerDiv;
Kode lerroa:     this.eventBus = eventBus || (0, _dom_events.getGlobalEventBus)();
Kode lerroa:     this.textContent = null;
Kode lerroa:     this.textContentItemsStr = [];
Kode lerroa:     this.textContentStream = null;
Kode lerroa:     this.renderingDone = false;
Kode lerroa:     this.pageIdx = pageIndex;
Kode lerroa:     this.pageNumber = this.pageIdx + 1;
Kode lerroa:     this.matches = [];
Kode lerroa:     this.viewport = viewport;
Kode lerroa:     this.textDivs = [];
Kode lerroa:     this.findController = findController;
Kode lerroa:     this.textLayerRenderTask = null;
Kode lerroa:     this.enhanceTextSelection = enhanceTextSelection;
Kode lerroa:     this._bindMouse();
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(TextLayerBuilder, [{
Kode lerroa:     key: '_finishRendering',
Kode lerroa:     value: function _finishRendering() {
Kode lerroa:       this.renderingDone = true;
Kode lerroa:       if (!this.enhanceTextSelection) {
Kode lerroa:         var endOfContent = document.createElement('div');
Kode lerroa:         endOfContent.className = 'endOfContent';
Kode lerroa:         this.textLayerDiv.appendChild(endOfContent);
Kode lerroa:       }
Kode lerroa:       this.eventBus.dispatch('textlayerrendered', {
Kode lerroa:         source: this,
Kode lerroa:         pageNumber: this.pageNumber,
Kode lerroa:         numTextDivs: this.textDivs.length
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'render',
Kode lerroa:     value: function render() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
Kode lerroa: 
Kode lerroa:       if (!(this.textContent || this.textContentStream) || this.renderingDone) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.cancel();
Kode lerroa:       this.textDivs = [];
Kode lerroa:       var textLayerFrag = document.createDocumentFragment();
Kode lerroa:       this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
Kode lerroa:         textContent: this.textContent,
Kode lerroa:         textContentStream: this.textContentStream,
Kode lerroa:         container: textLayerFrag,
Kode lerroa:         viewport: this.viewport,
Kode lerroa:         textDivs: this.textDivs,
Kode lerroa:         textContentItemsStr: this.textContentItemsStr,
Kode lerroa:         timeout: timeout,
Kode lerroa:         enhanceTextSelection: this.enhanceTextSelection
Kode lerroa:       });
Kode lerroa:       this.textLayerRenderTask.promise.then(function () {
Kode lerroa:         _this.textLayerDiv.appendChild(textLayerFrag);
Kode lerroa:         _this._finishRendering();
Kode lerroa:         _this.updateMatches();
Kode lerroa:       }, function (reason) {});
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'cancel',
Kode lerroa:     value: function cancel() {
Kode lerroa:       if (this.textLayerRenderTask) {
Kode lerroa:         this.textLayerRenderTask.cancel();
Kode lerroa:         this.textLayerRenderTask = null;
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setTextContentStream',
Kode lerroa:     value: function setTextContentStream(readableStream) {
Kode lerroa:       this.cancel();
Kode lerroa:       this.textContentStream = readableStream;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setTextContent',
Kode lerroa:     value: function setTextContent(textContent) {
Kode lerroa:       this.cancel();
Kode lerroa:       this.textContent = textContent;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'convertMatches',
Kode lerroa:     value: function convertMatches(matches, matchesLength) {
Kode lerroa:       var i = 0;
Kode lerroa:       var iIndex = 0;
Kode lerroa:       var textContentItemsStr = this.textContentItemsStr;
Kode lerroa:       var end = textContentItemsStr.length - 1;
Kode lerroa:       var queryLen = this.findController === null ? 0 : this.findController.state.query.length;
Kode lerroa:       var ret = [];
Kode lerroa:       if (!matches) {
Kode lerroa:         return ret;
Kode lerroa:       }
Kode lerroa:       for (var m = 0, len = matches.length; m < len; m++) {
Kode lerroa:         var matchIdx = matches[m];
Kode lerroa:         while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
Kode lerroa:           iIndex += textContentItemsStr[i].length;
Kode lerroa:           i++;
Kode lerroa:         }
Kode lerroa:         if (i === textContentItemsStr.length) {
Kode lerroa:           console.error('Could not find a matching mapping');
Kode lerroa:         }
Kode lerroa:         var match = {
Kode lerroa:           begin: {
Kode lerroa:             divIdx: i,
Kode lerroa:             offset: matchIdx - iIndex
Kode lerroa:           }
Kode lerroa:         };
Kode lerroa:         if (matchesLength) {
Kode lerroa:           matchIdx += matchesLength[m];
Kode lerroa:         } else {
Kode lerroa:           matchIdx += queryLen;
Kode lerroa:         }
Kode lerroa:         while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
Kode lerroa:           iIndex += textContentItemsStr[i].length;
Kode lerroa:           i++;
Kode lerroa:         }
Kode lerroa:         match.end = {
Kode lerroa:           divIdx: i,
Kode lerroa:           offset: matchIdx - iIndex
Kode lerroa:         };
Kode lerroa:         ret.push(match);
Kode lerroa:       }
Kode lerroa:       return ret;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'renderMatches',
Kode lerroa:     value: function renderMatches(matches) {
Kode lerroa:       if (matches.length === 0) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var textContentItemsStr = this.textContentItemsStr;
Kode lerroa:       var textDivs = this.textDivs;
Kode lerroa:       var prevEnd = null;
Kode lerroa:       var pageIdx = this.pageIdx;
Kode lerroa:       var isSelectedPage = this.findController === null ? false : pageIdx === this.findController.selected.pageIdx;
Kode lerroa:       var selectedMatchIdx = this.findController === null ? -1 : this.findController.selected.matchIdx;
Kode lerroa:       var highlightAll = this.findController === null ? false : this.findController.state.highlightAll;
Kode lerroa:       var infinity = {
Kode lerroa:         divIdx: -1,
Kode lerroa:         offset: undefined
Kode lerroa:       };
Kode lerroa:       function beginText(begin, className) {
Kode lerroa:         var divIdx = begin.divIdx;
Kode lerroa:         textDivs[divIdx].textContent = '';
Kode lerroa:         appendTextToDiv(divIdx, 0, begin.offset, className);
Kode lerroa:       }
Kode lerroa:       function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
Kode lerroa:         var div = textDivs[divIdx];
Kode lerroa:         var content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
Kode lerroa:         var node = document.createTextNode(content);
Kode lerroa:         if (className) {
Kode lerroa:           var span = document.createElement('span');
Kode lerroa:           span.className = className;
Kode lerroa:           span.appendChild(node);
Kode lerroa:           div.appendChild(span);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         div.appendChild(node);
Kode lerroa:       }
Kode lerroa:       var i0 = selectedMatchIdx,
Kode lerroa:           i1 = i0 + 1;
Kode lerroa:       if (highlightAll) {
Kode lerroa:         i0 = 0;
Kode lerroa:         i1 = matches.length;
Kode lerroa:       } else if (!isSelectedPage) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       for (var i = i0; i < i1; i++) {
Kode lerroa:         var match = matches[i];
Kode lerroa:         var begin = match.begin;
Kode lerroa:         var end = match.end;
Kode lerroa:         var isSelected = isSelectedPage && i === selectedMatchIdx;
Kode lerroa:         var highlightSuffix = isSelected ? ' selected' : '';
Kode lerroa:         if (this.findController) {
Kode lerroa:           this.findController.updateMatchPosition(pageIdx, i, textDivs, begin.divIdx);
Kode lerroa:         }
Kode lerroa:         if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
Kode lerroa:           if (prevEnd !== null) {
Kode lerroa:             appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
Kode lerroa:           }
Kode lerroa:           beginText(begin);
Kode lerroa:         } else {
Kode lerroa:           appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
Kode lerroa:         }
Kode lerroa:         if (begin.divIdx === end.divIdx) {
Kode lerroa:           appendTextToDiv(begin.divIdx, begin.offset, end.offset, 'highlight' + highlightSuffix);
Kode lerroa:         } else {
Kode lerroa:           appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, 'highlight begin' + highlightSuffix);
Kode lerroa:           for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
Kode lerroa:             textDivs[n0].className = 'highlight middle' + highlightSuffix;
Kode lerroa:           }
Kode lerroa:           beginText(end, 'highlight end' + highlightSuffix);
Kode lerroa:         }
Kode lerroa:         prevEnd = end;
Kode lerroa:       }
Kode lerroa:       if (prevEnd) {
Kode lerroa:         appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateMatches',
Kode lerroa:     value: function updateMatches() {
Kode lerroa:       if (!this.renderingDone) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var matches = this.matches;
Kode lerroa:       var textDivs = this.textDivs;
Kode lerroa:       var textContentItemsStr = this.textContentItemsStr;
Kode lerroa:       var clearedUntilDivIdx = -1;
Kode lerroa:       for (var i = 0, len = matches.length; i < len; i++) {
Kode lerroa:         var match = matches[i];
Kode lerroa:         var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
Kode lerroa:         for (var n = begin, end = match.end.divIdx; n <= end; n++) {
Kode lerroa:           var div = textDivs[n];
Kode lerroa:           div.textContent = textContentItemsStr[n];
Kode lerroa:           div.className = '';
Kode lerroa:         }
Kode lerroa:         clearedUntilDivIdx = match.end.divIdx + 1;
Kode lerroa:       }
Kode lerroa:       if (this.findController === null || !this.findController.active) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var pageMatches = void 0,
Kode lerroa:           pageMatchesLength = void 0;
Kode lerroa:       if (this.findController !== null) {
Kode lerroa:         pageMatches = this.findController.pageMatches[this.pageIdx] || null;
Kode lerroa:         pageMatchesLength = this.findController.pageMatchesLength ? this.findController.pageMatchesLength[this.pageIdx] || null : null;
Kode lerroa:       }
Kode lerroa:       this.matches = this.convertMatches(pageMatches, pageMatchesLength);
Kode lerroa:       this.renderMatches(this.matches);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindMouse',
Kode lerroa:     value: function _bindMouse() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       var div = this.textLayerDiv;
Kode lerroa:       var expandDivsTimer = null;
Kode lerroa:       div.addEventListener('mousedown', function (evt) {
Kode lerroa:         if (_this2.enhanceTextSelection && _this2.textLayerRenderTask) {
Kode lerroa:           _this2.textLayerRenderTask.expandTextDivs(true);
Kode lerroa:           if (expandDivsTimer) {
Kode lerroa:             clearTimeout(expandDivsTimer);
Kode lerroa:             expandDivsTimer = null;
Kode lerroa:           }
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var end = div.querySelector('.endOfContent');
Kode lerroa:         if (!end) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var adjustTop = evt.target !== div;
Kode lerroa:         adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue('-moz-user-select') !== 'none';
Kode lerroa:         if (adjustTop) {
Kode lerroa:           var divBounds = div.getBoundingClientRect();
Kode lerroa:           var r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
Kode lerroa:           end.style.top = (r * 100).toFixed(2) + '%';
Kode lerroa:         }
Kode lerroa:         end.classList.add('active');
Kode lerroa:       });
Kode lerroa:       div.addEventListener('mouseup', function () {
Kode lerroa:         if (_this2.enhanceTextSelection && _this2.textLayerRenderTask) {
Kode lerroa:           expandDivsTimer = setTimeout(function () {
Kode lerroa:             if (_this2.textLayerRenderTask) {
Kode lerroa:               _this2.textLayerRenderTask.expandTextDivs(false);
Kode lerroa:             }
Kode lerroa:             expandDivsTimer = null;
Kode lerroa:           }, EXPAND_DIVS_TIMEOUT);
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         var end = div.querySelector('.endOfContent');
Kode lerroa:         if (!end) {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         end.style.top = '';
Kode lerroa:         end.classList.remove('active');
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return TextLayerBuilder;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: var DefaultTextLayerFactory = function () {
Kode lerroa:   function DefaultTextLayerFactory() {
Kode lerroa:     _classCallCheck(this, DefaultTextLayerFactory);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(DefaultTextLayerFactory, [{
Kode lerroa:     key: 'createTextLayerBuilder',
Kode lerroa:     value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
Kode lerroa:       var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
Kode lerroa: 
Kode lerroa:       return new TextLayerBuilder({
Kode lerroa:         textLayerDiv: textLayerDiv,
Kode lerroa:         pageIndex: pageIndex,
Kode lerroa:         viewport: viewport,
Kode lerroa:         enhanceTextSelection: enhanceTextSelection
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return DefaultTextLayerFactory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.TextLayerBuilder = TextLayerBuilder;
Kode lerroa: exports.DefaultTextLayerFactory = DefaultTextLayerFactory;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 26 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.SecondaryToolbar = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdf_cursor_tools = __webpack_require__(6);
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var SecondaryToolbar = function () {
Kode lerroa:   function SecondaryToolbar(options, mainContainer, eventBus) {
Kode lerroa:     _classCallCheck(this, SecondaryToolbar);
Kode lerroa: 
Kode lerroa:     this.toolbar = options.toolbar;
Kode lerroa:     this.toggleButton = options.toggleButton;
Kode lerroa:     this.toolbarButtonContainer = options.toolbarButtonContainer;
Kode lerroa:     this.buttons = [{
Kode lerroa:       element: options.presentationModeButton,
Kode lerroa:       eventName: 'presentationmode',
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.openFileButton,
Kode lerroa:       eventName: 'openfile',
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.printButton,
Kode lerroa:       eventName: 'print',
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.downloadButton,
Kode lerroa:       eventName: 'download',
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.viewBookmarkButton,
Kode lerroa:       eventName: null,
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.firstPageButton,
Kode lerroa:       eventName: 'firstpage',
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.lastPageButton,
Kode lerroa:       eventName: 'lastpage',
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.pageRotateCwButton,
Kode lerroa:       eventName: 'rotatecw',
Kode lerroa:       close: false
Kode lerroa:     }, {
Kode lerroa:       element: options.pageRotateCcwButton,
Kode lerroa:       eventName: 'rotateccw',
Kode lerroa:       close: false
Kode lerroa:     }, {
Kode lerroa:       element: options.cursorSelectToolButton,
Kode lerroa:       eventName: 'switchcursortool',
Kode lerroa:       eventDetails: { tool: _pdf_cursor_tools.CursorTool.SELECT },
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.cursorHandToolButton,
Kode lerroa:       eventName: 'switchcursortool',
Kode lerroa:       eventDetails: { tool: _pdf_cursor_tools.CursorTool.HAND },
Kode lerroa:       close: true
Kode lerroa:     }, {
Kode lerroa:       element: options.documentPropertiesButton,
Kode lerroa:       eventName: 'documentproperties',
Kode lerroa:       close: true
Kode lerroa:     }];
Kode lerroa:     this.items = {
Kode lerroa:       firstPage: options.firstPageButton,
Kode lerroa:       lastPage: options.lastPageButton,
Kode lerroa:       pageRotateCw: options.pageRotateCwButton,
Kode lerroa:       pageRotateCcw: options.pageRotateCcwButton
Kode lerroa:     };
Kode lerroa:     this.mainContainer = mainContainer;
Kode lerroa:     this.eventBus = eventBus;
Kode lerroa:     this.opened = false;
Kode lerroa:     this.containerHeight = null;
Kode lerroa:     this.previousContainerHeight = null;
Kode lerroa:     this.reset();
Kode lerroa:     this._bindClickListeners();
Kode lerroa:     this._bindCursorToolsListener(options);
Kode lerroa:     this.eventBus.on('resize', this._setMaxHeight.bind(this));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(SecondaryToolbar, [{
Kode lerroa:     key: 'setPageNumber',
Kode lerroa:     value: function setPageNumber(pageNumber) {
Kode lerroa:       this.pageNumber = pageNumber;
Kode lerroa:       this._updateUIState();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPagesCount',
Kode lerroa:     value: function setPagesCount(pagesCount) {
Kode lerroa:       this.pagesCount = pagesCount;
Kode lerroa:       this._updateUIState();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       this.pageNumber = 0;
Kode lerroa:       this.pagesCount = 0;
Kode lerroa:       this._updateUIState();
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateUIState',
Kode lerroa:     value: function _updateUIState() {
Kode lerroa:       this.items.firstPage.disabled = this.pageNumber <= 1;
Kode lerroa:       this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;
Kode lerroa:       this.items.pageRotateCw.disabled = this.pagesCount === 0;
Kode lerroa:       this.items.pageRotateCcw.disabled = this.pagesCount === 0;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindClickListeners',
Kode lerroa:     value: function _bindClickListeners() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       this.toggleButton.addEventListener('click', this.toggle.bind(this));
Kode lerroa: 
Kode lerroa:       var _loop = function _loop(button) {
Kode lerroa:         var _buttons$button = _this.buttons[button],
Kode lerroa:             element = _buttons$button.element,
Kode lerroa:             eventName = _buttons$button.eventName,
Kode lerroa:             close = _buttons$button.close,
Kode lerroa:             eventDetails = _buttons$button.eventDetails;
Kode lerroa: 
Kode lerroa:         element.addEventListener('click', function (evt) {
Kode lerroa:           if (eventName !== null) {
Kode lerroa:             var details = { source: _this };
Kode lerroa:             for (var property in eventDetails) {
Kode lerroa:               details[property] = eventDetails[property];
Kode lerroa:             }
Kode lerroa:             _this.eventBus.dispatch(eventName, details);
Kode lerroa:           }
Kode lerroa:           if (close) {
Kode lerroa:             _this.close();
Kode lerroa:           }
Kode lerroa:         });
Kode lerroa:       };
Kode lerroa: 
Kode lerroa:       for (var button in this.buttons) {
Kode lerroa:         _loop(button);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindCursorToolsListener',
Kode lerroa:     value: function _bindCursorToolsListener(buttons) {
Kode lerroa:       this.eventBus.on('cursortoolchanged', function (evt) {
Kode lerroa:         buttons.cursorSelectToolButton.classList.remove('toggled');
Kode lerroa:         buttons.cursorHandToolButton.classList.remove('toggled');
Kode lerroa:         switch (evt.tool) {
Kode lerroa:           case _pdf_cursor_tools.CursorTool.SELECT:
Kode lerroa:             buttons.cursorSelectToolButton.classList.add('toggled');
Kode lerroa:             break;
Kode lerroa:           case _pdf_cursor_tools.CursorTool.HAND:
Kode lerroa:             buttons.cursorHandToolButton.classList.add('toggled');
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'open',
Kode lerroa:     value: function open() {
Kode lerroa:       if (this.opened) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.opened = true;
Kode lerroa:       this._setMaxHeight();
Kode lerroa:       this.toggleButton.classList.add('toggled');
Kode lerroa:       this.toolbar.classList.remove('hidden');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'close',
Kode lerroa:     value: function close() {
Kode lerroa:       if (!this.opened) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.opened = false;
Kode lerroa:       this.toolbar.classList.add('hidden');
Kode lerroa:       this.toggleButton.classList.remove('toggled');
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'toggle',
Kode lerroa:     value: function toggle() {
Kode lerroa:       if (this.opened) {
Kode lerroa:         this.close();
Kode lerroa:       } else {
Kode lerroa:         this.open();
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_setMaxHeight',
Kode lerroa:     value: function _setMaxHeight() {
Kode lerroa:       if (!this.opened) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.containerHeight = this.mainContainer.clientHeight;
Kode lerroa:       if (this.containerHeight === this.previousContainerHeight) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       this.toolbarButtonContainer.setAttribute('style', 'max-height: ' + (this.containerHeight - _ui_utils.SCROLLBAR_PADDING) + 'px;');
Kode lerroa:       this.previousContainerHeight = this.containerHeight;
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'isOpen',
Kode lerroa:     get: function get() {
Kode lerroa:       return this.opened;
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return SecondaryToolbar;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.SecondaryToolbar = SecondaryToolbar;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 27 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.Toolbar = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var PAGE_NUMBER_LOADING_INDICATOR = 'visiblePageIsLoading';
Kode lerroa: var SCALE_SELECT_CONTAINER_PADDING = 8;
Kode lerroa: var SCALE_SELECT_PADDING = 22;
Kode lerroa: 
Kode lerroa: var Toolbar = function () {
Kode lerroa:   function Toolbar(options, mainContainer, eventBus) {
Kode lerroa:     var l10n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _ui_utils.NullL10n;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, Toolbar);
Kode lerroa: 
Kode lerroa:     this.toolbar = options.container;
Kode lerroa:     this.mainContainer = mainContainer;
Kode lerroa:     this.eventBus = eventBus;
Kode lerroa:     this.l10n = l10n;
Kode lerroa:     this.items = options;
Kode lerroa:     this._wasLocalized = false;
Kode lerroa:     this.reset();
Kode lerroa:     this._bindListeners();
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(Toolbar, [{
Kode lerroa:     key: 'setPageNumber',
Kode lerroa:     value: function setPageNumber(pageNumber, pageLabel) {
Kode lerroa:       this.pageNumber = pageNumber;
Kode lerroa:       this.pageLabel = pageLabel;
Kode lerroa:       this._updateUIState(false);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPagesCount',
Kode lerroa:     value: function setPagesCount(pagesCount, hasPageLabels) {
Kode lerroa:       this.pagesCount = pagesCount;
Kode lerroa:       this.hasPageLabels = hasPageLabels;
Kode lerroa:       this._updateUIState(true);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setPageScale',
Kode lerroa:     value: function setPageScale(pageScaleValue, pageScale) {
Kode lerroa:       this.pageScaleValue = pageScaleValue;
Kode lerroa:       this.pageScale = pageScale;
Kode lerroa:       this._updateUIState(false);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'reset',
Kode lerroa:     value: function reset() {
Kode lerroa:       this.pageNumber = 0;
Kode lerroa:       this.pageLabel = null;
Kode lerroa:       this.hasPageLabels = false;
Kode lerroa:       this.pagesCount = 0;
Kode lerroa:       this.pageScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
Kode lerroa:       this.pageScale = _ui_utils.DEFAULT_SCALE;
Kode lerroa:       this._updateUIState(true);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_bindListeners',
Kode lerroa:     value: function _bindListeners() {
Kode lerroa:       var _this = this;
Kode lerroa: 
Kode lerroa:       var eventBus = this.eventBus,
Kode lerroa:           items = this.items;
Kode lerroa: 
Kode lerroa:       var self = this;
Kode lerroa:       items.previous.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('previouspage');
Kode lerroa:       });
Kode lerroa:       items.next.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('nextpage');
Kode lerroa:       });
Kode lerroa:       items.zoomIn.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('zoomin');
Kode lerroa:       });
Kode lerroa:       items.zoomOut.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('zoomout');
Kode lerroa:       });
Kode lerroa:       items.pageNumber.addEventListener('click', function () {
Kode lerroa:         this.select();
Kode lerroa:       });
Kode lerroa:       items.pageNumber.addEventListener('change', function () {
Kode lerroa:         eventBus.dispatch('pagenumberchanged', {
Kode lerroa:           source: self,
Kode lerroa:           value: this.value
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       items.scaleSelect.addEventListener('change', function () {
Kode lerroa:         if (this.value === 'custom') {
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         eventBus.dispatch('scalechanged', {
Kode lerroa:           source: self,
Kode lerroa:           value: this.value
Kode lerroa:         });
Kode lerroa:       });
Kode lerroa:       items.presentationModeButton.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('presentationmode');
Kode lerroa:       });
Kode lerroa:       items.openFile.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('openfile');
Kode lerroa:       });
Kode lerroa:       items.print.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('print');
Kode lerroa:       });
Kode lerroa:       items.download.addEventListener('click', function () {
Kode lerroa:         eventBus.dispatch('download');
Kode lerroa:       });
Kode lerroa:       items.scaleSelect.oncontextmenu = _ui_utils.noContextMenuHandler;
Kode lerroa:       eventBus.on('localized', function () {
Kode lerroa:         _this._localized();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_localized',
Kode lerroa:     value: function _localized() {
Kode lerroa:       this._wasLocalized = true;
Kode lerroa:       this._adjustScaleWidth();
Kode lerroa:       this._updateUIState(true);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_updateUIState',
Kode lerroa:     value: function _updateUIState() {
Kode lerroa:       var resetNumPages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       if (!this._wasLocalized) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var pageNumber = this.pageNumber,
Kode lerroa:           pagesCount = this.pagesCount,
Kode lerroa:           items = this.items;
Kode lerroa: 
Kode lerroa:       var scaleValue = (this.pageScaleValue || this.pageScale).toString();
Kode lerroa:       var scale = this.pageScale;
Kode lerroa:       if (resetNumPages) {
Kode lerroa:         if (this.hasPageLabels) {
Kode lerroa:           items.pageNumber.type = 'text';
Kode lerroa:         } else {
Kode lerroa:           items.pageNumber.type = 'number';
Kode lerroa:           this.l10n.get('of_pages', { pagesCount: pagesCount }, 'of {{pagesCount}}').then(function (msg) {
Kode lerroa:             items.numPages.textContent = msg;
Kode lerroa:           });
Kode lerroa:         }
Kode lerroa:         items.pageNumber.max = pagesCount;
Kode lerroa:       }
Kode lerroa:       if (this.hasPageLabels) {
Kode lerroa:         items.pageNumber.value = this.pageLabel;
Kode lerroa:         this.l10n.get('page_of_pages', {
Kode lerroa:           pageNumber: pageNumber,
Kode lerroa:           pagesCount: pagesCount
Kode lerroa:         }, '({{pageNumber}} of {{pagesCount}})').then(function (msg) {
Kode lerroa:           items.numPages.textContent = msg;
Kode lerroa:         });
Kode lerroa:       } else {
Kode lerroa:         items.pageNumber.value = pageNumber;
Kode lerroa:       }
Kode lerroa:       items.previous.disabled = pageNumber <= 1;
Kode lerroa:       items.next.disabled = pageNumber >= pagesCount;
Kode lerroa:       items.zoomOut.disabled = scale <= _ui_utils.MIN_SCALE;
Kode lerroa:       items.zoomIn.disabled = scale >= _ui_utils.MAX_SCALE;
Kode lerroa:       var customScale = Math.round(scale * 10000) / 100;
Kode lerroa:       this.l10n.get('page_scale_percent', { scale: customScale }, '{{scale}}%').then(function (msg) {
Kode lerroa:         var options = items.scaleSelect.options;
Kode lerroa:         var predefinedValueFound = false;
Kode lerroa:         for (var i = 0, ii = options.length; i < ii; i++) {
Kode lerroa:           var option = options[i];
Kode lerroa:           if (option.value !== scaleValue) {
Kode lerroa:             option.selected = false;
Kode lerroa:             continue;
Kode lerroa:           }
Kode lerroa:           option.selected = true;
Kode lerroa:           predefinedValueFound = true;
Kode lerroa:         }
Kode lerroa:         if (!predefinedValueFound) {
Kode lerroa:           items.customScaleOption.textContent = msg;
Kode lerroa:           items.customScaleOption.selected = true;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'updateLoadingIndicatorState',
Kode lerroa:     value: function updateLoadingIndicatorState() {
Kode lerroa:       var loading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
Kode lerroa: 
Kode lerroa:       var pageNumberInput = this.items.pageNumber;
Kode lerroa:       if (loading) {
Kode lerroa:         pageNumberInput.classList.add(PAGE_NUMBER_LOADING_INDICATOR);
Kode lerroa:       } else {
Kode lerroa:         pageNumberInput.classList.remove(PAGE_NUMBER_LOADING_INDICATOR);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_adjustScaleWidth',
Kode lerroa:     value: function _adjustScaleWidth() {
Kode lerroa:       var container = this.items.scaleSelectContainer;
Kode lerroa:       var select = this.items.scaleSelect;
Kode lerroa:       _ui_utils.animationStarted.then(function () {
Kode lerroa:         if (container.clientWidth === 0) {
Kode lerroa:           container.setAttribute('style', 'display: inherit;');
Kode lerroa:         }
Kode lerroa:         if (container.clientWidth > 0) {
Kode lerroa:           select.setAttribute('style', 'min-width: inherit;');
Kode lerroa:           var width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;
Kode lerroa:           select.setAttribute('style', 'min-width: ' + (width + SCALE_SELECT_PADDING) + 'px;');
Kode lerroa:           container.setAttribute('style', 'min-width: ' + width + 'px; ' + 'max-width: ' + width + 'px;');
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return Toolbar;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.Toolbar = Toolbar;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 28 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;
Kode lerroa: 
Kode lerroa: var ViewHistory = function () {
Kode lerroa:   function ViewHistory(fingerprint) {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var cacheSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_VIEW_HISTORY_CACHE_SIZE;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, ViewHistory);
Kode lerroa: 
Kode lerroa:     this.fingerprint = fingerprint;
Kode lerroa:     this.cacheSize = cacheSize;
Kode lerroa:     this._initializedPromise = this._readFromStorage().then(function (databaseStr) {
Kode lerroa:       var database = JSON.parse(databaseStr || '{}');
Kode lerroa:       if (!('files' in database)) {
Kode lerroa:         database.files = [];
Kode lerroa:       }
Kode lerroa:       if (database.files.length >= _this.cacheSize) {
Kode lerroa:         database.files.shift();
Kode lerroa:       }
Kode lerroa:       var index = void 0;
Kode lerroa:       for (var i = 0, length = database.files.length; i < length; i++) {
Kode lerroa:         var branch = database.files[i];
Kode lerroa:         if (branch.fingerprint === _this.fingerprint) {
Kode lerroa:           index = i;
Kode lerroa:           break;
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       if (typeof index !== 'number') {
Kode lerroa:         index = database.files.push({ fingerprint: _this.fingerprint }) - 1;
Kode lerroa:       }
Kode lerroa:       _this.file = database.files[index];
Kode lerroa:       _this.database = database;
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(ViewHistory, [{
Kode lerroa:     key: '_writeToStorage',
Kode lerroa:     value: function _writeToStorage() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         var databaseStr = JSON.stringify(_this2.database);
Kode lerroa:         localStorage.setItem('pdfjs.history', databaseStr);
Kode lerroa:         resolve();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_readFromStorage',
Kode lerroa:     value: function _readFromStorage() {
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         resolve(localStorage.getItem('pdfjs.history'));
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'set',
Kode lerroa:     value: function set(name, val) {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         _this3.file[name] = val;
Kode lerroa:         return _this3._writeToStorage();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'setMultiple',
Kode lerroa:     value: function setMultiple(properties) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         for (var name in properties) {
Kode lerroa:           _this4.file[name] = properties[name];
Kode lerroa:         }
Kode lerroa:         return _this4._writeToStorage();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'get',
Kode lerroa:     value: function get(name, defaultValue) {
Kode lerroa:       var _this5 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         var val = _this5.file[name];
Kode lerroa:         return val !== undefined ? val : defaultValue;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'getMultiple',
Kode lerroa:     value: function getMultiple(properties) {
Kode lerroa:       var _this6 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         var values = Object.create(null);
Kode lerroa:         for (var name in properties) {
Kode lerroa:           var val = _this6.file[name];
Kode lerroa:           values[name] = val !== undefined ? val : properties[name];
Kode lerroa:         }
Kode lerroa:         return values;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return ViewHistory;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.ViewHistory = ViewHistory;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 29 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.GenericCom = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _app = __webpack_require__(4);
Kode lerroa: 
Kode lerroa: var _preferences = __webpack_require__(30);
Kode lerroa: 
Kode lerroa: var _download_manager = __webpack_require__(31);
Kode lerroa: 
Kode lerroa: var _genericl10n = __webpack_require__(32);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
Kode lerroa: 
Kode lerroa: function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
Kode lerroa: 
Kode lerroa: ;
Kode lerroa: var GenericCom = {};
Kode lerroa: 
Kode lerroa: var GenericPreferences = function (_BasePreferences) {
Kode lerroa:   _inherits(GenericPreferences, _BasePreferences);
Kode lerroa: 
Kode lerroa:   function GenericPreferences() {
Kode lerroa:     _classCallCheck(this, GenericPreferences);
Kode lerroa: 
Kode lerroa:     return _possibleConstructorReturn(this, (GenericPreferences.__proto__ || Object.getPrototypeOf(GenericPreferences)).apply(this, arguments));
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(GenericPreferences, [{
Kode lerroa:     key: '_writeToStorage',
Kode lerroa:     value: function _writeToStorage(prefObj) {
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));
Kode lerroa:         resolve();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: '_readFromStorage',
Kode lerroa:     value: function _readFromStorage(prefObj) {
Kode lerroa:       return new Promise(function (resolve) {
Kode lerroa:         var readPrefs = JSON.parse(localStorage.getItem('pdfjs.preferences'));
Kode lerroa:         resolve(readPrefs);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return GenericPreferences;
Kode lerroa: }(_preferences.BasePreferences);
Kode lerroa: 
Kode lerroa: var GenericExternalServices = Object.create(_app.DefaultExternalServices);
Kode lerroa: GenericExternalServices.createDownloadManager = function () {
Kode lerroa:   return new _download_manager.DownloadManager();
Kode lerroa: };
Kode lerroa: GenericExternalServices.createPreferences = function () {
Kode lerroa:   return new GenericPreferences();
Kode lerroa: };
Kode lerroa: GenericExternalServices.createL10n = function () {
Kode lerroa:   return new _genericl10n.GenericL10n(_pdfjsLib.PDFJS.locale);
Kode lerroa: };
Kode lerroa: _app.PDFViewerApplication.externalServices = GenericExternalServices;
Kode lerroa: exports.GenericCom = GenericCom;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 30 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.BasePreferences = undefined;
Kode lerroa: 
Kode lerroa: var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var defaultPreferences = null;
Kode lerroa: function getDefaultPreferences() {
Kode lerroa:   if (!defaultPreferences) {
Kode lerroa:     defaultPreferences = Promise.resolve({
Kode lerroa:       "showPreviousViewOnLoad": true,
Kode lerroa:       "defaultZoomValue": "",
Kode lerroa:       "sidebarViewOnLoad": 0,
Kode lerroa:       "enableHandToolOnLoad": false,
Kode lerroa:       "cursorToolOnLoad": 0,
Kode lerroa:       "enableWebGL": false,
Kode lerroa:       "pdfBugEnabled": false,
Kode lerroa:       "disableRange": false,
Kode lerroa:       "disableStream": false,
Kode lerroa:       "disableAutoFetch": false,
Kode lerroa:       "disableFontFace": false,
Kode lerroa:       "disableTextLayer": false,
Kode lerroa:       "useOnlyCssZoom": false,
Kode lerroa:       "externalLinkTarget": 0,
Kode lerroa:       "enhanceTextSelection": false,
Kode lerroa:       "renderer": "canvas",
Kode lerroa:       "renderInteractiveForms": false,
Kode lerroa:       "enablePrintAutoRotate": false,
Kode lerroa:       "disablePageMode": false,
Kode lerroa:       "disablePageLabels": false
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   return defaultPreferences;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var BasePreferences = function () {
Kode lerroa:   function BasePreferences() {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     _classCallCheck(this, BasePreferences);
Kode lerroa: 
Kode lerroa:     if (this.constructor === BasePreferences) {
Kode lerroa:       throw new Error('Cannot initialize BasePreferences.');
Kode lerroa:     }
Kode lerroa:     this.prefs = null;
Kode lerroa:     this._initializedPromise = getDefaultPreferences().then(function (defaults) {
Kode lerroa:       Object.defineProperty(_this, 'defaults', {
Kode lerroa:         value: Object.freeze(defaults),
Kode lerroa:         writable: false,
Kode lerroa:         enumerable: true,
Kode lerroa:         configurable: false
Kode lerroa:       });
Kode lerroa:       _this.prefs = (0, _ui_utils.cloneObj)(defaults);
Kode lerroa:       return _this._readFromStorage(defaults);
Kode lerroa:     }).then(function (prefObj) {
Kode lerroa:       if (prefObj) {
Kode lerroa:         _this.prefs = prefObj;
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(BasePreferences, [{
Kode lerroa:     key: "_writeToStorage",
Kode lerroa:     value: function _writeToStorage(prefObj) {
Kode lerroa:       return Promise.reject(new Error('Not implemented: _writeToStorage'));
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "_readFromStorage",
Kode lerroa:     value: function _readFromStorage(prefObj) {
Kode lerroa:       return Promise.reject(new Error('Not implemented: _readFromStorage'));
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "reset",
Kode lerroa:     value: function reset() {
Kode lerroa:       var _this2 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         _this2.prefs = (0, _ui_utils.cloneObj)(_this2.defaults);
Kode lerroa:         return _this2._writeToStorage(_this2.defaults);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "reload",
Kode lerroa:     value: function reload() {
Kode lerroa:       var _this3 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         return _this3._readFromStorage(_this3.defaults);
Kode lerroa:       }).then(function (prefObj) {
Kode lerroa:         if (prefObj) {
Kode lerroa:           _this3.prefs = prefObj;
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "set",
Kode lerroa:     value: function set(name, value) {
Kode lerroa:       var _this4 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         if (_this4.defaults[name] === undefined) {
Kode lerroa:           throw new Error("Set preference: \"" + name + "\" is undefined.");
Kode lerroa:         } else if (value === undefined) {
Kode lerroa:           throw new Error('Set preference: no value is specified.');
Kode lerroa:         }
Kode lerroa:         var valueType = typeof value === "undefined" ? "undefined" : _typeof(value);
Kode lerroa:         var defaultType = _typeof(_this4.defaults[name]);
Kode lerroa:         if (valueType !== defaultType) {
Kode lerroa:           if (valueType === 'number' && defaultType === 'string') {
Kode lerroa:             value = value.toString();
Kode lerroa:           } else {
Kode lerroa:             throw new Error("Set preference: \"" + value + "\" is a " + valueType + ", " + ("expected a " + defaultType + "."));
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           if (valueType === 'number' && !Number.isInteger(value)) {
Kode lerroa:             throw new Error("Set preference: \"" + value + "\" must be an integer.");
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         _this4.prefs[name] = value;
Kode lerroa:         return _this4._writeToStorage(_this4.prefs);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: "get",
Kode lerroa:     value: function get(name) {
Kode lerroa:       var _this5 = this;
Kode lerroa: 
Kode lerroa:       return this._initializedPromise.then(function () {
Kode lerroa:         var defaultValue = _this5.defaults[name];
Kode lerroa:         if (defaultValue === undefined) {
Kode lerroa:           throw new Error("Get preference: \"" + name + "\" is undefined.");
Kode lerroa:         } else {
Kode lerroa:           var prefValue = _this5.prefs[name];
Kode lerroa:           if (prefValue !== undefined) {
Kode lerroa:             return prefValue;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         return defaultValue;
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return BasePreferences;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.BasePreferences = BasePreferences;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 31 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.DownloadManager = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: ;
Kode lerroa: function _download(blobUrl, filename) {
Kode lerroa:   var a = document.createElement('a');
Kode lerroa:   if (a.click) {
Kode lerroa:     a.href = blobUrl;
Kode lerroa:     a.target = '_parent';
Kode lerroa:     if ('download' in a) {
Kode lerroa:       a.download = filename;
Kode lerroa:     }
Kode lerroa:     (document.body || document.documentElement).appendChild(a);
Kode lerroa:     a.click();
Kode lerroa:     a.parentNode.removeChild(a);
Kode lerroa:   } else {
Kode lerroa:     if (window.top === window && blobUrl.split('#')[0] === window.location.href.split('#')[0]) {
Kode lerroa:       var padCharacter = blobUrl.indexOf('?') === -1 ? '?' : '&';
Kode lerroa:       blobUrl = blobUrl.replace(/#|$/, padCharacter + '$&');
Kode lerroa:     }
Kode lerroa:     window.open(blobUrl, '_parent');
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var DownloadManager = function () {
Kode lerroa:   function DownloadManager() {
Kode lerroa:     _classCallCheck(this, DownloadManager);
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(DownloadManager, [{
Kode lerroa:     key: 'downloadUrl',
Kode lerroa:     value: function downloadUrl(url, filename) {
Kode lerroa:       if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, 'http://example.com')) {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       _download(url + '#pdfjs.action=download', filename);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'downloadData',
Kode lerroa:     value: function downloadData(data, filename, contentType) {
Kode lerroa:       if (navigator.msSaveBlob) {
Kode lerroa:         return navigator.msSaveBlob(new Blob([data], { type: contentType }), filename);
Kode lerroa:       }
Kode lerroa:       var blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, _pdfjsLib.PDFJS.disableCreateObjectURL);
Kode lerroa:       _download(blobUrl, filename);
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'download',
Kode lerroa:     value: function download(blob, url, filename) {
Kode lerroa:       if (navigator.msSaveBlob) {
Kode lerroa:         if (!navigator.msSaveBlob(blob, filename)) {
Kode lerroa:           this.downloadUrl(url, filename);
Kode lerroa:         }
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       if (_pdfjsLib.PDFJS.disableCreateObjectURL) {
Kode lerroa:         this.downloadUrl(url, filename);
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var blobUrl = URL.createObjectURL(blob);
Kode lerroa:       _download(blobUrl, filename);
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return DownloadManager;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.DownloadManager = DownloadManager;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 32 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.GenericL10n = undefined;
Kode lerroa: 
Kode lerroa: var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
Kode lerroa: 
Kode lerroa: __webpack_require__(33);
Kode lerroa: 
Kode lerroa: function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Kode lerroa: 
Kode lerroa: var webL10n = document.webL10n;
Kode lerroa: 
Kode lerroa: var GenericL10n = function () {
Kode lerroa:   function GenericL10n(lang) {
Kode lerroa:     _classCallCheck(this, GenericL10n);
Kode lerroa: 
Kode lerroa:     this._lang = lang;
Kode lerroa:     this._ready = new Promise(function (resolve, reject) {
Kode lerroa:       webL10n.setLanguage(lang, function () {
Kode lerroa:         resolve(webL10n);
Kode lerroa:       });
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   _createClass(GenericL10n, [{
Kode lerroa:     key: 'getDirection',
Kode lerroa:     value: function getDirection() {
Kode lerroa:       return this._ready.then(function (l10n) {
Kode lerroa:         return l10n.getDirection();
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'get',
Kode lerroa:     value: function get(property, args, fallback) {
Kode lerroa:       return this._ready.then(function (l10n) {
Kode lerroa:         return l10n.get(property, args, fallback);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }, {
Kode lerroa:     key: 'translate',
Kode lerroa:     value: function translate(element) {
Kode lerroa:       return this._ready.then(function (l10n) {
Kode lerroa:         return l10n.translate(element);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:   }]);
Kode lerroa: 
Kode lerroa:   return GenericL10n;
Kode lerroa: }();
Kode lerroa: 
Kode lerroa: exports.GenericL10n = GenericL10n;
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 33 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: document.webL10n = function (window, document, undefined) {
Kode lerroa:   var gL10nData = {};
Kode lerroa:   var gTextData = '';
Kode lerroa:   var gTextProp = 'textContent';
Kode lerroa:   var gLanguage = '';
Kode lerroa:   var gMacros = {};
Kode lerroa:   var gReadyState = 'loading';
Kode lerroa:   var gAsyncResourceLoading = true;
Kode lerroa:   function getL10nResourceLinks() {
Kode lerroa:     return document.querySelectorAll('link[type="application/l10n"]');
Kode lerroa:   }
Kode lerroa:   function getL10nDictionary() {
Kode lerroa:     var script = document.querySelector('script[type="application/l10n"]');
Kode lerroa:     return script ? JSON.parse(script.innerHTML) : null;
Kode lerroa:   }
Kode lerroa:   function getTranslatableChildren(element) {
Kode lerroa:     return element ? element.querySelectorAll('*[data-l10n-id]') : [];
Kode lerroa:   }
Kode lerroa:   function getL10nAttributes(element) {
Kode lerroa:     if (!element) return {};
Kode lerroa:     var l10nId = element.getAttribute('data-l10n-id');
Kode lerroa:     var l10nArgs = element.getAttribute('data-l10n-args');
Kode lerroa:     var args = {};
Kode lerroa:     if (l10nArgs) {
Kode lerroa:       try {
Kode lerroa:         args = JSON.parse(l10nArgs);
Kode lerroa:       } catch (e) {
Kode lerroa:         console.warn('could not parse arguments for #' + l10nId);
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       id: l10nId,
Kode lerroa:       args: args
Kode lerroa:     };
Kode lerroa:   }
Kode lerroa:   function fireL10nReadyEvent(lang) {
Kode lerroa:     var evtObject = document.createEvent('Event');
Kode lerroa:     evtObject.initEvent('localized', true, false);
Kode lerroa:     evtObject.language = lang;
Kode lerroa:     document.dispatchEvent(evtObject);
Kode lerroa:   }
Kode lerroa:   function xhrLoadText(url, onSuccess, onFailure) {
Kode lerroa:     onSuccess = onSuccess || function _onSuccess(data) {};
Kode lerroa:     onFailure = onFailure || function _onFailure() {};
Kode lerroa:     var xhr = new XMLHttpRequest();
Kode lerroa:     xhr.open('GET', url, gAsyncResourceLoading);
Kode lerroa:     if (xhr.overrideMimeType) {
Kode lerroa:       xhr.overrideMimeType('text/plain; charset=utf-8');
Kode lerroa:     }
Kode lerroa:     xhr.onreadystatechange = function () {
Kode lerroa:       if (xhr.readyState == 4) {
Kode lerroa:         if (xhr.status == 200 || xhr.status === 0) {
Kode lerroa:           onSuccess(xhr.responseText);
Kode lerroa:         } else {
Kode lerroa:           onFailure();
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     xhr.onerror = onFailure;
Kode lerroa:     xhr.ontimeout = onFailure;
Kode lerroa:     try {
Kode lerroa:       xhr.send(null);
Kode lerroa:     } catch (e) {
Kode lerroa:       onFailure();
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function parseResource(href, lang, successCallback, failureCallback) {
Kode lerroa:     var baseURL = href.replace(/[^\/]*$/, '') || './';
Kode lerroa:     function evalString(text) {
Kode lerroa:       if (text.lastIndexOf('\\') < 0) return text;
Kode lerroa:       return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
Kode lerroa:     }
Kode lerroa:     function parseProperties(text, parsedPropertiesCallback) {
Kode lerroa:       var dictionary = {};
Kode lerroa:       var reBlank = /^\s*|\s*$/;
Kode lerroa:       var reComment = /^\s*#|^\s*$/;
Kode lerroa:       var reSection = /^\s*\[(.*)\]\s*$/;
Kode lerroa:       var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
Kode lerroa:       var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;
Kode lerroa:       function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
Kode lerroa:         var entries = rawText.replace(reBlank, '').split(/[\r\n]+/);
Kode lerroa:         var currentLang = '*';
Kode lerroa:         var genericLang = lang.split('-', 1)[0];
Kode lerroa:         var skipLang = false;
Kode lerroa:         var match = '';
Kode lerroa:         function nextEntry() {
Kode lerroa:           while (true) {
Kode lerroa:             if (!entries.length) {
Kode lerroa:               parsedRawLinesCallback();
Kode lerroa:               return;
Kode lerroa:             }
Kode lerroa:             var line = entries.shift();
Kode lerroa:             if (reComment.test(line)) continue;
Kode lerroa:             if (extendedSyntax) {
Kode lerroa:               match = reSection.exec(line);
Kode lerroa:               if (match) {
Kode lerroa:                 currentLang = match[1].toLowerCase();
Kode lerroa:                 skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;
Kode lerroa:                 continue;
Kode lerroa:               } else if (skipLang) {
Kode lerroa:                 continue;
Kode lerroa:               }
Kode lerroa:               match = reImport.exec(line);
Kode lerroa:               if (match) {
Kode lerroa:                 loadImport(baseURL + match[1], nextEntry);
Kode lerroa:                 return;
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:             var tmp = line.match(reSplit);
Kode lerroa:             if (tmp && tmp.length == 3) {
Kode lerroa:               dictionary[tmp[1]] = evalString(tmp[2]);
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         nextEntry();
Kode lerroa:       }
Kode lerroa:       function loadImport(url, callback) {
Kode lerroa:         xhrLoadText(url, function (content) {
Kode lerroa:           parseRawLines(content, false, callback);
Kode lerroa:         }, function () {
Kode lerroa:           console.warn(url + ' not found.');
Kode lerroa:           callback();
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:       parseRawLines(text, true, function () {
Kode lerroa:         parsedPropertiesCallback(dictionary);
Kode lerroa:       });
Kode lerroa:     }
Kode lerroa:     xhrLoadText(href, function (response) {
Kode lerroa:       gTextData += response;
Kode lerroa:       parseProperties(response, function (data) {
Kode lerroa:         for (var key in data) {
Kode lerroa:           var id,
Kode lerroa:               prop,
Kode lerroa:               index = key.lastIndexOf('.');
Kode lerroa:           if (index > 0) {
Kode lerroa:             id = key.substring(0, index);
Kode lerroa:             prop = key.substr(index + 1);
Kode lerroa:           } else {
Kode lerroa:             id = key;
Kode lerroa:             prop = gTextProp;
Kode lerroa:           }
Kode lerroa:           if (!gL10nData[id]) {
Kode lerroa:             gL10nData[id] = {};
Kode lerroa:           }
Kode lerroa:           gL10nData[id][prop] = data[key];
Kode lerroa:         }
Kode lerroa:         if (successCallback) {
Kode lerroa:           successCallback();
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:     }, failureCallback);
Kode lerroa:   }
Kode lerroa:   function loadLocale(lang, callback) {
Kode lerroa:     if (lang) {
Kode lerroa:       lang = lang.toLowerCase();
Kode lerroa:     }
Kode lerroa:     callback = callback || function _callback() {};
Kode lerroa:     clear();
Kode lerroa:     gLanguage = lang;
Kode lerroa:     var langLinks = getL10nResourceLinks();
Kode lerroa:     var langCount = langLinks.length;
Kode lerroa:     if (langCount === 0) {
Kode lerroa:       var dict = getL10nDictionary();
Kode lerroa:       if (dict && dict.locales && dict.default_locale) {
Kode lerroa:         console.log('using the embedded JSON directory, early way out');
Kode lerroa:         gL10nData = dict.locales[lang];
Kode lerroa:         if (!gL10nData) {
Kode lerroa:           var defaultLocale = dict.default_locale.toLowerCase();
Kode lerroa:           for (var anyCaseLang in dict.locales) {
Kode lerroa:             anyCaseLang = anyCaseLang.toLowerCase();
Kode lerroa:             if (anyCaseLang === lang) {
Kode lerroa:               gL10nData = dict.locales[lang];
Kode lerroa:               break;
Kode lerroa:             } else if (anyCaseLang === defaultLocale) {
Kode lerroa:               gL10nData = dict.locales[defaultLocale];
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         callback();
Kode lerroa:       } else {
Kode lerroa:         console.log('no resource to load, early way out');
Kode lerroa:       }
Kode lerroa:       fireL10nReadyEvent(lang);
Kode lerroa:       gReadyState = 'complete';
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var onResourceLoaded = null;
Kode lerroa:     var gResourceCount = 0;
Kode lerroa:     onResourceLoaded = function onResourceLoaded() {
Kode lerroa:       gResourceCount++;
Kode lerroa:       if (gResourceCount >= langCount) {
Kode lerroa:         callback();
Kode lerroa:         fireL10nReadyEvent(lang);
Kode lerroa:         gReadyState = 'complete';
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     function L10nResourceLink(link) {
Kode lerroa:       var href = link.href;
Kode lerroa:       this.load = function (lang, callback) {
Kode lerroa:         parseResource(href, lang, callback, function () {
Kode lerroa:           console.warn(href + ' not found.');
Kode lerroa:           console.warn('"' + lang + '" resource not found');
Kode lerroa:           gLanguage = '';
Kode lerroa:           callback();
Kode lerroa:         });
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     for (var i = 0; i < langCount; i++) {
Kode lerroa:       var resource = new L10nResourceLink(langLinks[i]);
Kode lerroa:       resource.load(lang, onResourceLoaded);
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function clear() {
Kode lerroa:     gL10nData = {};
Kode lerroa:     gTextData = '';
Kode lerroa:     gLanguage = '';
Kode lerroa:   }
Kode lerroa:   function getPluralRules(lang) {
Kode lerroa:     var locales2rules = {
Kode lerroa:       'af': 3,
Kode lerroa:       'ak': 4,
Kode lerroa:       'am': 4,
Kode lerroa:       'ar': 1,
Kode lerroa:       'asa': 3,
Kode lerroa:       'az': 0,
Kode lerroa:       'be': 11,
Kode lerroa:       'bem': 3,
Kode lerroa:       'bez': 3,
Kode lerroa:       'bg': 3,
Kode lerroa:       'bh': 4,
Kode lerroa:       'bm': 0,
Kode lerroa:       'bn': 3,
Kode lerroa:       'bo': 0,
Kode lerroa:       'br': 20,
Kode lerroa:       'brx': 3,
Kode lerroa:       'bs': 11,
Kode lerroa:       'ca': 3,
Kode lerroa:       'cgg': 3,
Kode lerroa:       'chr': 3,
Kode lerroa:       'cs': 12,
Kode lerroa:       'cy': 17,
Kode lerroa:       'da': 3,
Kode lerroa:       'de': 3,
Kode lerroa:       'dv': 3,
Kode lerroa:       'dz': 0,
Kode lerroa:       'ee': 3,
Kode lerroa:       'el': 3,
Kode lerroa:       'en': 3,
Kode lerroa:       'eo': 3,
Kode lerroa:       'es': 3,
Kode lerroa:       'et': 3,
Kode lerroa:       'eu': 3,
Kode lerroa:       'fa': 0,
Kode lerroa:       'ff': 5,
Kode lerroa:       'fi': 3,
Kode lerroa:       'fil': 4,
Kode lerroa:       'fo': 3,
Kode lerroa:       'fr': 5,
Kode lerroa:       'fur': 3,
Kode lerroa:       'fy': 3,
Kode lerroa:       'ga': 8,
Kode lerroa:       'gd': 24,
Kode lerroa:       'gl': 3,
Kode lerroa:       'gsw': 3,
Kode lerroa:       'gu': 3,
Kode lerroa:       'guw': 4,
Kode lerroa:       'gv': 23,
Kode lerroa:       'ha': 3,
Kode lerroa:       'haw': 3,
Kode lerroa:       'he': 2,
Kode lerroa:       'hi': 4,
Kode lerroa:       'hr': 11,
Kode lerroa:       'hu': 0,
Kode lerroa:       'id': 0,
Kode lerroa:       'ig': 0,
Kode lerroa:       'ii': 0,
Kode lerroa:       'is': 3,
Kode lerroa:       'it': 3,
Kode lerroa:       'iu': 7,
Kode lerroa:       'ja': 0,
Kode lerroa:       'jmc': 3,
Kode lerroa:       'jv': 0,
Kode lerroa:       'ka': 0,
Kode lerroa:       'kab': 5,
Kode lerroa:       'kaj': 3,
Kode lerroa:       'kcg': 3,
Kode lerroa:       'kde': 0,
Kode lerroa:       'kea': 0,
Kode lerroa:       'kk': 3,
Kode lerroa:       'kl': 3,
Kode lerroa:       'km': 0,
Kode lerroa:       'kn': 0,
Kode lerroa:       'ko': 0,
Kode lerroa:       'ksb': 3,
Kode lerroa:       'ksh': 21,
Kode lerroa:       'ku': 3,
Kode lerroa:       'kw': 7,
Kode lerroa:       'lag': 18,
Kode lerroa:       'lb': 3,
Kode lerroa:       'lg': 3,
Kode lerroa:       'ln': 4,
Kode lerroa:       'lo': 0,
Kode lerroa:       'lt': 10,
Kode lerroa:       'lv': 6,
Kode lerroa:       'mas': 3,
Kode lerroa:       'mg': 4,
Kode lerroa:       'mk': 16,
Kode lerroa:       'ml': 3,
Kode lerroa:       'mn': 3,
Kode lerroa:       'mo': 9,
Kode lerroa:       'mr': 3,
Kode lerroa:       'ms': 0,
Kode lerroa:       'mt': 15,
Kode lerroa:       'my': 0,
Kode lerroa:       'nah': 3,
Kode lerroa:       'naq': 7,
Kode lerroa:       'nb': 3,
Kode lerroa:       'nd': 3,
Kode lerroa:       'ne': 3,
Kode lerroa:       'nl': 3,
Kode lerroa:       'nn': 3,
Kode lerroa:       'no': 3,
Kode lerroa:       'nr': 3,
Kode lerroa:       'nso': 4,
Kode lerroa:       'ny': 3,
Kode lerroa:       'nyn': 3,
Kode lerroa:       'om': 3,
Kode lerroa:       'or': 3,
Kode lerroa:       'pa': 3,
Kode lerroa:       'pap': 3,
Kode lerroa:       'pl': 13,
Kode lerroa:       'ps': 3,
Kode lerroa:       'pt': 3,
Kode lerroa:       'rm': 3,
Kode lerroa:       'ro': 9,
Kode lerroa:       'rof': 3,
Kode lerroa:       'ru': 11,
Kode lerroa:       'rwk': 3,
Kode lerroa:       'sah': 0,
Kode lerroa:       'saq': 3,
Kode lerroa:       'se': 7,
Kode lerroa:       'seh': 3,
Kode lerroa:       'ses': 0,
Kode lerroa:       'sg': 0,
Kode lerroa:       'sh': 11,
Kode lerroa:       'shi': 19,
Kode lerroa:       'sk': 12,
Kode lerroa:       'sl': 14,
Kode lerroa:       'sma': 7,
Kode lerroa:       'smi': 7,
Kode lerroa:       'smj': 7,
Kode lerroa:       'smn': 7,
Kode lerroa:       'sms': 7,
Kode lerroa:       'sn': 3,
Kode lerroa:       'so': 3,
Kode lerroa:       'sq': 3,
Kode lerroa:       'sr': 11,
Kode lerroa:       'ss': 3,
Kode lerroa:       'ssy': 3,
Kode lerroa:       'st': 3,
Kode lerroa:       'sv': 3,
Kode lerroa:       'sw': 3,
Kode lerroa:       'syr': 3,
Kode lerroa:       'ta': 3,
Kode lerroa:       'te': 3,
Kode lerroa:       'teo': 3,
Kode lerroa:       'th': 0,
Kode lerroa:       'ti': 4,
Kode lerroa:       'tig': 3,
Kode lerroa:       'tk': 3,
Kode lerroa:       'tl': 4,
Kode lerroa:       'tn': 3,
Kode lerroa:       'to': 0,
Kode lerroa:       'tr': 0,
Kode lerroa:       'ts': 3,
Kode lerroa:       'tzm': 22,
Kode lerroa:       'uk': 11,
Kode lerroa:       'ur': 3,
Kode lerroa:       've': 3,
Kode lerroa:       'vi': 0,
Kode lerroa:       'vun': 3,
Kode lerroa:       'wa': 4,
Kode lerroa:       'wae': 3,
Kode lerroa:       'wo': 0,
Kode lerroa:       'xh': 3,
Kode lerroa:       'xog': 3,
Kode lerroa:       'yo': 0,
Kode lerroa:       'zh': 0,
Kode lerroa:       'zu': 3
Kode lerroa:     };
Kode lerroa:     function isIn(n, list) {
Kode lerroa:       return list.indexOf(n) !== -1;
Kode lerroa:     }
Kode lerroa:     function isBetween(n, start, end) {
Kode lerroa:       return start <= n && n <= end;
Kode lerroa:     }
Kode lerroa:     var pluralRules = {
Kode lerroa:       '0': function _(n) {
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '1': function _(n) {
Kode lerroa:         if (isBetween(n % 100, 3, 10)) return 'few';
Kode lerroa:         if (n === 0) return 'zero';
Kode lerroa:         if (isBetween(n % 100, 11, 99)) return 'many';
Kode lerroa:         if (n == 2) return 'two';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '2': function _(n) {
Kode lerroa:         if (n !== 0 && n % 10 === 0) return 'many';
Kode lerroa:         if (n == 2) return 'two';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '3': function _(n) {
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '4': function _(n) {
Kode lerroa:         if (isBetween(n, 0, 1)) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '5': function _(n) {
Kode lerroa:         if (isBetween(n, 0, 2) && n != 2) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '6': function _(n) {
Kode lerroa:         if (n === 0) return 'zero';
Kode lerroa:         if (n % 10 == 1 && n % 100 != 11) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '7': function _(n) {
Kode lerroa:         if (n == 2) return 'two';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '8': function _(n) {
Kode lerroa:         if (isBetween(n, 3, 6)) return 'few';
Kode lerroa:         if (isBetween(n, 7, 10)) return 'many';
Kode lerroa:         if (n == 2) return 'two';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '9': function _(n) {
Kode lerroa:         if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '10': function _(n) {
Kode lerroa:         if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';
Kode lerroa:         if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '11': function _(n) {
Kode lerroa:         if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
Kode lerroa:         if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';
Kode lerroa:         if (n % 10 == 1 && n % 100 != 11) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '12': function _(n) {
Kode lerroa:         if (isBetween(n, 2, 4)) return 'few';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '13': function _(n) {
Kode lerroa:         if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
Kode lerroa:         if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '14': function _(n) {
Kode lerroa:         if (isBetween(n % 100, 3, 4)) return 'few';
Kode lerroa:         if (n % 100 == 2) return 'two';
Kode lerroa:         if (n % 100 == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '15': function _(n) {
Kode lerroa:         if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';
Kode lerroa:         if (isBetween(n % 100, 11, 19)) return 'many';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '16': function _(n) {
Kode lerroa:         if (n % 10 == 1 && n != 11) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '17': function _(n) {
Kode lerroa:         if (n == 3) return 'few';
Kode lerroa:         if (n === 0) return 'zero';
Kode lerroa:         if (n == 6) return 'many';
Kode lerroa:         if (n == 2) return 'two';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '18': function _(n) {
Kode lerroa:         if (n === 0) return 'zero';
Kode lerroa:         if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '19': function _(n) {
Kode lerroa:         if (isBetween(n, 2, 10)) return 'few';
Kode lerroa:         if (isBetween(n, 0, 1)) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '20': function _(n) {
Kode lerroa:         if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';
Kode lerroa:         if (n % 1000000 === 0 && n !== 0) return 'many';
Kode lerroa:         if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';
Kode lerroa:         if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '21': function _(n) {
Kode lerroa:         if (n === 0) return 'zero';
Kode lerroa:         if (n == 1) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '22': function _(n) {
Kode lerroa:         if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '23': function _(n) {
Kode lerroa:         if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       },
Kode lerroa:       '24': function _(n) {
Kode lerroa:         if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';
Kode lerroa:         if (isIn(n, [2, 12])) return 'two';
Kode lerroa:         if (isIn(n, [1, 11])) return 'one';
Kode lerroa:         return 'other';
Kode lerroa:       }
Kode lerroa:     };
Kode lerroa:     var index = locales2rules[lang.replace(/-.*$/, '')];
Kode lerroa:     if (!(index in pluralRules)) {
Kode lerroa:       console.warn('plural form unknown for [' + lang + ']');
Kode lerroa:       return function () {
Kode lerroa:         return 'other';
Kode lerroa:       };
Kode lerroa:     }
Kode lerroa:     return pluralRules[index];
Kode lerroa:   }
Kode lerroa:   gMacros.plural = function (str, param, key, prop) {
Kode lerroa:     var n = parseFloat(param);
Kode lerroa:     if (isNaN(n)) return str;
Kode lerroa:     if (prop != gTextProp) return str;
Kode lerroa:     if (!gMacros._pluralRules) {
Kode lerroa:       gMacros._pluralRules = getPluralRules(gLanguage);
Kode lerroa:     }
Kode lerroa:     var index = '[' + gMacros._pluralRules(n) + ']';
Kode lerroa:     if (n === 0 && key + '[zero]' in gL10nData) {
Kode lerroa:       str = gL10nData[key + '[zero]'][prop];
Kode lerroa:     } else if (n == 1 && key + '[one]' in gL10nData) {
Kode lerroa:       str = gL10nData[key + '[one]'][prop];
Kode lerroa:     } else if (n == 2 && key + '[two]' in gL10nData) {
Kode lerroa:       str = gL10nData[key + '[two]'][prop];
Kode lerroa:     } else if (key + index in gL10nData) {
Kode lerroa:       str = gL10nData[key + index][prop];
Kode lerroa:     } else if (key + '[other]' in gL10nData) {
Kode lerroa:       str = gL10nData[key + '[other]'][prop];
Kode lerroa:     }
Kode lerroa:     return str;
Kode lerroa:   };
Kode lerroa:   function getL10nData(key, args, fallback) {
Kode lerroa:     var data = gL10nData[key];
Kode lerroa:     if (!data) {
Kode lerroa:       console.warn('#' + key + ' is undefined.');
Kode lerroa:       if (!fallback) {
Kode lerroa:         return null;
Kode lerroa:       }
Kode lerroa:       data = fallback;
Kode lerroa:     }
Kode lerroa:     var rv = {};
Kode lerroa:     for (var prop in data) {
Kode lerroa:       var str = data[prop];
Kode lerroa:       str = substIndexes(str, args, key, prop);
Kode lerroa:       str = substArguments(str, args, key);
Kode lerroa:       rv[prop] = str;
Kode lerroa:     }
Kode lerroa:     return rv;
Kode lerroa:   }
Kode lerroa:   function substIndexes(str, args, key, prop) {
Kode lerroa:     var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
Kode lerroa:     var reMatch = reIndex.exec(str);
Kode lerroa:     if (!reMatch || !reMatch.length) return str;
Kode lerroa:     var macroName = reMatch[1];
Kode lerroa:     var paramName = reMatch[2];
Kode lerroa:     var param;
Kode lerroa:     if (args && paramName in args) {
Kode lerroa:       param = args[paramName];
Kode lerroa:     } else if (paramName in gL10nData) {
Kode lerroa:       param = gL10nData[paramName];
Kode lerroa:     }
Kode lerroa:     if (macroName in gMacros) {
Kode lerroa:       var macro = gMacros[macroName];
Kode lerroa:       str = macro(str, param, key, prop);
Kode lerroa:     }
Kode lerroa:     return str;
Kode lerroa:   }
Kode lerroa:   function substArguments(str, args, key) {
Kode lerroa:     var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
Kode lerroa:     return str.replace(reArgs, function (matched_text, arg) {
Kode lerroa:       if (args && arg in args) {
Kode lerroa:         return args[arg];
Kode lerroa:       }
Kode lerroa:       if (arg in gL10nData) {
Kode lerroa:         return gL10nData[arg];
Kode lerroa:       }
Kode lerroa:       console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');
Kode lerroa:       return matched_text;
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa:   function translateElement(element) {
Kode lerroa:     var l10n = getL10nAttributes(element);
Kode lerroa:     if (!l10n.id) return;
Kode lerroa:     var data = getL10nData(l10n.id, l10n.args);
Kode lerroa:     if (!data) {
Kode lerroa:       console.warn('#' + l10n.id + ' is undefined.');
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     if (data[gTextProp]) {
Kode lerroa:       if (getChildElementCount(element) === 0) {
Kode lerroa:         element[gTextProp] = data[gTextProp];
Kode lerroa:       } else {
Kode lerroa:         var children = element.childNodes;
Kode lerroa:         var found = false;
Kode lerroa:         for (var i = 0, l = children.length; i < l; i++) {
Kode lerroa:           if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
Kode lerroa:             if (found) {
Kode lerroa:               children[i].nodeValue = '';
Kode lerroa:             } else {
Kode lerroa:               children[i].nodeValue = data[gTextProp];
Kode lerroa:               found = true;
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (!found) {
Kode lerroa:           var textNode = document.createTextNode(data[gTextProp]);
Kode lerroa:           element.insertBefore(textNode, element.firstChild);
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       delete data[gTextProp];
Kode lerroa:     }
Kode lerroa:     for (var k in data) {
Kode lerroa:       element[k] = data[k];
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   function getChildElementCount(element) {
Kode lerroa:     if (element.children) {
Kode lerroa:       return element.children.length;
Kode lerroa:     }
Kode lerroa:     if (typeof element.childElementCount !== 'undefined') {
Kode lerroa:       return element.childElementCount;
Kode lerroa:     }
Kode lerroa:     var count = 0;
Kode lerroa:     for (var i = 0; i < element.childNodes.length; i++) {
Kode lerroa:       count += element.nodeType === 1 ? 1 : 0;
Kode lerroa:     }
Kode lerroa:     return count;
Kode lerroa:   }
Kode lerroa:   function translateFragment(element) {
Kode lerroa:     element = element || document.documentElement;
Kode lerroa:     var children = getTranslatableChildren(element);
Kode lerroa:     var elementCount = children.length;
Kode lerroa:     for (var i = 0; i < elementCount; i++) {
Kode lerroa:       translateElement(children[i]);
Kode lerroa:     }
Kode lerroa:     translateElement(element);
Kode lerroa:   }
Kode lerroa:   return {
Kode lerroa:     get: function get(key, args, fallbackString) {
Kode lerroa:       var index = key.lastIndexOf('.');
Kode lerroa:       var prop = gTextProp;
Kode lerroa:       if (index > 0) {
Kode lerroa:         prop = key.substr(index + 1);
Kode lerroa:         key = key.substring(0, index);
Kode lerroa:       }
Kode lerroa:       var fallback;
Kode lerroa:       if (fallbackString) {
Kode lerroa:         fallback = {};
Kode lerroa:         fallback[prop] = fallbackString;
Kode lerroa:       }
Kode lerroa:       var data = getL10nData(key, args, fallback);
Kode lerroa:       if (data && prop in data) {
Kode lerroa:         return data[prop];
Kode lerroa:       }
Kode lerroa:       return '{{' + key + '}}';
Kode lerroa:     },
Kode lerroa:     getData: function getData() {
Kode lerroa:       return gL10nData;
Kode lerroa:     },
Kode lerroa:     getText: function getText() {
Kode lerroa:       return gTextData;
Kode lerroa:     },
Kode lerroa:     getLanguage: function getLanguage() {
Kode lerroa:       return gLanguage;
Kode lerroa:     },
Kode lerroa:     setLanguage: function setLanguage(lang, callback) {
Kode lerroa:       loadLocale(lang, function () {
Kode lerroa:         if (callback) callback();
Kode lerroa:       });
Kode lerroa:     },
Kode lerroa:     getDirection: function getDirection() {
Kode lerroa:       var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];
Kode lerroa:       var shortCode = gLanguage.split('-', 1)[0];
Kode lerroa:       return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';
Kode lerroa:     },
Kode lerroa:     translate: translateFragment,
Kode lerroa:     getReadyState: function getReadyState() {
Kode lerroa:       return gReadyState;
Kode lerroa:     },
Kode lerroa:     ready: function ready(callback) {
Kode lerroa:       if (!callback) {
Kode lerroa:         return;
Kode lerroa:       } else if (gReadyState == 'complete' || gReadyState == 'interactive') {
Kode lerroa:         window.setTimeout(function () {
Kode lerroa:           callback();
Kode lerroa:         });
Kode lerroa:       } else if (document.addEventListener) {
Kode lerroa:         document.addEventListener('localized', function once() {
Kode lerroa:           document.removeEventListener('localized', once);
Kode lerroa:           callback();
Kode lerroa:         });
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa: }(window, document);
Kode lerroa: 
Kode lerroa: /***/ }),
Kode lerroa: /* 34 */
Kode lerroa: /***/ (function(module, exports, __webpack_require__) {
Kode lerroa: 
Kode lerroa: "use strict";
Kode lerroa: 
Kode lerroa: 
Kode lerroa: Object.defineProperty(exports, "__esModule", {
Kode lerroa:   value: true
Kode lerroa: });
Kode lerroa: exports.PDFPrintService = undefined;
Kode lerroa: 
Kode lerroa: var _ui_utils = __webpack_require__(0);
Kode lerroa: 
Kode lerroa: var _app = __webpack_require__(4);
Kode lerroa: 
Kode lerroa: var _pdfjsLib = __webpack_require__(1);
Kode lerroa: 
Kode lerroa: var activeService = null;
Kode lerroa: var overlayManager = null;
Kode lerroa: function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size) {
Kode lerroa:   var scratchCanvas = activeService.scratchCanvas;
Kode lerroa:   var PRINT_RESOLUTION = 150;
Kode lerroa:   var PRINT_UNITS = PRINT_RESOLUTION / 72.0;
Kode lerroa:   scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);
Kode lerroa:   scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);
Kode lerroa:   var width = Math.floor(size.width * _ui_utils.CSS_UNITS) + 'px';
Kode lerroa:   var height = Math.floor(size.height * _ui_utils.CSS_UNITS) + 'px';
Kode lerroa:   var ctx = scratchCanvas.getContext('2d');
Kode lerroa:   ctx.save();
Kode lerroa:   ctx.fillStyle = 'rgb(255, 255, 255)';
Kode lerroa:   ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
Kode lerroa:   ctx.restore();
Kode lerroa:   return pdfDocument.getPage(pageNumber).then(function (pdfPage) {
Kode lerroa:     var renderContext = {
Kode lerroa:       canvasContext: ctx,
Kode lerroa:       transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],
Kode lerroa:       viewport: pdfPage.getViewport(1, size.rotation),
Kode lerroa:       intent: 'print'
Kode lerroa:     };
Kode lerroa:     return pdfPage.render(renderContext).promise;
Kode lerroa:   }).then(function () {
Kode lerroa:     return {
Kode lerroa:       width: width,
Kode lerroa:       height: height
Kode lerroa:     };
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: function PDFPrintService(pdfDocument, pagesOverview, printContainer, l10n) {
Kode lerroa:   this.pdfDocument = pdfDocument;
Kode lerroa:   this.pagesOverview = pagesOverview;
Kode lerroa:   this.printContainer = printContainer;
Kode lerroa:   this.l10n = l10n || _ui_utils.NullL10n;
Kode lerroa:   this.currentPage = -1;
Kode lerroa:   this.scratchCanvas = document.createElement('canvas');
Kode lerroa: }
Kode lerroa: PDFPrintService.prototype = {
Kode lerroa:   layout: function layout() {
Kode lerroa:     this.throwIfInactive();
Kode lerroa:     var body = document.querySelector('body');
Kode lerroa:     body.setAttribute('data-pdfjsprinting', true);
Kode lerroa:     var hasEqualPageSizes = this.pagesOverview.every(function (size) {
Kode lerroa:       return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;
Kode lerroa:     }, this);
Kode lerroa:     if (!hasEqualPageSizes) {
Kode lerroa:       console.warn('Not all pages have the same size. The printed ' + 'result may be incorrect!');
Kode lerroa:     }
Kode lerroa:     this.pageStyleSheet = document.createElement('style');
Kode lerroa:     var pageSize = this.pagesOverview[0];
Kode lerroa:     this.pageStyleSheet.textContent = '@supports ((size:A4) and (size:1pt 1pt)) {' + '@page { size: ' + pageSize.width + 'pt ' + pageSize.height + 'pt;}' + '}';
Kode lerroa:     body.appendChild(this.pageStyleSheet);
Kode lerroa:   },
Kode lerroa:   destroy: function destroy() {
Kode lerroa:     if (activeService !== this) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     this.printContainer.textContent = '';
Kode lerroa:     if (this.pageStyleSheet && this.pageStyleSheet.parentNode) {
Kode lerroa:       this.pageStyleSheet.parentNode.removeChild(this.pageStyleSheet);
Kode lerroa:       this.pageStyleSheet = null;
Kode lerroa:     }
Kode lerroa:     this.scratchCanvas.width = this.scratchCanvas.height = 0;
Kode lerroa:     this.scratchCanvas = null;
Kode lerroa:     activeService = null;
Kode lerroa:     ensureOverlay().then(function () {
Kode lerroa:       if (overlayManager.active !== 'printServiceOverlay') {
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       overlayManager.close('printServiceOverlay');
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   renderPages: function renderPages() {
Kode lerroa:     var _this = this;
Kode lerroa: 
Kode lerroa:     var pageCount = this.pagesOverview.length;
Kode lerroa:     var renderNextPage = function renderNextPage(resolve, reject) {
Kode lerroa:       _this.throwIfInactive();
Kode lerroa:       if (++_this.currentPage >= pageCount) {
Kode lerroa:         renderProgress(pageCount, pageCount, _this.l10n);
Kode lerroa:         resolve();
Kode lerroa:         return;
Kode lerroa:       }
Kode lerroa:       var index = _this.currentPage;
Kode lerroa:       renderProgress(index, pageCount, _this.l10n);
Kode lerroa:       renderPage(_this, _this.pdfDocument, index + 1, _this.pagesOverview[index]).then(_this.useRenderedPage.bind(_this)).then(function () {
Kode lerroa:         renderNextPage(resolve, reject);
Kode lerroa:       }, reject);
Kode lerroa:     };
Kode lerroa:     return new Promise(renderNextPage);
Kode lerroa:   },
Kode lerroa:   useRenderedPage: function useRenderedPage(printItem) {
Kode lerroa:     this.throwIfInactive();
Kode lerroa:     var img = document.createElement('img');
Kode lerroa:     img.style.width = printItem.width;
Kode lerroa:     img.style.height = printItem.height;
Kode lerroa:     var scratchCanvas = this.scratchCanvas;
Kode lerroa:     if ('toBlob' in scratchCanvas && !_pdfjsLib.PDFJS.disableCreateObjectURL) {
Kode lerroa:       scratchCanvas.toBlob(function (blob) {
Kode lerroa:         img.src = URL.createObjectURL(blob);
Kode lerroa:       });
Kode lerroa:     } else {
Kode lerroa:       img.src = scratchCanvas.toDataURL();
Kode lerroa:     }
Kode lerroa:     var wrapper = document.createElement('div');
Kode lerroa:     wrapper.appendChild(img);
Kode lerroa:     this.printContainer.appendChild(wrapper);
Kode lerroa:     return new Promise(function (resolve, reject) {
Kode lerroa:       img.onload = resolve;
Kode lerroa:       img.onerror = reject;
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa:   performPrint: function performPrint() {
Kode lerroa:     var _this2 = this;
Kode lerroa: 
Kode lerroa:     this.throwIfInactive();
Kode lerroa:     return new Promise(function (resolve) {
Kode lerroa:       setTimeout(function () {
Kode lerroa:         if (!_this2.active) {
Kode lerroa:           resolve();
Kode lerroa:           return;
Kode lerroa:         }
Kode lerroa:         print.call(window);
Kode lerroa:         setTimeout(resolve, 20);
Kode lerroa:       }, 0);
Kode lerroa:     });
Kode lerroa:   },
Kode lerroa: 
Kode lerroa:   get active() {
Kode lerroa:     return this === activeService;
Kode lerroa:   },
Kode lerroa:   throwIfInactive: function throwIfInactive() {
Kode lerroa:     if (!this.active) {
Kode lerroa:       throw new Error('This print request was cancelled or completed.');
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: var print = window.print;
Kode lerroa: window.print = function print() {
Kode lerroa:   if (activeService) {
Kode lerroa:     console.warn('Ignored window.print() because of a pending print job.');
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa:   ensureOverlay().then(function () {
Kode lerroa:     if (activeService) {
Kode lerroa:       overlayManager.open('printServiceOverlay');
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa:   try {
Kode lerroa:     dispatchEvent('beforeprint');
Kode lerroa:   } finally {
Kode lerroa:     if (!activeService) {
Kode lerroa:       console.error('Expected print service to be initialized.');
Kode lerroa:       ensureOverlay().then(function () {
Kode lerroa:         if (overlayManager.active === 'printServiceOverlay') {
Kode lerroa:           overlayManager.close('printServiceOverlay');
Kode lerroa:         }
Kode lerroa:       });
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     var activeServiceOnEntry = activeService;
Kode lerroa:     activeService.renderPages().then(function () {
Kode lerroa:       return activeServiceOnEntry.performPrint();
Kode lerroa:     }).catch(function () {}).then(function () {
Kode lerroa:       if (activeServiceOnEntry.active) {
Kode lerroa:         abort();
Kode lerroa:       }
Kode lerroa:     });
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: function dispatchEvent(eventType) {
Kode lerroa:   var event = document.createEvent('CustomEvent');
Kode lerroa:   event.initCustomEvent(eventType, false, false, 'custom');
Kode lerroa:   window.dispatchEvent(event);
Kode lerroa: }
Kode lerroa: function abort() {
Kode lerroa:   if (activeService) {
Kode lerroa:     activeService.destroy();
Kode lerroa:     dispatchEvent('afterprint');
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: function renderProgress(index, total, l10n) {
Kode lerroa:   var progressContainer = document.getElementById('printServiceOverlay');
Kode lerroa:   var progress = Math.round(100 * index / total);
Kode lerroa:   var progressBar = progressContainer.querySelector('progress');
Kode lerroa:   var progressPerc = progressContainer.querySelector('.relative-progress');
Kode lerroa:   progressBar.value = progress;
Kode lerroa:   l10n.get('print_progress_percent', { progress: progress }, progress + '%').then(function (msg) {
Kode lerroa:     progressPerc.textContent = msg;
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: var hasAttachEvent = !!document.attachEvent;
Kode lerroa: window.addEventListener('keydown', function (event) {
Kode lerroa:   if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) {
Kode lerroa:     window.print();
Kode lerroa:     if (hasAttachEvent) {
Kode lerroa:       return;
Kode lerroa:     }
Kode lerroa:     event.preventDefault();
Kode lerroa:     if (event.stopImmediatePropagation) {
Kode lerroa:       event.stopImmediatePropagation();
Kode lerroa:     } else {
Kode lerroa:       event.stopPropagation();
Kode lerroa:     }
Kode lerroa:     return;
Kode lerroa:   }
Kode lerroa: }, true);
Kode lerroa: if (hasAttachEvent) {
Kode lerroa:   document.attachEvent('onkeydown', function (event) {
Kode lerroa:     event = event || window.event;
Kode lerroa:     if (event.keyCode === 80 && event.ctrlKey) {
Kode lerroa:       event.keyCode = 0;
Kode lerroa:       return false;
Kode lerroa:     }
Kode lerroa:   });
Kode lerroa: }
Kode lerroa: if ('onbeforeprint' in window) {
Kode lerroa:   var stopPropagationIfNeeded = function stopPropagationIfNeeded(event) {
Kode lerroa:     if (event.detail !== 'custom' && event.stopImmediatePropagation) {
Kode lerroa:       event.stopImmediatePropagation();
Kode lerroa:     }
Kode lerroa:   };
Kode lerroa:   window.addEventListener('beforeprint', stopPropagationIfNeeded);
Kode lerroa:   window.addEventListener('afterprint', stopPropagationIfNeeded);
Kode lerroa: }
Kode lerroa: var overlayPromise = void 0;
Kode lerroa: function ensureOverlay() {
Kode lerroa:   if (!overlayPromise) {
Kode lerroa:     overlayManager = _app.PDFViewerApplication.overlayManager;
Kode lerroa:     if (!overlayManager) {
Kode lerroa:       throw new Error('The overlay manager has not yet been initialized.');
Kode lerroa:     }
Kode lerroa:     overlayPromise = overlayManager.register('printServiceOverlay', document.getElementById('printServiceOverlay'), abort, true);
Kode lerroa:     document.getElementById('printCancel').onclick = abort;
Kode lerroa:   }
Kode lerroa:   return overlayPromise;
Kode lerroa: }
Kode lerroa: _app.PDFPrintServiceFactory.instance = {
Kode lerroa:   supportsPrinting: true,
Kode lerroa:   createPrintService: function createPrintService(pdfDocument, pagesOverview, printContainer, l10n) {
Kode lerroa:     if (activeService) {
Kode lerroa:       throw new Error('The print service is created and active.');
Kode lerroa:     }
Kode lerroa:     activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, l10n);
Kode lerroa:     return activeService;
Kode lerroa:   }
Kode lerroa: };
Kode lerroa: exports.PDFPrintService = PDFPrintService;
Kode lerroa: 
Kode lerroa: /***/ })
Kode lerroa: /******/ ]);
Kode lerroa: //# sourceMappingURL=viewer.js.map
Kode lerroa: <!DOCTYPE html>
Kode lerroa: <html>
Kode lerroa: <head>
Kode lerroa:   <link rel="stylesheet" href="../../styles/contentScript.css"/>
Kode lerroa: </head>
Kode lerroa:   <body>
Kode lerroa:   <pre style="font-size: 200%"></pre>
Kode lerroa:   <script src="./index.js"></script>
Kode lerroa:   <script src="../../scripts/contentScript.js"></script>
Kode lerroa:   </body>
Kode lerroa: </html>
Kode lerroa: (() => {
Kode lerroa:   let fileToLoad = (new URL(document.location)).searchParams.get('file')
Kode lerroa: 
Kode lerroa:   function reqListener () {
Kode lerroa:     document.querySelector('pre').innerText = this.responseText
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   let oReq = new XMLHttpRequest()
Kode lerroa:   oReq.addEventListener('load', reqListener)
Kode lerroa:   oReq.open('GET', fileToLoad)
Kode lerroa:   oReq.send()
Kode lerroa: })()
Kode lerroa: <div id="groupSelectorContainer">
Kode lerroa:   // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa: </div>
Kode lerroa: <div id="abwaSidebarWrapper">
Kode lerroa:   <div id="abwaBucketBar"></div>
Kode lerroa:   <div id="abwaSidebarContainer">
Kode lerroa: 
Kode lerroa:   </div>
Kode lerroa:   <button id="abwaSidebarButton" data-toggled="false">
Kode lerroa:     <span class="abwaSidebarButtonIconBar"></span>
Kode lerroa:     <span class="abwaSidebarButtonIconBar"></span>
Kode lerroa:     <span class="abwaSidebarButtonIconBar"></span>
Kode lerroa:   </button>
Kode lerroa: </div>
Kode lerroa: <div id="tagsWrapper"  class="sidebarContainer">
Kode lerroa:   <div id="buttonContainer" class="bodyContainer">
Kode lerroa:   </div>
Kode lerroa: </div>
Kode lerroa: <div id="toolset" class="sidebarContainer" aria-hidden="true">
Kode lerroa:   <div id="toolsetHeader" class="containerHeader">
Kode lerroa:     PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appName'))
Kode lerroa:   </div>
Kode lerroa:   <div id="toolsetBody" class="bodyContainer"></div>
Kode lerroa:   <template id="toolsetButtonTemplate">
Kode lerroa:     <img type="button" class="toolButton" title="Toolset button"/>
Kode lerroa:   </template>
Kode lerroa: </div>
Kode lerroa: <div id="userFilterWrapper" class="sidebarContainer">
Kode lerroa:   <template id="userFilterTemplate">
Kode lerroa:     <div id="" class="filter">
Kode lerroa:       <input type="checkbox" class="userFilterCheckbox"/>
Kode lerroa:       <label for="" class="userFilterLabel"></label>
Kode lerroa:     </div>
Kode lerroa:   </template>
Kode lerroa:   <div id="modeHeader" class="containerHeader">
Kode lerroa:     <label>Reviewers</label>
Kode lerroa:   </div>
Kode lerroa:   <div id="userFilterContainer" class="bodyContainer">
Kode lerroa:     <div class="filter" data-user-all="true">
Kode lerroa:       <input id="userFilter_all" type="checkbox"/>
Kode lerroa:       <label for="userFilter_all">All</label>
Kode lerroa:     </div>
Kode lerroa:     <div id="usersContainer">
Kode lerroa: 
Kode lerroa:     </div>
Kode lerroa:   </div>
Kode lerroa: </div>
Kode lerroa: <div id="reviewCanvas">
Kode lerroa:   <div id="canvasOverlay"></div>
Kode lerroa:   <div id="canvasContainer"></div>
Kode lerroa:   <div id="canvasCloseButton">
Kode lerroa:     <span></span>
Kode lerroa:     <span></span>
Kode lerroa:     <span></span>
Kode lerroa:   </div>
Kode lerroa: </div>
Kode lerroa: 
Kode lerroa: <template id="propertyClusterTemplate">
Kode lerroa:   <div class="propertyCluster">
Kode lerroa:     <div class="clusterLabel">
Kode lerroa:       <span></span>
Kode lerroa:     </div>
Kode lerroa:     <div class="clusterContainer">
Kode lerroa:     </div>
Kode lerroa:   </div>
Kode lerroa: </template>
Kode lerroa: 
Kode lerroa: <template id="clusterColumnTemplate">
Kode lerroa:   <div class="clusterColumn">
Kode lerroa:   </div>
Kode lerroa: </template>
Kode lerroa: 
Kode lerroa: <template id="clusterPropertyTemplate">
Kode lerroa:   <div class="clusterProperty">
Kode lerroa:     <div class="propertyLabel">
Kode lerroa:     </div>
Kode lerroa:     <div class="propertyAnnotations">
Kode lerroa:     </div>
Kode lerroa:   </div>
Kode lerroa: </template>
Kode lerroa: 
Kode lerroa: <template id="annotationTemplate">
Kode lerroa:   <div class="canvasAnnotation">
Kode lerroa:   </div>
Kode lerroa: </template>
Kode lerroa: <!doctype html>
Kode lerroa: <html lang="en">
Kode lerroa: <head>
Kode lerroa:   <!-- Required meta tags -->
Kode lerroa:   <meta charset="utf-8">
Kode lerroa:   <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
Kode lerroa: 
Kode lerroa:   <link rel="stylesheet" type="text/css" href="../styles/options.css">
Kode lerroa: 
Kode lerroa:   <title>Mark&Go configuration</title>
Kode lerroa: </head>
Kode lerroa: <body>
Kode lerroa: <div class="container">
Kode lerroa:   <div class="jumbotron">
Kode lerroa:     <h2 class="title">We need your permission to mark local files</h2>
Kode lerroa:     <div class="card">
Kode lerroa:       <div class="card-header">Step 1 - Go to Mark&Go extension settings page</div>
Kode lerroa:       <div class="card-body">
Kode lerroa:         Right-click on the extension icon and click on <b>Manage extension</b>.<br/>
Kode lerroa:         <img src="../images/AllowAccessFileUrlExtension.png" width="50%"/>
Kode lerroa:       </div>
Kode lerroa:     </div>
Kode lerroa:     <div class="card">
Kode lerroa:       <div class="card-header" style="margin-top:10px;">Step 2 - Enable access to file URLs </div>
Kode lerroa:       <div class="card-body">
Kode lerroa:         Please ensure that it is activated <b>Allow access to file URLs</b> setting.
Kode lerroa:         <img src="../images/AllowAccessFileUrlScreenshot.png" width="90%"/>
Kode lerroa:       </div>
Kode lerroa:     </div>
Kode lerroa:   </div>
Kode lerroa: </div>
Kode lerroa: </body>
Kode lerroa: </html>
Kode lerroa: <html lang="en">
Kode lerroa: <head>
Kode lerroa:   <!-- Required meta tags -->
Kode lerroa:   <meta charset="utf-8">
Kode lerroa:   <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
Kode lerroa: 
Kode lerroa:   <link rel="stylesheet" type="text/css" href="../styles/options.css">
Kode lerroa: 
Kode lerroa:   <title>Configuration</title>
Kode lerroa: </head>
Kode lerroa: <body>
Kode lerroa: <div class="container">
Kode lerroa:   <!-- Header -->
Kode lerroa:   <header></header>
Kode lerroa: 
Kode lerroa:   <!-- Navigation bar -->
Kode lerroa: 
Kode lerroa:   <!-- Container -->
Kode lerroa:   <div id="main-container" class="container">
Kode lerroa: 
Kode lerroa:     <div class="jumbotron">
Kode lerroa:       <img class="logo" src="../images/PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))/icon-38.png">
Kode lerroa:       <h2 class="title">PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appName')) configuration</h2>
Kode lerroa:       <div class="card">
Kode lerroa:         <div class="card-header bg-dark text-white">User manual</div>
Kode lerroa:         <div class="card-body">
Kode lerroa:           <div class="form-group">
Kode lerroa:             Visit whenever you want the <a href="https://github.com/haritzmedina" target="_blank">user manual</a> for further information.
Kode lerroa:           </div>
Kode lerroa:         </div>
Kode lerroa:       </div>
Kode lerroa:       // PVSCL:IFCOND(MoodleProvider,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(MoodleProvider,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(BrowserStorage,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(Neo4J, LINE)
Kode lerroa: 
Kode lerroa:     </div>
Kode lerroa:   </div>
Kode lerroa: </div>
Kode lerroa: <script src="../scripts/options.js"></script>
Kode lerroa: </body>
Kode lerroa: </html>
Kode lerroa: <!DOCTYPE html>
Kode lerroa: <html>
Kode lerroa: <head>
Kode lerroa:   <meta charset="utf-8" />
Kode lerroa:   <title>Options</title>
Kode lerroa:   <link rel="stylesheet" type="text/css" href="../styles/popup.css">
Kode lerroa: </head>
Kode lerroa: <body>
Kode lerroa: <script src="../scripts/popup.js"></script>
Kode lerroa: </body>
Kode lerroa: </html>
Kode lerroa: import Events from '../../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import Annotation from '../Annotation'
Kode lerroa: import DOMTextUtils from '../../utils/DOMTextUtils'
Kode lerroa: import PDFTextUtils from '../../utils/PDFTextUtils'
Kode lerroa: import PDF from '../../target/formats/PDF'
Kode lerroa: import $ from 'jquery'
Kode lerroa: // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class CreateAnnotation {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for createAnnotation event
Kode lerroa:     this.initCreateAnnotationEvent()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initCreateAnnotationEvent (callback) {
Kode lerroa:     this.events.createAnnotationEvent = { element: document, event: Events.createAnnotation, handler: this.createAnnotationEventHandler() }
Kode lerroa:     this.events.createAnnotationEvent.element.addEventListener(this.events.createAnnotationEvent.event, this.events.createAnnotationEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createAnnotationEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       let annotationToCreate
Kode lerroa:       if (event.detail.purpose === 'replying') {
Kode lerroa:         // Annotation is already prepared to send to the server
Kode lerroa:         annotationToCreate = event.detail.replyingAnnotation
Kode lerroa:       } else if (event.detail.purpose === 'classifying') {
Kode lerroa:         let target
Kode lerroa:         // If selection is child of sidebar, return null
Kode lerroa:         if ($(document.getSelection().anchorNode).parents('#annotatorSidebarWrapper').toArray().length !== 0) {
Kode lerroa:           Alerts.infoAlert({ text: chrome.i18n.getMessage('CurrentSelectionNotAnnotable') })
Kode lerroa:           return
Kode lerroa:         }
Kode lerroa:         // Create target
Kode lerroa:         target = this.obtainTargetToCreateAnnotation(event.detail)
Kode lerroa:         // Create body
Kode lerroa:         const body = this.obtainBodyToCreateAnnotation(event.detail)
Kode lerroa:         // Create tags
Kode lerroa:         const tags = this.obtainTagsToCreateAnnotation(event.detail)
Kode lerroa:         // Construct the annotation to send to hypothesis
Kode lerroa:         annotationToCreate = new Annotation({
Kode lerroa:           target: target,
Kode lerroa:           tags: tags,
Kode lerroa:           body: body
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:       if (annotationToCreate) {
Kode lerroa:         window.abwa.annotationServerManager.client.createNewAnnotation(annotationToCreate.serialize(), (err, annotation) => {
Kode lerroa:           if (err) {
Kode lerroa:             Alerts.errorAlert({ text: 'Unexpected error, unable to create annotation' })
Kode lerroa:           } else {
Kode lerroa:             window.getSelection().removeAllRanges()
Kode lerroa:             // Deserialize retrieved annotation from the server
Kode lerroa:             const deserializedAnnotation = Annotation.deserialize(annotation)
Kode lerroa:             // Dispatch annotation created event
Kode lerroa:             LanguageUtils.dispatchCustomEvent(Events.annotationCreated, { annotation: deserializedAnnotation })
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         // Show error
Kode lerroa:         Alerts.errorAlert({ text: 'Unexpected error creating annotation.' + chrome.i18n.getMessage('ErrorContactDeveloper', ['createAnnotation', encodeURIComponent(new Error().stack)]) })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   obtainTagsToCreateAnnotation ({
Kode lerroa:     tags,
Kode lerroa:     /* PVSCL:IFCOND(Classifying) */ codeId /* PVSCL:ENDCOND */
Kode lerroa: 
Kode lerroa:   }) {
Kode lerroa:     if (tags) {
Kode lerroa:       tags = _.isArray(tags) ? tags : [tags]
Kode lerroa:     } else {
Kode lerroa:       tags = []
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Assessing, LINE)
Kode lerroa: 
Kode lerroa:     return tags
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   obtainBodyToCreateAnnotation ({
Kode lerroa:     /* PVSCL:IFCOND(Classifying) */codeId /* PVSCL:ENDCOND */
Kode lerroa: 
Kode lerroa:   }) {
Kode lerroa:     // Get bodies and tags for the annotation to be created
Kode lerroa:     const body = []
Kode lerroa:     // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa:     return body
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   obtainTargetToCreateAnnotation ({ repliedAnnotation }) {
Kode lerroa:     if (repliedAnnotation) {
Kode lerroa:       // Get replying annotation source and create a target
Kode lerroa:       return [{ source: repliedAnnotation.target[0].source }]
Kode lerroa:     } else {
Kode lerroa:       const target = [{}]
Kode lerroa:       const source = window.abwa.targetManager.getDocumentURIs()
Kode lerroa:       // Get document title
Kode lerroa:       source.title = window.abwa.targetManager.documentTitle || ''
Kode lerroa:       // Get UUID for current target
Kode lerroa:       source.id = window.abwa.targetManager.getDocumentId()
Kode lerroa:       target[0].source = source // Add source to the target
Kode lerroa:       // PVSCL:IFCOND(Selector, LINE)
Kode lerroa: 
Kode lerroa:       return target
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getSelectorsOfSelectedTextContent () {
Kode lerroa:     const range = document.getSelection().getRangeAt(0)
Kode lerroa:     const selectors = []
Kode lerroa:     // Create FragmentSelector
Kode lerroa:     if (_.findIndex(window.abwa.targetManager.documentFormat.selectors, (elem) => { return elem === 'FragmentSelector' }) !== -1) {
Kode lerroa:       let fragmentSelector = null
Kode lerroa:       if (window.abwa.targetManager.documentFormat === PDF) {
Kode lerroa:         fragmentSelector = PDFTextUtils.getFragmentSelector(range)
Kode lerroa:       } else {
Kode lerroa:         fragmentSelector = DOMTextUtils.getFragmentSelector(range)
Kode lerroa:       }
Kode lerroa:       if (fragmentSelector) {
Kode lerroa:         selectors.push(fragmentSelector)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // Create RangeSelector
Kode lerroa:     if (_.findIndex(window.abwa.targetManager.documentFormat.selectors, (elem) => { return elem === 'RangeSelector' }) !== -1) {
Kode lerroa:       const rangeSelector = DOMTextUtils.getRangeSelector(range)
Kode lerroa:       if (rangeSelector) {
Kode lerroa:         selectors.push(rangeSelector)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // Create TextPositionSelector
Kode lerroa:     if (_.findIndex(window.abwa.targetManager.documentFormat.selectors, (elem) => { return elem === 'TextPositionSelector' }) !== -1) {
Kode lerroa:       const rootElement = window.abwa.targetManager.getDocumentRootElement()
Kode lerroa:       const textPositionSelector = DOMTextUtils.getTextPositionSelector(range, rootElement)
Kode lerroa:       if (textPositionSelector) {
Kode lerroa:         selectors.push(textPositionSelector)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // Create TextQuoteSelector
Kode lerroa:     if (_.findIndex(window.abwa.targetManager.documentFormat.selectors, (elem) => { return elem === 'TextQuoteSelector' }) !== -1) {
Kode lerroa:       const textQuoteSelector = DOMTextUtils.getTextQuoteSelector(range)
Kode lerroa:       if (textQuoteSelector) {
Kode lerroa:         selectors.push(textQuoteSelector)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return selectors
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default CreateAnnotation
Kode lerroa: import Body from './Body'
Kode lerroa: 
Kode lerroa: class Assessing extends Body {
Kode lerroa:   constructor ({ purpose = Assessing.purpose, value }) {
Kode lerroa:     super(purpose)
Kode lerroa:     this.value = value
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   populate (code) {
Kode lerroa:     super.populate(code)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   serialize () {
Kode lerroa:     return super.serialize()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static deserialize (obj) {
Kode lerroa:     return new Assessing({ value: obj.value })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tooltip () {
Kode lerroa:     return 'Assessing: ' + this.value
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: Assessing.purpose = 'assessing'
Kode lerroa: 
Kode lerroa: export default Assessing
Kode lerroa: class Body {
Kode lerroa:   constructor (purpose) {
Kode lerroa:     this.purpose = purpose
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   populate (value) {
Kode lerroa:     this.value = value
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   serialize () {
Kode lerroa:     return { purpose: this.purpose, value: this.value }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static deserialize (obj) {
Kode lerroa:     return new Body(obj.purpose)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tooltip () {
Kode lerroa:     return ''
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Body
Kode lerroa: import Body from './Body'
Kode lerroa: // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: import Theme from '../../codebook/model/Theme'
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class Classifying extends Body {
Kode lerroa:   constructor ({ purpose = Classifying.purpose, code }) {
Kode lerroa:     super(purpose)
Kode lerroa:     if (!_.isEmpty(code)) {
Kode lerroa:       if (/* PVSCL:IFCOND(Hierarchy) */LanguageUtils.isInstanceOf(code, Code) || /* PVSCL:ENDCOND */LanguageUtils.isInstanceOf(code, Theme)) {
Kode lerroa: LanguageUtils.isInstanceOf(code, Theme)) {
Kode lerroa:         this.value = code.toObject()
Kode lerroa:       } else {
Kode lerroa:         this.value = code
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Body with classifying purpose must contain a code or theme')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   populate (code) {
Kode lerroa:     super.populate(code)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   serialize () {
Kode lerroa:     return super.serialize()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static deserialize (obj) {
Kode lerroa:     const code = window.abwa.codebookManager.codebookReader.codebook.getCodeOrThemeFromId(obj.id)
Kode lerroa:     return new Classifying({ code })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tooltip () {
Kode lerroa:     let tooltip = ''
Kode lerroa:     const code = window.abwa.codebookManager.codebookReader.codebook.getCodeOrThemeFromId(this.value.id)
Kode lerroa:     // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:     return tooltip
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: Classifying.purpose = 'classifying'
Kode lerroa: 
Kode lerroa: export default Classifying
Kode lerroa: import Body from './Body'
Kode lerroa: 
Kode lerroa: class Commenting extends Body {
Kode lerroa:   constructor ({ purpose = Commenting.purpose, value }) {
Kode lerroa:     super(purpose)
Kode lerroa:     this.value = value
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   populate (text) {
Kode lerroa:     super.populate(text)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   serialize () {
Kode lerroa:     return super.serialize()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tooltip () {
Kode lerroa:     return 'Comment: ' + this.value
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: Commenting.purpose = 'commenting'
Kode lerroa: 
Kode lerroa: export default Commenting
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: // PVSCL:IFCOND(MoodleProvider OR Autocomplete, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Autocomplete,LINE)
Kode lerroa: 
Kode lerroa: import $ from 'jquery'
Kode lerroa: // PVSCL:IFCOND(SentimentAnalysis,LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Commenting, LINE)
Kode lerroa: 
Kode lerroa: import Config from '../../Config'
Kode lerroa: // PVSCL:IFCOND(Assessing, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(SuggestedLiterature, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class CommentingForm {
Kode lerroa:   /**
Kode lerroa:    *
Kode lerroa:    * @param annotation annotation that is involved
Kode lerroa:    * @param callback callback to execute after form is closed
Kode lerroa:    * @param addingHtml
Kode lerroa:    */
Kode lerroa:   static showCommentingForm (annotation, callback, addingHtml) {
Kode lerroa:     // Save status of sidebar and close it
Kode lerroa:     const sidebarStatus = window.abwa.sidebar.isOpened()
Kode lerroa:     window.abwa.sidebar.closeSidebar()
Kode lerroa:     // PVSCL:IFCOND(PreviousAssignments,LINE)
Kode lerroa: 
Kode lerroa:     const title = CommentingForm.getFormTitle(annotation)
Kode lerroa:     const showForm = (preConfirmData = {}) => {
Kode lerroa:       // Get last call to this form annotation text, not the init one
Kode lerroa:       if (_.isObject(preConfirmData) && preConfirmData.comment) {
Kode lerroa:         annotation.text = preConfirmData.comment
Kode lerroa:       }
Kode lerroa:       // Create form
Kode lerroa:       const generateFormObjects = { annotation, showForm, sidebarStatus }
Kode lerroa:       // PVSCL:IFCOND(Autocomplete,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(PreviousAssignments,LINE)
Kode lerroa: 
Kode lerroa:       const html = CommentingForm.generateCommentFormHTML({ annotation, addingHtml })
Kode lerroa:       const swalCallback = CommentingForm.generateCommentFormCallback({ annotation, preConfirmData, sidebarStatus, callback })
Kode lerroa:       const preConfirm = CommentingForm.generateCommentFormPreConfirm({ preConfirmData, swalCallback, showForm })
Kode lerroa:       const onBeforeOpen = CommentingForm.generateOnBeforeOpenForm({ annotation })
Kode lerroa:       Alerts.multipleInputAlert({
Kode lerroa:         title: title || '',
Kode lerroa:         html: html,
Kode lerroa:         onBeforeOpen: onBeforeOpen,
Kode lerroa:         // position: Alerts.position.bottom, // TODO Must be check if it is better to show in bottom or not
Kode lerroa:         callback: swalCallback,
Kode lerroa:         preConfirm: preConfirm
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     showForm()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getFormTitle (annotation) {
Kode lerroa:     let title = 'Commenting'
Kode lerroa:     // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa:     return title
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(PreviousAssignments,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   static generateCommentFormPreConfirm ({ preConfirmData, callback, showForm }) {
Kode lerroa:     const preConfirm = () => {
Kode lerroa:       preConfirmData.comment = document.querySelector('#comment').value
Kode lerroa:       // PVSCL:IFCOND(SuggestedLiterature, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(Categorize, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(SentimentAnalysis, LINE)
Kode lerroa: 
Kode lerroa:     }
Kode lerroa:     return preConfirm
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(SentimentAnalysis, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   static generateCommentFormHTML ({ annotation, addingHtml }) {
Kode lerroa:     let html = addingHtml || ''
Kode lerroa:     // PVSCL:IFCOND(PreviousAssignments,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Categorize, LINE)
Kode lerroa: 
Kode lerroa:     let purposeCommentingBody
Kode lerroa:     if (_.isArray(annotation.body)) {
Kode lerroa:       purposeCommentingBody = annotation.body.find(body => body.purpose === 'commenting')
Kode lerroa:     }
Kode lerroa:     const commentText = purposeCommentingBody ? purposeCommentingBody.value : ''
Kode lerroa:     html += '<textarea class="swal2-textarea" data-minchars="1" data-multiple id="comment" rows="6" autofocus>' + commentText + '</textarea>'
Kode lerroa:     // PVSCL:IFCOND(SuggestedLiterature,LINE)
Kode lerroa: 
Kode lerroa:     return html
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static generateOnBeforeOpenForm ({ annotation }) {
Kode lerroa:     // On before open
Kode lerroa:     let onBeforeOpen = () => {
Kode lerroa:       // PVSCL:IFCOND(Autocomplete,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(SuggestedLiterature, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(Categorize, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(PreviousAssignments,LINE)
Kode lerroa: 
Kode lerroa:     }
Kode lerroa:     return onBeforeOpen
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Autocomplete,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   static generateCommentFormCallback ({ annotation, preConfirmData, callback, sidebarStatus }) {
Kode lerroa:     // Callback
Kode lerroa:     return (err, result) => {
Kode lerroa:       if (!_.isUndefined(preConfirmData.comment)) { // It was pressed OK button instead of cancel, so update the annotation
Kode lerroa:         if (err) {
Kode lerroa:           window.alert('Unable to load alert. Is this an annotable document?')
Kode lerroa:         } else {
Kode lerroa:           const bodyToUpdate = []
Kode lerroa:           bodyToUpdate.push(new Commenting({ value: preConfirmData.comment }))
Kode lerroa:           // Update annotation
Kode lerroa:           annotation.text = preConfirmData.comment || ''
Kode lerroa:           // PVSCL:IFCOND(SuggestedLiterature,LINE)
Kode lerroa: 
Kode lerroa:           // PVSCL:IFCOND(Assessing, LINE)
Kode lerroa: 
Kode lerroa:           // Update annotation's body
Kode lerroa:           annotation.body = _.uniqBy(_.concat(bodyToUpdate, annotation.body), a => a.purpose)
Kode lerroa:           if (sidebarStatus) {
Kode lerroa:             window.abwa.sidebar.openSidebar()
Kode lerroa:           }
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null, annotation)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default CommentingForm
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Config from '../../Config'
Kode lerroa: import Codebook from '../../codebook/model/Codebook'
Kode lerroa: 
Kode lerroa: const RETRIEVE_PREVIOUS_ASSIGNMENT_INTERVAL_IN_SECONDS = 60
Kode lerroa: 
Kode lerroa: class PreviousAssignments {
Kode lerroa:   constructor () {
Kode lerroa:     this.previousAssignments = []
Kode lerroa:     this.intervals = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing previousAssignments')
Kode lerroa:     // Load previous assignments
Kode lerroa:     this.reloadPreviousAssignments(() => {
Kode lerroa:       console.debug('Initialized previousAssignments')
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:       this.intervals.retrievePreviousAssignment = window.setInterval(() => {
Kode lerroa:         this.reloadPreviousAssignments()
Kode lerroa:       }, RETRIEVE_PREVIOUS_ASSIGNMENT_INTERVAL_IN_SECONDS * 1000)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     if (this.intervals.retrievePreviousAssignment) {
Kode lerroa:       clearInterval(this.intervals.retrievePreviousAssignment)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadPreviousAssignments (callback) {
Kode lerroa:     // Get student id
Kode lerroa:     const studentId = window.abwa.targetManager.fileMetadata.studentId
Kode lerroa:     window.abwa.annotationServerManager.client.searchAnnotations({
Kode lerroa:       tag: Config.namespace + ':guide',
Kode lerroa:       group: window.abwa.groupSelector.currentGroup.id
Kode lerroa:     }, (err, annotations) => {
Kode lerroa:       if (err) {
Kode lerroa:         // Nothing to do
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         const previousAssignments = []
Kode lerroa:         for (let i = 0; i < annotations.length; i++) {
Kode lerroa:           Codebook.fromAnnotation(annotations[i], (rubric) => {
Kode lerroa:             // If current assignment is previous assignment, don't add
Kode lerroa:             if (window.abwa.targetManager.fileMetadata.cmid !== rubric.cmid) {
Kode lerroa:               const previousAssignment = { name: rubric.assignmentName }
Kode lerroa:               const teacherUrl = rubric.getUrlToStudentAssignmentForTeacher(studentId)
Kode lerroa:               const studentUrl = rubric.getUrlToStudentAssignmentForStudent(studentId)
Kode lerroa:               // If it is unable to retrieve the URL, don't add
Kode lerroa:               if (!_.isNull(teacherUrl) && !_.isNull(studentUrl)) {
Kode lerroa:                 previousAssignment.teacherUrl = teacherUrl
Kode lerroa:                 previousAssignment.studentUrl = studentUrl
Kode lerroa:                 previousAssignments.push(previousAssignment)
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:         this.previousAssignments = previousAssignments
Kode lerroa:         console.debug('Updated previous assignments')
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   retrievePreviousAssignments () {
Kode lerroa:     return window.abwa.previousAssignments.previousAssignments
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createPreviousAssignmentsUI (previousAssignments) {
Kode lerroa:     const previousAssignmentsContainer = document.createElement('div')
Kode lerroa:     previousAssignmentsContainer.className = 'previousAssignmentsContainer'
Kode lerroa:     for (let i = 0; i < previousAssignments.length; i++) {
Kode lerroa:       const previousAssignment = previousAssignments[i]
Kode lerroa:       // Create previous assignment element container
Kode lerroa:       const previousAssignmentElement = document.createElement('span')
Kode lerroa:       previousAssignmentElement.className = 'previousAssignmentContainer'
Kode lerroa:       // Create previous assignment link
Kode lerroa:       const previousAssignmentLinkElement = document.createElement('a')
Kode lerroa:       if (window.abwa.rolesManager.role === Config.tags.producer) {
Kode lerroa:         previousAssignmentLinkElement.href = previousAssignment.teacherUrl
Kode lerroa:       } else {
Kode lerroa:         previousAssignmentLinkElement.href = previousAssignment.studentUrl
Kode lerroa:       }
Kode lerroa:       previousAssignmentLinkElement.target = '_blank'
Kode lerroa:       previousAssignmentLinkElement.innerText = previousAssignment.name
Kode lerroa:       previousAssignmentLinkElement.className = 'previousAssignmentLink'
Kode lerroa:       previousAssignmentElement.appendChild(previousAssignmentLinkElement)
Kode lerroa:       // Create previous assignment append img
Kode lerroa:       const previousAssignmentAppendElement = document.createElement('img')
Kode lerroa:       previousAssignmentAppendElement.src = chrome.extension.getURL('images/append.png')
Kode lerroa:       previousAssignmentAppendElement.title = 'Append the assignment URL'
Kode lerroa:       previousAssignmentAppendElement.className = 'previousAssignmentAppendButton'
Kode lerroa:       if (window.abwa.rolesManager.role === Config.tags.producer) {
Kode lerroa:         previousAssignmentAppendElement.dataset.studentUrl = previousAssignment.studentUrl
Kode lerroa:       } else {
Kode lerroa:         previousAssignmentAppendElement.dataset.studentUrl = previousAssignment.teacherUrl
Kode lerroa:       }
Kode lerroa:       previousAssignmentElement.appendChild(previousAssignmentAppendElement)
Kode lerroa:       previousAssignmentsContainer.appendChild(previousAssignmentElement)
Kode lerroa:     }
Kode lerroa:     return previousAssignmentsContainer
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default PreviousAssignments
Kode lerroa: import AnnotationUtils from '../../utils/AnnotationUtils'
Kode lerroa: import Config from '../../Config'
Kode lerroa: import moment from 'moment'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class ReplyAnnotation {
Kode lerroa:   /**
Kode lerroa:    * Returns if annotation is replied by any annotation in replies
Kode lerroa:    * @param annotation
Kode lerroa:    * @param allReplies
Kode lerroa:    */
Kode lerroa:   static hasReplies (annotation, allReplies) {
Kode lerroa:     try {
Kode lerroa:       return ReplyAnnotation.getReplies(annotation, allReplies).length > 0
Kode lerroa:     } catch (e) {
Kode lerroa:       return false
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Returns all the reply annotations that reply "annotation"
Kode lerroa:    * @param annotation
Kode lerroa:    * @param allReplies
Kode lerroa:    * @returns {Array}
Kode lerroa:    */
Kode lerroa:   static getReplies (annotation, allReplies) {
Kode lerroa:     let replies = _.filter(allReplies, (replyAnnotation) => {
Kode lerroa:       return AnnotationUtils.isReplyOf(annotation, replyAnnotation)
Kode lerroa:     })
Kode lerroa:     replies = _.orderBy(replies, 'updated')
Kode lerroa:     return replies
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createRepliesData (annotation, replyAnnotations = []) {
Kode lerroa:     let htmlText = ''
Kode lerroa:     // Add feedback comment text
Kode lerroa:     htmlText += ReplyAnnotation.createReplyLog(annotation)
Kode lerroa:     htmlText += '<hr/>'
Kode lerroa:     // Get replies for this annotation
Kode lerroa:     const replies = ReplyAnnotation.getReplies(annotation, replyAnnotations)
Kode lerroa:     // What and who
Kode lerroa:     for (let i = 0; i < replies.length; i++) {
Kode lerroa:       const reply = replies[i]
Kode lerroa:       htmlText += this.createReplyLog(reply)
Kode lerroa:       if (replies.length - 1 > i) {
Kode lerroa:         htmlText += '<hr/>'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return { htmlText: htmlText, replies: replies }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createReplyLog (reply) {
Kode lerroa:     let htmlText = ''
Kode lerroa:     let userSpanClassName = 'reply_user'
Kode lerroa:     let textSpanClassName = 'reply_text'
Kode lerroa:     const dateSpanClassName = 'reply_date'
Kode lerroa:     // PVSCL:IFCOND( Validate, LINE )
Kode lerroa: 
Kode lerroa:     // Add user name
Kode lerroa:     if (reply.creator === window.abwa.groupSelector.getCreatorData()) {
Kode lerroa:       htmlText += '<span class="' + userSpanClassName + '">You: </span>'
Kode lerroa:     } else {
Kode lerroa:       const username = reply.creator.replace(window.abwa.annotationServerManager.annotationServerMetadata.userUrl, '')
Kode lerroa:       htmlText += '<span class="' + userSpanClassName + '">' + username + ': </span>'
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(Commenting, LINE)
Kode lerroa: 
Kode lerroa:     if (reply.modified) {
Kode lerroa:       htmlText += '<span title="' + moment(reply.modified).format('MMMM Do YYYY, h:mm:ss a') + '" class="' + dateSpanClassName + '">' + moment(reply.modified).fromNow() + '</span>'
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     return htmlText
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ReplyAnnotation
Kode lerroa: import Body from './Body'
Kode lerroa: 
Kode lerroa: class SuggestingLiterature extends Body {
Kode lerroa:   constructor ({ purpose = SuggestingLiterature.purpose, value = [] }) {
Kode lerroa:     super(purpose)
Kode lerroa:     this.value = value
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   populate (value) {
Kode lerroa:     super.populate(value)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   serialize () {
Kode lerroa:     return super.serialize()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tooltip () {
Kode lerroa:     return 'Suggested literature: \n ' + this.value.join('\n ')
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: SuggestingLiterature.purpose = 'suggestingLiterature'
Kode lerroa: 
Kode lerroa: export default SuggestingLiterature
Kode lerroa: class AnnotationList {
Kode lerroa:   static openAnnotationList () {
Kode lerroa:     // Get current annotation server
Kode lerroa:     const selectedAnnotationServerManager = window.abwa.annotationServerManager
Kode lerroa: 
Kode lerroa:     // Get current annotation group
Kode lerroa:     const currentGroupId = window.abwa.groupSelector.currentGroup.id
Kode lerroa: 
Kode lerroa:     // Redirect depending on the annotation server and parametrize with the current group ID
Kode lerroa:     const url = selectedAnnotationServerManager.constructSearchUrl({ group: currentGroupId })
Kode lerroa:     window.open(url, '_blank')
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationList
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import axios from 'axios'
Kode lerroa: 
Kode lerroa: import { Review } from '../../exporter/reviewModel'
Kode lerroa: 
Kode lerroa: class Canvas {
Kode lerroa:   static generateCanvas () {
Kode lerroa:     window.abwa.sidebar.closeSidebar()
Kode lerroa:     const review = Review.parseAnnotations(window.abwa.annotationManagement.annotationReader.allAnnotations)
Kode lerroa:     const canvasPageURL = chrome.extension.getURL('pages/specific/reviewCanvas.html')
Kode lerroa:     axios.get(canvasPageURL).then((response) => {
Kode lerroa:       document.body.insertAdjacentHTML('beforeend', response.data)
Kode lerroa:       document.querySelector('#abwaSidebarButton').style.display = 'none'
Kode lerroa: 
Kode lerroa:       const canvasContainer = document.querySelector('#canvasContainer')
Kode lerroa:       document.querySelector('#canvasOverlay').addEventListener('click', function () {
Kode lerroa:         document.querySelector('#reviewCanvas').parentNode.removeChild(document.querySelector('#reviewCanvas'))
Kode lerroa:         document.querySelector('#abwaSidebarButton').style.display = 'block'
Kode lerroa:       })
Kode lerroa:       document.querySelector('#canvasContainer').addEventListener('click', function (e) {
Kode lerroa:         e.stopPropagation()
Kode lerroa:       })
Kode lerroa:       document.addEventListener('keydown', function (e) {
Kode lerroa:         if (e.code === 'Escape' && document.querySelector('#reviewCanvas') != null) document.querySelector('#reviewCanvas').parentNode.removeChild(document.querySelector('#reviewCanvas'))
Kode lerroa:         document.querySelector('#abwaSidebarButton').style.display = 'block'
Kode lerroa:       })
Kode lerroa:       document.querySelector('#canvasCloseButton').addEventListener('click', function () {
Kode lerroa:         document.querySelector('#reviewCanvas').parentNode.removeChild(document.querySelector('#reviewCanvas'))
Kode lerroa:         document.querySelector('#abwaSidebarButton').style.display = 'block'
Kode lerroa:       })
Kode lerroa:       const canvasClusters = {}
Kode lerroa:       window.abwa.codebookManager.codebookReader.codebook.themes.forEach((theme) => {
Kode lerroa:         canvasClusters[theme.name] = theme.codes.map((code) => { return code.name })
Kode lerroa:         canvasClusters[theme.name].push(theme.name)
Kode lerroa:       })
Kode lerroa: 
Kode lerroa:       const clusterTemplate = document.querySelector('#propertyClusterTemplate')
Kode lerroa:       const columnTemplate = document.querySelector('#clusterColumnTemplate')
Kode lerroa:       const propertyTemplate = document.querySelector('#clusterPropertyTemplate')
Kode lerroa:       const annotationTemplate = document.querySelector('#annotationTemplate')
Kode lerroa:       // let clusterHeight = 100.0/Object.keys(canvasClusters).length
Kode lerroa: 
Kode lerroa:       const getCriterionLevel = (annotations) => {
Kode lerroa:         if (annotations.length === 0) return 'emptyCluster'
Kode lerroa:         if (annotations[0].level == null || annotations[0].level === '') return 'unsorted'
Kode lerroa:         const criterionLevel = annotations[0].level
Kode lerroa:         for (let i = 1; i < annotations.length; i++) {
Kode lerroa:           if (annotations[i].level == null || annotations[i].level === '') return 'unsorted'
Kode lerroa:           else if (annotations[i].level !== criterionLevel) return 'unsorted'
Kode lerroa:         }
Kode lerroa:         return criterionLevel.replace(/\s/g, '')
Kode lerroa:       }
Kode lerroa: 
Kode lerroa:       const displayAnnotation = (annotation) => {
Kode lerroa:         let swalContent = ''
Kode lerroa:         if (annotation.highlightText != null && annotation.highlightText !== '') swalContent += '<h2 style="text-align:left;margin-bottom:10px;">Highlight</h2><div style="text-align:justify;font-style:italic">"' + annotation.highlightText.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '"</div>'
Kode lerroa:         if (annotation.comment != null && annotation.comment !== '') swalContent += '<h2 style="text-align:left;margin-top:10px;margin-bottom:10px;">Comment</h2><div style="text-align:justify;">' + annotation.comment.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>'
Kode lerroa:         if (annotation.suggestedLiterature != null && annotation.suggestedLiterature.length > 0) swalContent += '<h2 style="text-align:left;margin-top:10px;margin-bottom:10px;">Suggested literature</h2><div style="text-align:justify;"><ul style="padding-left:10px;">' + annotation.suggestedLiterature.map((e) => { return '<li>' + e.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</li>' }).join('') + '</ul></div>'
Kode lerroa:         const swal = require('sweetalert2').default
Kode lerroa:         swal({
Kode lerroa:           html: swalContent,
Kode lerroa:           confirmButtonText: 'View in context'
Kode lerroa:         }).then((result) => {
Kode lerroa:           if (result.value) {
Kode lerroa:             document.querySelector('#reviewCanvas').parentNode.removeChild(document.querySelector('#reviewCanvas'))
Kode lerroa:             window.abwa.annotationManagement.goToAnnotation(window.abwa.annotationManagement.annotationReader.allAnnotations.find((e) => { return e.id === annotation.id }))
Kode lerroa:             document.querySelector('#abwaSidebarButton').style.display = 'block'
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa: 
Kode lerroa:       const getGroupAnnotationCount = (group) => {
Kode lerroa:         let i = 0
Kode lerroa:         canvasClusters[group].forEach((e) => { i += review.annotations.filter((a) => { return a.criterion === e }).length })
Kode lerroa:         return i
Kode lerroa:       }
Kode lerroa:       const getColumnAnnotationCount = (properties) => {
Kode lerroa:         let i = 0
Kode lerroa:         properties.forEach((e) => { i += review.annotations.filter((a) => { return a.criterion === e }).length })
Kode lerroa:         return i
Kode lerroa:       }
Kode lerroa:       const getGroupHeight = (group) => {
Kode lerroa:         if (review.annotations.filter((e) => { return e.criterion !== 'Typos' }).length === 0) return 33.3333
Kode lerroa:         return 15.0 + getGroupAnnotationCount(group) * (100.0 - 15 * Object.keys(canvasClusters).length) / review.annotations.filter((e) => { return e.criterion !== 'Typos' }).length
Kode lerroa:       }
Kode lerroa:       const getColumnWidth = (properties, group) => {
Kode lerroa:         const colNum = canvasClusters[group].length === 2 ? 2 : Math.ceil(canvasClusters[group].length / 2)
Kode lerroa:         if (getGroupAnnotationCount(group) === 0) return 100.0 / Math.ceil(canvasClusters[group].length / 2)
Kode lerroa:         return 15.0 + getColumnAnnotationCount(properties) * (100.0 - 15 * colNum) / getGroupAnnotationCount(group)
Kode lerroa:       }
Kode lerroa:       const getPropertyHeight = (property, properties) => {
Kode lerroa:         if (properties.length === 1) return 100
Kode lerroa:         if (getColumnAnnotationCount(properties) === 0 && properties.length === 2) return 50
Kode lerroa:         return 15.0 + review.annotations.filter((e) => { return e.criterion === property }).length * (100.0 - 15 * 2) / getColumnAnnotationCount(properties)
Kode lerroa:       }
Kode lerroa: 
Kode lerroa:       for (const key in canvasClusters) {
Kode lerroa:         const clusterElement = clusterTemplate.content.cloneNode(true)
Kode lerroa:         // clusterElement.querySelector(".propertyCluster").style.height = clusterHeight+'%'
Kode lerroa:         clusterElement.querySelector('.propertyCluster').style.height = getGroupHeight(key) + '%'
Kode lerroa:         clusterElement.querySelector('.clusterLabel span').innerText = key
Kode lerroa:         const clusterContainer = clusterElement.querySelector('.clusterContainer')
Kode lerroa:         let currentColumn = null
Kode lerroa:         for (let i = 0; i < canvasClusters[key].length; i++) {
Kode lerroa:           if (i % 2 === 0 || canvasClusters[key].length === 2) {
Kode lerroa:             currentColumn = columnTemplate.content.cloneNode(true)
Kode lerroa:             if (canvasClusters[key].length === 1) currentColumn.querySelector('.clusterColumn').style.width = '100%'
Kode lerroa:             /* else if(canvasClusters[key].length==2) currentColumn.querySelector('.clusterColumn').style.width = "50%"
Kode lerroa:             else currentColumn.querySelector('.clusterColumn').style.width = parseFloat(100.0/Math.ceil(canvasClusters[key].length/2)).toString()+'%' */
Kode lerroa:             else {
Kode lerroa:               let columnWidth
Kode lerroa:               if (canvasClusters[key].length === 2) {
Kode lerroa:                 columnWidth = getColumnWidth([canvasClusters[key][i]], key)
Kode lerroa:                 if (getColumnAnnotationCount(canvasClusters[key]) === 0) {
Kode lerroa:                   currentColumn.querySelector('.clusterColumn').style.height = 50 + '%'
Kode lerroa:                 }
Kode lerroa:               } else if (i < canvasClusters[key].length - 1) columnWidth = getColumnWidth([canvasClusters[key][i], canvasClusters[key][i + 1]], key)
Kode lerroa:               else columnWidth = getColumnWidth([canvasClusters[key][i]], key)
Kode lerroa:               currentColumn.querySelector('.clusterColumn').style.width = columnWidth + '%'
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           const clusterProperty = propertyTemplate.content.cloneNode(true)
Kode lerroa:           clusterProperty.querySelector('.propertyLabel').innerText = canvasClusters[key][i]
Kode lerroa:           /* if(canvasClusters[key].length==1||canvasClusters[key].length==2||(canvasClusters[key].length%2==1&&i==canvasClusters[key].length-1)) clusterProperty.querySelector(".clusterProperty").style.height = "100%"
Kode lerroa:           else clusterProperty.querySelector(".clusterProperty").style.height = "50%"; */
Kode lerroa:           let propertyHeight = 100
Kode lerroa:           if (canvasClusters[key].length === 2) propertyHeight = getPropertyHeight(canvasClusters[key][i], [canvasClusters[key][i]])
Kode lerroa:           else if (i % 2 === 0 && i < canvasClusters[key].length - 1) propertyHeight = getPropertyHeight(canvasClusters[key][i], [canvasClusters[key][i], canvasClusters[key][i + 1]])
Kode lerroa:           else if (i % 2 === 1) propertyHeight = getPropertyHeight(canvasClusters[key][i], [canvasClusters[key][i], canvasClusters[key][i - 1]])
Kode lerroa:           clusterProperty.querySelector('.clusterProperty').style.height = propertyHeight + '%'
Kode lerroa:           clusterProperty.querySelector('.clusterProperty').style.width = '100%'
Kode lerroa: 
Kode lerroa:           const criterionAnnotations = review.annotations.filter((e) => { return e.criterion === canvasClusters[key][i] })
Kode lerroa:           if (criterionAnnotations.length === 0) clusterProperty.querySelector('.propertyAnnotations').style.display = 'none'
Kode lerroa:           clusterProperty.querySelector('.clusterProperty').className += ' ' + getCriterionLevel(criterionAnnotations)
Kode lerroa: 
Kode lerroa:           const annotationWidth = 100.0 / criterionAnnotations.length
Kode lerroa:           for (let j = 0; j < criterionAnnotations.length; j++) {
Kode lerroa:             const annotationElement = annotationTemplate.content.cloneNode(true)
Kode lerroa:             annotationElement.querySelector('.canvasAnnotation').style.width = annotationWidth + '%'
Kode lerroa:             if (criterionAnnotations[j].highlightText != null) annotationElement.querySelector('.canvasAnnotation').innerText = '"' + criterionAnnotations[j].highlightText + '"'
Kode lerroa:             if (criterionAnnotations[j].level != null) annotationElement.querySelector('.canvasAnnotation').className += ' ' + criterionAnnotations[j].level.replace(/\s/g, '')
Kode lerroa:             else annotationElement.querySelector('.canvasAnnotation').className += ' unsorted'
Kode lerroa:             annotationElement.querySelector('.canvasAnnotation').addEventListener('click', function () {
Kode lerroa:               displayAnnotation(criterionAnnotations[j])
Kode lerroa:             })
Kode lerroa:             clusterProperty.querySelector('.propertyAnnotations').appendChild(annotationElement)
Kode lerroa:           }
Kode lerroa: 
Kode lerroa:           currentColumn.querySelector('.clusterColumn').appendChild(clusterProperty)
Kode lerroa:           if (i % 2 === 1 || i === canvasClusters[key].length - 1 || canvasClusters[key].length === 2) clusterContainer.appendChild(currentColumn)
Kode lerroa:         }
Kode lerroa:         canvasContainer.appendChild(clusterElement)
Kode lerroa:       }
Kode lerroa:       Alerts.closeAlert()
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Canvas
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import AnnotationUtils from '../../utils/AnnotationUtils'
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: import Config from '../../Config'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Theme from '../../codebook/model/Theme'
Kode lerroa: 
Kode lerroa: const HyperSheetColors = {
Kode lerroa:   red: {
Kode lerroa:     red: 0.8980392,
Kode lerroa:     green: 0.49803922,
Kode lerroa:     blue: 0.49803922
Kode lerroa:   },
Kode lerroa:   white: {
Kode lerroa:     red: 1,
Kode lerroa:     green: 1,
Kode lerroa:     blue: 1
Kode lerroa:   },
Kode lerroa:   yellow: {
Kode lerroa:     red: 1,
Kode lerroa:     green: 0.8980392,
Kode lerroa:     blue: 0.6
Kode lerroa:   },
Kode lerroa:   green: {
Kode lerroa:     red: 0.7137255,
Kode lerroa:     green: 0.84313726,
Kode lerroa:     blue: 0.65882355
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: class GoogleSheetGenerator {
Kode lerroa:   static generate (callback) {
Kode lerroa:     // Spreadsheet for SLRs
Kode lerroa:     GoogleSheetGenerator.createSpreadsheet((err, spreadsheetMetadata) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ title: 'Error creating spreadsheet' })
Kode lerroa:       } else {
Kode lerroa:         const spreadsheetId = spreadsheetMetadata.spreadsheetId
Kode lerroa:         const sheetId = spreadsheetMetadata.sheetId
Kode lerroa:         let spreadsheetUrl = 'https://docs.google.com/spreadsheets/d/' + spreadsheetId
Kode lerroa:         if (sheetId) {
Kode lerroa:           spreadsheetUrl += '/edit#gid=' + sheetId
Kode lerroa:         }
Kode lerroa:         Alerts.infoAlert({
Kode lerroa:           title: 'Spreadsheet correctly created',
Kode lerroa:           text: 'This is your spreadsheet URL: <a href="' + spreadsheetUrl + '" target="_blank">' + spreadsheetUrl + '</a>'
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createSpreadsheet (callback) {
Kode lerroa:     // TODO Check if slr:spreadsheet annotation exists
Kode lerroa:     // TODO If exists, ask user overwrite or create new
Kode lerroa:     Alerts.loadingAlert({ title: 'Creating spreadsheet', text: 'Please be patient...' })
Kode lerroa:     const promises = []
Kode lerroa:     // Promise to create spreadsheet
Kode lerroa:     promises.push(new Promise((resolve, reject) => {
Kode lerroa:       chrome.runtime.sendMessage({
Kode lerroa:         scope: 'googleSheets',
Kode lerroa:         cmd: 'createSpreadsheet',
Kode lerroa:         data: { properties: { title: window.abwa.groupSelector.currentGroup.name } }
Kode lerroa:       }, (result) => {
Kode lerroa:         if (_.has(result.err)) {
Kode lerroa:           reject(result.err)
Kode lerroa:         } else {
Kode lerroa:           resolve({ spreadsheet: result })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }))
Kode lerroa:     // Promise to retrieve all annotations from current group
Kode lerroa:     promises.push(new Promise((resolve, reject) => {
Kode lerroa:       // TODO Change the limit of annotations
Kode lerroa:       window.abwa.annotationServerManager.client.searchAnnotations({
Kode lerroa:         group: window.abwa.groupSelector.currentGroup.id,
Kode lerroa:         limit: 100000000,
Kode lerroa:         order: 'desc',
Kode lerroa:         sort: 'updated'
Kode lerroa:       }, (err, annotations) => {
Kode lerroa:         if (err) {
Kode lerroa:           reject(err)
Kode lerroa:         } else {
Kode lerroa:           resolve({ annotations: annotations })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }))
Kode lerroa:     Promise.all(promises).catch(() => {
Kode lerroa: 
Kode lerroa:     }).then((resolves) => {
Kode lerroa:       console.debug(resolves)
Kode lerroa:       const annotationsResolve = _.find(resolves, (resolve) => { return _.has(resolve, 'annotations') })
Kode lerroa:       const spreadsheetResolve = _.find(resolves, (resolve) => { return _.has(resolve, 'spreadsheet') })
Kode lerroa:       const spreadsheetId = spreadsheetResolve.spreadsheet.spreadsheetId
Kode lerroa:       // Get annotations for coding and assessing
Kode lerroa:       const slrInfo = GoogleSheetGenerator.getSLRInfoFromAnnotations(annotationsResolve.annotations)
Kode lerroa:       const primaryStudies = slrInfo.primaryStudies
Kode lerroa:       const sheetId = 0
Kode lerroa:       // Update spreadsheet with primary studies data
Kode lerroa:       const rows = []
Kode lerroa:       // Calculate for each code which one is the number of columns (multivalued use case)
Kode lerroa:       const columns = GoogleSheetGenerator.calculateColumns(primaryStudies)
Kode lerroa:       // First row is for codebook facets
Kode lerroa:       const themes = _.filter(window.abwa.codebookManager.codebookReader.codebook.themes, (code) => {
Kode lerroa:         return code.parentCode === null
Kode lerroa:       })
Kode lerroa:       rows.push(GoogleSheetGenerator.createHeaderSpreadsheetRow(themes, columns))
Kode lerroa:       // Retrieve rows for primary studies
Kode lerroa:       for (let i = 0; i < primaryStudies.length; i++) {
Kode lerroa:         rows.push(primaryStudies[i].toSpreadsheetRow(columns))
Kode lerroa:       }
Kode lerroa:       console.debug(rows)
Kode lerroa:       GoogleSheetGenerator.populateSpreadsheet({ spreadsheetId, sheetId, rows, callback })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static populateSpreadsheet ({ spreadsheetId, sheetId, rows, callback }) {
Kode lerroa:     chrome.runtime.sendMessage({
Kode lerroa:       scope: 'googleSheets',
Kode lerroa:       cmd: 'updateSpreadsheet',
Kode lerroa:       data: {
Kode lerroa:         spreadsheetId: spreadsheetId,
Kode lerroa:         sheetId: sheetId,
Kode lerroa:         rows: rows,
Kode lerroa:         rowIndex: 0,
Kode lerroa:         columnIndex: 0
Kode lerroa:       }
Kode lerroa:     }, (result) => {
Kode lerroa:       if (_.has(result, 'error')) {
Kode lerroa:         callback(result.error)
Kode lerroa:       } else {
Kode lerroa:         callback(null, { spreadsheetId: spreadsheetId, sheetId: sheetId })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createHeaderSpreadsheetRow (parentCodes, codesColumnCalc) {
Kode lerroa:     const cells = []
Kode lerroa:     // Title cell
Kode lerroa:     cells.push({
Kode lerroa:       userEnteredValue: {
Kode lerroa:         formulaValue: '=HYPERLINK("' + window.abwa.groupSelector.currentGroup.links.html + '", "Title")'
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // Fill columns headers and take into account for each parent code which one is the number of columns (multivalued use case)
Kode lerroa:     for (let i = 0; i < codesColumnCalc.length; i++) {
Kode lerroa:       const lengthOfCurrentColumn = codesColumnCalc[i].columns
Kode lerroa:       const theme = codesColumnCalc[i].theme
Kode lerroa:       for (let j = 0; j < lengthOfCurrentColumn; j++) {
Kode lerroa:         cells.push({
Kode lerroa:           userEnteredValue: {
Kode lerroa:             stringValue: theme.name
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       values: cells
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getSLRInfoFromAnnotations (annotations) {
Kode lerroa:     const codingAnnotations = _.filter(annotations, (annotation) => {
Kode lerroa:       if (annotation.body && _.isArray(annotation.body)) {
Kode lerroa:         return _.isObject(annotation.body.find(body => body.purpose === 'classifying'))
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     const validatingAnnotations = _.filter(annotations, (annotation) => {
Kode lerroa:       if (annotation.body && _.isArray(annotation.body)) {
Kode lerroa:         return _.isObject(annotation.body.find(body => body.purpose === 'assessing'))
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     const anAnnotationForEachPrimaryStudy = _.uniqWith(codingAnnotations, (a, b) => {
Kode lerroa:       return AnnotationUtils.areFromSameDocument(a, b)
Kode lerroa:     })
Kode lerroa:     const users = _.map(_.uniqBy(codingAnnotations, (anno) => { return anno.user }), 'user')
Kode lerroa:     // Create primary studies
Kode lerroa:     const primaryStudies = []
Kode lerroa:     for (let i = 0; i < anAnnotationForEachPrimaryStudy.length; i++) {
Kode lerroa:       const annotationForPrimaryStudy = anAnnotationForEachPrimaryStudy[i]
Kode lerroa:       const codingAnnotationsForPrimaryStudy = _.filter(codingAnnotations, (codingAnnotation) => {
Kode lerroa:         return AnnotationUtils.areFromSameDocument(annotationForPrimaryStudy, codingAnnotation)
Kode lerroa:       })
Kode lerroa:       // Retrieve from any annotation the document title
Kode lerroa:       let title
Kode lerroa:       try {
Kode lerroa:         // Look for any annotation with document title
Kode lerroa:         let annotationWithTitle = _.find(codingAnnotationsForPrimaryStudy, (annotation) => {
Kode lerroa:           if (_.has(annotation, 'target[0].source.title')) {
Kode lerroa:             return _.isString(annotation.target[0].source.title)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:         if (annotationWithTitle) {
Kode lerroa:           title = annotationWithTitle.target[0].source.title
Kode lerroa:         } /* PVSCL:IFCOND(Hypothesis) */else {
Kode lerroa: 
Kode lerroa:       } catch (e) {
Kode lerroa:         title = 'Document ' + i
Kode lerroa:       }
Kode lerroa:       // Retrieve reliable URL for the primary study
Kode lerroa:       let reliableURL = _.find(_.map(codingAnnotationsForPrimaryStudy, (annotation) => {
Kode lerroa:         return AnnotationUtils.getReliableURItoLocateTarget(annotation)
Kode lerroa:       }), (possibleReliableURLs) => {
Kode lerroa:         return possibleReliableURLs !== null
Kode lerroa:       })
Kode lerroa:       reliableURL = reliableURL || 'undefined' // TODO In the case that no reliableURL is found, go to the annotation if annotation server is Hypothes.is (check if it is possible to do the same with other remote annotation servers (e.g.: Neo4J)
Kode lerroa:       // Retrieve users for current primary study
Kode lerroa:       const usersForPrimaryStudy = _.map(_.uniqBy(codingAnnotationsForPrimaryStudy, (anno) => { return anno.user }), 'user')
Kode lerroa:       const primaryStudy = new PrimaryStudy({ metadata: { url: reliableURL, title: title }, users: usersForPrimaryStudy })
Kode lerroa:       const parentCodes = GoogleSheetGenerator.parseCodesFromCodingAnnotations({
Kode lerroa:         targetUrl: reliableURL,
Kode lerroa:         codingAnnotations: codingAnnotationsForPrimaryStudy,
Kode lerroa:         validatingAnnotations
Kode lerroa:       })
Kode lerroa:       primaryStudy.codes = parentCodes
Kode lerroa:       primaryStudies.push(primaryStudy)
Kode lerroa:     }
Kode lerroa:     return { primaryStudies: primaryStudies, users: users }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static parseCodesFromCodingAnnotations ({ codingAnnotations, validatingAnnotations, targetUrl }) {
Kode lerroa:     const classifiedThemes = {}
Kode lerroa:     for (let i = 0; i < codingAnnotations.length; i++) {
Kode lerroa:       const codingAnnotation = codingAnnotations[i]
Kode lerroa:       // Check if annotation is validated
Kode lerroa:       const validatingAnnotation = _.find(validatingAnnotations, (validatingAnnotation) => {
Kode lerroa:         const validatedAnnotationId = validatingAnnotation[Config.namespace + ':target'].replace('https://hypothes.is/api/annotations/', '')
Kode lerroa:         return codingAnnotation.id === validatedAnnotationId
Kode lerroa:       })
Kode lerroa:       // Get code or theme that is classified with
Kode lerroa:       const codingAnnotationBody = codingAnnotation.body.find(body => body.purpose === 'classifying')
Kode lerroa:       const themeOrCode = window.abwa.codebookManager.codebookReader.codebook.getCodeOrThemeFromId(codingAnnotationBody.value.id)
Kode lerroa:       let theme
Kode lerroa:       let code
Kode lerroa:       if (LanguageUtils.isInstanceOf(themeOrCode, Theme)) {
Kode lerroa:         theme = themeOrCode
Kode lerroa:       } else {
Kode lerroa:         theme = themeOrCode.theme
Kode lerroa:         code = themeOrCode
Kode lerroa:       }
Kode lerroa:       if (code) {
Kode lerroa:         // What is classified is the code
Kode lerroa:         if (classifiedThemes[theme.id]) {
Kode lerroa:           // Theme is already classified by another annotation
Kode lerroa:         } else {
Kode lerroa:           // Theme is not classified by any other annotation yet
Kode lerroa:           const chosenCodes = {}
Kode lerroa:           chosenCodes[code.id] = new Code({ codeId: code.id, codeName: code.name, annotations: [codingAnnotation], validatingAnnotation, targetUrl })
Kode lerroa:           classifiedThemes[theme.id] = new Codes({ theme, chosenCodes, multivalued: theme.multivalued, targetUrl })
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         // What is classified is the theme
Kode lerroa:         if (classifiedThemes[theme.id]) {
Kode lerroa:           // Theme is already classified by another annotation, nothing to do if not validated
Kode lerroa:         } else {
Kode lerroa:           classifiedThemes[theme.id] = new Codes({ theme, chosenCodes: {}, itself: codingAnnotation, multivalued: theme.multivalued })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return classifiedThemes
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static calculateColumns (primaryStudies) {
Kode lerroa:     // Get all parent codes
Kode lerroa:     const themes = window.abwa.codebookManager.codebookReader.codebook.themes
Kode lerroa:     return themes.map((theme) => {
Kode lerroa:       const primaryStudyWithMaxValuesForThisCode = _.maxBy(primaryStudies, (ps) => {
Kode lerroa:         if (_.has(ps.codes, theme.id)) {
Kode lerroa:           return ps.codes[theme.id].numberOfColumns()
Kode lerroa:         } else {
Kode lerroa:           return 1
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       if (!_.isUndefined(primaryStudyWithMaxValuesForThisCode) && _.has(primaryStudyWithMaxValuesForThisCode.codes, theme.id)) {
Kode lerroa:         return { theme: theme, columns: primaryStudyWithMaxValuesForThisCode.codes[theme.id].numberOfColumns() }
Kode lerroa:       } else {
Kode lerroa:         return { theme: theme, columns: 1 }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: class PrimaryStudy {
Kode lerroa:   constructor ({ metadata, codes, users }) {
Kode lerroa:     this.title = metadata.title
Kode lerroa:     this.url = metadata.url
Kode lerroa:     this.codes = codes
Kode lerroa:     this.users = users // Users that had codified this primary study
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toSpreadsheetRow (codesColumnCalc) {
Kode lerroa:     let cells = []
Kode lerroa:     // Title column
Kode lerroa:     cells.push({
Kode lerroa:       userEnteredValue: {
Kode lerroa:         formulaValue: '=HYPERLINK("' + this.url + '", "' + this.title + '")'
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // Calculate the rest of the columns based on columnsCalc
Kode lerroa:     for (let i = 0; i < codesColumnCalc.length; i++) {
Kode lerroa:       const lengthOfCurrentColumn = codesColumnCalc[i].columns
Kode lerroa:       const theme = codesColumnCalc[i].theme
Kode lerroa:       if (_.has(this.codes, theme.id)) {
Kode lerroa:         // Filled cells
Kode lerroa:         const currentCodeCells = this.codes[theme.id].toCells(this.users)
Kode lerroa:         // Empty cells
Kode lerroa:         for (let j = currentCodeCells.length; j < lengthOfCurrentColumn; j++) {
Kode lerroa:           currentCodeCells.push({ userEnteredValue: { stringValue: '' } })
Kode lerroa:         }
Kode lerroa:         cells = cells.concat(currentCodeCells)
Kode lerroa:       } else {
Kode lerroa:         // No evidence in current primary study for that code, all empty
Kode lerroa:         // Empty cells
Kode lerroa:         for (let j = 0; j < lengthOfCurrentColumn; j++) {
Kode lerroa:           cells.push({ userEnteredValue: { stringValue: '' } })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       values: cells
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: class Code {
Kode lerroa:   constructor ({ codeId, codeName, annotations, validatingAnnotation, targetUrl }) {
Kode lerroa:     this.codeId = codeId
Kode lerroa:     this.codeName = codeName
Kode lerroa:     this.annotations = annotations
Kode lerroa:     this.validatingAnnotation = validatingAnnotation
Kode lerroa:     this.targetUrl = targetUrl
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toCell (users) {
Kode lerroa:     if (this.validatingAnnotation) {
Kode lerroa:       // Find validated annotation
Kode lerroa:       const validatedAnnotationId = this.validatingAnnotation[Config.namespace + ':target'].replace('https://hypothes.is/api/annotations/', '')
Kode lerroa:       let annotation = _.find(this.annotations, (annotation) => { return annotation.id === validatedAnnotationId })
Kode lerroa:       if (!_.isObject(annotation)) { // If not found, retrieve first annotation, but something is probably wrong
Kode lerroa:         annotation = this.annotations[0]
Kode lerroa:       }
Kode lerroa:       return {
Kode lerroa:         userEnteredValue: {
Kode lerroa:           formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + this.codeName + '")'
Kode lerroa:         },
Kode lerroa:         userEnteredFormat: {
Kode lerroa:           backgroundColor: HyperSheetColors.green
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       if (users.length > 1) {
Kode lerroa:         // Yellow or red, because more than one user has annotations in this Primary Study
Kode lerroa:         const allUsersWithThisCode = _.every(users, (user) => {
Kode lerroa:           return _.find(this.annotations, (annotation) => {
Kode lerroa:             return annotation.user === user
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:         const annotation = this.annotations[0]
Kode lerroa:         if (allUsersWithThisCode) {
Kode lerroa:           return {
Kode lerroa:             userEnteredValue: {
Kode lerroa:               formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + this.codeName + '")'
Kode lerroa:             },
Kode lerroa:             userEnteredFormat: {
Kode lerroa:               backgroundColor: HyperSheetColors.yellow
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           return {
Kode lerroa:             userEnteredValue: {
Kode lerroa:               formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + this.codeName + '")'
Kode lerroa:             },
Kode lerroa:             userEnteredFormat: {
Kode lerroa:               backgroundColor: HyperSheetColors.red
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         // If only 1 user has annotated, it must be white
Kode lerroa:         const annotation = this.annotations[0]
Kode lerroa:         return {
Kode lerroa:           userEnteredValue: {
Kode lerroa:             formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + this.codeName + '")'
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: Code.status = {
Kode lerroa:   inProgress: {
Kode lerroa:     name: 'inProgress'
Kode lerroa:   },
Kode lerroa:   conflicting: {
Kode lerroa:     name: 'conflicting'
Kode lerroa:   },
Kode lerroa:   coinciding: {
Kode lerroa:     name: 'coinciding'
Kode lerroa:   },
Kode lerroa:   validated: {
Kode lerroa:     name: 'validated'
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: class Codes {
Kode lerroa:   constructor ({ parentCode, chosenCodes = {}, itself, multivalued = false, validatingAnnotation, targetUrl }) {
Kode lerroa:     this.parentCode = parentCode
Kode lerroa:     this.chosenCodes = chosenCodes
Kode lerroa:     this.itself = itself
Kode lerroa:     this.multivalued = multivalued
Kode lerroa:     this.validatingAnnotation = validatingAnnotation
Kode lerroa:     this.targetUrl = targetUrl
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   numberOfColumns () {
Kode lerroa:     if (this.multivalued) {
Kode lerroa:       return _.values(this.chosenCodes).length || 1
Kode lerroa:     } else {
Kode lerroa:       return 1
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toCells (allUsers) {
Kode lerroa:     const pairs = _.toPairs(this.chosenCodes)
Kode lerroa:     if (pairs.length > 0) {
Kode lerroa:       if (this.multivalued) {
Kode lerroa:         // If multivalued
Kode lerroa:         const chosenCodes = _.values(this.chosenCodes)
Kode lerroa:         const cells = []
Kode lerroa:         for (let i = 0; i < chosenCodes.length; i++) {
Kode lerroa:           const chosenCode = chosenCodes[i]
Kode lerroa:           cells.push(chosenCode.toCell(allUsers))
Kode lerroa:         }
Kode lerroa:         return cells
Kode lerroa:       } else {
Kode lerroa:         // No multivalued, codify status
Kode lerroa:         const chosenCodes = _.values(this.chosenCodes)
Kode lerroa:         // Check if someone is validated
Kode lerroa:         const validatedCode = _.find(chosenCodes, (chosenCode) => { return chosenCode.validatingAnnotation })
Kode lerroa:         if (validatedCode) {
Kode lerroa:           // Find validated annotation
Kode lerroa:           const validatedAnnotationId = validatedCode.validatingAnnotation[Config.namespace + ':target'].replace('https://hypothes.is/api/annotations/', '')
Kode lerroa:           let annotation = _.find(validatedCode.annotations, (annotation) => { return annotation.id === validatedAnnotationId })
Kode lerroa:           if (!_.isObject(annotation)) { // If not found, retrieve first annotation, but something is probably wrong
Kode lerroa:             annotation = validatedCode.annotations[0]
Kode lerroa:           }
Kode lerroa:           return [{
Kode lerroa:             userEnteredValue: {
Kode lerroa:               formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + validatedCode.codeName + '")'
Kode lerroa:             },
Kode lerroa:             userEnteredFormat: {
Kode lerroa:               backgroundColor: HyperSheetColors.green
Kode lerroa:             }
Kode lerroa:           }]
Kode lerroa:         } else {
Kode lerroa:           // Can be in conflict or coinciding, if more than one code, is conflicting, if only one, coinciding or in-progress
Kode lerroa:           if (chosenCodes.length > 1) {
Kode lerroa:             const annotation = chosenCodes[0].annotations[0] // Retrieve one annotation
Kode lerroa:             // Conflict
Kode lerroa:             return [{
Kode lerroa:               userEnteredValue: {
Kode lerroa:                 formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + chosenCodes[0].codeName + '")'
Kode lerroa:               },
Kode lerroa:               userEnteredFormat: {
Kode lerroa:                 backgroundColor: HyperSheetColors.red
Kode lerroa:               }
Kode lerroa:             }]
Kode lerroa:           } else {
Kode lerroa:             // Review all users
Kode lerroa:             const annotation = chosenCodes[0].annotations[0] // Retrieve one annotation
Kode lerroa:             const chosenCode = chosenCodes[0]
Kode lerroa:             const every = _.every(allUsers, (user) => {
Kode lerroa:               const index = _.findIndex(chosenCode.annotations, (annotation) => {
Kode lerroa:                 return user === annotation.user
Kode lerroa:               })
Kode lerroa:               return index !== -1
Kode lerroa:             })
Kode lerroa:             /* let every = _.every(chosenCode.annotations, (annotation) => {
Kode lerroa:               let index = _.findIndex(allUsers, (user) => {
Kode lerroa:                 return user === annotation.user
Kode lerroa:               })
Kode lerroa:               return index !== -1
Kode lerroa:             }) */
Kode lerroa:             if (every && allUsers.length > 1) {
Kode lerroa:               // All reviewers has annotated with that code and more than one reviewer has codified the PS
Kode lerroa:               return [{
Kode lerroa:                 userEnteredValue: {
Kode lerroa:                   formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + chosenCodes[0].codeName + '")'
Kode lerroa:                 },
Kode lerroa:                 userEnteredFormat: {
Kode lerroa:                   backgroundColor: HyperSheetColors.yellow
Kode lerroa:                 }
Kode lerroa:               }]
Kode lerroa:             } else {
Kode lerroa:               // Not all reviewers has annotated with that code or there is only one reviewer that has codified the PS
Kode lerroa:               return [{
Kode lerroa:                 userEnteredValue: {
Kode lerroa:                   formulaValue: '=HYPERLINK("' + this.targetUrl + '#' + Config.urlParamName + ':' + annotation.id + '", "' + chosenCodes[0].codeName + '")'
Kode lerroa:                 }
Kode lerroa:               }]
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       if (this.itself) {
Kode lerroa:         // Get quote of annotation in itself
Kode lerroa:         const textQuoteSelector = _.find(this.itself.target[0].selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:         let quote = 'Quote'
Kode lerroa:         if (textQuoteSelector && textQuoteSelector.exact) {
Kode lerroa:           quote = textQuoteSelector.exact
Kode lerroa:         }
Kode lerroa:         if (this.validatingAnnotation) {
Kode lerroa:           return [
Kode lerroa:             {
Kode lerroa:               userEnteredValue: {
Kode lerroa:                 formulaValue: '=HYPERLINK("' + this.itself.uri + '#' + Config.urlParamName + ':' + this.itself.id + '", "' + quote + '")'
Kode lerroa:               },
Kode lerroa:               userEnteredFormat: {
Kode lerroa:                 backgroundColor: HyperSheetColors.yellow
Kode lerroa:               }
Kode lerroa:             }]
Kode lerroa:         } else {
Kode lerroa:           return [{
Kode lerroa:             userEnteredValue: {
Kode lerroa:               formulaValue: '=HYPERLINK("' + this.itself.uri + '#' + Config.urlParamName + ':' + this.itself.id + '", "' + quote + '")'
Kode lerroa:             }
Kode lerroa:           }]
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return []
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GoogleSheetGenerator
Kode lerroa: import Commenting from '../purposes/Commenting'
Kode lerroa: import MoodleClientManager from '../../moodle/MoodleClientManager'
Kode lerroa: import Events from '../../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleUtils from '../../moodle/MoodleUtils'
Kode lerroa: 
Kode lerroa: class MoodleComment {
Kode lerroa:   constructor () {
Kode lerroa:     this.moodleClientManager = null
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     this.moodleClientManager = new MoodleClientManager(window.abwa.codebookManager.codebookReader.codebook.moodleEndpoint)
Kode lerroa:     this.moodleClientManager.init(() => {
Kode lerroa:       this.events.annotationCreatedEvent = { element: document, event: Events.annotationCreated, handler: this.createdAnnotationHandler() }
Kode lerroa:       this.events.annotationCreatedEvent.element.addEventListener(this.events.annotationCreatedEvent.event, this.events.annotationCreatedEvent.handler, false)
Kode lerroa:     })
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createdAnnotationHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const annotation = event.detail.annotation
Kode lerroa:       // If annotation has references, means that it is an annotation replying another annotation
Kode lerroa:       if (annotation.references.length >= 1) {
Kode lerroa:         // Construct annotation link
Kode lerroa:         const url = MoodleUtils.createURLForAnnotation({
Kode lerroa:           annotation: event.detail.annotation,
Kode lerroa:           studentId: window.abwa.targetManager.fileMetadata.studentId,
Kode lerroa:           cmid: window.abwa.targetManager.fileMetadata.cmid,
Kode lerroa:           courseId: window.abwa.targetManager.fileMetadata.courseId
Kode lerroa:         })
Kode lerroa:         const commentingBody = annotation.getBodyForPurpose(Commenting.purpose)
Kode lerroa:         const text = '<a href="' + url + '">' + commentingBody.value + '</a>'
Kode lerroa:         this.moodleClientManager.addSubmissionComment({
Kode lerroa:           courseId: window.abwa.targetManager.fileMetadata.courseId,
Kode lerroa:           text: text,
Kode lerroa:           studentId: window.abwa.targetManager.fileMetadata.studentId,
Kode lerroa:           itemId: '',
Kode lerroa:           contextId: ''
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     // Remove the event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleComment
Kode lerroa: import MoodleClientManager from '../../moodle/MoodleClientManager'
Kode lerroa: import MoodleUtils from '../../moodle/MoodleUtils'
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Config from '../../Config'
Kode lerroa: import Events from '../../Events'
Kode lerroa: import Commenting from '../purposes/Commenting'
Kode lerroa: // const linkifyUrls = require('linkify-urls')
Kode lerroa: 
Kode lerroa: class MoodleReport {
Kode lerroa:   constructor () {
Kode lerroa:     this.moodleClientManager = null
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing moodle report')
Kode lerroa:     this.moodleClientManager = new MoodleClientManager(window.abwa.codebookManager.codebookReader.codebook.moodleEndpoint)
Kode lerroa:     this.moodleClientManager.init(() => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         console.debug('Initialized moodle report')
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // TODO Listens when annotation is created, updated, deleted or codeToAll
Kode lerroa:     this.initEventListeners()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initEventListeners (callback) {
Kode lerroa:     this.events.annotatedContentManagerUpdatedEvent = { element: document, event: Events.annotatedContentManagerUpdated, handler: this.createUpdateMoodleFromMarksEventListener() }
Kode lerroa:     this.events.annotatedContentManagerUpdatedEvent.element.addEventListener(this.events.annotatedContentManagerUpdatedEvent.event, this.events.annotatedContentManagerUpdatedEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createUpdateMoodleFromMarksEventListener () {
Kode lerroa:     return () => {
Kode lerroa:       const annotatedThemes = window.abwa.annotatedContentManager.annotatedThemes
Kode lerroa:       window.abwa.moodleReport.updateMoodleFromMarks(annotatedThemes, (err) => {
Kode lerroa:         if (err) {
Kode lerroa:           Alerts.errorAlert({
Kode lerroa:             text: 'Unable to push marks to moodle, please make sure that you are logged in Moodle and try it again.' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack]),
Kode lerroa:             title: 'Unable to update marks in moodle'
Kode lerroa:           })
Kode lerroa:         } else {
Kode lerroa:           Alerts.temporalAlert({
Kode lerroa:             text: 'The mark is updated in moodle',
Kode lerroa:             title: 'Correctly marked',
Kode lerroa:             type: Alerts.alertType.success,
Kode lerroa:             toast: true
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateMoodleFromMarks (annotatedThemes, callback) {
Kode lerroa:     // Get all code annotations
Kode lerroa:     let annotations = []
Kode lerroa:     for (let i = 0; i < annotatedThemes.length; i++) {
Kode lerroa:       const themeId = annotatedThemes[i].theme.id
Kode lerroa:       const currentlyAnnotatedCode = window.abwa.annotatedContentManager.searchAnnotatedCodeForGivenThemeId(themeId)
Kode lerroa:       if (currentlyAnnotatedCode) {
Kode lerroa:         const codeAnnotaions = currentlyAnnotatedCode.annotations
Kode lerroa:         annotations.push(codeAnnotaions)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     annotations = _.flatten(annotations)
Kode lerroa:     // let annotations = _.flatten(_.map(annotatedThemes, annotatedTheme => annotatedTheme.annotations))
Kode lerroa:     // Get student id
Kode lerroa:     const studentId = window.abwa.targetManager.fileMetadata.studentId
Kode lerroa:     // Filter from search only the annotations which are used to classify and are from this cmid
Kode lerroa:     const cmid = window.abwa.codebookManager.codebookReader.codebook.cmid
Kode lerroa:     annotations = _.filter(annotations, (anno) => {
Kode lerroa:       return anno.uri !== window.abwa.groupSelector.currentGroup.links.html &&
Kode lerroa:         _.find(anno.tags, (tag) => {
Kode lerroa:           return tag === 'cmid:' + cmid
Kode lerroa:         })
Kode lerroa:     })
Kode lerroa:     const marks = _.map(annotations, (annotation) => {
Kode lerroa:       const criteriaName = _.find(annotation.tags, (tag) => {
Kode lerroa:         return tag.includes(Config.namespace + ':' + Config.tags.grouped.relation + ':')
Kode lerroa:       }).replace(Config.namespace + ':' + Config.tags.grouped.relation + ':', '')
Kode lerroa:       let levelName = _.find(annotation.tags, (tag) => {
Kode lerroa:         return tag.includes(Config.namespace + ':' + Config.tags.grouped.subgroup + ':')
Kode lerroa:       })
Kode lerroa:       if (levelName) {
Kode lerroa:         levelName = levelName.replace(Config.namespace + ':' + Config.tags.grouped.subgroup + ':', '')
Kode lerroa:       } else {
Kode lerroa:         levelName = null
Kode lerroa:       }
Kode lerroa:       const url = MoodleUtils.createURLForAnnotation({ annotation, studentId, courseId: window.abwa.codebookManager.codebookReader.codebook.courseId, cmid: cmid })
Kode lerroa:       // Construct feedback
Kode lerroa:       const comment = annotation.getBodyForPurpose(Commenting.purpose)
Kode lerroa:       const text = comment ? comment.value : ''
Kode lerroa:       let feedbackCommentElement = ''
Kode lerroa:       if (text) {
Kode lerroa:         /* let urlizedText = linkifyUrls(text, {
Kode lerroa:           attributes: {
Kode lerroa:             target: '_blank'
Kode lerroa:           }
Kode lerroa:         }) */
Kode lerroa:         const urlizedText = text
Kode lerroa:         const quoteSelector = _.find(annotation.target[0].selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:         if (quoteSelector) {
Kode lerroa:           feedbackCommentElement = '<b>' + urlizedText + '</b><br/><a href="' + url + '">See in context</a>'
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         feedbackCommentElement = '<b>-</b><br/><a href="' + url + '">See in context</a>'
Kode lerroa:       }
Kode lerroa:       return { criteriaName, levelName, text, url, feedbackCommentElement }
Kode lerroa:     })
Kode lerroa:     console.log(marks)
Kode lerroa:     // Reorder criterias as same as are presented in rubric
Kode lerroa:     const sortingArr = _.map(window.abwa.codebookManager.codebookReader.codebook.themes, 'name')
Kode lerroa:     marks.slice().sort((a, b) => {
Kode lerroa:       return sortingArr.indexOf(a.criteriaName) - sortingArr.indexOf(b.criteriaName)
Kode lerroa:     })
Kode lerroa:     console.log(marks)
Kode lerroa:     // Get for each criteria name and mark its corresponding criterionId and level from window.abwa.rubric
Kode lerroa:     const criterionAndLevels = this.getCriterionAndLevel(marks)
Kode lerroa:     const feedbackComment = this.getFeedbackComment(marks)
Kode lerroa:     // Compose moodle data
Kode lerroa:     const moodleGradingData = this.composeMoodleGradingData({
Kode lerroa:       criterionAndLevels,
Kode lerroa:       userId: studentId,
Kode lerroa:       assignmentId: window.abwa.codebookManager.codebookReader.codebook.assignmentId,
Kode lerroa:       feedbackComment: feedbackComment
Kode lerroa:     })
Kode lerroa:     // Update student grading in moodle
Kode lerroa:     this.moodleClientManager.updateStudentGradeWithRubric(moodleGradingData, (err) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getCriterionAndLevel (marks) {
Kode lerroa:     const annotationGuide = window.abwa.codebookManager.codebookReader.codebook
Kode lerroa:     const criterionAndLevel = []
Kode lerroa:     for (let i = 0; i < marks.length; i++) {
Kode lerroa:       const mark = marks[i]
Kode lerroa:       const criteria = _.find(annotationGuide.themes, (theme) => {
Kode lerroa:         return theme.name === mark.criteriaName
Kode lerroa:       })
Kode lerroa:       let level = _.find(criteria.codes, (code) => {
Kode lerroa:         return code.name === mark.levelName
Kode lerroa:       })
Kode lerroa:       if (_.isUndefined(level)) {
Kode lerroa:         level = { levelId: -1 }
Kode lerroa:       }
Kode lerroa:       const remark = mark.text
Kode lerroa:       criterionAndLevel.push({ criterionId: criteria.moodleCriteriaId, levelid: level.moodleLevelId, remark })
Kode lerroa:     }
Kode lerroa:     console.log(criterionAndLevel)
Kode lerroa:     const resultingMarks = {}
Kode lerroa:     // TODO Append links if shared
Kode lerroa:     // Merge remarks with same criterionId and append remark
Kode lerroa:     _.forEach(criterionAndLevel, (crit) => {
Kode lerroa:       const remark = _.has(resultingMarks[crit.criterionId], 'remark') ? resultingMarks[crit.criterionId].remark + '\n\n' + crit.remark : crit.remark
Kode lerroa:       const levelid = crit.levelid
Kode lerroa:       resultingMarks[crit.criterionId] = { remark: remark, levelid: levelid }
Kode lerroa:     })
Kode lerroa:     // Convert merge object to an array
Kode lerroa:     return _.map(resultingMarks, (mark, key) => { return { criterionId: key, levelid: mark.levelid, remark: mark.remark } })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getFeedbackComment (marks) {
Kode lerroa:     let feedbackComment = '<h2>How to see feedback in your assignment?</h2><ul>' +
Kode lerroa:       '<li><a target="_blank" href="https://chrome.google.com/webstore/detail/markgo/kjedcndgienemldgjpjjnhjdhfoaocfa">Install Mark&Go</a></li>' +
Kode lerroa:       '<li><a target="_blank" href="' + window.abwa.groupSelector.currentGroup.links.html + '">Join feedback group</a></li>' +
Kode lerroa:       '</ul><hr/>' // TODO i18n
Kode lerroa:     const groupedMarksArray = _.values(_.groupBy(marks, 'criteriaName'))
Kode lerroa:     _.forEach(groupedMarksArray, (markGroup) => {
Kode lerroa:       // Criteria + level
Kode lerroa:       const criteria = markGroup[0].criteriaName
Kode lerroa:       const levelId = markGroup[0].levelName
Kode lerroa:       feedbackComment += '<h3>Criteria: ' + criteria + ' - Mark: ' + levelId + '</h3><br/>'
Kode lerroa:       // Comments
Kode lerroa:       _.forEach(markGroup, (mark) => {
Kode lerroa:         feedbackComment += mark.feedbackCommentElement + '<br/>'
Kode lerroa:       })
Kode lerroa:       // hr
Kode lerroa:       feedbackComment += '<hr/>'
Kode lerroa:     })
Kode lerroa:     return feedbackComment
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   composeMoodleGradingData ({ criterionAndLevels, userId, assignmentId, feedbackComment }) {
Kode lerroa:     const rubric = { criteria: [] }
Kode lerroa:     for (let i = 0; i < criterionAndLevels.length; i++) {
Kode lerroa:       const criterionAndLevel = criterionAndLevels[i]
Kode lerroa:       if (criterionAndLevel.levelid > -1) { // If it is -1, the student is not grade for this criteria
Kode lerroa:         rubric.criteria.push({
Kode lerroa:           criterionid: criterionAndLevel.criterionId,
Kode lerroa:           fillings: [
Kode lerroa:             {
Kode lerroa:               criterionid: '0',
Kode lerroa:               levelid: criterionAndLevel.levelid,
Kode lerroa:               remark: criterionAndLevel.remark,
Kode lerroa:               remarkformat: 1
Kode lerroa:             }
Kode lerroa:           ]
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       userid: userId + '',
Kode lerroa:       assignmentid: assignmentId,
Kode lerroa:       attemptnumber: '-1',
Kode lerroa:       addattempt: 1,
Kode lerroa:       workflowstate: '',
Kode lerroa:       applytoall: 1,
Kode lerroa:       grade: '0',
Kode lerroa:       advancedgradingdata: { rubric: rubric },
Kode lerroa:       plugindata: {
Kode lerroa:         assignfeedbackcomments_editor: {
Kode lerroa:           format: '1', // HTML
Kode lerroa:           text: feedbackComment
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     // Remove the event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleReport
Kode lerroa: import DOMTextUtils from '../../utils/DOMTextUtils'
Kode lerroa: // TODO const PDFTextUtils = require('../../utils/PDFTextUtils')
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: import Events from '../../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa: import Annotation from '../Annotation'
Kode lerroa: // PVSCL:IFCOND(Replying, LINE)
Kode lerroa: 
Kode lerroa: import $ from 'jquery'
Kode lerroa: // PVSCL:IFCOND(Commenting, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Remote, LINE)
Kode lerroa: 
Kode lerroa: const ANNOTATION_OBSERVER_INTERVAL_IN_SECONDS = 3
Kode lerroa: require('jquery-contextmenu/dist/jquery.contextMenu')
Kode lerroa: 
Kode lerroa: class ReadAnnotation {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     // Event listener created annotation
Kode lerroa:     this.initAnnotationCreatedEventListener()
Kode lerroa:     // Event listener deleted annotation
Kode lerroa:     this.initAnnotationDeletedEventListener()
Kode lerroa:     // PVSCL:IFCOND(DeleteAll, LINE)
Kode lerroa: 
Kode lerroa:     // Event listener updated annotation
Kode lerroa:     // PVSCL:IFCOND(Update, LINE)
Kode lerroa: 
Kode lerroa:     this.loadAnnotations((err) => {
Kode lerroa:       // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(err)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:     this.initAnnotationsObserver()
Kode lerroa:     // PVSCL:IFCOND(Remote, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ImportAnnotations, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:     // Destroy annotations observer
Kode lerroa:     clearInterval(this.observerInterval)
Kode lerroa:     // PVSCL:IFCOND(Remote, LINE)
Kode lerroa: 
Kode lerroa:     // Destroy annotations clean interval if exist
Kode lerroa:     clearInterval(this.cleanInterval)
Kode lerroa:     // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Remote, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Initializes annotations observer, to ensure dynamic web pages maintain highlights on the screen
Kode lerroa:    * @param callback Callback when initialization finishes
Kode lerroa:    */
Kode lerroa:   initAnnotationsObserver (callback) {
Kode lerroa:     this.observerInterval = setInterval(() => {
Kode lerroa:       // console.debug('Observer interval')
Kode lerroa:       let annotationsToHighlight
Kode lerroa:       // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:       if (annotationsToHighlight) {
Kode lerroa:         for (let i = 0; i < this.allAnnotations.length; i++) {
Kode lerroa:           const annotation = this.allAnnotations[i]
Kode lerroa:           // Search if annotation exist
Kode lerroa:           const element = document.querySelector('[data-annotation-id="' + annotation.id + '"]')
Kode lerroa:           // If annotation doesn't exist, try to find it
Kode lerroa:           if (!_.isElement(element)) {
Kode lerroa:             Promise.resolve().then(() => { this.highlightAnnotation(annotation) })
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }, ANNOTATION_OBSERVER_INTERVAL_IN_SECONDS * 1000)
Kode lerroa:     // TODO Improve the way to highlight to avoid this interval (when search in PDFs it is highlighted empty element instead of element)
Kode lerroa:     this.cleanInterval = setInterval(() => {
Kode lerroa:       // console.debug('Clean interval')
Kode lerroa:       const highlightedElements = document.querySelectorAll('.highlightedAnnotation')
Kode lerroa:       highlightedElements.forEach((element) => {
Kode lerroa:         if (element.innerText === '') {
Kode lerroa:           $(element).remove()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }, ANNOTATION_OBSERVER_INTERVAL_IN_SECONDS * 1000)
Kode lerroa:     // Callback
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Create, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Delete, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   updateAllAnnotations (callback) {
Kode lerroa:     // Retrieve annotations for current url and group
Kode lerroa:     window.abwa.annotationServerManager.client.searchAnnotations({
Kode lerroa:       url: window.abwa.targetManager.getDocumentURIToSearchInAnnotationServer(),
Kode lerroa:       uri: window.abwa.targetManager.getDocumentURIToSaveInAnnotationServer(),
Kode lerroa:       group: window.abwa.groupSelector.currentGroup.id,
Kode lerroa:       order: 'asc'
Kode lerroa:     }, (err, annotationObjects) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         // Deserialize retrieved annotations
Kode lerroa:         this.allAnnotations = annotationObjects.map(annotationObject => Annotation.deserialize(annotationObject))
Kode lerroa:         // PVSCL:IFCOND(Replying, LINE)
Kode lerroa: 
Kode lerroa:         // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:         // Redraw all annotations
Kode lerroa:         this.redrawAnnotations()
Kode lerroa:         LanguageUtils.dispatchCustomEvent(Events.updatedAllAnnotations, { annotations: this.allAnnotations })
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, this.allAnnotations)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadAnnotations (callback) {
Kode lerroa:     this.updateAllAnnotations((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:         // TODO Show user no able to load all annotations
Kode lerroa:         console.error('Unable to load annotations')
Kode lerroa:       } else {
Kode lerroa:         let unHiddenAnnotations
Kode lerroa:         // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:         // PVSCL:IFCOND(Selector, LINE)
Kode lerroa: 
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   retrieveCurrentAnnotations () {
Kode lerroa:     let currentAnnotations
Kode lerroa:     // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:     return currentAnnotations
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Selector, LINE)
Kode lerroa: 
Kode lerroa:           },
Kode lerroa:           items: items
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   redrawAnnotations (callback) {
Kode lerroa:     // Unhighlight all annotations
Kode lerroa:     this.unHighlightAllAnnotations()
Kode lerroa:     // Highlight all annotations
Kode lerroa:     // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   unHighlightAllAnnotations () {
Kode lerroa:     // Remove created annotations
Kode lerroa:     const highlightedElements = [...document.querySelectorAll('[data-annotation-id]')]
Kode lerroa:     DOMTextUtils.unHighlightElements(highlightedElements)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createDoubleClickEventHandler (annotation) {
Kode lerroa:     const highlights = document.querySelectorAll('[data-annotation-id="' + annotation.id + '"]')
Kode lerroa:     for (let i = 0; i < highlights.length; i++) {
Kode lerroa:       const highlight = highlights[i]
Kode lerroa:       highlight.addEventListener('dblclick', () => {
Kode lerroa:         this.commentAnnotationHandler(annotation)
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:ENDCOND
Kode lerroa:   // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Update, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(DeleteAll, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ImportAnnotations, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ReadAnnotation
Kode lerroa: class Resume {
Kode lerroa:   static resume () {
Kode lerroa:     if (window.abwa.annotationManagement.annotationReader.allAnnotations.length > 0) {
Kode lerroa:       window.abwa.annotationManagement.goToAnnotation(window.abwa.annotationManagement.annotationReader.allAnnotations.reduce(
Kode lerroa:         (max, a) => a.modified > max.modified ? a : max)
Kode lerroa:       )
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Resume
Kode lerroa: import html2canvas from 'html2canvas'
Kode lerroa: import FileSaver from 'file-saver'
Kode lerroa: import JsPDF from 'jspdf'
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import PDF from '../../target/formats/PDF'
Kode lerroa: 
Kode lerroa: window.html2canvas = html2canvas
Kode lerroa: 
Kode lerroa: class Screenshots {
Kode lerroa:   static takeScreenshot (callback) {
Kode lerroa:     let promise = null
Kode lerroa:     if (window.abwa.targetManager.documentFormat === PDF) {
Kode lerroa:       // Current viewer status
Kode lerroa:       const currentScale = window.PDFViewerApplication.pdfViewer.currentScale
Kode lerroa:       window.PDFViewerApplication.pdfViewer.currentScale = 1
Kode lerroa:       const currentPage = window.PDFViewerApplication.page
Kode lerroa:       // Go to first page
Kode lerroa:       window.PDFViewerApplication.page = 1
Kode lerroa: 
Kode lerroa:       Alerts.loadingAlert({
Kode lerroa:         title: 'Please hold on',
Kode lerroa:         text: 'We are creating the annotated PDF document (<span></span> of ' + window.PDFViewerApplication.pagesCount + ')',
Kode lerroa:         timerIntervalHandler: (swal) => {
Kode lerroa:           swal.getContent().querySelector('span').textContent = window.PDFViewerApplication.page
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       // Create pdf file
Kode lerroa:       const pdf = new JsPDF('p', 'cm', 'a4', true)
Kode lerroa:       // Redraw annotations
Kode lerroa:       window.abwa.annotationManagement.annotationReader.redrawAnnotations()
Kode lerroa:       // Append rubric
Kode lerroa:       const criteriaElement = document.querySelector('#buttonContainer')
Kode lerroa:       if (criteriaElement) {
Kode lerroa:         html2canvas(criteriaElement).then((rubric) => {
Kode lerroa:           const offsetWidth = criteriaElement.offsetWidth
Kode lerroa:           const offsetHeight = criteriaElement.offsetHeight
Kode lerroa:           pdf.addImage(rubric.toDataURL(), 'png', 0, 0, 29 * offsetWidth / offsetHeight, 29)
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:       // Create promises array
Kode lerroa:       const promisesData = [...Array(window.PDFViewerApplication.pagesCount).keys()].map((index) => { return { i: index } })
Kode lerroa:       // Page screenshot promise
Kode lerroa:       const takePDFPageScreenshot = (d) => {
Kode lerroa:         return new Promise((resolve, reject) => {
Kode lerroa:           // Go to page
Kode lerroa:           window.PDFViewerApplication.page = d.i + 1
Kode lerroa:           // Redraw annotations
Kode lerroa:           window.abwa.annotationManagement.annotationReader.redrawAnnotations()
Kode lerroa:           setTimeout(() => {
Kode lerroa:             html2canvas(document.querySelector('.page[data-page-number="' + (d.i + 1) + '"]'), { scale: 1 }).then((canvas) => {
Kode lerroa:               resolve()
Kode lerroa:               if (!(d.i === 0 && !_.isElement(criteriaElement))) {
Kode lerroa:                 pdf.addPage()
Kode lerroa:               }
Kode lerroa:               pdf.addImage(canvas.toDataURL(), 'png', 0, 0, pdf.internal.pageSize.getWidth(), pdf.internal.pageSize.getHeight(), '', 'FAST')
Kode lerroa:             })
Kode lerroa:           }, 750)
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:       // Wait a little bit to draw annotations in first page
Kode lerroa:       setTimeout(() => {
Kode lerroa:         // Reduce promise chain
Kode lerroa:         const promiseChain = promisesData.reduce(
Kode lerroa:           (chain, d) => chain.then(() => {
Kode lerroa:             return takePDFPageScreenshot(d)
Kode lerroa:           }), Promise.resolve([])
Kode lerroa:         )
Kode lerroa:         // To execute after promise chain is finished
Kode lerroa:         promiseChain.then((canvases) => {
Kode lerroa:           // Restore previous page and zoom
Kode lerroa:           window.PDFViewerApplication.pdfViewer.currentScale = currentScale
Kode lerroa:           window.PDFViewerApplication.page = currentPage
Kode lerroa:           Alerts.closeAlert()
Kode lerroa:           pdf.save('activity.pdf')
Kode lerroa:           // Callback
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }, 3000)
Kode lerroa:     } else {
Kode lerroa:       promise = new Promise((resolve) => {
Kode lerroa:         html2canvas(document.body).then((canvas) => {
Kode lerroa:           resolve(canvas)
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     promise.then((canvas) => {
Kode lerroa:       canvas.toBlob((blob) => {
Kode lerroa:         FileSaver.saveAs(blob, 'exam.png')
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Screenshots
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import PDF from '../../target/formats/PDF'
Kode lerroa: import FileSaver from 'file-saver'
Kode lerroa: import { Review } from '../../exporter/reviewModel'
Kode lerroa: 
Kode lerroa: class TextSummary {
Kode lerroa:   static generateReview () {
Kode lerroa:     Alerts.loadingAlert({ text: chrome.i18n.getMessage('GeneratingReviewReport') })
Kode lerroa:     const review = Review.parseAnnotations(window.abwa.annotationManagement.annotationReader.allAnnotations)
Kode lerroa:     const report = review.toString()
Kode lerroa:     const blob = new window.Blob([report], { type: 'text/plain;charset=utf-8' })
Kode lerroa:     // If document is a PDF, get the title
Kode lerroa:     let title
Kode lerroa:     if (window.abwa.targetManager.documentFormat.pdf === PDF) {
Kode lerroa:       title = window.PDFViewerApplication.baseUrl !== null ? window.PDFViewerApplication.baseUrl.split('/')[window.PDFViewerApplication.baseUrl.split('/').length - 1].replace(/\.pdf/i, '') : ''
Kode lerroa:     } else {
Kode lerroa:       title = document.title
Kode lerroa:     }
Kode lerroa:     let docTitle = 'Review report'
Kode lerroa:     if (title !== '') docTitle += ' for ' + title
Kode lerroa:     FileSaver.saveAs(blob, docTitle + '.txt')
Kode lerroa:     Alerts.closeAlert()
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default TextSummary
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Events from '../../Events'
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: 
Kode lerroa: class UserFilter {
Kode lerroa:   constructor () {
Kode lerroa:     this.filteredUsers = [] // Includes only the users that are filtered by
Kode lerroa:     this.allUsers = [] // Includes all the users that have created annotation in the document
Kode lerroa:     this.events = {}
Kode lerroa:     this.userFilterWrapper = null
Kode lerroa:     this.usersContainer = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing UserFilter')
Kode lerroa:     this.initUserFilterStructure((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         // Handle error
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         // Annotations updated event handler
Kode lerroa:         this.initAnnotationsUpdatedEventHandler()
Kode lerroa:         // Init event handler when click in all
Kode lerroa:         this.initAllFilter()
Kode lerroa:         // Init panel construction
Kode lerroa:         this.initUsersPanel()
Kode lerroa:         console.debug('Initialized UserFilter')
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   addFilteredUser (user) {
Kode lerroa:     // If the user is not in the all users list
Kode lerroa:     if (_.isArray(this.allUsers) && !_.find(this.allUsers, user)) {
Kode lerroa:       this.allUsers.push(user)
Kode lerroa:     }
Kode lerroa:     // Add the user to the filter if it is filtered
Kode lerroa:     if (_.isArray(this.filteredUsers)) {
Kode lerroa:       if (!_.find(this.filteredUsers, user)) {
Kode lerroa:         this.filteredUsers.push(user)
Kode lerroa:         return true
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initUserFilterStructure (callback) {
Kode lerroa:     const tagWrapperUrl = chrome.extension.getURL('pages/sidebar/userFilterWrapper.html')
Kode lerroa:     $.get(tagWrapperUrl, (html) => {
Kode lerroa:       this.sidebarContainer = document.querySelector('#abwaSidebarContainer')
Kode lerroa:       // Insert user filter after toolset
Kode lerroa:       this.sidebarContainer.querySelector('#toolset').insertAdjacentHTML('afterend', html)
Kode lerroa:       this.userFilterWrapper = document.querySelector('#userFilterWrapper')
Kode lerroa:       this.usersContainer = document.querySelector('#usersContainer')
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   hideUserFilterContainer () {
Kode lerroa:     $(this.userFilterWrapper).hide()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   showUserFilterContainer () {
Kode lerroa:     $(this.userFilterWrapper).show()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initAllFilter () {
Kode lerroa:     const allFilter = document.querySelector('#userFilter_all')
Kode lerroa:     allFilter.checked = true
Kode lerroa:     // Init event handler on change all filter
Kode lerroa:     allFilter.addEventListener('change', (event) => {
Kode lerroa:       if (event.target.checked) {
Kode lerroa:         this.activateAll()
Kode lerroa:       } else {
Kode lerroa:         this.deactivateAll()
Kode lerroa:       }
Kode lerroa:       // Dispatch event user filter has changed
Kode lerroa:       this.dispatchFilterChanged()
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   activateAll () {
Kode lerroa:     const checkboxes = this.usersContainer.querySelectorAll('input')
Kode lerroa:     this.filteredUsers = _.clone(this.allUsers)
Kode lerroa:     // Activate all the checkboxes
Kode lerroa:     checkboxes.forEach((checkbox) => {
Kode lerroa:       checkbox.checked = true
Kode lerroa:       $(checkbox).attr('checked', 'true')
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deactivateAll () {
Kode lerroa:     const checkboxes = this.usersContainer.querySelectorAll('input')
Kode lerroa:     this.filteredUsers = []
Kode lerroa:     // Deactivate all the checkboxes
Kode lerroa:     checkboxes.forEach((checkbox) => {
Kode lerroa:       checkbox.checked = false
Kode lerroa:       $(checkbox).removeAttr('checked')
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initAnnotationsUpdatedEventHandler (callback) {
Kode lerroa:     this.events.updatedAllAnnotations = { element: document, event: Events.updatedAllAnnotations, handler: this.createUpdatedAllAnnotationsEventHandler() }
Kode lerroa:     this.events.updatedAllAnnotations.element.addEventListener(this.events.updatedAllAnnotations.event, this.events.updatedAllAnnotations.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createUpdatedAllAnnotationsEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Retrieve all annotations
Kode lerroa:       let annotations = []
Kode lerroa:       if (_.hasIn(event, 'detail.annotations')) {
Kode lerroa:         annotations = event.detail.annotations // If is included in the event
Kode lerroa:       } else {
Kode lerroa:         annotations = window.abwa.annotationManagement.annotationReader.allAnnotations // Or retrieve directly from annotator reader
Kode lerroa:       }
Kode lerroa:       this.updateUsersPanel(annotations)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initUsersPanel () {
Kode lerroa:     const annotations = window.abwa.annotationManagement.annotationReader.allAnnotations
Kode lerroa:     if (_.isArray(annotations)) {
Kode lerroa:       // Retrieve users who had annotated the document
Kode lerroa:       this.allUsers = _.uniq(_.map(annotations, (annotation) => {
Kode lerroa:         return annotation.creator
Kode lerroa:       }))
Kode lerroa:       this.filteredUsers = _.clone(this.allUsers)
Kode lerroa:       // Upload sidebar panel with users
Kode lerroa:       this.usersContainer.innerHTML = '' // Empty the container
Kode lerroa:       for (let i = 0; i < this.allUsers.length; i++) {
Kode lerroa:         $(this.usersContainer).append(this.createUserFilterElement(this.allUsers[i]))
Kode lerroa:       }
Kode lerroa:       // Activate all users
Kode lerroa:       const checkboxes = this.usersContainer.querySelectorAll('input')
Kode lerroa:       for (let i = 0; i < checkboxes.length; i++) {
Kode lerroa:         const currentCheckbox = checkboxes[i]
Kode lerroa:         currentCheckbox.checked = true
Kode lerroa:       }
Kode lerroa:       // If all old filtered users are current all users, just activate all of them
Kode lerroa:       this.checkAllActivated()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateUsersPanel (annotations) {
Kode lerroa:     if (_.isArray(annotations)) {
Kode lerroa:       // Retrieve users who had annotated the document
Kode lerroa:       this.allUsers = _.uniq(_.map(annotations, (annotation) => {
Kode lerroa:         return annotation.creator
Kode lerroa:       }))
Kode lerroa:       // Upload sidebar panel with users
Kode lerroa:       this.usersContainer.innerHTML = '' // Empty the container
Kode lerroa:       for (let i = 0; i < this.allUsers.length; i++) {
Kode lerroa:         $(this.usersContainer).append(this.createUserFilterElement(this.allUsers[i]))
Kode lerroa:       }
Kode lerroa:       // Activate users which where previously activated (and remove if no user is found from this.allUsers and this.filteredUsers)
Kode lerroa:       const checkboxes = this.usersContainer.querySelectorAll('input')
Kode lerroa:       for (let i = 0; i < checkboxes.length; i++) {
Kode lerroa:         const currentCheckbox = checkboxes[i]
Kode lerroa:         if (_.isString(_.find(this.filteredUsers, (oldUser) => {
Kode lerroa:           return LanguageUtils.normalizeStringToValidID(oldUser) === currentCheckbox.id.replace('userFilter_', '')
Kode lerroa:         }))) {
Kode lerroa:           currentCheckbox.checked = true
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       // If all old filtered users are current all users, just activate all of them
Kode lerroa:       this.checkAllActivated()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createUserFilterElement (name) {
Kode lerroa:     const userFilterTemplate = document.querySelector('#userFilterTemplate')
Kode lerroa:     const userFilterElement = $(userFilterTemplate.content.firstElementChild).clone().get(0)
Kode lerroa:     // Set text and properties for label and input
Kode lerroa:     const input = userFilterElement.querySelector('input')
Kode lerroa:     input.id = 'userFilter_' + LanguageUtils.normalizeStringToValidID(name)
Kode lerroa:     const label = userFilterElement.querySelector('label')
Kode lerroa:     label.innerText = name.replace(window.abwa.annotationServerManager.annotationServerMetadata.userUrl, '')
Kode lerroa:     label.htmlFor = 'userFilter_' + LanguageUtils.normalizeStringToValidID(name)
Kode lerroa:     // Set event handler for input check status
Kode lerroa:     input.addEventListener('change', (event) => {
Kode lerroa:       // Update filtered array
Kode lerroa:       if (event.target.checked) {
Kode lerroa:         // Add to filtered elements
Kode lerroa:         if (!_.includes(this.filteredUsers, name)) {
Kode lerroa:           this.filteredUsers.push(name)
Kode lerroa:         }
Kode lerroa:         // Activate all filter if all users are selected
Kode lerroa:         this.checkAllActivated()
Kode lerroa:       } else {
Kode lerroa:         // Remove from filtered elements
Kode lerroa:         _.pull(this.filteredUsers, name)
Kode lerroa:         // Deactivate all filter
Kode lerroa:         document.querySelector('#userFilter_all').checked = false
Kode lerroa:       }
Kode lerroa:       // Dispatch filter changed
Kode lerroa:       this.dispatchFilterChanged()
Kode lerroa:     })
Kode lerroa:     return userFilterElement
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Activate "All" checkbox if all the users' checkboxes are activated
Kode lerroa:    */
Kode lerroa:   checkAllActivated () {
Kode lerroa:     const allCheckboxes = this.usersContainer.querySelectorAll('input')
Kode lerroa:     const deactivatedCheckboxes = _.find(allCheckboxes, (checkbox) => { return checkbox.checked === false })
Kode lerroa:     if (_.isUndefined(deactivatedCheckboxes)) { // There are not found any deactivated checkboxes
Kode lerroa:       document.querySelector('#userFilter_all').checked = true
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   dispatchFilterChanged () {
Kode lerroa:     LanguageUtils.dispatchCustomEvent(Events.userFilterChange, { filteredUsers: this.filteredUsers })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove observer
Kode lerroa:     // clearInterval(this.observerInterval)
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:     // Remove user filter container from sidebar
Kode lerroa:     if (_.isElement(this.userFilterWrapper)) {
Kode lerroa:       this.userFilterWrapper.remove()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default UserFilter
Kode lerroa: import _ from 'lodash'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Commenting, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(SuggestedLiterature, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Assessing, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class Annotation {
Kode lerroa:   constructor ({
Kode lerroa:     id,
Kode lerroa:     body = [],
Kode lerroa:     references = [],
Kode lerroa:     group = window.abwa.groupSelector.currentGroup.id,
Kode lerroa:     permissions = {
Kode lerroa:       read: ['group:' + window.abwa.groupSelector.currentGroup.id]
Kode lerroa:     },
Kode lerroa:     target,
Kode lerroa:     tags = [],
Kode lerroa:     creator = window.abwa.groupSelector.getCreatorData() || window.abwa.groupSelector.user.userid,
Kode lerroa:     created,
Kode lerroa:     modified
Kode lerroa:   }) {
Kode lerroa:     if (!_.isArray(target) || _.isEmpty(target[0])) {
Kode lerroa:       throw new Error('Annotation must have a non-empty target')
Kode lerroa:     }
Kode lerroa:     this.target = target
Kode lerroa:     this.id = id
Kode lerroa:     this.body = body
Kode lerroa:     this.references = references
Kode lerroa:     this.permissions = permissions
Kode lerroa:     this.tags = _.uniq(tags)
Kode lerroa:     this.creator = creator
Kode lerroa:     this.group = group
Kode lerroa:     const createdDate = Date.parse(created)
Kode lerroa:     if (_.isNumber(createdDate)) {
Kode lerroa:       this.created = new Date(created)
Kode lerroa:     }
Kode lerroa:     const modifiedDate = Date.parse(modified)
Kode lerroa:     if (_.isNumber(modifiedDate)) {
Kode lerroa:       this.modified = new Date(modified)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getBodyForPurpose (purpose) {
Kode lerroa:     if (_.isString(purpose) && _.isArray(this.body)) {
Kode lerroa:       return this.body.find((body) => {
Kode lerroa:         if (body && body.purpose) {
Kode lerroa:           return body.purpose === purpose
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   serialize () {
Kode lerroa:     const data = {
Kode lerroa:       '@context': 'http://www.w3.org/ns/anno.jsonld',
Kode lerroa:       group: this.group || window.abwa.groupSelector.currentGroup.id,
Kode lerroa:       creator: this.creator || window.abwa.groupSelector.getCreatorData() || window.abwa.groupSelector.user.userid,
Kode lerroa:       document: {},
Kode lerroa:       body: this.body,
Kode lerroa:       permissions: this.permissions || {
Kode lerroa:         read: ['group:' + window.abwa.groupSelector.currentGroup.id]
Kode lerroa:       },
Kode lerroa:       references: this.references || [],
Kode lerroa:       // PVSCL:IFCOND(SuggestedLiterature,LINE)
Kode lerroa: 
Kode lerroa:       tags: this.tags,
Kode lerroa:       target: this.target,
Kode lerroa:       text: '',
Kode lerroa:       uri: /* PVSCL:IFCOND(DOI) */ this.target[0].source.doi || /* PVSCL:ENDCOND */ this.target[0].source.url || this.target[0].source.urn
Kode lerroa:  this.target[0].source.url || this.target[0].source.urn
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa:     return data
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static deserialize (annotationObject) {
Kode lerroa:     const annotation = new Annotation({
Kode lerroa:       id: annotationObject.id,
Kode lerroa:       group: annotationObject.group,
Kode lerroa:       creator: annotationObject.creator,
Kode lerroa:       permissions: annotationObject.permissions,
Kode lerroa:       references: annotationObject.references,
Kode lerroa:       tags: annotationObject.tags,
Kode lerroa:       target: annotationObject.target,
Kode lerroa:       created: annotationObject.created,
Kode lerroa:       modified: annotationObject.updated
Kode lerroa:     })
Kode lerroa:     if (_.isArray(annotation.body)) {
Kode lerroa:       annotation.body = annotationObject.body.map((body) => {
Kode lerroa:         // PVSCL:IFCOND(Classifying, LINE)
Kode lerroa: 
Kode lerroa:         // PVSCL:IFCOND(Commenting, LINE)
Kode lerroa: 
Kode lerroa:         // PVSCL:IFCOND(SuggestedLiterature, LINE)
Kode lerroa: 
Kode lerroa:         // PVSCL:IFCOND(Assessing, LINE)
Kode lerroa: 
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa:     return annotation
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Annotation
Kode lerroa: import ReadAnnotation from './read/ReadAnnotation'
Kode lerroa: import CreateAnnotation from './create/CreateAnnotation'
Kode lerroa: import UpdateAnnotation from './UpdateAnnotation'
Kode lerroa: import DeleteAnnotation from './DeleteAnnotation'
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import PDF from '../target/formats/PDF'
Kode lerroa: import Events from '../Events'
Kode lerroa: import Classifying from './purposes/Classifying'
Kode lerroa: import Annotation from './Annotation'
Kode lerroa: 
Kode lerroa: class AnnotationManagement {
Kode lerroa:   constructor () {
Kode lerroa:     this.annotationCreator = new CreateAnnotation()
Kode lerroa:     this.annotationReader = new ReadAnnotation()
Kode lerroa:     this.annotationUpdater = new UpdateAnnotation()
Kode lerroa:     this.annotationDeleter = new DeleteAnnotation()
Kode lerroa:     this.events = {}
Kode lerroa:     // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     this.annotationCreator.init()
Kode lerroa:     this.annotationReader.init((err) => {
Kode lerroa:       // Navigate to the annotation if initial annotation exist
Kode lerroa:       if (window.abwa.annotationBasedInitializer.initAnnotation) {
Kode lerroa:         const annotationToNavigate = Annotation.deserialize(window.abwa.annotationBasedInitializer.initAnnotation)
Kode lerroa:         this.goToAnnotation(annotationToNavigate)
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(err)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     this.annotationUpdater.init()
Kode lerroa:     this.annotationDeleter.init()
Kode lerroa:     this.activateSelectionEvent()
Kode lerroa:     // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   activateSelectionEvent (callback) {
Kode lerroa:     this.events.mouseUpOnDocumentHandler = { element: document, event: 'mouseup', handler: this.mouseUpOnDocumentHandlerConstructor() }
Kode lerroa:     this.events.mouseUpOnDocumentHandler.element.addEventListener(this.events.mouseUpOnDocumentHandler.event, this.events.mouseUpOnDocumentHandler.handler)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   mouseUpOnDocumentHandlerConstructor () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Check if something is selected
Kode lerroa:       if (document.getSelection().toString().length !== 0) {
Kode lerroa:         if ($(event.target).parents('#abwaSidebarWrapper').toArray().length === 0 &&
Kode lerroa:           $(event.target).parents('.swal2-container').toArray().length === 0 &&
Kode lerroa:           $(event.target).parents('#canvasContainer').toArray().length === 0
Kode lerroa:         ) {
Kode lerroa:           window.abwa.sidebar.openSidebar()
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         console.debug('Current selection is empty')
Kode lerroa:         // If selection is child of sidebar, return null
Kode lerroa:         if ($(event.target).parents('#abwaSidebarWrapper').toArray().length === 0 &&
Kode lerroa:           event.target.id !== 'context-menu-layer') {
Kode lerroa:           console.debug('Current selection is not child of the annotator sidebar')
Kode lerroa:           window.abwa.sidebar.closeSidebar()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Destroy annotation operators
Kode lerroa:     this.annotationReader.destroy()
Kode lerroa:     this.annotationCreator.destroy()
Kode lerroa:     this.annotationUpdater.destroy()
Kode lerroa:     this.annotationDeleter.destroy()
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   goToAnnotation (annotation) {
Kode lerroa:     // If document is pdf, the DOM is dynamic, we must scroll to annotation using PDF.js FindController
Kode lerroa:     if (window.abwa.targetManager.documentFormat === PDF) {
Kode lerroa:       const queryTextSelector = _.find(annotation.target[0].selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:       if (queryTextSelector && queryTextSelector.exact) {
Kode lerroa:         // Get page for the annotation
Kode lerroa:         const fragmentSelector = _.find(annotation.target[0].selector, (selector) => { return selector.type === 'FragmentSelector' })
Kode lerroa:         if (fragmentSelector && fragmentSelector.page) {
Kode lerroa:           // Check if annotation was found by 'find' command, otherwise go to page
Kode lerroa:           if (window.PDFViewerApplication.page !== fragmentSelector.page) {
Kode lerroa:             window.PDFViewerApplication.page = fragmentSelector.page
Kode lerroa:             this.annotationReader.redrawAnnotations()
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         window.PDFViewerApplication.findController.executeCommand('find', { query: queryTextSelector.exact, phraseSearch: true })
Kode lerroa:         // Timeout to remove highlight used by PDF.js
Kode lerroa:         this.removeFindTagsInPDFs()
Kode lerroa:       }
Kode lerroa:     } else { // Else, try to find the annotation by data-annotation-id element attribute
Kode lerroa:       const firstElementToScroll = document.querySelector('[data-annotation-id="' + annotation.id + '"]')
Kode lerroa:       // If go to annotation is done by init annotation and it is not found, wait for some seconds for ajax content to be loaded and try again to go to annotation
Kode lerroa:       if (!_.isElement(firstElementToScroll) && !_.isNumber(this.initializationTimeout)) { // It is done only once, if timeout does not exist previously (otherwise it won't finish never calling goToAnnotation
Kode lerroa:         this.initializationTimeout = setTimeout(() => {
Kode lerroa:           console.debug('Trying to scroll to init annotation in 2 seconds')
Kode lerroa:           this.initAnnotatorByAnnotation()
Kode lerroa:         }, 2000)
Kode lerroa:       } else {
Kode lerroa:         firstElementToScroll.scrollIntoView({ behavior: 'smooth', block: 'center' })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   removeFindTagsInPDFs () {
Kode lerroa:     setTimeout(() => {
Kode lerroa:       // Remove class for middle selected elements in find function of PDF.js
Kode lerroa:       document.querySelectorAll('.highlight.selected.middle').forEach(elem => {
Kode lerroa:         $(elem).removeClass('highlight selected middle')
Kode lerroa:       })
Kode lerroa:       // Remove wrap for begin and end selected elements in find function of PDF.js
Kode lerroa:       document.querySelectorAll('.highlight.selected').forEach(elem => {
Kode lerroa:         if (elem.children.length === 1) {
Kode lerroa:           $(elem.children[0]).unwrap()
Kode lerroa:         } else {
Kode lerroa:           $(document.createTextNode(elem.innerText)).insertAfter(elem)
Kode lerroa:           $(elem).remove()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }, 1000)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationManagement
Kode lerroa: import Events from '../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: 
Kode lerroa: class DeleteAnnotation {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for createAnnotation event
Kode lerroa:     this.initDeleteAnnotationEvent()
Kode lerroa:     // Add event listener for deleteAllAnnotations event
Kode lerroa:     this.deleteAllAnnotationsEvent()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initDeleteAnnotationEvent (callback) {
Kode lerroa:     this.events.deleteAnnotationEvent = { element: document, event: Events.deleteAnnotation, handler: this.deleteAnnotationEventHandler() }
Kode lerroa:     this.events.deleteAnnotationEvent.element.addEventListener(this.events.deleteAnnotationEvent.event, this.events.deleteAnnotationEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deleteAllAnnotationsEvent (callback) {
Kode lerroa:     this.events.deleteAllAnnotationEvent = { element: document, event: Events.deleteAllAnnotations, handler: this.deleteAllAnnotationsEventHandler() }
Kode lerroa:     this.events.deleteAllAnnotationEvent.element.addEventListener(this.events.deleteAllAnnotationEvent.event, this.events.deleteAllAnnotationEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deleteAllAnnotationsEventHandler () {
Kode lerroa:     return () => {
Kode lerroa:       // Retrieve all the annotations
Kode lerroa:       const allAnnotations = window.abwa.annotationManagement.annotationReader.allAnnotations
Kode lerroa:       // Filter by current user's annotations, as other users are not deleteable
Kode lerroa:       const annotationsToDelete = allAnnotations.filter(annotation => {
Kode lerroa:         return annotation.creator === window.abwa.groupSelector.getCreatorData()
Kode lerroa:       })
Kode lerroa:       window.abwa.annotationServerManager.client.deleteAnnotations(annotationsToDelete, (err) => {
Kode lerroa:         if (err) {
Kode lerroa:           Alerts.errorAlert({ text: 'Unable to delete all the annotations in the document. Please try it again.' })
Kode lerroa:         } else {
Kode lerroa:           LanguageUtils.dispatchCustomEvent(Events.deletedAllAnnotations, { annotations: annotationsToDelete })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deleteAnnotationEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Get annotation to delete
Kode lerroa:       const annotation = event.detail.annotation
Kode lerroa:       // Ask for confirmation
Kode lerroa:       Alerts.confirmAlert({
Kode lerroa:         alertType: Alerts.alertType.question,
Kode lerroa:         title: 'Delete annotation',
Kode lerroa:         text: 'Are you sure you want to delete this annotation?',
Kode lerroa:         callback: () => {
Kode lerroa:           // Delete annotation
Kode lerroa:           window.abwa.annotationServerManager.client.deleteAnnotation(annotation.id, (err, result) => {
Kode lerroa:             if (err) {
Kode lerroa:               // Unable to delete this annotation
Kode lerroa:               console.error('Error while trying to delete annotation %s', annotation.id)
Kode lerroa:             } else {
Kode lerroa:               if (!result.deleted) {
Kode lerroa:                 // Alert user error happened
Kode lerroa:                 Alerts.errorAlert({ text: chrome.i18n.getMessage('errorDeletingHypothesisAnnotation') })
Kode lerroa:               } else {
Kode lerroa:                 // Send annotation deleted event
Kode lerroa:                 LanguageUtils.dispatchCustomEvent(Events.annotationDeleted, { annotation: annotation })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DeleteAnnotation
Kode lerroa: import Events from '../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import Annotation from './Annotation'
Kode lerroa: 
Kode lerroa: class UpdateAnnotation {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for createAnnotation event
Kode lerroa:     this.initCreateAnnotationEvent()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initCreateAnnotationEvent (callback) {
Kode lerroa:     this.events.updateAnnotationEvent = { element: document, event: Events.updateAnnotation, handler: this.updateAnnotationEventHandler() }
Kode lerroa:     this.events.updateAnnotationEvent.element.addEventListener(this.events.updateAnnotationEvent.event, this.events.updateAnnotationEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateAnnotationEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Get annotation to update
Kode lerroa:       const annotation = event.detail.annotation
Kode lerroa:       // Send updated annotation to the server
Kode lerroa:       window.abwa.annotationServerManager.client.updateAnnotation(
Kode lerroa:         annotation.id,
Kode lerroa:         annotation.serialize(),
Kode lerroa:         (err, annotation) => {
Kode lerroa:           if (err) {
Kode lerroa:             Alerts.errorAlert({ text: 'Unexpected error, unable to create annotation' })
Kode lerroa:           } else {
Kode lerroa:             // Deserialize retrieved annotation from the server
Kode lerroa:             const deserializedAnnotation = Annotation.deserialize(annotation)
Kode lerroa:             // Dispatch annotation created event
Kode lerroa:             LanguageUtils.dispatchCustomEvent(Events.annotationUpdated, { annotation: deserializedAnnotation })
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default UpdateAnnotation
Kode lerroa: import AnnotationServer from '../AnnotationServer'
Kode lerroa: 
Kode lerroa: class BrowserStorage extends AnnotationServer {
Kode lerroa:   constructor ({ group }) {
Kode lerroa:     super({ group })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default BrowserStorage
Kode lerroa: import _ from 'lodash'
Kode lerroa: import RandomUtils from '../../utils/RandomUtils'
Kode lerroa: import wildcard from 'wildcard'
Kode lerroa: 
Kode lerroa: class BrowserStorageClient {
Kode lerroa:   constructor (database, manager) {
Kode lerroa:     this.database = database
Kode lerroa:     this.manager = manager
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createNewAnnotation (annotation, callback) {
Kode lerroa:     try {
Kode lerroa:       const annotationToStore = BrowserStorageClient.constructAnnotation({
Kode lerroa:         annotation,
Kode lerroa:         user: this.database.user,
Kode lerroa:         annotations: this.database.annotations
Kode lerroa:       })
Kode lerroa:       console.debug('Create annotation')
Kode lerroa:       console.debug(annotationToStore)
Kode lerroa:       // Store in database
Kode lerroa:       this.database.annotations.push(annotationToStore)
Kode lerroa:       // Update storage
Kode lerroa:       this.manager.saveDatabase(this.database)
Kode lerroa:       // Callback
Kode lerroa:       callback(null, annotationToStore)
Kode lerroa:     } catch (e) {
Kode lerroa:       callback(e)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createNewAnnotations (annotations = [], callback) {
Kode lerroa:     try {
Kode lerroa:       const toStoreAnnotations = []
Kode lerroa:       for (let i = 0; i < annotations.length; i++) {
Kode lerroa:         const annotation = annotations[i]
Kode lerroa:         const toStoreAnnotation = BrowserStorageClient.constructAnnotation({
Kode lerroa:           annotation,
Kode lerroa:           user: this.database.user,
Kode lerroa:           annotations: this.database.annotations
Kode lerroa:         })
Kode lerroa:         toStoreAnnotations.push(toStoreAnnotation)
Kode lerroa:       }
Kode lerroa:       // Store in database
Kode lerroa:       this.database.annotations = this.database.annotations.concat(toStoreAnnotations)
Kode lerroa:       // Update storage
Kode lerroa:       this.manager.saveDatabase(this.database)
Kode lerroa:       callback(null, toStoreAnnotations)
Kode lerroa:     } catch (e) {
Kode lerroa:       callback(e)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static constructAnnotation ({ annotation, user, annotations }) {
Kode lerroa:     // Check if the required parameter group exists
Kode lerroa:     if (annotation.group) {
Kode lerroa:       // TODO Check if annotation follows the standard schema
Kode lerroa:       let annotationToCreate = BrowserStorageClient.constructEmptyAnnotation()
Kode lerroa:       // Override properties of annotation with inserted content
Kode lerroa:       annotationToCreate = Object.assign(annotationToCreate, annotation)
Kode lerroa: 
Kode lerroa:       // UserInfo
Kode lerroa:       if (_.isEmpty(annotationToCreate.user_info)) {
Kode lerroa:         annotationToCreate.user_info = { display_name: user.display_name }
Kode lerroa:       }
Kode lerroa:       // User
Kode lerroa:       if (_.isEmpty(annotationToCreate.user)) {
Kode lerroa:         annotationToCreate.user = user.userid
Kode lerroa:       }
Kode lerroa:       // Id
Kode lerroa:       const arrayOfIds = _.map(annotations, 'id')
Kode lerroa:       annotationToCreate.id = RandomUtils.randomUnique(arrayOfIds, 22)
Kode lerroa: 
Kode lerroa:       // Permissions
Kode lerroa:       BrowserStorageClient.setAnnotationPermissions(annotationToCreate, user)
Kode lerroa:       // TODO Links property ?
Kode lerroa:       // Return constructed annotation to create
Kode lerroa:       return annotationToCreate
Kode lerroa:     } else {
Kode lerroa:       if (_.isEmpty(annotation.group)) {
Kode lerroa:         throw new Error('Required parameter missing in annotation: group.\n' + annotation.toString())
Kode lerroa:       } else if (_.isEmpty(annotation.uri)) {
Kode lerroa:         throw new Error('Required parameter missing in annotation: uri.\n' + annotation.toString())
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static constructEmptyAnnotation () {
Kode lerroa:     // Get current time
Kode lerroa:     const now = new Date()
Kode lerroa:     return {
Kode lerroa:       updated: now.toISOString(),
Kode lerroa:       group: '',
Kode lerroa:       target: [
Kode lerroa:         {
Kode lerroa:           source: '',
Kode lerroa:           selector: []
Kode lerroa:         }
Kode lerroa:       ],
Kode lerroa:       links: {
Kode lerroa:         json: '',
Kode lerroa:         html: '',
Kode lerroa:         incontext: ''
Kode lerroa:       },
Kode lerroa:       tags: [],
Kode lerroa:       text: '',
Kode lerroa:       created: now.toISOString(),
Kode lerroa:       flagged: false,
Kode lerroa:       user_info: {},
Kode lerroa:       moderation: {
Kode lerroa:         flagCount: 0
Kode lerroa:       },
Kode lerroa:       references: [],
Kode lerroa:       user: '',
Kode lerroa:       hidden: false,
Kode lerroa:       id: '',
Kode lerroa:       permissions: {}
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   searchAnnotations (data = {}, callback) {
Kode lerroa:     const annotations = this.database.annotations
Kode lerroa:     let filteredAnnotations = _.filter(annotations, (annotation) => {
Kode lerroa:       let result = true
Kode lerroa:       // URL
Kode lerroa:       if (result && (data.uri || data.url)) {
Kode lerroa:         if (!_.isEmpty(annotation.target)) {
Kode lerroa:           // Check if uri exists in any of the source's URIs
Kode lerroa:           result = !_.isEmpty(_.filter(_.values(annotation.target[0].source), (uri) => {
Kode lerroa:             return data.url === uri || data.uri === uri
Kode lerroa:           }))
Kode lerroa:         } else if (annotation.uri) {
Kode lerroa:           result = annotation.uri === data.url || annotation.uri === data.uri
Kode lerroa:         } else {
Kode lerroa:           result = false
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       // User
Kode lerroa:       if (result && (data.user)) {
Kode lerroa:         result = annotation.user === data.user
Kode lerroa:       }
Kode lerroa:       // Group
Kode lerroa:       if (result && (data.group)) {
Kode lerroa:         result = annotation.group === data.group
Kode lerroa:       }
Kode lerroa:       // Tags
Kode lerroa:       if (result && (data.tag || data.tags)) {
Kode lerroa:         let tags = []
Kode lerroa:         if (_.isArray(data.tags) && _.every(data.tags, _.isString)) {
Kode lerroa:           tags = data.tags
Kode lerroa:         }
Kode lerroa:         if (_.isString(data.tags)) {
Kode lerroa:           tags.push(data.tags)
Kode lerroa:         }
Kode lerroa:         if (_.isString(data.tag)) {
Kode lerroa:           tags.push(data.tag)
Kode lerroa:         }
Kode lerroa:         // Remove duplicated tags
Kode lerroa:         tags = _.uniq(tags)
Kode lerroa:         // Check if annotation's tags includes all the annotations
Kode lerroa:         result = tags.length === _.intersection(annotation.tags, tags).length
Kode lerroa:       }
Kode lerroa:       // Uri.parts
Kode lerroa:       if (result && (data['uri.parts'])) {
Kode lerroa:         const splittedUri = annotation.uri.split(/[#+/:=?.-]/) // Chars used to split URIs for uri.parts in Hypothes.is https://hyp.is/ajJkEI3pEemPn2ukkpZWjQ/h.readthedocs.io/en/latest/api-reference/v1/
Kode lerroa:         result = _.some(splittedUri, (str) => { return str === data['uri.parts'] })
Kode lerroa:       }
Kode lerroa:       // Wildcard_uri
Kode lerroa:       if (result && (data.wildcard_uri)) {
Kode lerroa:         result = wildcard(data.wildcard_uri, annotation.uri)
Kode lerroa:       }
Kode lerroa:       // TODO Quote
Kode lerroa:       // References
Kode lerroa:       if (result && (data.references)) {
Kode lerroa:         if (_.isString(data.references)) {
Kode lerroa:           result = annotation.references.includes(data.references)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       // Text
Kode lerroa:       if (result && data.text) {
Kode lerroa:         if (_.isString(data.text)) {
Kode lerroa:           result = annotation.text.includes(data.text)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       // Any, this is the last one as it is the algorithm with higher computational cost
Kode lerroa:       if (result && (data.any)) {
Kode lerroa:         const anyUrl = annotation.uri.includes(data.any) // Any checks in uri
Kode lerroa:         const anyTag = annotation.tags.includes(data.any) // Any checks in tags
Kode lerroa:         const anyText = annotation.text.includes(data.text)
Kode lerroa:         result = anyUrl || anyTag || anyText // TODO Quote
Kode lerroa:       }
Kode lerroa:       return result
Kode lerroa:     })
Kode lerroa:     if (data.order) {
Kode lerroa:       const sort = data.sort || 'updated'
Kode lerroa:       filteredAnnotations = _.orderBy(filteredAnnotations, sort, data.order)
Kode lerroa:     }
Kode lerroa:     if (data.limit) {
Kode lerroa:       filteredAnnotations = _.take(filteredAnnotations, data.limit)
Kode lerroa:     }
Kode lerroa:     callback(null, filteredAnnotations)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static updateAnnotationFromList ({ id, annotation, annotations, currentUser }) {
Kode lerroa:     const annotationToUpdateIndex = _.findIndex(annotations, (annotationInDatabase) => {
Kode lerroa:       return annotationInDatabase.id === id
Kode lerroa:     })
Kode lerroa:     if (annotationToUpdateIndex > -1) {
Kode lerroa:       const annotationToUpdate = annotations[annotationToUpdateIndex]
Kode lerroa:       // Check permissions to delete
Kode lerroa:       if (_.isArray(annotationToUpdate.permissions.update)) {
Kode lerroa:         const owner = _.find(annotationToUpdate.permissions.update, (userid) => {
Kode lerroa:           return userid === currentUser.userid
Kode lerroa:         })
Kode lerroa:         if (_.isString(owner)) {
Kode lerroa:           const annotationUpdated = Object.assign(annotationToUpdate, annotation)
Kode lerroa:           // Update updated time
Kode lerroa:           annotationUpdated.updated = (new Date()).toISOString()
Kode lerroa:           // Update url in target if changed
Kode lerroa:           if (annotationToUpdate.uri !== annotation.uri) {
Kode lerroa:             _.forEach(annotationUpdated.target, (target, index) => {
Kode lerroa:               if (annotationUpdated.target[index]) {
Kode lerroa:                 annotationUpdated.target[index].source = annotation.uri
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:           // Permissions
Kode lerroa:           BrowserStorageClient.setAnnotationPermissions(annotationUpdated, currentUser)
Kode lerroa:           // Update the annotation from list
Kode lerroa:           annotations[annotationToUpdateIndex] = annotationUpdated
Kode lerroa:           // Return deleted annotation
Kode lerroa:           return annotationUpdated
Kode lerroa:         } else {
Kode lerroa:           // Your are not the owner
Kode lerroa:           throw new Error('Your are not the owner of the annotation ID: ' + id)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Annotation with ID ' + id + ' does not exist')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateAnnotation (id, annotation, callback) {
Kode lerroa:     if (_.isString(id) && _.isObject(annotation)) {
Kode lerroa:       try {
Kode lerroa:         const updatedAnnotation = BrowserStorageClient.updateAnnotationFromList({
Kode lerroa:           id: id,
Kode lerroa:           annotation: annotation,
Kode lerroa:           annotations: this.database.annotations,
Kode lerroa:           currentUser: this.database.user
Kode lerroa:         })
Kode lerroa:         // TODO Update storage
Kode lerroa:         this.manager.saveDatabase(this.database)
Kode lerroa:         callback(null, updatedAnnotation)
Kode lerroa:       } catch (e) {
Kode lerroa:         callback(e)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static deleteAnnotationFromList ({ id, annotations, currentUser }) {
Kode lerroa:     const annotationToDeleteIndex = _.findIndex(annotations, (annotation) => {
Kode lerroa:       return annotation.id === id
Kode lerroa:     })
Kode lerroa:     if (annotationToDeleteIndex > -1) {
Kode lerroa:       const annotation = annotations[annotationToDeleteIndex]
Kode lerroa:       // Check permissions to delete
Kode lerroa:       if (_.isArray(annotation.permissions.delete)) {
Kode lerroa:         const owner = _.find(annotation.permissions.delete, (userid) => {
Kode lerroa:           return userid === currentUser.userid
Kode lerroa:         })
Kode lerroa:         if (_.isString(owner)) {
Kode lerroa:           // Delete the annotation from list
Kode lerroa:           annotations.splice(annotationToDeleteIndex, 1)
Kode lerroa:           // Return deleted annotation
Kode lerroa:           return annotation
Kode lerroa:         } else {
Kode lerroa:           // Your are not the owner
Kode lerroa:           throw new Error('Your are not the owner of the annotation ID: ' + id)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Annotation with ID ' + id + ' does not exist')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deleteAnnotation (id, callback) {
Kode lerroa:     let annotationId
Kode lerroa:     if (_.isObject(id) && _.has(id, 'id')) {
Kode lerroa:       annotationId = id.id
Kode lerroa:     } else if (_.isString(id)) {
Kode lerroa:       annotationId = id
Kode lerroa:     } else {
Kode lerroa:       callback(new Error('The param id is not an annotation or the ID of an annotation'))
Kode lerroa:       return
Kode lerroa:     }
Kode lerroa:     try {
Kode lerroa:       const deletedAnnotation = BrowserStorageClient.deleteAnnotationFromList({
Kode lerroa:         id: annotationId,
Kode lerroa:         annotations: this.database.annotations,
Kode lerroa:         currentUser: this.database.user
Kode lerroa:       })
Kode lerroa:       // TODO Update storage
Kode lerroa:       this.manager.saveDatabase(this.database)
Kode lerroa:       // Callback
Kode lerroa:       callback(null, { deleted: true, id: deletedAnnotation.id })
Kode lerroa:     } catch (e) {
Kode lerroa:       callback(e)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deleteAnnotations (annotationsArray, callback) {
Kode lerroa:     let toDeleteAnnotationIds
Kode lerroa:     if (_.every(annotationsArray, (annotation) => { return annotation.id })) {
Kode lerroa:       toDeleteAnnotationIds = _.map(annotationsArray, 'id')
Kode lerroa:     } else if (_.every(annotationsArray, String)) {
Kode lerroa:       toDeleteAnnotationIds = annotationsArray
Kode lerroa:     } else {
Kode lerroa:       callback(new Error('The annotations array is not an array of annotations or an array of strings'))
Kode lerroa:       return
Kode lerroa:     }
Kode lerroa:     try {
Kode lerroa:       const deletedAnnotations = []
Kode lerroa:       for (let i = 0; i < toDeleteAnnotationIds.length; i++) {
Kode lerroa:         const toDeleteAnnotationId = toDeleteAnnotationIds[i]
Kode lerroa:         const deletedAnnotation = BrowserStorageClient.deleteAnnotationFromList({
Kode lerroa:           id: toDeleteAnnotationId,
Kode lerroa:           annotations: this.database.annotations,
Kode lerroa:           currentUser: this.database.user
Kode lerroa:         })
Kode lerroa:         deletedAnnotations.push(deletedAnnotation)
Kode lerroa:       }
Kode lerroa:       // TODO Update Storage
Kode lerroa:       this.manager.saveDatabase(this.database)
Kode lerroa:       // Callback
Kode lerroa:       callback(null, { deleted: true, annotations: deletedAnnotations })
Kode lerroa:     } catch (e) {
Kode lerroa:       callback(e)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   fetchAnnotation (id, callback) {
Kode lerroa:     if (_.isString(id)) {
Kode lerroa:       const foundAnnotation = _.find(this.database.annotations, (annotation) => {
Kode lerroa:         return annotation.id === id
Kode lerroa:       })
Kode lerroa:       if (_.isObject(foundAnnotation)) {
Kode lerroa:         // TODO Check if has reading permissions
Kode lerroa:         // Callback
Kode lerroa:         callback(null, foundAnnotation)
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('Annotation with ID ' + id + ' not found'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       callback(id)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getListOfGroups (data, callback) {
Kode lerroa:     const groups = _.map(this.database.groups, (group) => {
Kode lerroa:       return {
Kode lerroa:         id: group.id,
Kode lerroa:         name: group.name,
Kode lerroa:         links: group.links
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     callback(null, groups)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getUserProfile (callback) {
Kode lerroa:     const profile = this.database.user
Kode lerroa:     // Retrieve groups and parse
Kode lerroa:     profile.groups = _.map(this.database.groups, (group) => {
Kode lerroa:       return {
Kode lerroa:         name: group.name,
Kode lerroa:         description: group.description,
Kode lerroa:         id: group.id,
Kode lerroa:         url: group.links.html
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     callback(null, profile)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateGroup (id, data, callback) {
Kode lerroa:     if (_.isString(id)) {
Kode lerroa:       const groupToUpdateIndex = _.findIndex(this.database.groups, (group) => {
Kode lerroa:         return group.id === id
Kode lerroa:       })
Kode lerroa:       if (groupToUpdateIndex > -1) {
Kode lerroa:         // Retrieve group data
Kode lerroa:         const groupToUpdate = this.database.groups[groupToUpdateIndex]
Kode lerroa:         // Update group data
Kode lerroa:         const updatedGroup = Object.assign(groupToUpdate, data)
Kode lerroa:         // Update in-memory database
Kode lerroa:         this.database.groups[groupToUpdateIndex] = updatedGroup
Kode lerroa:         // TODO Update Storage
Kode lerroa:         this.manager.saveDatabase(this.database)
Kode lerroa:         // Callback
Kode lerroa:         callback(null, updatedGroup)
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('Group with ID ' + id + ' does not exist'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       callback(new Error('Required parameter to update the group missing: id'))
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createNewGroup (data, callback) {
Kode lerroa:     if (_.has(data, 'name')) {
Kode lerroa:       const createdGroup = BrowserStorageClient.constructGroup({
Kode lerroa:         name: data.name,
Kode lerroa:         description: data.description,
Kode lerroa:         annotationServerUrl: this.manager.annotationServerUrl,
Kode lerroa:         groups: this.database.groups
Kode lerroa:       })
Kode lerroa:       this.database.groups.push(createdGroup)
Kode lerroa:       // TODO Update Storage
Kode lerroa:       this.manager.saveDatabase(this.database)
Kode lerroa:       // Callback
Kode lerroa:       callback(null, createdGroup)
Kode lerroa:     } else {
Kode lerroa:       callback(new Error('Required parameter to create new group missing: name'))
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static constructGroup ({ name, description = '', groups, annotationServerUrl }) {
Kode lerroa:     // Get a random id
Kode lerroa:     const arrayOfIds = _.map(groups, 'id')
Kode lerroa:     const groupId = RandomUtils.randomUnique(arrayOfIds, 8)
Kode lerroa:     return {
Kode lerroa:       name: name,
Kode lerroa:       description: description || '',
Kode lerroa:       links: { html: annotationServerUrl + '/groups/' + groupId },
Kode lerroa:       id: groupId
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static setAnnotationPermissions (annotation, currentUser) {
Kode lerroa:     annotation.permissions = annotation.permissions || {}
Kode lerroa:     if (_.isEmpty(annotation.permissions.read)) {
Kode lerroa:       annotation.permissions.read = [currentUser.userid]
Kode lerroa:     }
Kode lerroa:     if (_.isEmpty(annotation.permissions.admin)) {
Kode lerroa:       annotation.permissions.admin = [currentUser.userid]
Kode lerroa:     }
Kode lerroa:     if (_.isEmpty(annotation.permissions.delete)) {
Kode lerroa:       annotation.permissions.delete = [currentUser.userid]
Kode lerroa:     }
Kode lerroa:     if (_.isEmpty(annotation.permissions.update)) {
Kode lerroa:       annotation.permissions.update = [currentUser.userid]
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   removeAMemberFromAGroup ({ id, user = null }, callback) {
Kode lerroa:     if (_.isString(id)) {
Kode lerroa:       // Remove group from group list
Kode lerroa:       const removedGroup = _.remove(this.database.groups, (group) => {
Kode lerroa:         return group.id === id
Kode lerroa:       })
Kode lerroa:       // Remove annotations that pertain to the group
Kode lerroa:       _.remove(this.database.annotations, (annotation) => {
Kode lerroa:         return annotation.group === id
Kode lerroa:       })
Kode lerroa:       if (removedGroup) {
Kode lerroa:         this.manager.saveDatabase(this.database)
Kode lerroa:         callback(null, removedGroup)
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('The group trying to leave does not exist.'))
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default BrowserStorageClient
Kode lerroa: import ChromeStorage from '../../utils/ChromeStorage'
Kode lerroa: import URLUtils from '../../utils/URLUtils'
Kode lerroa: import BrowserStorageClient from './BrowserStorageClient'
Kode lerroa: import AnnotationServerManager from '../AnnotationServerManager'
Kode lerroa: // const mockDatabase = require('./mockDatabase')
Kode lerroa: import EmptyDatabase from './EmptyDatabase'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class BrowserStorageManager extends AnnotationServerManager {
Kode lerroa:   constructor () {
Kode lerroa:     super()
Kode lerroa:     this.browserStorageClient = this.client
Kode lerroa:     this.annotationsDatabase = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     // Retrieve database of annotations
Kode lerroa:     ChromeStorage.getData('db.annotations', ChromeStorage.local, (err, data) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         if (_.isString(data)) {
Kode lerroa:           // Parse
Kode lerroa:           try {
Kode lerroa:             this.annotationsDatabase = JSON.parse(data)
Kode lerroa:           } catch (e) {
Kode lerroa:             this.annotationsDatabase = EmptyDatabase
Kode lerroa:           } finally {
Kode lerroa:             this.client = new BrowserStorageClient(this.annotationsDatabase, this)
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           // Load empty database
Kode lerroa:           this.annotationsDatabase = EmptyDatabase
Kode lerroa:           this.client = new BrowserStorageClient(this.annotationsDatabase, this)
Kode lerroa:         }
Kode lerroa:         // Callback
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   saveDatabase (database, callback) {
Kode lerroa:     const stringifiedDatabase = JSON.stringify(database)
Kode lerroa:     ChromeStorage.setData('db.annotations', stringifiedDatabase, ChromeStorage.local, (err) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, database)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   constructSearchUrl (obj) {
Kode lerroa:     const hashParam = URLUtils.objectToParams(obj)
Kode lerroa:     return chrome.extension.getURL('content/browserStorage/browserStorageSearch.html') + '#' + hashParam
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   cleanDatabase (callback) {
Kode lerroa:     ChromeStorage.setData('db.annotations', 1, ChromeStorage.local, (err) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         if (err) {
Kode lerroa:           callback(err)
Kode lerroa:         } else {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default BrowserStorageManager
Kode lerroa: {
Kode lerroa:   "user": {
Kode lerroa:     "userid": "generic_user",
Kode lerroa:     "display_name": "Generic user"
Kode lerroa:   },
Kode lerroa:   "groups": [],
Kode lerroa:   "annotations": [
Kode lerroa: 
Kode lerroa:   ]
Kode lerroa: }
Kode lerroa: import AnnotationServer from '../AnnotationServer'
Kode lerroa: 
Kode lerroa: class Hypothesis extends AnnotationServer {
Kode lerroa:   constructor ({ group }) {
Kode lerroa:     super({ group })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Hypothesis
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: import HypothesisClient from 'hypothesis-api-client'
Kode lerroa: 
Kode lerroa: import AnnotationServerManager from '../AnnotationServerManager'
Kode lerroa: 
Kode lerroa: const reloadIntervalInSeconds = 10 // Reload the hypothesis client every 10 seconds
Kode lerroa: 
Kode lerroa: class HypothesisClientManager extends AnnotationServerManager {
Kode lerroa:   constructor () {
Kode lerroa:     super()
Kode lerroa:     this.client = null
Kode lerroa:     this.hypothesisToken = null
Kode lerroa:     this.reloadInterval = null
Kode lerroa:     this.annotationServerMetadata = {
Kode lerroa:       annotationUrl: 'https://hypothes.is/api/annotations/',
Kode lerroa:       annotationServerUrl: 'https://hypothes.is/api',
Kode lerroa:       groupUrl: 'https://hypothes.is/groups/',
Kode lerroa:       userUrl: 'https://hypothes.is/users/'
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     this.reloadClient(() => {
Kode lerroa:       // Start reloading of client
Kode lerroa:       this.reloadInterval = setInterval(() => {
Kode lerroa:         this.reloadClient()
Kode lerroa:       }, reloadIntervalInSeconds * 1000)
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadClient (callback) {
Kode lerroa:     if (_.has(window.background, 'hypothesisManager')) {
Kode lerroa:       if (_.isString(window.background.hypothesisManager.token)) {
Kode lerroa:         if (this.hypothesisToken !== window.background.hypothesisManager.token) {
Kode lerroa:           this.hypothesisToken = window.background.hypothesisManager.token
Kode lerroa:           if (this.hypothesisToken) {
Kode lerroa:             this.client = new HypothesisClient(window.background.hypothesisManager.token)
Kode lerroa:           } else {
Kode lerroa:             this.client = new HypothesisClient()
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         window.background.hypothesisManager.retrieveHypothesisToken((err, token) => {
Kode lerroa:           if (err) {
Kode lerroa:             this.client = new HypothesisClient()
Kode lerroa:             this.hypothesisToken = null
Kode lerroa:           } else {
Kode lerroa:             this.client = new HypothesisClient(token)
Kode lerroa:             this.hypothesisToken = token
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       chrome.runtime.sendMessage({ scope: 'hypothesis', cmd: 'getToken' }, (token) => {
Kode lerroa:         if (this.hypothesisToken !== token) {
Kode lerroa:           this.hypothesisToken = token
Kode lerroa:           if (this.hypothesisToken) {
Kode lerroa:             this.client = new HypothesisClient(token)
Kode lerroa:           } else {
Kode lerroa:             this.client = new HypothesisClient()
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   isLoggedIn () {
Kode lerroa:     return !_.isEmpty(this.hypothesisToken)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   constructSearchUrl ({ groupId }) {
Kode lerroa:     return this.annotationServerMetadata.groupUrl + groupId
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   logIn (callback) {
Kode lerroa:     // TODO Check if user grant permission to access hypothesis account
Kode lerroa:     if (!this.isLoggedIn()) {
Kode lerroa:       this.askUserToLogInHypothesis((err, token) => {
Kode lerroa:         if (err) {
Kode lerroa:           callback(err)
Kode lerroa:         } else {
Kode lerroa:           callback(null, token)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     } else {
Kode lerroa:       callback(null, this.hypothesisToken)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   askUserToLogInHypothesis (callback) {
Kode lerroa:     const swal = require('sweetalert2').default
Kode lerroa:     // Ask question
Kode lerroa:     swal({
Kode lerroa:       title: 'Hypothes.is login required', // TODO i18n
Kode lerroa:       text: chrome.i18n.getMessage('HypothesisLoginRequired'),
Kode lerroa:       type: 'info',
Kode lerroa:       showCancelButton: true
Kode lerroa:     }).then((result) => {
Kode lerroa:       if (result.value) {
Kode lerroa:         // Prompt hypothesis login form
Kode lerroa:         chrome.runtime.sendMessage({ scope: 'hypothesis', cmd: 'userLoginForm' }, (result) => {
Kode lerroa:           if (result.error) {
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback(new Error(result.error))
Kode lerroa:             }
Kode lerroa:           } else {
Kode lerroa:             this.reloadClient(() => {
Kode lerroa:               if (_.isFunction(callback)) {
Kode lerroa:                 callback(null, this.hypothesisToken)
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('User don\'t want to log in hypothes.is'))
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     if (this.reloadInterval) {
Kode lerroa:       clearInterval(this.reloadInterval)
Kode lerroa:     }
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default HypothesisClientManager
Kode lerroa: /* eslint-disable */
Kode lerroa: import _ from 'lodash'
Kode lerroa: import axios from 'axios'
Kode lerroa: // const jsonld = require('jsonld')
Kode lerroa: 
Kode lerroa: // Configuration constants
Kode lerroa: const now = new Date()
Kode lerroa: var contextus = []
Kode lerroa: var contextualization = [ 'http://www.w3.org/ns/anno.jsonld', {"assessing":"oa:assessing", "slr":"http://rdf.onekin.org/resource/ns/slr/"}, {"datacite":"http://purl.org/spar/datacite/", "urn":"datacite:urn", "url":"datacite:url", "doi":"datacite:doi"}, {"dcterms": "http://purl.org/dc/terms/", "title": "dcterms:title", "created": "dcterms:created", "modified": "dcterms:modified"}, { '@vocab': 'http://rdf.onekin.org/resources/ns/' } ]
Kode lerroa: 
Kode lerroa: /// /UTILS
Kode lerroa: function doNothing () {}
Kode lerroa: 
Kode lerroa: function sleep (miliseconds) {
Kode lerroa:   var currentTime = new Date().getTime()
Kode lerroa:   while (currentTime + miliseconds >= new Date().getTime()) { }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function getObjectId (data, id) {
Kode lerroa:   for (let i = 0; i < data.length; i++) {
Kode lerroa:     let item = data [i]
Kode lerroa:     if (item.id === id){
Kode lerroa:       return item
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return data
Kode lerroa: }
Kode lerroa: 
Kode lerroa: 
Kode lerroa: /*
Kode lerroa: function isString (value) {
Kode lerroa:   return typeof value === 'string' || value instanceof String
Kode lerroa: }
Kode lerroa: */
Kode lerroa: 
Kode lerroa: function escapalo (data){
Kode lerroa:   let textQuoteSelectorIndex
Kode lerroa:   if (Array.isArray(data.target)){
Kode lerroa:      textQuoteSelectorIndex = _.findIndex(data.target[0].selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:   }else{
Kode lerroa:     textQuoteSelectorIndex = _.findIndex(data.target.selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:   }
Kode lerroa:   if (textQuoteSelectorIndex > -1) {
Kode lerroa:     let pre = data.target[0].selector[textQuoteSelectorIndex].prefix
Kode lerroa:     data.target[0].selector[textQuoteSelectorIndex].prefix  = escape(pre)
Kode lerroa:     let suf = data.target[0].selector[textQuoteSelectorIndex].suffix
Kode lerroa:     data.target[0].selector[textQuoteSelectorIndex].suffix  = escape(suf)
Kode lerroa:   }
Kode lerroa:   if (data['text']) {
Kode lerroa:     data['text'] = escape(data['text'])
Kode lerroa:   }
Kode lerroa:   if (data['body']) {
Kode lerroa:     if (data.body.description) {
Kode lerroa:       data.body.description = escape(data.body.description)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   return data
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function descapalo (data){
Kode lerroa:   if (!data) return data
Kode lerroa:   if (!data.target) return data
Kode lerroa:   let textQuoteSelectorIndex
Kode lerroa:   if (Array.isArray(data.target)){
Kode lerroa:      textQuoteSelectorIndex = _.findIndex(data.target[0].selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:      if (textQuoteSelectorIndex > -1) {
Kode lerroa:        let pre = data.target[0].selector[textQuoteSelectorIndex].prefix
Kode lerroa:        data.target[0].selector[textQuoteSelectorIndex].prefix  = unescape(pre)
Kode lerroa:        let suf = data.target[0].selector[textQuoteSelectorIndex].suffix
Kode lerroa:        data.target[0].selector[textQuoteSelectorIndex].suffix  = unescape(suf)
Kode lerroa:      }
Kode lerroa:   }else{
Kode lerroa:     textQuoteSelectorIndex = _.findIndex(data.target.selector, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:     if (textQuoteSelectorIndex > -1) {
Kode lerroa:       let pre = data.target.selector[textQuoteSelectorIndex].prefix
Kode lerroa:       data.target.selector[textQuoteSelectorIndex].prefix  = unescape(pre)
Kode lerroa:       let suf = data.target.selector[textQuoteSelectorIndex].suffix
Kode lerroa:       data.target.selector[textQuoteSelectorIndex].suffix  = unescape(suf)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   if (data['text']) {
Kode lerroa:     data['text'] = unescape(data['text'])
Kode lerroa:   }
Kode lerroa:   if (data['body']) {
Kode lerroa:     if (data.body.description) {
Kode lerroa:       data.body.description = escape(data.body.description)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return data
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function traverse (o) {
Kode lerroa:   for (var i in o) {
Kode lerroa:     //debuggingg('>>>> ' + i + ' <<<<' + JSON.stringify(o[i]))
Kode lerroa:     if (i === 'text') {
Kode lerroa:       o[i] = unescape(o[i])
Kode lerroa:     }
Kode lerroa:     if (i === 'description') {
Kode lerroa:       o[i] = unescape(o[i])
Kode lerroa:     }
Kode lerroa:     if (o[i]['@value'] && o[i]['type']=== 'xsd:long') {
Kode lerroa:       //alert (parseInt(o[i]['@value']))
Kode lerroa:         o[i] = parseInt(o[i]['@value'])
Kode lerroa:     }
Kode lerroa:     if (i === 'group' && o[i] !== null && typeof (o[i]) === 'object') {
Kode lerroa:       o[i] = o[i]['@value']
Kode lerroa:     }
Kode lerroa:     if (i === 'id' && o[i] !== null && typeof (o[i]) === 'object') {
Kode lerroa:     //  debuggingg('>>>> RETURNING')
Kode lerroa:       return traverse(o[i])
Kode lerroa:     }
Kode lerroa:     if (o[i] !== null && typeof (o[i]) === 'object') {
Kode lerroa:       // going one step down in the object tree!!
Kode lerroa:       //debuggingg('>>>> TRAVERSING')
Kode lerroa:       o[i] = traverse(o[i])
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   return o
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function apiCallJSON (settings, callback) {
Kode lerroa:   debuggingg('apiCallJSON:: ' + settings.data)
Kode lerroa:   axios(settings).catch(() => {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback(new Error('Unable to execute:  ' + settings.data), [])
Kode lerroa:     }
Kode lerroa:   }).then((response) => {
Kode lerroa:     if (!_.isUndefined(response)) {
Kode lerroa:       let expandedData = response.data
Kode lerroa:       if (expandedData.length === 0) {
Kode lerroa:         callback(null, [])
Kode lerroa:       } else {
Kode lerroa:         // compact a document according to a particular context
Kode lerroa:         // TODO To be solved when jsonld dependency get compilable
Kode lerroa:         /* jsonld.compact(expandedData, { '@context': contextualization }, function (err, compacted) {
Kode lerroa:           if (err) console.error('Error compacting: ' + err)
Kode lerroa:           callback(null, compacted)
Kode lerroa:         }) */
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   })
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function apiCall (settings, callback) {
Kode lerroa:   debuggingg('apiCall:: ' + settings.data)
Kode lerroa:   axios(settings).catch(() => {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback(new Error('Unable to execute:  ' + settings.data), [])
Kode lerroa:     }
Kode lerroa:   }).then((response) => {
Kode lerroa:     if (!_.isUndefined(response)) {
Kode lerroa:       if (!_.isUndefined(response.data.results[0])) { doNothing() } // debuggingg('RESULT:' + JSON.stringify(response.data.results[0]))
Kode lerroa:       if (!_.isUndefined(response.data.errors[0])) { doNothing() } // debuggingg('ERROR::' + JSON.stringify(response.data.errors[0]))
Kode lerroa:       let result = response.data
Kode lerroa:       callback(null, result)
Kode lerroa:     }
Kode lerroa:   })
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:    * Giving an annotation data, it is created in Neo4J
Kode lerroa:    * @param context The this object to access configuration data
Kode lerroa:    * @param query
Kode lerroa:    * @param callback Function to execute after annotation creation
Kode lerroa:    */
Kode lerroa: function commitNeo4J (query, callback) {
Kode lerroa:   debuggingg(' QUERY>> ' + query)
Kode lerroa:   let url = contextus.baseURI + '/db/data/transaction/commit'
Kode lerroa:   let statement = `{ "statements" : [ {"includeStats" : true,
Kode lerroa:     "statement" :  "` + query + `"} ]}`
Kode lerroa:   let settings = {
Kode lerroa:     'async': true,
Kode lerroa:     'crossDomain': true,
Kode lerroa:     'url': url,
Kode lerroa:     'method': 'POST',
Kode lerroa:     'headers': {
Kode lerroa:       'authorization': 'Basic ' + contextus.userToken, // admin:onekin https://www.base64decode.org/   https://neo4j.com/docs/http-api/3.5/security/
Kode lerroa:       'content-type': 'application/json',
Kode lerroa:       'cache-control': 'no-cache'
Kode lerroa:     },
Kode lerroa:     data: statement
Kode lerroa:   }
Kode lerroa:   debuggingg(JSON.stringify(settings, null, 2))
Kode lerroa:   apiCall(settings, callback)
Kode lerroa: }
Kode lerroa: 
Kode lerroa: var verbose = true
Kode lerroa: function debuggingg (msg, priority) {
Kode lerroa:   if (priority === true) verbose = true
Kode lerroa:   if (verbose) {
Kode lerroa:     console.debug('::>' + msg)
Kode lerroa:   }
Kode lerroa:   if (priority === false) verbose = false
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function randomString (length = 17, charSet) {
Kode lerroa:   charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-'
Kode lerroa:   let randomString = ''
Kode lerroa:   for (let i = 0; i < length; i++) {
Kode lerroa:     let randomPoz = Math.floor(Math.random() * charSet.length)
Kode lerroa:     randomString += charSet.substring(randomPoz, randomPoz + 1)
Kode lerroa:   }
Kode lerroa:   return randomString + now.getMilliseconds()
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function escapify (myJSON) {
Kode lerroa:   var myJSONString = JSON.stringify(myJSON)
Kode lerroa:   var myEscapedJSONString = myJSONString.replace(/'/g, "\\'").replace(/"/g, '\\"')
Kode lerroa:     .replace(/&/g, '\\&')
Kode lerroa:   // myEscapedJSONString is now ready to be POST'ed to the server.
Kode lerroa:   return myEscapedJSONString
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:    * Giving an annotation data, it is created in Neo4J
Kode lerroa:    * @param context The this object to access configuration data
Kode lerroa:    * @param queries queries
Kode lerroa:    * @param callback Function to execute after annotation creation
Kode lerroa:    */
Kode lerroa: /* function commitNeo4JMultiple (queries, callback, context) {
Kode lerroa:   if (!context) {
Kode lerroa:     context = contextus
Kode lerroa:   }
Kode lerroa:   let url = context.baseURI + '/db/data/transaction/commit'
Kode lerroa:   let sts = `{ "statements" : [ `
Kode lerroa:   let first = true
Kode lerroa:   for (let i = 0; i < queries.length; i++) {
Kode lerroa:     if (first) {
Kode lerroa:       first = false
Kode lerroa:       sts += `{"includeStats" : true, "statement" :  "` + queries[i] + `"}`
Kode lerroa:     } else {
Kode lerroa:       sts += `, {"includeStats" : true, "statement" :  "` + queries[i] + `"}`
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   sts += ` ]}`
Kode lerroa:   let settings = {
Kode lerroa:     'async': true,
Kode lerroa:     'crossDomain': true,
Kode lerroa:     'url': url,
Kode lerroa:     'method': 'POST',
Kode lerroa:     'headers': {
Kode lerroa:       'authorization': 'Basic ' + context.userToken, // IKER https:// neo4j.com/docs/http-api/3.5/security/
Kode lerroa:       'content-type': 'application/json',
Kode lerroa:       'cache-control': 'no-cache'
Kode lerroa:     },
Kode lerroa:     data: sts
Kode lerroa:   }
Kode lerroa:   apiCall(settings, callback)
Kode lerroa: } */
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:  * Lauches a cypher query and returns the rdf representation
Kode lerroa:  * @param cypher
Kode lerroa:  * @param callback
Kode lerroa:  */
Kode lerroa: function cypherRDFNeo4J (cypher, callback) {
Kode lerroa:   let url = contextus.baseURI + '/rdf/cypheronrdf'
Kode lerroa:   let statement = ` {"cypher" : "` + cypher + `"}`
Kode lerroa:   let settings = {
Kode lerroa:     'async': true,
Kode lerroa:     'crossDomain': true,
Kode lerroa:     'url': url,
Kode lerroa:     'method': 'POST',
Kode lerroa:     'headers': {
Kode lerroa:       'authorization': 'Basic ' + contextus.userToken, // IKER https:// neo4j.com/docs/http-api/3.5/security/
Kode lerroa:       'content-type': 'application/json',
Kode lerroa:       'Accept': 'application/ld+json',
Kode lerroa:       'cache-control': 'no-cache'
Kode lerroa:     },
Kode lerroa:     data: statement
Kode lerroa:   }
Kode lerroa:   apiCallJSON(settings, callback)
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function initializeGraph (err, response) {
Kode lerroa:   let q = "CREATE (:NamespacePrefixDefinition {`http://www.w3.org/ns/activitystreams#`: 'as',`http://xmlns.com/foaf/0.1/`: 'foaf', `http://www.w3.org/ns/oa#`: 'oa', `http://www.w3.org/ns/prov#`: 'prov', `http://rdf.onekin.org/resources/ns/`: 'onekin', `http://purl.org/spar/datacite/`: 'datacite', `http://purl.org/dc/terms/`: 'dcterms'})"
Kode lerroa:   if (err) {
Kode lerroa:     commitNeo4J(q, debuggingg, contextus)
Kode lerroa:     return
Kode lerroa:   }
Kode lerroa:   if (!_.isUndefined(response.results[0].data[0].row)) {
Kode lerroa:     if (response.results[0].data[0].row[0] === 0) {
Kode lerroa:       commitNeo4J(q, createIndex)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: function createIndex (err, response) {
Kode lerroa:   let q = []
Kode lerroa:   q = 'CREATE INDEX ON :Resource(uri)'
Kode lerroa:   if (err) {
Kode lerroa:     commitNeo4J(q, debuggingg, contextus)
Kode lerroa:     return
Kode lerroa:   }
Kode lerroa:   commitNeo4J(q, debuggingg)
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /// END UTILS ///
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:  * Neo4J client class
Kode lerroa:  */
Kode lerroa: class Neo4JClient {
Kode lerroa:   /**
Kode lerroa:    * Create a Neo4J client
Kode lerroa:     * @param userName The user name for annotations
Kode lerroa:     * @param userToken The base64(user+password) to access the Neo4J API
Kode lerroa:   * @param baseURI The base URI of the Neo4J server. For example,  http:// localhost:7474
Kode lerroa:    */
Kode lerroa:   constructor (userName, userToken, baseURI) {
Kode lerroa:     this.userName = 'defaultUser'
Kode lerroa:     this.userToken = 'YWRtaW46b25la2lu' // admin:onekin
Kode lerroa:     this.baseURI = 'http://localhost:7474'
Kode lerroa:     this.baseN4J = 'http://neo4j.com/base/'
Kode lerroa:     if (userName) {
Kode lerroa:       if (userName != "") this.userName = userName //  btoa(user+":"+password)  // IKER: base64-encoded string of username:password.
Kode lerroa:     }
Kode lerroa:     if (userToken) {
Kode lerroa:       if (userToken != "") this.userToken = userToken //  btoa(user+":"+password)  // IKER: base64-encoded string of username:password.
Kode lerroa:     }
Kode lerroa:     //alert (this.userName+'::'+this.userToken )
Kode lerroa:     if (baseURI) {
Kode lerroa:       this.baseURI = baseURI //  btoa(user+":"+password)  // IKER: base64-encoded string of username:password.
Kode lerroa:     }
Kode lerroa:     this.group = {
Kode lerroa:       name: 'OpenSLR',
Kode lerroa:       description: 'Default Open Systematic Literature Review',
Kode lerroa:       id: "1",
Kode lerroa:       url: this.baseURI
Kode lerroa:     }
Kode lerroa:     contextus.userName = this.userName
Kode lerroa:     contextus.userToken = this.userToken
Kode lerroa:     contextus.baseURI = this.baseURI
Kode lerroa:     contextus.baseN4J = this.baseN4J
Kode lerroa:     let q = 'match (n:NamespacePrefixDefinition) return count(n)'
Kode lerroa:     commitNeo4J(q, initializeGraph)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Giving an annotation data, it is created in Neo4J
Kode lerroa:    * @param data Annotation {@link https:// h.readthedocs.io/en/latest/api-reference/#operation/createAnnotation body schema}
Kode lerroa:    * @param callback Function to execute after annotation creation
Kode lerroa:    */
Kode lerroa:   createNewAnnotation (data, callback) {
Kode lerroa:     console.debug (JSON.stringify(data, null, 4) )
Kode lerroa:     sleep(100)
Kode lerroa:     if (!data['@type'] && !data['type']) {
Kode lerroa:       data['@type'] = 'Annotation'
Kode lerroa:     } else if (!data['@type'] && data['type']) {
Kode lerroa:       data['@type'] = data['type']
Kode lerroa:       delete data['type']
Kode lerroa:     }
Kode lerroa:     console.debug ('1')
Kode lerroa:     data['user'] = this.userName
Kode lerroa:     if (!data['@id'] && !data['id']) {
Kode lerroa:       data['@id'] = randomString()
Kode lerroa:     }
Kode lerroa:     if (data['@id'] && data['id']) {
Kode lerroa:       delete data['id']
Kode lerroa:     }
Kode lerroa:     if (!data['@id'].startsWith(this.baseN4J)) {
Kode lerroa:       data['@id'] = this.baseN4J + data['@id']
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     if (data['target'] && data['oa:target']) {
Kode lerroa:       data['target'] = data['oa:target']
Kode lerroa:       delete data['oa:target']
Kode lerroa:     }
Kode lerroa: console.debug ('2' + data['agreement'])
Kode lerroa:     if (data['agreement']){
Kode lerroa:       let gree = data['agreement']
Kode lerroa:       let value = data['body']['value']
Kode lerroa:       data['body']['value']= gree
Kode lerroa:       data['body']['onekin__value'] = value
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     data = escapalo (data)
Kode lerroa:     // data['permissions'] = null
Kode lerroa: console.debug ('3')
Kode lerroa:     let today = new Date();
Kode lerroa:     var date = today.getFullYear()+'-'+(today.getMonth()+1)+'-'+today.getDate()
Kode lerroa:     var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds()
Kode lerroa:     var dateTime = date+'T'+time+'Z'
Kode lerroa:     if (!data['dcterms:created'] && !data['created']) {
Kode lerroa:       data['created'] = dateTime
Kode lerroa:     }
Kode lerroa:     data['modified'] = dateTime
Kode lerroa: console.debug ('4')
Kode lerroa:     data['@context'] = contextualization
Kode lerroa:     let q = `CALL semantics.importRDFSnippet(' ` + escapify(data) + `', 'JSON-LD', { handleMultival: 'ARRAY' , multivalPropList : ['http://www.w3.org/ns/oa#hasBody', 'http://rdf.onekin.org/resources/ns/references','http://rdf.onekin.org/resources/ns/tags']})`
Kode lerroa:     debuggingg(' PRE-QUERY>> ' + q)
Kode lerroa:     commitNeo4J(q, (err, result) => {
Kode lerroa:       if (err) {
Kode lerroa:         let msg = 'Error creating annotation: ' + JSON.stringify(err)
Kode lerroa:         console.error(err)
Kode lerroa:         callback(new Error(msg))
Kode lerroa:       } else {
Kode lerroa:         data['user'] = this.userName
Kode lerroa:         data['id'] = data['@id'].replace(this.baseN4J, '')
Kode lerroa: 
Kode lerroa:         if (data['target'] && !data['oa:target']) {
Kode lerroa:           data['oa:target'] = data['target']
Kode lerroa:         }
Kode lerroa: 
Kode lerroa:         data = descapalo (data)
Kode lerroa: debuggingg ('result:: ' + JSON.stringify(data) )
Kode lerroa:         callback(null, data)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Create a new, private group for the currently-authenticated user.
Kode lerroa:    * @param data Check the body request schema in https:// h.readthedocs.io/en/latest/api-reference/#operation/createGroup
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   createNewGroup (data, callback) {
Kode lerroa:     callback(new Error('Neo4J does not manage groups'))
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Creates in Neo4J server sequentially a given list of annotations
Kode lerroa:    * @param annotations A list of annotation bodies
Kode lerroa:    * @param callback Function to execute after annotations are created
Kode lerroa:    * @return progress Holds progress of creating process, current and max values in number of pending annotations to finish.
Kode lerroa:    */
Kode lerroa:   createNewAnnotationsSequential (annotations, callback) {
Kode lerroa:     let createdAnnotations = []
Kode lerroa:     let progress = { current: 0, max: annotations.length }
Kode lerroa:     //  Create promise handler
Kode lerroa:     let runPromiseToCreateAnnotation = (d) => {
Kode lerroa:       return new Promise((resolve, reject) => {
Kode lerroa:         this.createNewAnnotation(d, (err, annotation) => {
Kode lerroa:           if (err) {
Kode lerroa:             reject(err)
Kode lerroa:           } else {
Kode lerroa:             createdAnnotations.push(annotation)
Kode lerroa:             resolve()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     let promiseChain = annotations.reduce(
Kode lerroa:       (chain, d, index) => {
Kode lerroa:         return chain.then(() => {
Kode lerroa:           progress.current = index //  Update progress current value
Kode lerroa:           return runPromiseToCreateAnnotation(d)
Kode lerroa:         })
Kode lerroa:       }, Promise.resolve()
Kode lerroa:     )
Kode lerroa:     promiseChain.catch((reject) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(reject)
Kode lerroa:       }
Kode lerroa:     }).then(() => {
Kode lerroa:       progress.current = annotations.length
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null, createdAnnotations)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Create a list of annotations in parallel
Kode lerroa:    * @param annotations A list of annotation bodies
Kode lerroa:    * @param callback Function to execute after annotations are created
Kode lerroa:    */
Kode lerroa:   createNewAnnotationsParallel (annotations, callback) {
Kode lerroa:     let promises = []
Kode lerroa:     for (let i = 0; i < annotations.length; i++) {
Kode lerroa:       promises.push(new Promise((resolve, reject) => {
Kode lerroa:         this.createNewAnnotation(annotations[i], (err, response) => {
Kode lerroa:           if (err) {
Kode lerroa:             reject(err)
Kode lerroa:           } else {
Kode lerroa:             resolve(response)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:         return true
Kode lerroa:       }))
Kode lerroa:     }
Kode lerroa:     Promise.all(promises).catch(() => {
Kode lerroa:       callback(new Error('Some annotations cannot be created'))
Kode lerroa:     }).then((responses) => {
Kode lerroa:       if (responses.length === annotations.length) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, responses)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(new Error('Some annotations cannot be created'))
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Given an array of annotations creates them in the Neo4J server
Kode lerroa:    * @param annotations
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   createNewAnnotations (annotations, callback) {
Kode lerroa:     if (_.isArray(annotations) && !_.isEmpty(annotations)) {
Kode lerroa:       this.createNewAnnotationsParallel(annotations, callback)
Kode lerroa:     } else {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Annotations object is not an array or is empty.'))
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Returns users profile:
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   getUserProfile (callback) {
Kode lerroa:     let profile = {
Kode lerroa:       'userid': this.userName,
Kode lerroa:       'display_name': this.userName,
Kode lerroa:       groups: [this.group],
Kode lerroa:       'annotations': [ ]
Kode lerroa:     }
Kode lerroa:     callback(null, profile)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Fetches an annotation by id
Kode lerroa:    * @param id
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   fetchAnnotation (id, callback) {
Kode lerroa:     let cypher = `match (r)<-[c]-(n)-[a]->(p)-[b]->(q) where n.uri = '` + this.baseN4J + id + `' return n,a,p,b,q, c, r`
Kode lerroa:     debuggingg('FETCHING ID => ' + id + ':::' + cypher)
Kode lerroa:     cypherRDFNeo4J(cypher, (err, data) => {
Kode lerroa:       if (err) {
Kode lerroa:         console.error(err)
Kode lerroa:       } else {
Kode lerroa:         let newdata = this.transformJSON(data, null, 2)
Kode lerroa:         newdata = getObjectId (newdata, this.baseN4J + id)
Kode lerroa:         if (!_.isArray(newdata.target)) {
Kode lerroa:           let array = [newdata.target]
Kode lerroa:           newdata.target = array
Kode lerroa:           newdata['oa:target'] = newdata.target
Kode lerroa:         } else {
Kode lerroa:           newdata['oa:target'] = newdata.target
Kode lerroa:         }
Kode lerroa:         //alert (JSON.stringify (newdata, null, 2))
Kode lerroa:         callback(null, newdata)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     this.cleanGarbage()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   cleanGarbage () {
Kode lerroa:     // let cypher = `MATCH (n:Resource) WHERE not ()--> (n) AND NOT (n) -->() DELETE n `
Kode lerroa:     let cypher = `match (n:Resource) where not ()--> (n) AND  n.uri STARTS WITH 'genid' detach delete n `
Kode lerroa:     debuggingg('Cleaning garbage STARTING ')
Kode lerroa:     commitNeo4J(cypher, (err, data) => {
Kode lerroa:       if (err) {
Kode lerroa:         console.error(err)
Kode lerroa:       } else {
Kode lerroa:         debuggingg('Cleaning garbage => ' + JSON.stringify(data))
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateAnnotation (idold, data, callback) {
Kode lerroa:     data['@id'] = idold
Kode lerroa:     debuggingg('UPDATING IDOLD => ' + idold)
Kode lerroa:       this.deleteAnnotation(data, (err, res) => {
Kode lerroa:         if (err) console.error(err)
Kode lerroa:         data.created = res.created
Kode lerroa:         //alert (data.created)
Kode lerroa:         this.createNewAnnotation(data, callback)
Kode lerroa:       })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Given an annotation or annotation id string, it deletes from Neo4J
Kode lerroa:    * @param annotation
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   deleteAnnotation (annotation, callback) {
Kode lerroa:     let linking = false
Kode lerroa:     let id = null
Kode lerroa:     if (_.isString(annotation)) {
Kode lerroa:       id = annotation
Kode lerroa:       linking = true
Kode lerroa:     } else if (_.has(annotation, 'id')) {
Kode lerroa:       id = annotation.id
Kode lerroa:     } else if (_.has(annotation, '@id')) {
Kode lerroa:       id = annotation['@id']
Kode lerroa:     } else {
Kode lerroa:       callback(new Error('This is not an annotation or an annotation ID.'))
Kode lerroa:       return
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     if (!id.startsWith(this.baseN4J)) {
Kode lerroa:       id = this.baseN4J + id
Kode lerroa:     }
Kode lerroa:     // let cypher = `MATCH (n{uri : '` + id + `'})-[oa__hasTarget]->(p)-[oa__hasSelector]->(q) DETACH  DELETE  n,p,q`
Kode lerroa:     let cypher = `MATCH (n{uri : '` + id + `'})-[:oa__hasTarget]->(p)-[:oa__hasSelector]->(q) DETACH  DELETE  n,p,q`
Kode lerroa:     if (_.has(annotation, 'tags')) {
Kode lerroa:       if (annotation['tags'].includes('motivation:linking')) {
Kode lerroa:         cypher = `MATCH (n{uri : '` + id + `'}) DETACH  DELETE n`
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (linking) {
Kode lerroa:       cypher = `MATCH (n{uri : '` + id + `'}) DETACH  DELETE n`
Kode lerroa:     }
Kode lerroa:     debuggingg('DELETING ID => ' + id + JSON.stringify(annotation))
Kode lerroa: 
Kode lerroa:     commitNeo4J(cypher, (err, data) => {
Kode lerroa:         if (err) {
Kode lerroa:           console.error(err)
Kode lerroa:         } else {
Kode lerroa:           callback(null, data)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Given a list of annotations or annotation ids, they are deleted in Neo4J
Kode lerroa:    * @param annotations a list of annotations or list of strings with each id
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   deleteAnnotations (annotations, callback) {
Kode lerroa:     //  Check and parse annotations to a list of ids (if it is not yet)
Kode lerroa:     let toDeleteAnnotations = []
Kode lerroa:     if (_.every(annotations, (annotation) => { return annotation.id })) {
Kode lerroa:       toDeleteAnnotations = _.map(annotations, 'id')
Kode lerroa:     } else if (_.every(annotations, String)) {
Kode lerroa:       toDeleteAnnotations = annotations
Kode lerroa:     }
Kode lerroa:     //  Create promises to delete all the annotations
Kode lerroa:     let promises = []
Kode lerroa:     for (let i = 0; i < toDeleteAnnotations.length; i++) {
Kode lerroa:       promises.push(new Promise((resolve, reject) => {
Kode lerroa:         this.deleteAnnotation(toDeleteAnnotations[i], (err, response) => {
Kode lerroa:           if (err) {
Kode lerroa:             reject(new Error('Unable to delete annotation id: ' + toDeleteAnnotations.id))
Kode lerroa:           } else {
Kode lerroa:             resolve(response)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:         return true
Kode lerroa:       }))
Kode lerroa:     }
Kode lerroa:     //  When all the annotations are deleted
Kode lerroa:     Promise.all(promises).catch((rejectedList) => {
Kode lerroa:       //  TODO List of rejected annotations
Kode lerroa:       callback(new Error('Unable to delete some annotations: '))
Kode lerroa:     }).then((responses) => {
Kode lerroa:       callback(null, responses)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Search annotations
Kode lerroa:    * @param data
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   searchAnnotations (data, callback) {
Kode lerroa:     // /Search by .....? Id, tags, group, user???
Kode lerroa:     let q = ''
Kode lerroa:     // URL
Kode lerroa: 
Kode lerroa:     let qmatch = `match (r)<-[c]-(n)-[a]->(p)-[b]->(q), (p)-[d]->(s)`
Kode lerroa:     let qreturn = ` return n,a,p,b,q,c,r,d,s`
Kode lerroa:     let qwhere = ` where `
Kode lerroa:     let qwhereboolean = false
Kode lerroa:     if (data.id) {
Kode lerroa:       qwhere += ` n.uri = '` + this.baseN4J + data.id + `' `
Kode lerroa:       qwhereboolean = true
Kode lerroa:       debuggingg('SEARCHING ID => ' + data.id)
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     if (data.uri && data.url) {
Kode lerroa:       if (qwhereboolean) qwhere += ` AND `
Kode lerroa:       qwhere += `( q.datacite__urn = '` + data.uri + `' `
Kode lerroa:       qwhere += `OR q.datacite__urn = '` + data.url + `' `
Kode lerroa:       qwhere += `OR q.datacite__url = '` + data.uri + `' `
Kode lerroa:       qwhere += `OR q.datacite__url = '` + data.url + `' `
Kode lerroa:       qwhere += `OR q.datacite__doi = '` + data.uri + `' `
Kode lerroa:       qwhere += `OR q.datacite__doi = '` + data.url + `') `
Kode lerroa:       qwhereboolean = true
Kode lerroa:       debuggingg('SEARCHING URI and URL => ' + data.uri + ' || ' + data.url)
Kode lerroa:     } else {
Kode lerroa:       if (data.uri) {
Kode lerroa:         if (qwhereboolean) qwhere += ` AND `
Kode lerroa:         qwhere += `( q.datacite__urn = '` + data.uri + `' `
Kode lerroa:         qwhere += `OR q.datacite__url = '` + data.uri + `' `
Kode lerroa:         qwhere += `OR q.datacite__doi = '` + data.uri + `') `
Kode lerroa:         qwhereboolean = true
Kode lerroa:         debuggingg('SEARCHING URI => ' + data.uri)
Kode lerroa:       }
Kode lerroa:       if (data.url) {
Kode lerroa:         if (qwhereboolean) qwhere += ` AND `
Kode lerroa:         qwhere += `( q.datacite__urn = '` + data.url + `' `
Kode lerroa:         qwhere += `OR q.datacite__url = '` + data.url + `' `
Kode lerroa:         qwhere += `OR q.datacite__doi = '` + data.url + `') `
Kode lerroa:         qwhereboolean = true
Kode lerroa:         debuggingg('SEARCHING URL => ' + data.url)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // User
Kode lerroa:     if ((data.user)) {
Kode lerroa:       qmatch += `, (n)-[dct__creator]->(n2) `
Kode lerroa:       if (qwhereboolean) qwhere += ` AND `
Kode lerroa:       qwhere += ` n2.uri = '` + data.user + `' `
Kode lerroa:       qwhereboolean = true
Kode lerroa:       debuggingg('SEARCHING USER=> ' + data.user)
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     // Tags
Kode lerroa:     if ((data.tag || data.tags)) {
Kode lerroa:       let tags = []
Kode lerroa:       if (_.isArray(data.tags) && _.every(data.tags, _.isString)) {
Kode lerroa:         tags = data.tags
Kode lerroa:       }
Kode lerroa:       if (_.isString(data.tags)) {
Kode lerroa:         tags.push(data.tags)
Kode lerroa:       }
Kode lerroa:       if (_.isString(data.tag)) {
Kode lerroa:         tags.push(data.tag)
Kode lerroa:       }
Kode lerroa:       // Remove duplicated tags
Kode lerroa:       tags = _.uniq(tags)
Kode lerroa:       // Check if annotation's tags includes all the tags
Kode lerroa:       if (qwhereboolean) qwhere += ` AND `
Kode lerroa:       qwhere += ` '` + tags + `' IN n.onekin__tags `
Kode lerroa:       qwhereboolean = true
Kode lerroa:       var linking = false
Kode lerroa:       if (tags[0] === 'motivation:linking') {
Kode lerroa:         linking = true
Kode lerroa:         qreturn = ` return n,c`
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     if (qwhereboolean) {
Kode lerroa:       q = qmatch + qwhere + qreturn
Kode lerroa:     } else {
Kode lerroa:       q = qmatch + qreturn
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     cypherRDFNeo4J(q, (err, data) => {
Kode lerroa:       if (err) {
Kode lerroa:         console.error(err)
Kode lerroa:         callback(err, null)
Kode lerroa:       } else {
Kode lerroa:         let newData = []
Kode lerroa:         if (linking && !_.isEmpty(data)) {
Kode lerroa:           if (_.isEmpty(data['@graph'])) {
Kode lerroa:             newData.push(data)
Kode lerroa:           } else newData = this.transformJSON(data)
Kode lerroa:         } else newData = this.transformJSON(data)
Kode lerroa:         if (linking) {
Kode lerroa:           debuggingg('THIS IS LINKING 1 ::::> ' + JSON.stringify(newData))
Kode lerroa:         }
Kode lerroa:         // newData = this.transformJSON(data)
Kode lerroa:         if (linking) {
Kode lerroa:           debuggingg('THIS IS LINKING ::::> ' + JSON.stringify(newData))
Kode lerroa:         }
Kode lerroa:         for (let i = 0; i < newData.length; i++) {
Kode lerroa:           if (!_.isArray(newData[i].tags)) {
Kode lerroa:             let array = []
Kode lerroa:             array.push(newData[i].tags)
Kode lerroa:             newData[i].tags = array
Kode lerroa:           }
Kode lerroa:           if (!_.isArray(newData[i].target)  && newData[i].motivation !== 'assessing') {
Kode lerroa:             let array = []
Kode lerroa:             array.push(newData[i].target)
Kode lerroa:             newData[i].target = array
Kode lerroa:             newData[i]['oa:target'] = newData[i].target
Kode lerroa:           } else {
Kode lerroa:             newData[i]['oa:target'] = newData[i].target
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         // debuggingg('SEARCH ' + q + '\n POST-RESULT: ' + JSON.stringify(newData, null, 4), false)
Kode lerroa:         callback(null, newData)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     this.cleanGarbage()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Transform
Kode lerroa:    * @param data json
Kode lerroa:    * @return annotation json in required format
Kode lerroa:    */
Kode lerroa:   transformJSON33 (data) {
Kode lerroa:     // let txt = JSON.stringify(data, null, 1)
Kode lerroa:     // txt = txt.replace(new RegExp('"id": "http://neo4j.com/base/', 'g'), '"id": "')
Kode lerroa:     // debuggingg('*******\nCJSON.parse :: \n ' + txt + '\n**********\n')
Kode lerroa:     // data = JSON.parse(txt)
Kode lerroa:     let ctxt = data['@context']
Kode lerroa:     let grafus = data['@graph'] || {}
Kode lerroa:     let idTextQuoteSelector = {}
Kode lerroa:     let idTarget = {}
Kode lerroa:     let annotation = []
Kode lerroa:     for (let i = 0; i < grafus.length; i++) {
Kode lerroa:       let olddatum = grafus[i]
Kode lerroa:       if (olddatum['type']) {
Kode lerroa:         if (olddatum['type'] === 'Annotation') {
Kode lerroa:           olddatum['@context'] = ctxt
Kode lerroa:           annotation.push(olddatum)
Kode lerroa:         }
Kode lerroa:         if (olddatum['type'].endsWith('Selector')) { // === 'TextQuoteSelector') {
Kode lerroa:           idTextQuoteSelector[olddatum['id']] = olddatum
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         idTarget[olddatum['id']] = olddatum
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     annotation = traverse(annotation)
Kode lerroa:     debuggingg('*******\nCJSON.parse 55 :: \n ' + JSON.stringify(annotation, null, 2) + '\n**********\n')
Kode lerroa:     return annotation
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Transform
Kode lerroa:    * @param data json
Kode lerroa:    * @return annotation json in required format
Kode lerroa:    */
Kode lerroa:   transformJSON (data) {
Kode lerroa:     //let txt = JSON.stringify(data, null, 1)
Kode lerroa:     // txt = txt.replace(new RegExp('"id": "http://neo4j.com/base/', 'g'), '"id": "')
Kode lerroa:     // debuggingg('*******\nCJSON.parse :: \n ' + txt + '\n**********\n')
Kode lerroa:     //data = JSON.parse(txt)
Kode lerroa:     let ctxt = data['@context']
Kode lerroa:     let grafus = data['@graph'] || {}
Kode lerroa:     let idTextQuoteSelector = {}
Kode lerroa:     let idTarget = {}
Kode lerroa:     let annotation = []
Kode lerroa:     for (let i = 0; i < grafus.length; i++) {
Kode lerroa:       let olddatum = grafus[i]
Kode lerroa:       if (olddatum['type']) {
Kode lerroa:         if (olddatum['type'] === 'Annotation') {
Kode lerroa:           olddatum['@context'] = ctxt
Kode lerroa:           annotation.push(olddatum)
Kode lerroa:         }
Kode lerroa:         if (olddatum['type'].endsWith('Selector')) { // === 'TextQuoteSelector') {
Kode lerroa:           idTextQuoteSelector[olddatum['id']] = olddatum
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         idTarget[olddatum['id']] = olddatum
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     let anntxt = JSON.stringify(annotation, null, 3)
Kode lerroa:     let list = null
Kode lerroa:     list = idTarget
Kode lerroa:     for (let j in list) {
Kode lerroa:       let key = j
Kode lerroa:       let val = list[j]
Kode lerroa:       debuggingg('>>>>>>> ' + key)
Kode lerroa:       anntxt = anntxt.replace(new RegExp('"' + key + '"', 'g'), JSON.stringify(val))
Kode lerroa:     }
Kode lerroa:     list = null
Kode lerroa:     list = idTextQuoteSelector
Kode lerroa:     for (let j in list) {
Kode lerroa:       let key = j
Kode lerroa:       let val = list[j]
Kode lerroa:       debuggingg('>>>>>>> ' + key)
Kode lerroa:       anntxt = anntxt.replace(new RegExp('"' + key + '"', 'g'), JSON.stringify(val))
Kode lerroa:     }
Kode lerroa:     annotation = JSON.parse(anntxt)
Kode lerroa:     annotation = traverse(annotation)
Kode lerroa:     for (let i = 0; i < annotation.length; i++) {
Kode lerroa:       annotation[i] = descapalo (annotation[i])
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     debuggingg('*******\nCJSON.parse 22 :: \n ' + JSON.stringify(annotation, null, 2) + '\n**********\n')
Kode lerroa:     return annotation
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Get list of groups for current user
Kode lerroa:    * @param data
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   getListOfGroups (data, callback) {
Kode lerroa:     callback(null, this.group)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Update a group metadata: name, description or id (only for Authorities). Check: https:// h.readthedocs.io/en/latest/api-reference/#tag/groups/paths/~1groups~1{id}/patch
Kode lerroa:    * @param groupId
Kode lerroa:    * @param data
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   updateGroup (groupId, data, callback) {
Kode lerroa:     callback(new Error('Neo4J does not manage groups'))
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Retrieve a group data by its ID
Kode lerroa:    * @param groupId
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   fetchGroup (groupId, callback) {
Kode lerroa:     callback(new Error('Neo4J does not manage groups'))
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Remove a member from a Neo4J group. Currently only is allowed to remove yourself.
Kode lerroa:    * @param data
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   removeAMemberFromAGroup (data, callback) {
Kode lerroa:     callback(new Error('Neo4J does not manage groups'))
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: export default Neo4JClient
Kode lerroa: import _ from 'lodash'
Kode lerroa: import AnnotationServerManager from '../AnnotationServerManager'
Kode lerroa: import Alerts from '../../utils/Alerts'
Kode lerroa: import Neo4JClient from './Neo4JClient' // TODO Substitute by the real neo4j client
Kode lerroa: const userLoginCheckIntervalPeriodInSeconds = 5
Kode lerroa: 
Kode lerroa: class Neo4JClientManager extends AnnotationServerManager {
Kode lerroa:   constructor () {
Kode lerroa:     super()
Kode lerroa:     this.annotationServerMetadata = {
Kode lerroa:       annotationUrl: 'http://neo4j.com/base/',
Kode lerroa:       groupUrl: 'http://neo4j.com/base/',
Kode lerroa:       userUrl: 'http://neo4j.com/base/',
Kode lerroa:       annotationServerUrl: 'http://neo4j.com/base/'
Kode lerroa:     }
Kode lerroa:     this.isLoggedInInterval = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     this.reloadClient(callback)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   isLoggedIn (callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       this.getCredentials((err, credentials) => {
Kode lerroa:         if (err) {
Kode lerroa:           callback(err)
Kode lerroa:         } else {
Kode lerroa:           // TODO Check if user grant permission to access neo4j account
Kode lerroa:         //  if (true){ //credentials.endpoint === 'https://onekin.or' && credentials.token === 'aaa' && credentials.user === 'bbb') {
Kode lerroa:           callback(null, true)
Kode lerroa:           //          } else {
Kode lerroa:           //          callback(null, false)
Kode lerroa:           //      }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getCredentials (callback) {
Kode lerroa:     chrome.runtime.sendMessage({ scope: 'neo4j', cmd: 'getCredentials' }, ({ err, credentials }) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(new Error(err))
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, credentials)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   logIn (callback) {
Kode lerroa:     if (!this.isLoggedIn()) {
Kode lerroa:       this.askUserToLogIn((err) => {
Kode lerroa:         if (err) {
Kode lerroa:           callback(err)
Kode lerroa:         } else {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     } else {
Kode lerroa:       callback(null)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   askUserToLogIn (callback) {
Kode lerroa:     Alerts.confirmAlert({
Kode lerroa:       title: 'Neo4J login is required.',
Kode lerroa:       text: 'Please provide the required login configuration for neo4j.',
Kode lerroa:       callback: () => {
Kode lerroa:         Alerts.loadingAlert({ text: 'Waiting for neo4j credentials in the login tab.' })
Kode lerroa:         // Open new tab with configuration
Kode lerroa:         const neo4jConfigurationWindow = window.open(chrome.extension.getURL('pages/options.html#neo4jConfiguration'))
Kode lerroa:         // Interval until correctly logged in
Kode lerroa:         this.isLoggedInInterval = setInterval(() => {
Kode lerroa:           if (neo4jConfigurationWindow.closed) {
Kode lerroa:             if (_.isInteger(this.isLoggedInInterval)) {
Kode lerroa:               clearInterval(this.isLoggedInInterval)
Kode lerroa:             }
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback(new Error('The neo4j login tab was closed'))
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:           // Check if it is logged in or not
Kode lerroa:           this.isLoggedIn((err, isLoggedIn) => {
Kode lerroa:             if (err) {
Kode lerroa:               if (_.isInteger(this.isLoggedInInterval)) {
Kode lerroa:                 clearInterval(this.isLoggedInInterval)
Kode lerroa:               }
Kode lerroa:               if (_.isFunction(callback)) {
Kode lerroa:                 callback(err)
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               // If it is logged in, callback and remove interval who checks periodically login status
Kode lerroa:               if (isLoggedIn) {
Kode lerroa:                 Alerts.closeAlert()
Kode lerroa:                 if (_.isInteger(this.isLoggedInInterval)) {
Kode lerroa:                   clearInterval(this.isLoggedInInterval)
Kode lerroa:                 }
Kode lerroa:                 if (_.isFunction(callback)) {
Kode lerroa:                   callback(null)
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }, userLoginCheckIntervalPeriodInSeconds * 1000)
Kode lerroa:       },
Kode lerroa:       cancelCallback: () => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(new Error('User don\'t want to provide login credentials for neo4j'))
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadClient (callback) {
Kode lerroa:     // TODO Instantiate neo4j client with the correct credentials that the user has already provided
Kode lerroa:     this.getCredentials((err, credentials) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         //        alert ("CREDENTIASL: " + JSON.stringify(credentials.token,null, 4))
Kode lerroa:         this.client = new Neo4JClient(credentials.user, credentials.token, credentials.endpoint)
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadClientDELETE (callback) {
Kode lerroa:     // TODO Instantiate neo4j client with the correct credentials that the user has already provided
Kode lerroa:     this.client = new Neo4JClient()
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     clearInterval(this.isLoggedInInterval)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Neo4JClientManager
Kode lerroa: class AnnotationServer {
Kode lerroa:   constructor ({ group }) {
Kode lerroa:     this.group = group
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationServer
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class AnnotationServerManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.client = {}
Kode lerroa:     this.annotationServerMetadata = {
Kode lerroa:       annotationUrl: 'https://localannotationsdatabase.org/annotation/',
Kode lerroa:       groupUrl: 'https://localannotationsdatabase.org/group/',
Kode lerroa:       userUrl: 'https://localannotationsdatabase.org/user/',
Kode lerroa:       annotationServerUrl: 'https://localannotationsdatabase.org'
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   isLoggedIn () {
Kode lerroa:     return true
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   logIn (callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback(null)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadClient (callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback(null)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   constructSearchUrl ({
Kode lerroa:     groupId
Kode lerroa:   }) {
Kode lerroa:     return this.annotationServerMetadata + groupId
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback(null)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationServerManager
Kode lerroa: import Task from './Task'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import CryptoUtils from '../../utils/CryptoUtils'
Kode lerroa: import AnnotationUtils from '../../utils/AnnotationUtils'
Kode lerroa: import Codebook from '../../codebook/model/Codebook'
Kode lerroa: import Config from '../../Config'
Kode lerroa: // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BrowserStorage, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class CreateHighlighterTask extends Task {
Kode lerroa:   constructor (config) {
Kode lerroa:     super()
Kode lerroa:     this.config = config
Kode lerroa:     this.currentPromisesList = []
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     const promisesData = []
Kode lerroa:     for (let i = 0; i < this.config.activities.length; i++) {
Kode lerroa:       const rubric = this.config.activities[i].data.rubric
Kode lerroa:       const student = this.config.activities[i].data.student
Kode lerroa:       const siteUrl = new URL(rubric.moodleEndpoint)
Kode lerroa:       const courseId = this.config.activities[i].data.courseId
Kode lerroa:       const groupName = siteUrl.host + courseId + student.id
Kode lerroa:       // We create a hash using the course ID and the student ID to anonymize the Hypothes.is group
Kode lerroa:       const hashedGroupName = 'MG' + CryptoUtils.hash(groupName).substring(0, 23)
Kode lerroa:       promisesData.push({ rubric, groupName: hashedGroupName, id: i })
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     this.currentPromisesStatus = []
Kode lerroa: 
Kode lerroa:     const runPromiseToGenerateGroup = (d) => {
Kode lerroa:       return new Promise((resolve, reject) => {
Kode lerroa:         this.generateGroup({
Kode lerroa:           rubric: d.rubric,
Kode lerroa:           groupName: d.groupName,
Kode lerroa:           id: d.id,
Kode lerroa:           callback: (err, result) => {
Kode lerroa:             if (err) {
Kode lerroa:               reject(err)
Kode lerroa:             } else {
Kode lerroa:               this.currentPromisesStatus[d.id] = true
Kode lerroa:               if (result && result.nothingDone) {
Kode lerroa:                 resolve()
Kode lerroa:               } else {
Kode lerroa:                 setTimeout(resolve, 5000)
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     const promiseChain = promisesData.reduce(
Kode lerroa:       (chain, d) =>
Kode lerroa:         chain.then(() => {
Kode lerroa:           return runPromiseToGenerateGroup(d)
Kode lerroa:         }), Promise.resolve()
Kode lerroa:     )
Kode lerroa: 
Kode lerroa:     promiseChain.then(() => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   generateGroup ({ rubric, groupName, id, callback }) {
Kode lerroa:     this.currentPromisesStatus[id] = 'Checking if the group already exists'
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       this.loadAnnotationServer(() => {
Kode lerroa:         this.initLoginProcess(() => {
Kode lerroa:           // Create group
Kode lerroa:           this.annotationServerClientManager.client.getUserProfile((err, userProfile) => {
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               if (err) {
Kode lerroa:                 console.error(err)
Kode lerroa:                 this.currentPromisesStatus[id] = 'An unexpected error occurred when retrieving your user profile. Please check connection with the annotation server'
Kode lerroa:                 callback(err)
Kode lerroa:               } else {
Kode lerroa:                 this.currentPromisesStatus[id] = 'Checking if the annotation server is up to date'
Kode lerroa:                 this.annotationServerClientManager.client.getListOfGroups({}, (err, groups) => {
Kode lerroa:                   if (err) {
Kode lerroa:                     if (_.isFunction(callback)) {
Kode lerroa:                       callback(err)
Kode lerroa:                     }
Kode lerroa:                   } else {
Kode lerroa:                     this.groups = groups
Kode lerroa:                     const group = _.find(groups, (group) => {
Kode lerroa:                       return group.name === groupName
Kode lerroa:                     })
Kode lerroa:                     if (_.isEmpty(group)) {
Kode lerroa:                       this.currentPromisesStatus[id] = 'Creating new group to store annotations'
Kode lerroa:                       this.createGroup({ name: groupName }, (err, group) => {
Kode lerroa:                         this.setAnnotationServer(group, (annotationServer) => {
Kode lerroa:                           if (err) {
Kode lerroa:                             console.error('ErrorConfiguringHighlighter')
Kode lerroa:                             this.currentPromisesStatus[id] = chrome.i18n.getMessage('ErrorConfiguringHighlighter') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator')
Kode lerroa:                             callback(new Error(chrome.i18n.getMessage('ErrorConfiguringHighlighter') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])))
Kode lerroa:                           } else {
Kode lerroa:                             this.currentPromisesStatus[id] = 'Creating rubric highlighter in the annotation server'
Kode lerroa:                             this.createHighlighterAnnotations({
Kode lerroa:                               rubric, annotationServer, userProfile
Kode lerroa:                             }, () => {
Kode lerroa:                               callback(null)
Kode lerroa:                             })
Kode lerroa:                           }
Kode lerroa:                         })
Kode lerroa:                       })
Kode lerroa:                     } else {
Kode lerroa:                       this.setAnnotationServer(group, (annotationServer) => {
Kode lerroa:                         // Check if highlighter for assignment is already created
Kode lerroa:                         this.annotationServerClientManager.client.searchAnnotations({
Kode lerroa:                           group: annotationServer.group.id,
Kode lerroa:                           any: '"cmid:' + rubric.cmid + '"',
Kode lerroa:                           wildcard_uri: 'https://hypothes.is/groups/*'
Kode lerroa:                         }, (err, annotations) => {
Kode lerroa:                           if (err) {
Kode lerroa:                             callback(err)
Kode lerroa:                             this.currentPromisesStatus[id] = chrome.i18n.getMessage('ErrorConfiguringHighlighter') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])
Kode lerroa:                           } else {
Kode lerroa:                             this.currentPromisesStatus[id] = 'Updating rubric highlighter in the annotation server'
Kode lerroa:                             this.updateHighlighterAnnotations({
Kode lerroa:                               rubric, annotations, annotationServer, userProfile
Kode lerroa:                             }, () => {
Kode lerroa:                               callback(null)
Kode lerroa:                             })
Kode lerroa:                           }
Kode lerroa:                         })
Kode lerroa:                       })
Kode lerroa:                     }
Kode lerroa:                   }
Kode lerroa:                 })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setAnnotationServer (newGroup, callback) {
Kode lerroa:     let annotationAnnotationServer
Kode lerroa:     let group
Kode lerroa:     if (newGroup === null) {
Kode lerroa:       group = window.abwa.groupSelector.currentGroup
Kode lerroa:     } else {
Kode lerroa:       group = newGroup
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateHighlighterAnnotations ({ rubric, annotations, annotationServer, userProfile }, callback) {
Kode lerroa:     // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa:     // Create teacher annotation if not exists
Kode lerroa:     this.createTeacherAnnotation({ producerId: userProfile.userid, annotationServer: annotationServer }, (err) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(new Error(chrome.i18n.getMessage('ErrorRelatingMoodleAndTool') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])))
Kode lerroa:       } else {
Kode lerroa:         // Restore object
Kode lerroa:         rubric.annotationServer = annotationServer
Kode lerroa:         rubric = Codebook.createCodebookFromObject(rubric)
Kode lerroa:         // Check annotations pending
Kode lerroa:         const annotationsPending = _.differenceWith(rubric.toAnnotations(), annotations, AnnotationUtils.areEqual)
Kode lerroa:         // Check annotations to remove
Kode lerroa:         const annotationsToRemove = _.differenceWith(annotations, rubric.toAnnotations(), AnnotationUtils.areEqual)
Kode lerroa:         if (annotationsPending.length === 0 && annotationsToRemove.length === 0) {
Kode lerroa:           console.debug('Highlighter is already updated, skipping to the next group')
Kode lerroa:           callback(null, { nothingDone: true })
Kode lerroa:         } else {
Kode lerroa:           this.annotationServerClientManager.client.deleteAnnotations(annotationsToRemove, (err) => {
Kode lerroa:             if (err) {
Kode lerroa:               callback(new Error(chrome.i18n.getMessage('ErrorConfiguringHighlighter') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])))
Kode lerroa:             } else {
Kode lerroa:               this.annotationServerClientManager.client.createNewAnnotations(annotationsPending, (err, createdAnnotations) => {
Kode lerroa:                 if (err) {
Kode lerroa:                   callback(new Error(chrome.i18n.getMessage('ErrorConfiguringHighlighter') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])))
Kode lerroa:                 } else {
Kode lerroa:                   console.debug('Highlighter for group updated')
Kode lerroa:                   callback(null)
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createHighlighterAnnotations ({ rubric, annotationServer, userProfile }, callback) {
Kode lerroa:     // Generate group annotations
Kode lerroa:     rubric.annotationServer = annotationServer
Kode lerroa:     // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa:     rubric = Codebook.createCodebookFromObject(rubric) // convert to rubric to be able to run toAnnotations() function
Kode lerroa:     const annotations = rubric.toAnnotations()
Kode lerroa:     this.createTeacherAnnotation({ producerId: userProfile.userid, annotationServer: annotationServer }, (err) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(new Error(chrome.i18n.getMessage('ErrorRelatingMoodleAndTool') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])))
Kode lerroa:       } else {
Kode lerroa:         // Create annotations in hypothesis
Kode lerroa:         this.annotationServerClientManager.client.createNewAnnotations(annotations, (err, createdAnnotations) => {
Kode lerroa:           if (err) {
Kode lerroa:             callback(new Error(chrome.i18n.getMessage('ErrorConfiguringHighlighter') + '<br/>' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])))
Kode lerroa:           } else {
Kode lerroa:             console.debug('Group created')
Kode lerroa:             callback(null)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createGroup ({ name, assignmentName = '', student = '' }, callback) {
Kode lerroa:     this.annotationServerClientManager.client.createNewGroup({ name: name, description: 'An resource based generated group to mark the assignment in moodle called ' + assignmentName }, (err, group) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, group)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createTeacherAnnotation ({ producerId, annotationServer }, callback) {
Kode lerroa:     const teacherAnnotation = this.generateTeacherAnnotation(producerId, annotationServer)
Kode lerroa:     // Check if annotation already exists
Kode lerroa:     this.annotationServerClientManager.client.searchAnnotations({ group: annotationServer.group.id, tags: Config.namespace + ':' + Config.tags.producer }, (err, annotations) => {
Kode lerroa:       if (err) {
Kode lerroa: 
Kode lerroa:       } else {
Kode lerroa:         // If annotation exist and teacher is the same, nothing to do
Kode lerroa:         if (annotations.length > 0 && annotations[0].text === teacherAnnotation.text) {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         } else { // Otherwise, create the annotation
Kode lerroa:           this.annotationServerClientManager.client.createNewAnnotation(teacherAnnotation, (err, annotation) => {
Kode lerroa:             if (err) {
Kode lerroa:               if (_.isFunction(callback)) {
Kode lerroa:                 callback(err)
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               console.debug('Created teacher annotation')
Kode lerroa:               if (_.isFunction(callback)) {
Kode lerroa:                 callback()
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   generateTeacherAnnotation (producerId, annotationServer) {
Kode lerroa:     return {
Kode lerroa:       group: annotationServer.group.id,
Kode lerroa:       permissions: {
Kode lerroa:         read: ['group:' + annotationServer.group.id]
Kode lerroa:       },
Kode lerroa:       references: [],
Kode lerroa:       tags: [Config.namespace + ':' + Config.tags.producer],
Kode lerroa:       target: [],
Kode lerroa:       text: 'producerId: ' + producerId,
Kode lerroa:       uri: annotationServer.group.links.html // Compatibility with both group representations getGroups and userProfile
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadAnnotationServer (callback) {
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()=1, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initLoginProcess (callback) {
Kode lerroa:     this.annotationServerClientManager.logIn((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         callback(null)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getStatus () {
Kode lerroa:     const numberTotal = this.config.activities.length
Kode lerroa:     const finished = _.countBy(this.currentPromisesStatus, (promiseList) => {
Kode lerroa:       return promiseList === true
Kode lerroa:     }).true || '0'
Kode lerroa:     if (finished < numberTotal) {
Kode lerroa:       const currentTaskName = _.last(this.currentPromisesStatus)
Kode lerroa:       if (currentTaskName !== true) {
Kode lerroa:         return currentTaskName + ' (' + finished + '/' + numberTotal + ')'
Kode lerroa:       } else {
Kode lerroa:         return 'Creating group (' + finished + '/' + numberTotal + ')'
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       return 'Creating group (' + finished + '/' + numberTotal + ')'
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default CreateHighlighterTask
Kode lerroa: class Task {
Kode lerroa:   getStatus () {
Kode lerroa:     return 'Current status unavailable'
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Task
Kode lerroa: import ChromeStorage from '../utils/ChromeStorage'
Kode lerroa: import Config from '../Config'
Kode lerroa: 
Kode lerroa: class AnnotationServerManager {
Kode lerroa:   init () {
Kode lerroa:     // Initialize replier for requests related to annotationServer
Kode lerroa:     this.initResponsers()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initResponsers () {
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'annotationServer') {
Kode lerroa:         if (request.cmd === 'getSelectedAnnotationServer') {
Kode lerroa:           ChromeStorage.getData('annotationServer.selected', ChromeStorage.sync, (err, annotationServer) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               if (annotationServer) {
Kode lerroa:                 const parsedAnnotationServer = JSON.parse(annotationServer.data)
Kode lerroa:                 sendResponse({ annotationServer: parsedAnnotationServer || '' })
Kode lerroa:               } else {
Kode lerroa:                 const defaultAnnotationServer = Config.defaultAnnotationServer
Kode lerroa:                 sendResponse({ annotationServer: defaultAnnotationServer })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'setSelectedAnnotationServer') {
Kode lerroa:           const selectedAnnotationServer = request.data.annotationServer
Kode lerroa:           ChromeStorage.setData('annotationServer.selected', { data: JSON.stringify(selectedAnnotationServer) }, ChromeStorage.sync, (err) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ annotationServer: selectedAnnotationServer })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return true
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationServerManager
Kode lerroa: import GoogleSheetClient from '../googleSheets/GoogleSheetClient'
Kode lerroa: // PVSCL:IFCOND(GoogleSheetConsumer,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class GoogleSheetsManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.googleSheetClient = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'googleSheets') {
Kode lerroa:         if (request.cmd === 'getToken') {
Kode lerroa:           chrome.identity.getAuthToken({ interactive: true }, function (token) {
Kode lerroa:             if (chrome.runtime.lastError) {
Kode lerroa:               sendResponse({ error: chrome.runtime.lastError })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ token: token })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:           return true
Kode lerroa:         } else if (request.cmd === 'getTokenSilent') {
Kode lerroa:           chrome.identity.getAuthToken({ interactive: false }, function (token) {
Kode lerroa:             if (chrome.runtime.lastError) {
Kode lerroa:               sendResponse({ error: chrome.runtime.lastError })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ token: token })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:           return true
Kode lerroa:         }/* PVSCL:IFCOND(GoogleSheetProvider) */ else if (request.cmd === 'getSpreadsheet') {
Kode lerroa: /* PVSCL:IFCOND(GoogleSheetConsumer) */ else if (request.cmd === 'createSpreadsheet') {
Kode lerroa: 
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GoogleSheetsManager
Kode lerroa: import DOM from '../utils/DOM'
Kode lerroa: import $ from 'jquery'
Kode lerroa: const checkHypothesisLoggedIntervalInSeconds = 20 // fetch token every X seconds
Kode lerroa: const checkHypothesisLoggedInWhenPromptInSeconds = 0.5 // When user is prompted to login, the checking should be with higher period
Kode lerroa: const maxTries = 10 // max tries before deleting the token
Kode lerroa: 
Kode lerroa: class HypothesisManager {
Kode lerroa:   constructor () {
Kode lerroa:     // Define token
Kode lerroa:     this.token = null
Kode lerroa:     // Define tries before logout
Kode lerroa:     this.tries = 0
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Try to load token for first time
Kode lerroa:     this.retrieveHypothesisToken((err, token) => {
Kode lerroa:       this.setToken(err, token)
Kode lerroa:     })
Kode lerroa: 
Kode lerroa:     // Create an observer to check if user is logged to hypothesis
Kode lerroa:     this.createRetryHypothesisTokenRetrieve()
Kode lerroa: 
Kode lerroa:     // Initialize replier for login form authentication
Kode lerroa:     this.initShowHypothesisLoginForm()
Kode lerroa: 
Kode lerroa:     // Initialize replier for requests of hypothesis related metadata
Kode lerroa:     this.initResponserForGetToken()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createRetryHypothesisTokenRetrieve (intervalSeconds = checkHypothesisLoggedIntervalInSeconds) {
Kode lerroa:     const intervalHandler = () => {
Kode lerroa:       this.retrieveHypothesisToken((err, token) => {
Kode lerroa:         this.setToken(err, token)
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     this.retrieveTokenInterval = setInterval(intervalHandler, intervalSeconds * 1000)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   changeTokenRetrieveInterval (seconds = checkHypothesisLoggedIntervalInSeconds) {
Kode lerroa:     clearInterval(this.retrieveTokenInterval)
Kode lerroa:     this.createRetryHypothesisTokenRetrieve(seconds)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   retrieveHypothesisToken (callback) {
Kode lerroa:     const callSettings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       url: 'https://hypothes.is/account/developer',
Kode lerroa:       method: 'GET'
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     DOM.scrapElement(callSettings, '#token', (error, resultNodes) => {
Kode lerroa:       if (error) {
Kode lerroa:         callback(error)
Kode lerroa:       } else {
Kode lerroa:         if (!resultNodes[0]) {
Kode lerroa:           $.post('https://hypothes.is/account/developer', () => {
Kode lerroa:             DOM.scrapElement(callSettings, '#token', (error, resultNodes) => {
Kode lerroa:               if (error) {
Kode lerroa:                 callback(error)
Kode lerroa:               } else {
Kode lerroa:                 const hypothesisToken = resultNodes[0].value
Kode lerroa:                 callback(null, hypothesisToken)
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           })
Kode lerroa:         } else {
Kode lerroa:           const hypothesisToken = resultNodes[0].value
Kode lerroa:           callback(null, hypothesisToken)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setToken (err, token) {
Kode lerroa:     if (err) {
Kode lerroa:       console.error('The token is unreachable')
Kode lerroa:       if (this.tries >= maxTries) { // The token is unreachable after some tries, probably the user is logged out
Kode lerroa:         this.token = null // Probably the website is down or the user has been logged out
Kode lerroa:         console.error('The token is deleted after unsuccessful %s tries', maxTries)
Kode lerroa:       } else {
Kode lerroa:         this.tries += 1 // The token is unreachable, add a done try
Kode lerroa:         console.debug('The token is unreachable for %s time(s), but is maintained %s', this.tries, this.token)
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       console.debug('User is logged in Hypothesis. His token is %s', token)
Kode lerroa:       this.token = token
Kode lerroa:       this.tries = 0
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initShowHypothesisLoginForm () {
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'hypothesis') {
Kode lerroa:         if (request.cmd === 'userLoginForm') {
Kode lerroa:           // Create new tab on google chrome
Kode lerroa:           chrome.tabs.create({ url: 'https://hypothes.is/login' }, (tab) => {
Kode lerroa:             // Retrieve hypothesis token periodically
Kode lerroa:             const interval = setInterval(() => {
Kode lerroa:               this.retrieveHypothesisToken((err, token) => {
Kode lerroa:                 if (err) {
Kode lerroa:                   console.log('Checking again in %s seconds', checkHypothesisLoggedInWhenPromptInSeconds)
Kode lerroa:                 } else {
Kode lerroa:                   // Once logged in, take the token and close the tab
Kode lerroa:                   this.token = token
Kode lerroa:                   chrome.tabs.remove(tab.id, () => {
Kode lerroa:                     clearInterval(interval)
Kode lerroa:                     sendResponse({ token: this.token })
Kode lerroa:                   })
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }, checkHypothesisLoggedInWhenPromptInSeconds * 1000)
Kode lerroa:             // Set event for when user close the tab
Kode lerroa:             const closeTabListener = (closedTabId) => {
Kode lerroa:               if (closedTabId === tab.id && !this.token) {
Kode lerroa:                 // Remove listener for hypothesis token
Kode lerroa:                 clearInterval(interval)
Kode lerroa:                 // Hypothes.is login tab is closed
Kode lerroa:                 sendResponse({ error: 'Hypothesis tab closed intentionally' })
Kode lerroa:               }
Kode lerroa:               chrome.tabs.onRemoved.removeListener(closeTabListener)
Kode lerroa:             }
Kode lerroa:             chrome.tabs.onRemoved.addListener(closeTabListener)
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return true
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initResponserForGetToken () {
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'hypothesis') {
Kode lerroa:         if (request.cmd === 'getToken') {
Kode lerroa:           sendResponse(this.token)
Kode lerroa:         } else if (request.cmd === 'startListeningLogin') {
Kode lerroa:           this.changeTokenRetrieveInterval(checkHypothesisLoggedInWhenPromptInSeconds) // Reduce to 0.5 seconds
Kode lerroa:         } else if (request.cmd === 'stopListeningLogin') {
Kode lerroa:           this.changeTokenRetrieveInterval(checkHypothesisLoggedIntervalInSeconds) // Token retrieve to 20 seconds
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default HypothesisManager
Kode lerroa: import axios from 'axios'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import ChromeStorage from '../utils/ChromeStorage'
Kode lerroa: import MoodleClient from '../moodle/MoodleClient'
Kode lerroa: import MoodleFunctions from '../moodle/MoodleFunctions'
Kode lerroa: 
Kode lerroa: class MoodleBackgroundManager {
Kode lerroa:   init () {
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'moodle') {
Kode lerroa:         if (request.cmd === 'getTokenForEndpoint') {
Kode lerroa:           if (_.isString(request.data.endpoint)) {
Kode lerroa:             const endpoint = request.data.endpoint
Kode lerroa:             this.getTokens(endpoint, (err, tokens) => {
Kode lerroa:               if (err) {
Kode lerroa:                 sendResponse({ err: err })
Kode lerroa:               } else {
Kode lerroa:                 this.testTokens({ endpoint, tokens }, (err, tokens) => {
Kode lerroa:                   if (err) {
Kode lerroa:                     sendResponse({ err: err })
Kode lerroa:                   } else {
Kode lerroa:                     // Return token in response
Kode lerroa:                     sendResponse({ tokens: tokens })
Kode lerroa:                   }
Kode lerroa:                 })
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:         } else if (request.cmd === 'setMoodleCustomEndpoint') {
Kode lerroa:           const endpoint = request.data.endpoint
Kode lerroa:           ChromeStorage.setData('moodleCustomEndpoint', { data: JSON.stringify(endpoint) }, ChromeStorage.sync, (err, data) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ endpoint: endpoint })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'getMoodleCustomEndpoint') {
Kode lerroa:           ChromeStorage.getData('moodleCustomEndpoint', ChromeStorage.sync, (err, endpoint) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               if (endpoint) {
Kode lerroa:                 const parsedEndpoint = JSON.parse(endpoint.data)
Kode lerroa:                 sendResponse({ endpoint: parsedEndpoint || '' })
Kode lerroa:               } else {
Kode lerroa:                 sendResponse({ endpoint: '' })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'saveGrantedPermissionMoodle') {
Kode lerroa:           ChromeStorage.setData('moodlePermission', { saved: true }, ChromeStorage.sync, (err) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ saved: true })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'hasGrantedPermissionMoodle') {
Kode lerroa:           ChromeStorage.getData('moodlePermission', ChromeStorage.sync, (err, consent) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ consent: consent })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'isApiSimulationActivated') {
Kode lerroa:           ChromeStorage.getData('moodleApiSimulation', ChromeStorage.sync, (err, isActivated) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ activated: false })
Kode lerroa:             } else {
Kode lerroa:               sendResponse(isActivated || { activated: false })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'setApiSimulationActivation') {
Kode lerroa:           ChromeStorage.setData('moodleApiSimulation', { activated: request.data.isActivated }, ChromeStorage.sync, (err, response) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err, saved: false })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ saved: true })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'isAutoOpenFilesActivated') {
Kode lerroa:           ChromeStorage.getData('autoOpenFiles', ChromeStorage.sync, (err, isActivated) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ activated: false })
Kode lerroa:             } else {
Kode lerroa:               sendResponse(isActivated || { activated: false })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'setAutoOpenFiles') {
Kode lerroa:           ChromeStorage.setData('autoOpenFiles', { activated: request.data.isActivated }, ChromeStorage.sync, (err, response) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err, saved: false })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ saved: true })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getTokens (endpoint, callback) {
Kode lerroa:     // Open preferences page
Kode lerroa:     axios.get(endpoint + 'user/preferences.php')
Kode lerroa:       .then((response) => {
Kode lerroa:         const parser = new window.DOMParser()
Kode lerroa:         const docPreferences = parser.parseFromString(response.data, 'text/html')
Kode lerroa:         const tokenLinkElement = docPreferences.querySelector('a[href*="managetoken.php"]')
Kode lerroa:         if (_.isElement(tokenLinkElement)) {
Kode lerroa:           const manageToken = tokenLinkElement.href
Kode lerroa:           // Open managetokens page
Kode lerroa:           axios.get(manageToken)
Kode lerroa:             .then((response) => {
Kode lerroa:               // Retrieve all tokens
Kode lerroa:               const docManageToken = parser.parseFromString(response.data, 'text/html')
Kode lerroa:               const tokenElements = docManageToken.querySelectorAll('.c0:not([scope="col"])')
Kode lerroa:               if (!_.isEmpty(tokenElements)) {
Kode lerroa:                 const tokens = _.map(tokenElements, (tokenElement) => {
Kode lerroa:                   console.log(tokenElement.innerText)
Kode lerroa:                   return tokenElement.innerText
Kode lerroa:                 })
Kode lerroa:                 callback(null, tokens)
Kode lerroa:               } else {
Kode lerroa:                 callback(new Error('Unable to retrieve tokens from DOM'))
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:         } else {
Kode lerroa:           callback(new Error('Unable to open managetoken.php. Are you subscribed to any service?'))
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   testTokens ({ endpoint, tokens }, callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       // Test all tokens
Kode lerroa:       if (_.isString(endpoint) && !_.isEmpty(tokens)) {
Kode lerroa:         const promises = []
Kode lerroa:         for (let i = 0; i < tokens.length; i++) {
Kode lerroa:           const token = tokens[i]
Kode lerroa:           // Test each service
Kode lerroa:           const moodleClient = new MoodleClient(endpoint, token)
Kode lerroa:           const functionsToTest = _.values(MoodleFunctions)
Kode lerroa:           for (let i = 0; i < functionsToTest.length; i++) {
Kode lerroa:             const bindFunction = functionsToTest[i].clientFunc.bind(moodleClient)
Kode lerroa:             promises.push(new Promise((resolve) => {
Kode lerroa:               bindFunction(functionsToTest[i].testParams, (err, result) => {
Kode lerroa:                 resolve({
Kode lerroa:                   token: token,
Kode lerroa:                   service: functionsToTest[i].wsFunc,
Kode lerroa:                   enabled: !(err || result.exception === 'webservice_access_exception')
Kode lerroa:                 })
Kode lerroa:               })
Kode lerroa:             }))
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         Promise.all(promises).then((resolves) => {
Kode lerroa:           let tests = _.map(_.groupBy(resolves, 'token'), (elem, key) => {
Kode lerroa:             return { token: key, tests: elem }
Kode lerroa:           })
Kode lerroa:           // Remove tokens with not any of the functions enabled
Kode lerroa:           tests = _.filter(tests, (test) => { return _.find(test.tests, 'enabled') })
Kode lerroa:           if (_.isObject(resolves)) {
Kode lerroa:             callback(null, tests)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       console.error('No callback defined')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleBackgroundManager
Kode lerroa: import _ from 'lodash'
Kode lerroa: import URLUtils from '../utils/URLUtils'
Kode lerroa: import ChromeStorage from '../utils/ChromeStorage'
Kode lerroa: 
Kode lerroa: class MoodleDownloadManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.files = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     chrome.downloads.onCreated.addListener((downloadItem) => {
Kode lerroa:       // Get required data to mark on moodle
Kode lerroa:       const hashParams = URLUtils.extractHashParamsFromUrl(downloadItem.url, ':')
Kode lerroa:       const studentId = hashParams.studentId
Kode lerroa:       const courseId = hashParams.courseId
Kode lerroa:       const cmid = hashParams.cmid
Kode lerroa:       if (_.isString(studentId)) { // File is downloaded from moodle
Kode lerroa:         // Save file metadata and data to mark on moodle
Kode lerroa:         this.files[downloadItem.id] = {
Kode lerroa:           url: URLUtils.retrieveMainUrl(downloadItem.url),
Kode lerroa:           studentId: studentId,
Kode lerroa:           courseId: courseId,
Kode lerroa:           cmid: cmid,
Kode lerroa:           mag: hashParams.mag || null
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa: 
Kode lerroa:     chrome.downloads.onDeterminingFilename.addListener((downloadItem, suggest) => {
Kode lerroa:       if (this.files[downloadItem.id]) { // Only for files downloaded from moodle
Kode lerroa:         ChromeStorage.getData('fileFormats', ChromeStorage.sync, (err, fileExtensions) => {
Kode lerroa:           if (err) {
Kode lerroa:             suggest() // Suggest default
Kode lerroa:           } else {
Kode lerroa:             let fileExtensionArray = []
Kode lerroa:             if (fileExtensions) {
Kode lerroa:               fileExtensionArray = (JSON.parse(fileExtensions.data) + defaultFileExtensionsAsPlainText).split(',')
Kode lerroa:             } else {
Kode lerroa:               fileExtensionArray = defaultFileExtensionsAsPlainText.split(',')
Kode lerroa:             }
Kode lerroa:             const originalFilenameExtension = _.last(downloadItem.filename.split('.'))
Kode lerroa:             const matchExtension = _.find(fileExtensionArray, (ext) => { return ext === originalFilenameExtension })
Kode lerroa:             if (_.isString(matchExtension)) {
Kode lerroa:               suggest({ filename: downloadItem.filename + '.txt' })
Kode lerroa:             } else {
Kode lerroa:               suggest()
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:         // Async suggestion
Kode lerroa:         return true
Kode lerroa:       } else {
Kode lerroa:         return false
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa: 
Kode lerroa:     chrome.downloads.onChanged.addListener((downloadItem) => {
Kode lerroa:       // Download is pending
Kode lerroa:       if (this.files[downloadItem.id] && downloadItem.filename && downloadItem.filename.current) {
Kode lerroa:         // Save download file path
Kode lerroa:         const files = _.values(_.forIn(window.background.moodleDownloadManager.files, (file, key) => { file.key = key }))
Kode lerroa:         if (downloadItem.filename.current.startsWith('/')) { // Unix-based filesystem
Kode lerroa:           const repeatedLocalFiles = _.filter(files, (file) => { return file.localPath === encodeURI('file://' + downloadItem.filename.current) })
Kode lerroa:           _.forEach(repeatedLocalFiles, (repeatedLocalFiles) => {
Kode lerroa:             delete window.background.moodleDownloadManager.files[repeatedLocalFiles.key]
Kode lerroa:           })
Kode lerroa:           this.files[downloadItem.id].localPath = encodeURI('file://' + downloadItem.filename.current)
Kode lerroa:         } else { // Windows-based filesystem
Kode lerroa:           const repeatedLocalFiles = _.filter(files, (file) => { return file.localPath === encodeURI('file:///' + _.replace(downloadItem.filename.current, /\\/g, '/')) })
Kode lerroa:           _.forEach(repeatedLocalFiles, (repeatedLocalFiles) => {
Kode lerroa:             delete window.background.moodleDownloadManager.files[repeatedLocalFiles.key]
Kode lerroa:           })
Kode lerroa:           this.files[downloadItem.id].localPath = encodeURI('file:///' + _.replace(downloadItem.filename.current, /\\/g, '/'))
Kode lerroa:         }
Kode lerroa:       } else if (_.isObject(downloadItem.state) && downloadItem.state.current === 'complete') { // When the download is finished
Kode lerroa:         // If mag is set in the URL, open a new tab with the document
Kode lerroa:         if (this.files[downloadItem.id].mag && this.files[downloadItem.id].studentId) {
Kode lerroa:           const localUrl = this.files[downloadItem.id].localPath + '#mag:' + this.files[downloadItem.id].mag + '&studentId:' + this.files[downloadItem.id].studentId
Kode lerroa:           chrome.extension.isAllowedFileSchemeAccess((isAllowedAccess) => {
Kode lerroa:             if (isAllowedAccess === false) {
Kode lerroa:               chrome.tabs.create({ url: chrome.runtime.getURL('pages/filePermission.html') })
Kode lerroa:             } else {
Kode lerroa:               // Open the file automatically
Kode lerroa:               chrome.tabs.create({ url: localUrl }, () => {
Kode lerroa:                 this.files[downloadItem.id].mag = null
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else {
Kode lerroa:           // Check if auto-open option is activated
Kode lerroa:           ChromeStorage.getData('autoOpenFiles', ChromeStorage.sync, (err, result) => {
Kode lerroa:             if (err) {
Kode lerroa:               // Nothing to do
Kode lerroa:             } else {
Kode lerroa:               const autoOpen = result.activated // TODO Change
Kode lerroa:               if (autoOpen) {
Kode lerroa:                 const localUrl = this.files[downloadItem.id].localPath + '#autoOpen:true'
Kode lerroa:                 // Check if permission to access files is enabled, otherwise open a new tab with the message.
Kode lerroa:                 chrome.extension.isAllowedFileSchemeAccess((isAllowedAccess) => {
Kode lerroa:                   if (isAllowedAccess === false) {
Kode lerroa:                     chrome.tabs.create({ url: chrome.runtime.getURL('pages/filePermission.html') })
Kode lerroa:                   } else {
Kode lerroa:                     // Open the file automatically
Kode lerroa:                     chrome.tabs.create({ url: localUrl })
Kode lerroa:                   }
Kode lerroa:                 })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa: 
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'annotationFile') {
Kode lerroa:         if (request.cmd === 'fileMetadata') {
Kode lerroa:           if (request.data.filepath) {
Kode lerroa:             const file = _.find(this.files, (file) => {
Kode lerroa:               if (file.localPath === request.data.filepath) {
Kode lerroa:                 return file
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:             sendResponse({ file: file })
Kode lerroa:           }
Kode lerroa:         } else if (request.cmd === 'setPlainTextFileExtension') {
Kode lerroa:           // Save file formats
Kode lerroa:           ChromeStorage.setData('fileFormats', { data: JSON.stringify(request.data.fileExtensions) }, ChromeStorage.sync, () => {
Kode lerroa:             sendResponse({ err: null })
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'getPlainTextFileExtension') {
Kode lerroa:           // Retrieve from chrome storage file formats and return to user
Kode lerroa:           ChromeStorage.getData('fileFormats', ChromeStorage.sync, (err, fileExtensions) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               if (fileExtensions) {
Kode lerroa:                 const parsedFileExtensions = JSON.parse(fileExtensions.data)
Kode lerroa:                 sendResponse({ fileExtensions: parsedFileExtensions || '' })
Kode lerroa:               } else {
Kode lerroa:                 sendResponse({ fileExtensions: '' })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: const defaultFileExtensionsAsPlainText = 'xml,xsl,xslt,xquery,xsql,'
Kode lerroa: 
Kode lerroa: export default MoodleDownloadManager
Kode lerroa: import ChromeStorage from '../utils/ChromeStorage'
Kode lerroa: 
Kode lerroa: class Neo4JManager {
Kode lerroa:   init () {
Kode lerroa:     this.initResponser()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initResponser () {
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'neo4j') {
Kode lerroa:         if (request.cmd === 'getCredentials') {
Kode lerroa:           ChromeStorage.getData('neo4j.credentials', ChromeStorage.sync, (err, credentials) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               if (credentials) {
Kode lerroa:                 const parsedCredentials = JSON.parse(credentials.data)
Kode lerroa:                 sendResponse({ credentials: parsedCredentials || {} })
Kode lerroa:               } else {
Kode lerroa:                 sendResponse({ credentials: {} })
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else if (request.cmd === 'setCredentials') {
Kode lerroa:           const credentials = request.data.credentials
Kode lerroa:           ChromeStorage.setData('neo4j.credentials', { data: JSON.stringify(credentials) }, ChromeStorage.sync, (err) => {
Kode lerroa:             if (err) {
Kode lerroa:               sendResponse({ err: err })
Kode lerroa:             } else {
Kode lerroa:               sendResponse({ credentials: credentials })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Neo4JManager
Kode lerroa: import DOI from 'doi-regex'
Kode lerroa: // PVSCL:IFCOND(ScienceDirect, LINE)
Kode lerroa: 
Kode lerroa: import Config from '../Config'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class TargetManager {
Kode lerroa:   constructor () {
Kode lerroa:     // PVSCL:IFCOND(DOI, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ScienceDirect, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Dropbox, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // PVSCL:IFCOND(DOI, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ScienceDirect, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Dropbox, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   extractAnnotationId (url) {
Kode lerroa:     if (url.includes('#')) {
Kode lerroa:       const parts = url.split('#')[1].split(':')
Kode lerroa:       if (parts[0] === Config.urlParamName) {
Kode lerroa:         return parts[1] || null
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default TargetManager
Kode lerroa: import CircularJSON from 'circular-json-es6'
Kode lerroa: import ChromeStorage from '../utils/ChromeStorage'
Kode lerroa: import CreateHighlighterTask from './tasks/CreateHighlighterTask'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Config from '../Config'
Kode lerroa: 
Kode lerroa: class TaskManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.currentTasks = []
Kode lerroa:     this.currentTask = {}
Kode lerroa:     this.currentTaskInstance = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Init background listener for background tasks
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'task') {
Kode lerroa:         if (request.cmd === 'createHighlighters') {
Kode lerroa:           if (request.data) {
Kode lerroa:             const rubric = CircularJSON.parse(request.data.rubric)
Kode lerroa:             const students = request.data.students
Kode lerroa:             const courseId = request.data.courseId
Kode lerroa:             const task = this.prepareCreateHighlightersTask(rubric, students, courseId)
Kode lerroa:             const numberOfAnnotationsToCreate = task.activities.length * (_.reduce(_.map(rubric.themes, (theme) => { return theme.codes.length }), (sum, n) => { return sum + n }) + 2)
Kode lerroa:             const minutesPending = Math.round(numberOfAnnotationsToCreate / 60)
Kode lerroa:             this.addTasks(task)
Kode lerroa:             sendResponse({ minutes: minutesPending })
Kode lerroa:           }
Kode lerroa:         } else if (request.cmd === 'getCurrentTaskStatus') {
Kode lerroa:           if (_.isObject(this.currentTaskInstance)) {
Kode lerroa:             sendResponse({ status: 'CreateHighlighterTask pending', statusMessage: this.currentTaskInstance.getStatus() })
Kode lerroa:           } else {
Kode lerroa:             sendResponse({ status: 'Nothing pending' })
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // Restore previous activities
Kode lerroa:     this.restoreTasks(() => {
Kode lerroa:       console.log('Task manager initialized')
Kode lerroa:       // Start task management
Kode lerroa:       this.checkTask()
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   addTasks (task) {
Kode lerroa:     console.debug('Added new task ' + task.task + ' with id: ' + task.id)
Kode lerroa:     // Add to current tasks
Kode lerroa:     this.currentTasks.push(task)
Kode lerroa:     // Save current tasks
Kode lerroa:     this.saveTasks()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   saveTasks () {
Kode lerroa:     ChromeStorage.setData('tasks', this.currentTasks, ChromeStorage.local, () => {
Kode lerroa: 
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   restoreTasks (callback) {
Kode lerroa:     // Restore pending tasks
Kode lerroa:     ChromeStorage.getData('tasks', ChromeStorage.local, (err, tasks) => {
Kode lerroa:       if (err) {
Kode lerroa:         this.currentTasks = []
Kode lerroa:       } else {
Kode lerroa:         this.currentTasks = []
Kode lerroa:       }
Kode lerroa:       this.currentTask = {}
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   removeFinishedTask () {
Kode lerroa:     _.remove(this.currentTasks, (task) => {
Kode lerroa:       return task.id === this.currentTask.id
Kode lerroa:     })
Kode lerroa:     this.currentTask = {}
Kode lerroa:     // Save current tasks
Kode lerroa:     this.saveTasks()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   doTask (todoTask) {
Kode lerroa:     this.currentTask = todoTask
Kode lerroa:     if (this.currentTask.task === 'createHighlighters') {
Kode lerroa:       const currentTask = this.currentTask
Kode lerroa:       // Create notification handler for task
Kode lerroa:       const buttonClickListener = (notificationId, buttonIndex) => {
Kode lerroa:         // TODO If notification id is the current one for this task
Kode lerroa:         if (buttonIndex === 0) {
Kode lerroa:           if (_.isFunction(currentTask.notificationHandler)) {
Kode lerroa:             currentTask.notificationHandler()
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         // Remove notification listener
Kode lerroa:         chrome.notifications.onButtonClicked.removeListener(buttonClickListener)
Kode lerroa:       }
Kode lerroa:       chrome.notifications.onButtonClicked.addListener(buttonClickListener)
Kode lerroa:       // Create task
Kode lerroa:       const task = new CreateHighlighterTask(this.currentTask)
Kode lerroa:       task.init(() => {
Kode lerroa:         // Task is finished
Kode lerroa:         this.notifyTask(this.currentTask.notification)
Kode lerroa:         this.removeFinishedTask()
Kode lerroa:         this.currentTaskInstance = null
Kode lerroa:       })
Kode lerroa:       this.currentTaskInstance = task
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   checkTask () {
Kode lerroa:     this.taskTimeout = setTimeout(() => {
Kode lerroa:       if (this.currentTasks.length > 0) {
Kode lerroa:         if (_.isEmpty(this.currentTask)) {
Kode lerroa:           const todoTask = this.currentTasks[0]
Kode lerroa:           this.doTask(todoTask)
Kode lerroa:           this.checkTask()
Kode lerroa:         } else {
Kode lerroa:           this.checkTask()
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.checkTask()
Kode lerroa:       }
Kode lerroa:     }, 1000)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   notifyTask (notification) {
Kode lerroa:     // Notify task is finished
Kode lerroa:     chrome.notifications.create('task' + this.currentTask.id, {
Kode lerroa:       type: 'basic',
Kode lerroa:       title: 'Configuration done',
Kode lerroa:       message: notification,
Kode lerroa:       iconUrl: chrome.extension.getURL('images/' + Config.urlParamName + 'icon-512.png'),
Kode lerroa:       buttons: [
Kode lerroa:         { title: 'Yes' }]
Kode lerroa:     }, () => {
Kode lerroa:       console.debug('Notification send to user, task is finished')
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   prepareCreateHighlightersTask (rubric, students, courseId) {
Kode lerroa:     const activities = []
Kode lerroa:     for (let i = 0; i < students.length; i++) {
Kode lerroa:       activities.push({
Kode lerroa:         type: 'createHighlighter',
Kode lerroa:         data: { student: students[i], rubric, courseId }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       id: Math.random(),
Kode lerroa:       task: 'createHighlighters',
Kode lerroa:       activities: activities,
Kode lerroa:       notification: 'The tool is prepared to mark ' + rubric.name + ' assignment. Would you like to mark them now?',
Kode lerroa:       notificationHandler: () => {
Kode lerroa:         chrome.tabs.create({ url: rubric.moodleEndpoint + 'mod/assign/view.php?id=' + rubric.cmid })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: TaskManager.tasks = {
Kode lerroa:   createHighlighters: (data, callback) => {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default TaskManager
Kode lerroa: import jsYaml from 'js-yaml'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Config from '../../Config'
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: 
Kode lerroa: class Code {
Kode lerroa:   constructor ({
Kode lerroa:     id,
Kode lerroa:     name,
Kode lerroa:     description = '',
Kode lerroa:     createdDate = new Date(),
Kode lerroa:     color, theme/* PVSCL:IFCOND(MoodleProvider) */,
Kode lerroa: 
Kode lerroa:   }) {
Kode lerroa:     this.id = id
Kode lerroa:     this.name = name
Kode lerroa:     this.color = color
Kode lerroa:     this.theme = theme
Kode lerroa:     this.description = description
Kode lerroa:     if (LanguageUtils.isInstanceOf(createdDate, Date)) {
Kode lerroa:       this.createdDate = createdDate
Kode lerroa:     } else {
Kode lerroa:       const timestamp = Date.parse(createdDate)
Kode lerroa:       if (_.isNumber(timestamp)) {
Kode lerroa:         this.createdDate = new Date(createdDate)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toAnnotations () {
Kode lerroa:     return [this.toAnnotation()]
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toAnnotation () {
Kode lerroa:     const codeTag = Config.namespace + ':' + Config.tags.grouped.subgroup + ':' + this.name
Kode lerroa:     const isCodeOfTag = Config.namespace + ':' + Config.tags.grouped.relation + ':' + this.theme.name
Kode lerroa:     const motivationTag = Config.namespace + ':' + Config.tags.motivation + ':' + 'codebookDevelopment'
Kode lerroa:     const tags = [codeTag, isCodeOfTag, motivationTag]
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:     return {
Kode lerroa:       id: this.id,
Kode lerroa:       group: this.theme.annotationGuide.annotationServer.group.id,
Kode lerroa:       permissions: {
Kode lerroa:         read: ['group:' + this.theme.annotationGuide.annotationServer.group.id]
Kode lerroa:       },
Kode lerroa:       motivation: 'codebookDevelopment',
Kode lerroa:       references: [],
Kode lerroa:       tags: tags,
Kode lerroa:       target: [],
Kode lerroa:       text: jsYaml.dump({ id: this.id || '', description: this.description }),
Kode lerroa:       uri: this.theme.annotationGuide.annotationServer.group.links.html
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getTags () {
Kode lerroa:     return [Config.namespace + ':' + Config.tags.grouped.subgroup + ':' + this.name, Config.namespace + ':' + Config.tags.grouped.relation + ':' + this.theme.name]
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static fromAnnotations () {
Kode lerroa:     // TODO Xabi
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static fromAnnotation (annotation, theme = {}) {
Kode lerroa:     const codeTag = _.find(annotation.tags, (tag) => {
Kode lerroa:       return tag.includes(Config.namespace + ':' + Config.tags.grouped.subgroup + ':')
Kode lerroa:     })
Kode lerroa:     if (_.isString(codeTag)) {
Kode lerroa:       const name = codeTag.replace(Config.namespace + ':' + Config.tags.grouped.subgroup + ':', '')
Kode lerroa:       const config = jsYaml.load(annotation.text)
Kode lerroa:       if (_.isObject(config)) {
Kode lerroa:         const description = config.description
Kode lerroa:         const id = annotation.id
Kode lerroa:         let codeToReturn
Kode lerroa:         // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:         return codeToReturn
Kode lerroa:       } else {
Kode lerroa:         console.error('Unable to retrieve mark configuration from annotation')
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       console.error('Unable to retrieve mark from annotation')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toObject () {
Kode lerroa:     return {
Kode lerroa:       name: this.name,
Kode lerroa:       description: this.description,
Kode lerroa:       id: this.id,
Kode lerroa:       theme: this.theme.toObject()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Code
Kode lerroa: import jsYaml from 'js-yaml'
Kode lerroa: import Theme from './Theme'
Kode lerroa: import Config from '../../Config'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BrowserStorage, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class Codebook {
Kode lerroa:   constructor ({
Kode lerroa:     id = null,
Kode lerroa:     name = '',
Kode lerroa:     annotationServer = null/* PVSCL:IFCOND(MoodleProvider or MoodleReport or MoodleResource) */,
Kode lerroa: /* PVSCL:IFCOND(GoogleSheetProvider) */,
Kode lerroa: 
Kode lerroa:   }) {
Kode lerroa:     this.id = id
Kode lerroa:     this.name = name
Kode lerroa:     this.themes = []
Kode lerroa:     this.annotationServer = annotationServer
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(GoogleSheetProvider,LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toAnnotation () {
Kode lerroa:     const motivationTag = 'motivation:defining'
Kode lerroa:     const guideTag = Config.namespace + ':guide'
Kode lerroa:     const tags = [motivationTag, guideTag]
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider or MoodleReport or MoodleResource,LINE)
Kode lerroa: 
Kode lerroa:     // Construct text attribute of the annotation
Kode lerroa:     let textObject
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider or MoodleReport or MoodleResource,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(GoogleSheetProvider,LINE)
Kode lerroa: 
Kode lerroa:     // Return the constructed annotation
Kode lerroa:     return {
Kode lerroa:       name: this.name,
Kode lerroa:       group: this.annotationServer.group.id,
Kode lerroa:       permissions: {
Kode lerroa:         read: ['group:' + this.annotationServer.group.id]
Kode lerroa:       },
Kode lerroa:       references: [],
Kode lerroa:       motivation: 'defining',
Kode lerroa:       tags: tags,
Kode lerroa:       target: [],
Kode lerroa:       text: jsYaml.dump(textObject),
Kode lerroa:       uri: this.annotationServer.group.links.html
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toAnnotations () {
Kode lerroa:     let annotations = []
Kode lerroa:     // Create annotation for current element
Kode lerroa:     annotations.push(this.toAnnotation())
Kode lerroa:     // Create annotations for all criterias
Kode lerroa:     for (let i = 0; i < this.themes.length; i++) {
Kode lerroa:       annotations = annotations.concat(this.themes[i].toAnnotations())
Kode lerroa:     }
Kode lerroa:     return annotations
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static fromAnnotation (annotation, callback) {
Kode lerroa:     this.setAnnotationServer(null, (annotationServer) => {
Kode lerroa:       const annotationGuideOpts = { id: annotation.id, name: annotation.name, annotationServer: annotationServer }
Kode lerroa:       // PVSCL:IFCOND(GoogleSheetProvider or MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(GoogleSheetProvider, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:       let guide
Kode lerroa:       guide = new Codebook(annotationGuideOpts)
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(guide)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static fromAnnotations (annotations, callback) {
Kode lerroa:     // return Codebook
Kode lerroa:     const guideAnnotation = _.remove(annotations, (annotation) => {
Kode lerroa:       return _.some(annotation.tags, (tag) => { return tag === Config.namespace + ':guide' })
Kode lerroa:     })
Kode lerroa:     if (guideAnnotation.length > 0) {
Kode lerroa:       Codebook.fromAnnotation(guideAnnotation[0], (guide) => {
Kode lerroa:         // TODO Complete the guide from the annotations
Kode lerroa:         // For the rest of annotations, get themes and codes
Kode lerroa:         const themeAnnotations = _.remove(annotations, (annotation) => {
Kode lerroa:           return _.some(annotation.tags, (tag) => {
Kode lerroa:             return tag.includes(Config.namespace + ':' + Config.tags.grouped.group + ':')
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:         // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:         for (let i = 0; i < themeAnnotations.length; i++) {
Kode lerroa:           const theme = Theme.fromAnnotation(themeAnnotations[i], guide)
Kode lerroa:           if (LanguageUtils.isInstanceOf(theme, Theme)) {
Kode lerroa:             guide.themes.push(theme)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, guide)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     } else {
Kode lerroa:       callback(new Error('No annotations for codebook defined'))
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static setAnnotationServer (newGroup, callback) {
Kode lerroa:     let annotationAnnotationServer
Kode lerroa:     let group
Kode lerroa:     if (newGroup === null) {
Kode lerroa:       group = window.abwa.groupSelector.currentGroup
Kode lerroa:     } else {
Kode lerroa:       group = newGroup
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1,LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(BuiltIn or ImportCodebook or NOT(Codebook) or ImportAnnotations, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(GoogleSheetProvider,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   getCodeOrThemeFromId (id) {
Kode lerroa:     let themeOrCodeToReturn = null
Kode lerroa:     const theme = _.find(this.themes, (theme) => {
Kode lerroa:       return theme.id === id
Kode lerroa:     })
Kode lerroa:     if (LanguageUtils.isInstanceOf(theme, Theme)) {
Kode lerroa:       themeOrCodeToReturn = theme
Kode lerroa:     } /* PVSCL:IFCOND(Hierarchy) */ else {
Kode lerroa: 
Kode lerroa:     return themeOrCodeToReturn
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ExportCodebook or Export, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(PreviousAssignments, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   getThemeByName (name) {
Kode lerroa:     if (_.isString(name)) {
Kode lerroa:       return this.themes.find(theme => theme.name === name)
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Codebook
Kode lerroa: import jsYaml from 'js-yaml'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Config from '../../Config'
Kode lerroa: // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: import LanguageUtils from '../../utils/LanguageUtils'
Kode lerroa: 
Kode lerroa: class Theme {
Kode lerroa:   constructor ({
Kode lerroa:     id,
Kode lerroa:     name,
Kode lerroa:     color,
Kode lerroa:     annotationGuide,
Kode lerroa:     createdDate = new Date(),
Kode lerroa:     description = ''/* PVSCL:IFCOND(GoogleSheetProvider and Hierarchy) */,
Kode lerroa: /* PVSCL:IFCOND(MoodleProvider) */,
Kode lerroa: 
Kode lerroa:   }) {
Kode lerroa:     this.id = id
Kode lerroa:     this.name = name
Kode lerroa:     this.description = description
Kode lerroa:     this.color = color
Kode lerroa:     this.annotationGuide = annotationGuide
Kode lerroa:     if (LanguageUtils.isInstanceOf(createdDate, Date)) {
Kode lerroa:       this.createdDate = createdDate
Kode lerroa:     } else {
Kode lerroa:       const timestamp = Date.parse(createdDate)
Kode lerroa:       if (_.isNumber(timestamp)) {
Kode lerroa:         this.createdDate = new Date(createdDate)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(GoogleSheetProvider and Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toAnnotations () {
Kode lerroa:     let annotations = []
Kode lerroa:     // Create its annotations
Kode lerroa:     annotations.push(this.toAnnotation())
Kode lerroa:     // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:     return annotations
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toAnnotation () {
Kode lerroa:     const themeTag = Config.namespace + ':' + Config.tags.grouped.group + ':' + this.name
Kode lerroa:     const motivationTag = Config.namespace + ':' + Config.tags.motivation + ':' + 'codebookDevelopment'
Kode lerroa:     const tags = [themeTag, motivationTag]
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(GoogleSheetProvider and Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:     return {
Kode lerroa:       id: this.id,
Kode lerroa:       group: this.annotationGuide.annotationServer.group.id,
Kode lerroa:       permissions: {
Kode lerroa:         read: ['group:' + this.annotationGuide.annotationServer.group.id]
Kode lerroa:       },
Kode lerroa:       motivation: 'codebookDevelopment',
Kode lerroa:       references: [],
Kode lerroa:       tags: tags,
Kode lerroa:       target: [],
Kode lerroa:       text: jsYaml.dump({
Kode lerroa:         id: this.id || ''/* PVSCL:IFCOND(BuiltIn) */,
Kode lerroa: 
Kode lerroa:       }),
Kode lerroa:       uri: this.annotationGuide.annotationServer.group.links.html
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static fromAnnotations () {
Kode lerroa:     // TODO Xabi
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static fromAnnotation (annotation, annotationGuide = {}) {
Kode lerroa:     const themeTag = _.find(annotation.tags, (tag) => {
Kode lerroa:       return tag.includes(Config.namespace + ':' + Config.tags.grouped.group + ':')
Kode lerroa:     })
Kode lerroa:     // PVSCL:IFCOND(GoogleSheetProvider and Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:     if (_.isString(themeTag)) {
Kode lerroa:       const name = themeTag.replace(Config.namespace + ':' + Config.tags.grouped.group + ':', '')
Kode lerroa:       const config = jsYaml.load(annotation.text)
Kode lerroa:       // PVSCL:IFCOND(GoogleSheetProvider and Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:       if (_.isObject(config)) {
Kode lerroa:         const description = config.description
Kode lerroa:         const id = annotation.id
Kode lerroa:         // PVSCL:IFCOND(MoodleReport,LINE)
Kode lerroa: 
Kode lerroa:         return new Theme({
Kode lerroa:           id,
Kode lerroa:           name,
Kode lerroa:           description,
Kode lerroa:           createdDate: annotation.updated,
Kode lerroa:           annotationGuide/* PVSCL:IFCOND(GoogleSheetProvider and Hierarchy) */,
Kode lerroa: /* PVSCL:IFCOND(MoodleReport) */,
Kode lerroa: 
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa: 
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       console.error('Unable to retrieve criteria from annotation')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate, LINE) // Check if it is possible to add codes to the definition model if it is not selected Dynamic feature
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleProvider or ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   toObject () {
Kode lerroa:     return {
Kode lerroa:       name: this.name,
Kode lerroa:       description: this.description,
Kode lerroa:       id: this.id
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getTags () {
Kode lerroa:     return [Config.namespace + ':' + Config.tags.grouped.group + ':' + this.name]
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Theme
Kode lerroa: import UserDefinedHighlighterDefinition from './BuiltInCodebookScheme'
Kode lerroa: import Codebook from '../../../model/Codebook'
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class BuiltIn {
Kode lerroa:   static createDefaultAnnotations (callback) {
Kode lerroa:     Codebook.setAnnotationServer(null, (annotationServer) => {
Kode lerroa:       // Create annotation guide from user defined highlighter definition
Kode lerroa:       const annotationGuide = Codebook.fromObjects(UserDefinedHighlighterDefinition)
Kode lerroa:       // Create review schema from default criterias
Kode lerroa:       annotationGuide.annotationServer = annotationServer
Kode lerroa:       // Create highlighter annotations
Kode lerroa:       const annotations = annotationGuide.toAnnotations()
Kode lerroa:       // TODO Codes annotations should be related to its corresponding theme: it requires to update Code annotations to relate them by ID instead of by tag
Kode lerroa:       // Send create highlighter
Kode lerroa:       window.abwa.annotationServerManager.client.createNewAnnotations(annotations, (err, annotations) => {
Kode lerroa:         if (err) {
Kode lerroa:           Alerts.errorAlert({ text: 'Unable to create new group.' })
Kode lerroa:         } else {
Kode lerroa:           window.abwa.sidebar.openSidebar()
Kode lerroa:           Alerts.closeAlert()
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null, annotations)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default BuiltIn
Kode lerroa: {
Kode lerroa:   "name": "Test",
Kode lerroa:   "definition": [
Kode lerroa:     {
Kode lerroa:       "name": "Presentation",
Kode lerroa:       "description": "Gathers mistakes and errors related to how the documentation is presented",
Kode lerroa:       "codes": [
Kode lerroa:         {
Kode lerroa:           "name": "Typo",
Kode lerroa:           "description": "A mistake in typing"
Kode lerroa:         },
Kode lerroa:         {
Kode lerroa:           "name": "Grammar error",
Kode lerroa:           "description": "A faulty, unconventional or controversial usage in verb tenses"
Kode lerroa:         },
Kode lerroa:         {
Kode lerroa:           "name": "Orthography error",
Kode lerroa:           "description": "An error in spelling, hyphenation, capitalization, word breaks, emphasis and punctuation"
Kode lerroa:         }
Kode lerroa:       ]
Kode lerroa:     }
Kode lerroa:   ]
Kode lerroa: }
Kode lerroa: import Codebook from '../../../model/Codebook'
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class EmptyCodebook {
Kode lerroa:   static createDefaultAnnotations (callback) {
Kode lerroa:     Codebook.setAnnotationServer(null, (annotationServer) => {
Kode lerroa:       const emptyCodebook = new Codebook({ annotationServer: annotationServer })
Kode lerroa:       const emptyCodebookAnnotation = emptyCodebook.toAnnotation()
Kode lerroa:       window.abwa.annotationServerManager.client.createNewAnnotation(emptyCodebookAnnotation, (err, annotation) => {
Kode lerroa:         if (err) {
Kode lerroa:           Alerts.errorAlert({ text: 'Unable to create required configuration for Dynamic highlighter. Please, try it again.' }) // TODO i18n
Kode lerroa:         } else {
Kode lerroa:           // Open the sidebar, to notify user that the annotator is correctly created
Kode lerroa:           window.abwa.sidebar.openSidebar()
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null, [annotation])
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default EmptyCodebook
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Codebook from '../../../model/Codebook'
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import URLUtils from '../../../../utils/URLUtils'
Kode lerroa: import Config from '../../../../Config'
Kode lerroa: 
Kode lerroa: class GSheetParser {
Kode lerroa:   static parseCurrentSheet (callback) {
Kode lerroa:     const spreadsheetId = GSheetParser.retrieveSpreadsheetId()
Kode lerroa:     const sheetId = GSheetParser.retrieveSheetId()
Kode lerroa:     GSheetParser.retrieveCurrentToken((err, token) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         GSheetParser.getSpreadsheet(spreadsheetId, token, (err, spreadsheet) => {
Kode lerroa:           if (err) {
Kode lerroa:             callback(err)
Kode lerroa:           } else {
Kode lerroa:             let sheetName
Kode lerroa:             // Retrieve spreadsheet title
Kode lerroa:             // PVSCL:IFCOND(Manual,LINE)
Kode lerroa: 
Kode lerroa:             // PVSCL:IFCOND(ApplicationBased,LINE)
Kode lerroa: 
Kode lerroa:             const codebook = Codebook.fromGoogleSheet({ spreadsheetId, sheetId, spreadsheet, sheetName })
Kode lerroa:             if (_.isError(codebook)) {
Kode lerroa:               callback(err)
Kode lerroa:             } else {
Kode lerroa:               if (_.isFunction(callback)) {
Kode lerroa:                 callback(null, codebook)
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveCurrentToken (callback) {
Kode lerroa:     chrome.runtime.sendMessage({ scope: 'googleSheets', cmd: 'getToken' }, (result) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         if (result.token) {
Kode lerroa:           callback(null, result.token)
Kode lerroa:         } else {
Kode lerroa:           callback(result.error)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getSpreadsheet (spreadsheetId, token, callback) {
Kode lerroa:     chrome.runtime.sendMessage({
Kode lerroa:       scope: 'googleSheets',
Kode lerroa:       cmd: 'getSpreadsheet',
Kode lerroa:       data: JSON.stringify({
Kode lerroa:         spreadsheetId: spreadsheetId
Kode lerroa:       })
Kode lerroa:     }, (response) => {
Kode lerroa:       if (response.error) {
Kode lerroa:         Alerts.errorAlert({
Kode lerroa:           text: 'You don\'t have permission to access the spreadsheet! Are you using the same Google account for the spreadsheet and for Google Chrome?<br/>If you don\'t know how to solve this problem: Please create on top right: "Share -> Get shareable link", and give edit permission.' // TODO i18n
Kode lerroa:         })
Kode lerroa:         callback(new Error('Unable to retrieve spreadsheet data. Permission denied.'))
Kode lerroa:       } else {
Kode lerroa:         try {
Kode lerroa:           const spreadsheet = JSON.parse(response.spreadsheet)
Kode lerroa:           callback(null, spreadsheet)
Kode lerroa:         } catch (e) {
Kode lerroa:           callback(e)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveSpreadsheetId () {
Kode lerroa:     // Get current google sheet id
Kode lerroa:     this.spreadsheetId = window.location.href.match(/[-\w]{25,}/)[0]
Kode lerroa:     return window.location.href.match(/[-\w]{25,}/)[0]
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveSheetId () {
Kode lerroa:     const hashParams = URLUtils.extractHashParamsFromUrl(window.location.href, '=')
Kode lerroa:     return parseInt(hashParams.gid)
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GSheetParser
Kode lerroa: import _ from 'lodash'
Kode lerroa: import GoogleSheetsClientManager from '../../../../googleSheets/GoogleSheetsClientManager'
Kode lerroa: import GSheetParser from './GSheetParser'
Kode lerroa: import GroupInitializer from './GroupInitializer'
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import swal from 'sweetalert2'
Kode lerroa: // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BrowserStorage, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class GoogleSheetContentScriptManager {
Kode lerroa:   init (callback) {
Kode lerroa:     window.googleSheetProvider.googleSheetClientManager = new GoogleSheetsClientManager()
Kode lerroa:     this.loadAnnotationServer(() => {
Kode lerroa:       this.initLoginProcess((err, tokens) => {
Kode lerroa:         if (err) {
Kode lerroa:           swal('Oops!',
Kode lerroa:             'Unable to configure current spreadsheet. Failed login to services.', // TODO i18n
Kode lerroa:             'error') // Notify error to user
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           // Show tool is configuring prompt
Kode lerroa:           this.showToolIsConfiguring()
Kode lerroa:           // console.debug('Correctly logged in to hypothesis: %s', tokens.hypothesis)
Kode lerroa:           console.debug('Correctly logged in to gSheet: %s', tokens.gSheet)
Kode lerroa:           this.initGoogleSheetParsing(() => {
Kode lerroa:             // Execute callback without errors
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback()
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   showToolIsConfiguring () {
Kode lerroa:     swal({
Kode lerroa:       position: 'top-end',
Kode lerroa:       title: 'Configuring the tool, please be patient', // TODO i18n
Kode lerroa:       text: 'If the tool takes too much time, please reload the page and try again.',
Kode lerroa:       showConfirmButton: false,
Kode lerroa:       onOpen: () => {
Kode lerroa:         swal.showLoading()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initLoginProcess (callback) {
Kode lerroa:     window.googleSheetProvider.annotationServerManager.logIn((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         window.googleSheetProvider.googleSheetClientManager.logInGoogleSheets((err, gSheetToken) => {
Kode lerroa:           if (err) {
Kode lerroa:             callback(err)
Kode lerroa:           } else {
Kode lerroa:             callback(null, {
Kode lerroa:               gSheet: gSheetToken
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadAnnotationServer (callback) {
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()=1, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initGoogleSheetParsing (callback) {
Kode lerroa:     GSheetParser.parseCurrentSheet((err, codebook) => {
Kode lerroa:       if (err) {
Kode lerroa:         console.error(err)
Kode lerroa:         Alerts.errorAlert({ text: err.message })
Kode lerroa:       } else {
Kode lerroa:         window.googleSheetProvider.GroupInitializer = new GroupInitializer()
Kode lerroa:         window.googleSheetProvider.GroupInitializer.init(codebook, (err) => {
Kode lerroa:           if (err) {
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback(err)
Kode lerroa:             }
Kode lerroa:           } else {
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback()
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GoogleSheetContentScriptManager
Kode lerroa: import _ from 'lodash'
Kode lerroa: import swal from 'sweetalert2'
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import ChromeStorage from '../../../../utils/ChromeStorage'
Kode lerroa: import Codebook from '../../../model/Codebook'
Kode lerroa: // PVSCL:IFCOND(ApplicationBased, LINE)
Kode lerroa: 
Kode lerroa: const selectedGroupNamespace = 'hypothesis.currentGroup'
Kode lerroa: 
Kode lerroa: class GroupInitializer {
Kode lerroa:   init (annotationGuide, callback) {
Kode lerroa:     this.annotationGuide = annotationGuide
Kode lerroa:     this.initializeGroup((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initializeGroup (callback) {
Kode lerroa:     // Get if current hypothesis group exists
Kode lerroa:     window.googleSheetProvider.annotationServerManager.client.getListOfGroups({}, (err, groups) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         const group = _.find(groups, (group) => {
Kode lerroa:           let isGroupNameEqual
Kode lerroa:           // PVSCL:IFCOND(ApplicationBased, LINE)
Kode lerroa: 
Kode lerroa:           // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:           return isGroupNameEqual
Kode lerroa:         })
Kode lerroa:         // Create the group if not exists
Kode lerroa:         if (_.isEmpty(group)) {
Kode lerroa:           this.createGroup((err) => {
Kode lerroa:             if (err) {
Kode lerroa:               swal('Oops!', // TODO i18n
Kode lerroa:                 'There was a problem while creating the group. Please reload the page and try it again. <br/>' +
Kode lerroa:                 'If the error continues, please contact administrator.',
Kode lerroa:                 'error') // Show to the user the error
Kode lerroa:               if (_.isFunction(callback)) {
Kode lerroa:                 callback(err)
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               this.createFacetsAndCodes((err) => {
Kode lerroa:                 if (err) {
Kode lerroa:                   swal('Oops!', // TODO i18n
Kode lerroa:                     'There was a problem while creating buttons for the sidebar. Please reload the page and try it again. <br/>' +
Kode lerroa:                     'If the error continues, please contact the administrator.',
Kode lerroa:                     'error') // Show to the user the error
Kode lerroa:                   // Remove created hypothesis group
Kode lerroa:                   this.removeGroup()
Kode lerroa:                   if (_.isFunction(callback)) {
Kode lerroa:                     callback(err)
Kode lerroa:                   }
Kode lerroa:                 } else {
Kode lerroa:                   // Save as current group the generated one
Kode lerroa:                   ChromeStorage.setData(selectedGroupNamespace, { data: JSON.stringify(this.annotationGuide.annotationServer.group) }, ChromeStorage.local)
Kode lerroa:                   // Get group url
Kode lerroa:                   const selectedAnnotationServerManager = window.googleSheetProvider.annotationServerManager
Kode lerroa:                   const groupUrl = selectedAnnotationServerManager.constructSearchUrl({ group: this.annotationGuide.annotationServer.group.id })
Kode lerroa:                   Alerts.successAlert({
Kode lerroa:                     title: 'Correctly configured', // TODO i18n
Kode lerroa:                     text: chrome.i18n.getMessage('VisitTheCreatedGroup') + ' <a href="' + groupUrl + '" target="_blank">here</a>.'
Kode lerroa:                   })
Kode lerroa:                   if (_.isFunction(callback)) {
Kode lerroa:                     callback()
Kode lerroa:                   }
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else {
Kode lerroa:           const selectedAnnotationServerManager = window.googleSheetProvider.annotationServerManager
Kode lerroa:           const groupUrl = selectedAnnotationServerManager.constructSearchUrl({ group: group.id })
Kode lerroa:           swal('The group ' + group.name + ' already exists', // TODO i18n
Kode lerroa:             chrome.i18n.getMessage('VisitTheCreatedGroup') + ' <a href="' + groupUrl + '" target="_blank">here</a>.',
Kode lerroa:             'info')
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:           // TODO Update Hypothesis group
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createGroup (callback) {
Kode lerroa:     window.googleSheetProvider.annotationServerManager.client.createNewGroup({ name: this.annotationGuide.name }, (err, group) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         console.debug('Created group in hypothesis: ')
Kode lerroa:         console.debug(group)
Kode lerroa:         Codebook.setAnnotationServer(group, (annotationServer) => {
Kode lerroa:           this.annotationGuide.annotationServer = annotationServer
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createFacetsAndCodes (callback) {
Kode lerroa:     const annotations = this.annotationGuide.toAnnotations()
Kode lerroa:     console.debug('Generated dimensions and categories annotations: ')
Kode lerroa:     console.debug(annotations)
Kode lerroa:     window.googleSheetProvider.annotationServerManager.client.createNewAnnotations(annotations, (err) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   removeGroup (callback) {
Kode lerroa:     if (this.annotationGuide.annotationServer) {
Kode lerroa:       window.googleSheetProvider.annotationServerManager.client.removeAMemberFromAGroup(this.annotationGuide.annotationServer.group.id, 'me', (err) => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         } else {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GroupInitializer
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleGradingAugmentation from './MoodleGradingAugmentation'
Kode lerroa: import MoodleGraderAugmentation from './MoodleGraderAugmentation'
Kode lerroa: import MoodleViewPluginAssignSubmissionAugmentation from './MoodleViewPluginAssignSubmissionAugmentation'
Kode lerroa: 
Kode lerroa: class MoodleAugmentation {
Kode lerroa:   init () {
Kode lerroa:     // TODO Check moodle version
Kode lerroa:     // Get current website
Kode lerroa:     if ((new URL(window.location)).searchParams.get('action') === 'grader') {
Kode lerroa:       this.augmentator = new MoodleGraderAugmentation()
Kode lerroa:     } else if ((new URL(window.location)).searchParams.get('action') === 'grading') {
Kode lerroa:       this.augmentator = new MoodleGradingAugmentation()
Kode lerroa:     } else if ((new URL(window.location).searchParams.get('action') === 'viewpluginassignsubmission')) {
Kode lerroa:       this.augmentator = new MoodleViewPluginAssignSubmissionAugmentation()
Kode lerroa:     }
Kode lerroa:     if (_.isObject(this.augmentator)) {
Kode lerroa:       this.augmentator.init()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleAugmentation
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleScraping from '../MoodleScraping'
Kode lerroa: 
Kode lerroa: class MoodleGraderAugmentation {
Kode lerroa:   constructor () {
Kode lerroa:     this.studentChangeCheckerInterval = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Handle change event (moodle grading page is dinamic, when changing from one student to the next one, it uses ajax to reload part of the site, but student id is different)
Kode lerroa:     this.initStudentChangeHandler({
Kode lerroa:       onChange: () => {
Kode lerroa:         this.augmentGraderPageFiles()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   augmentGraderPageFiles () {
Kode lerroa:     // Get student ID
Kode lerroa:     this.getStudentId((err, studentId) => {
Kode lerroa:       if (err) {
Kode lerroa:         // TODO Alert user
Kode lerroa:         console.error('Unable to load student id')
Kode lerroa:       } else {
Kode lerroa:         this.modifySubmittedFilesUrl(studentId)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   modifySubmittedFilesUrl (studentId) {
Kode lerroa:     // Get files elements
Kode lerroa:     this.waitUntilFilesAreLoaded((submissionFilesContainer) => {
Kode lerroa:       MoodleScraping.scrapAssignmentData((err, assignmentData) => {
Kode lerroa:         if (err) {
Kode lerroa: 
Kode lerroa:         } else {
Kode lerroa:           const submittedFilesElements = submissionFilesContainer.querySelectorAll('a')
Kode lerroa:           // Change URLs of files elements
Kode lerroa:           _.forEach(submittedFilesElements, (submittedFileElement) => {
Kode lerroa:             submittedFileElement.href = submittedFileElement.href + '#studentId:' +
Kode lerroa:               studentId + '&courseId:' + assignmentData.courseId + '&cmid:' + assignmentData.cmid
Kode lerroa:           })
Kode lerroa:           console.debug('Modified submission files for current student ' + studentId)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   waitUntilUserInfoIsLoaded (callback) {
Kode lerroa:     const interval = setInterval(() => {
Kode lerroa:       const currentUserInfoElement = document.querySelector('[data-region="user-info"]')
Kode lerroa:       if (_.isElement(currentUserInfoElement)) {
Kode lerroa:         clearInterval(interval)
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(currentUserInfoElement)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }, 500)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   waitUntilFilesAreLoaded (callback) {
Kode lerroa:     const interval = setInterval(() => {
Kode lerroa:       const submissionFilesContainer = document.querySelector('.assignsubmission_file')
Kode lerroa:       if (_.isElement(submissionFilesContainer)) {
Kode lerroa:         clearInterval(interval)
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(submissionFilesContainer)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }, 500)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getStudentId (callback) {
Kode lerroa:     // Get student ID
Kode lerroa:     this.waitUntilUserInfoIsLoaded((currentUserInfoElement) => {
Kode lerroa:       const studentId = (new URL(currentUserInfoElement.querySelector('a').href)).searchParams.get('id')
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null, studentId)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initStudentChangeHandler () {
Kode lerroa:     let savedStudentId = null
Kode lerroa:     this.studentChangeCheckerInterval = setInterval(() => {
Kode lerroa:       this.getStudentId((err, studentId) => {
Kode lerroa:         if (err) {
Kode lerroa: 
Kode lerroa:         } else {
Kode lerroa:           if (studentId !== savedStudentId) { // Student has changed
Kode lerroa:             savedStudentId = studentId // Save the new student id
Kode lerroa:             this.modifySubmittedFilesUrl(studentId)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }, 500)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     if (this.studentChangeCheckerInterval) {
Kode lerroa:       clearInterval(this.studentChangeCheckerInterval)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleGraderAugmentation
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleScraping from '../MoodleScraping'
Kode lerroa: 
Kode lerroa: class MoodleGradingAugmentation {
Kode lerroa:   init () {
Kode lerroa:     // Get course id
Kode lerroa:     MoodleScraping.scrapAssignmentData((err, assignmentData) => {
Kode lerroa:       if (err) {
Kode lerroa: 
Kode lerroa:       } else {
Kode lerroa:         const gradingTable = document.querySelector('.gradingtable')
Kode lerroa:         const tableBody = gradingTable.querySelector('tbody')
Kode lerroa:         let rows = tableBody.querySelectorAll(':scope > tr')
Kode lerroa:         // In moodle 3.1 are added some empty rows which are hidden
Kode lerroa:         rows = _.filter(rows, (row) => {
Kode lerroa:           return !row.classList.contains('emptyrow')
Kode lerroa:         })
Kode lerroa:         _.forEach(rows, (row) => {
Kode lerroa:           // Get student id
Kode lerroa:           const studentId = (new URL(row.querySelector('a[href*="/user/view.php"').href)).searchParams.get('id')
Kode lerroa:           // Get student files
Kode lerroa:           const submittedFilesElements = row.querySelectorAll('a[href*="assignsubmission_file/submission_files"')
Kode lerroa:           // Change URLs of files elements
Kode lerroa:           _.forEach(submittedFilesElements, (submittedFileElement) => {
Kode lerroa:             submittedFileElement.href = submittedFileElement.href + '#studentId:' +
Kode lerroa:               studentId + '&courseId:' + assignmentData.courseId + '&cmid:' + assignmentData.cmid
Kode lerroa:           })
Kode lerroa:           // When sent files are more than 5, files are not directly shown, you need to click and another website is opened with submitted files. See https://github.com/haritzmedina/MarkAndGo/issues/13
Kode lerroa:           const assignmentSubmissionElement = row.querySelector('a[href*="action=viewpluginassignsubmission"')
Kode lerroa:           if (_.isElement(assignmentSubmissionElement)) {
Kode lerroa:             assignmentSubmissionElement.href = assignmentSubmissionElement.href + '&studentId=' + studentId
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleGradingAugmentation
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleScraping from '../MoodleScraping'
Kode lerroa: 
Kode lerroa: class MoodleViewPluginAssignSubmissionAugmentation {
Kode lerroa:   init () {
Kode lerroa:     // Get course id
Kode lerroa:     MoodleScraping.scrapAssignmentData((err, assignmentData) => {
Kode lerroa:       if (err) {
Kode lerroa: 
Kode lerroa:       } else {
Kode lerroa:         console.log(assignmentData)
Kode lerroa:         // Get current student id
Kode lerroa:         const studentId = (new URL(window.location)).searchParams.get('studentId')
Kode lerroa:         const submittedFilesElements = document.querySelectorAll('a[href*="assignsubmission_file/submission_files"')
Kode lerroa:         // Change URLs of files elements
Kode lerroa:         _.forEach(submittedFilesElements, (submittedFileElement) => {
Kode lerroa:           submittedFileElement.href = submittedFileElement.href + '#studentId:' +
Kode lerroa:             studentId + '&courseId:' + assignmentData.courseId + '&cmid:' + assignmentData.cmid
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleViewPluginAssignSubmissionAugmentation
Kode lerroa: import MoodleClientManager from '../../../../moodle/MoodleClientManager'
Kode lerroa: import MoodleFunctions from '../../../../moodle/MoodleFunctions'
Kode lerroa: import _ from 'lodash'
Kode lerroa: // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BrowserStorage, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import Codebook from '../../../model/Codebook'
Kode lerroa: import Theme from '../../../model/Theme'
Kode lerroa: import LanguageUtils from '../../../../utils/LanguageUtils'
Kode lerroa: import CircularJSON from 'circular-json-es6'
Kode lerroa: import MoodleScraping from './MoodleScraping'
Kode lerroa: 
Kode lerroa: class MoodleProvider {
Kode lerroa:   constructor () {
Kode lerroa:     this.rubric = null
Kode lerroa:     this.assignmentId = null
Kode lerroa:     this.moodleEndpoint = null
Kode lerroa:     this.assignmentName = null
Kode lerroa:     this.AnnotationServerClientManager = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     // Ask for configuration
Kode lerroa:     Alerts.confirmAlert({
Kode lerroa:       title: 'Mark&Go assignment configuration',
Kode lerroa:       text: 'Do you want to configure this assignment to mark using Mark&Go?',
Kode lerroa:       cancelCallback: () => {
Kode lerroa:         callback(null)
Kode lerroa:       },
Kode lerroa:       callback: () => {
Kode lerroa:         // Create hypothesis client
Kode lerroa:         this.loadAnnotationServer(() => {
Kode lerroa:           MoodleScraping.scrapAssignmentData((err, assignmentData) => {
Kode lerroa:             if (err) {
Kode lerroa: 
Kode lerroa:             } else {
Kode lerroa:               this.cmid = assignmentData.cmid
Kode lerroa:               this.moodleEndpoint = assignmentData.moodleEndpoint
Kode lerroa:               this.assignmentName = assignmentData.assignmentName
Kode lerroa:               // Create moodle client
Kode lerroa:               this.moodleClientManager = new MoodleClientManager(this.moodleEndpoint)
Kode lerroa:               this.moodleClientManager.init((err) => {
Kode lerroa:                 if (err) {
Kode lerroa:                   // Unable to init moodle client manager
Kode lerroa:                   Alerts.errorAlert({ text: 'Unable to retrieve rubric from moodle, have you the required permissions to get the rubric via API?' })
Kode lerroa:                   callback(err)
Kode lerroa:                 } else {
Kode lerroa:                   const promises = []
Kode lerroa:                   // Get rubric
Kode lerroa:                   promises.push(new Promise((resolve, reject) => {
Kode lerroa:                     this.getRubric(assignmentData.cmid, assignmentData.courseId, (err, rubric) => {
Kode lerroa:                       if (err) {
Kode lerroa:                         reject(err)
Kode lerroa:                       } else {
Kode lerroa:                         resolve(rubric)
Kode lerroa:                       }
Kode lerroa:                     })
Kode lerroa:                   }))
Kode lerroa:                   // Get students
Kode lerroa:                   promises.push(new Promise((resolve, reject) => {
Kode lerroa:                     this.getStudents(assignmentData.courseId, (err, students) => {
Kode lerroa:                       if (err) {
Kode lerroa:                         reject(err)
Kode lerroa:                       } else {
Kode lerroa:                         resolve(students)
Kode lerroa:                       }
Kode lerroa:                     })
Kode lerroa:                   }))
Kode lerroa:                   Promise.all(promises).catch((rejects) => {
Kode lerroa:                     const reject = _.isArray(rejects) ? rejects[0] : rejects
Kode lerroa:                     Alerts.errorAlert({
Kode lerroa:                       title: 'Something went wrong',
Kode lerroa:                       text: reject.message
Kode lerroa:                     })
Kode lerroa:                   }).then((resolves) => {
Kode lerroa:                     if (resolves && resolves.length > 1) {
Kode lerroa:                       let students = null
Kode lerroa:                       if (LanguageUtils.isInstanceOf(resolves[0], Codebook)) {
Kode lerroa:                         this.rubric = resolves[0]
Kode lerroa:                         students = resolves[1]
Kode lerroa:                       } else {
Kode lerroa:                         this.rubric = resolves[1]
Kode lerroa:                         students = resolves[0]
Kode lerroa:                       }
Kode lerroa:                       // Send task to background
Kode lerroa:                       chrome.runtime.sendMessage({ scope: 'task', cmd: 'createHighlighters', data: { rubric: CircularJSON.stringifyStrict(this.rubric), students: students, courseId: assignmentData.courseId } }, (result) => {
Kode lerroa:                         if (result.err) {
Kode lerroa:                           Alerts.errorAlert({
Kode lerroa:                             title: 'Something went wrong',
Kode lerroa:                             text: 'Error when sending createHighlighters to the background. Please try it again.'
Kode lerroa:                           })
Kode lerroa:                         } else {
Kode lerroa:                           const minutes = result.minutes
Kode lerroa:                           let notFirstTime = false
Kode lerroa:                           Alerts.updateableAlert({
Kode lerroa:                             title: 'Configuration started',
Kode lerroa:                             text: 'We are configuring the assignment to mark using Mark&Go.' +
Kode lerroa:                               `This can take around <b>${minutes} minute(s)</b>.` +
Kode lerroa:                               'You can close this window, we will notify you when it is finished.<br/>Current status: <span></span>',
Kode lerroa:                             timerIntervalHandler: (swal, timerInterval) => {
Kode lerroa:                               chrome.runtime.sendMessage({ scope: 'task', cmd: 'getCurrentTaskStatus' }, (result) => {
Kode lerroa:                                 if (result.status && result.status === 'Nothing pending' && notFirstTime) {
Kode lerroa:                                   Alerts.closeAlert()
Kode lerroa:                                   clearInterval(timerInterval)
Kode lerroa:                                   Alerts.updateableAlert({ text: 'The assignment is correctly configured', title: 'Configuration finished' })
Kode lerroa:                                 } else if (result.status && result.status === 'CreateHighlighterTask pending') {
Kode lerroa:                                   notFirstTime = true
Kode lerroa:                                   swal.getContent().querySelector('span').textContent = result.statusMessage
Kode lerroa:                                 }
Kode lerroa:                               })
Kode lerroa:                             },
Kode lerroa:                             timerIntervalPeriodInSeconds: 2
Kode lerroa:                           })
Kode lerroa:                           // Show message
Kode lerroa:                           callback(null)
Kode lerroa:                         }
Kode lerroa:                       })
Kode lerroa:                     }
Kode lerroa:                   }).catch((rejects) => {
Kode lerroa:                     const reject = _.isArray(rejects) ? rejects[0] : rejects
Kode lerroa:                     Alerts.errorAlert({
Kode lerroa:                       title: 'Something went wrong',
Kode lerroa:                       text: reject.message + '.\n' + chrome.i18n.getMessage('ContactAdministrator', [err.message, err.stack])
Kode lerroa:                     })
Kode lerroa:                   })
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getRubric (cmid, courseId, callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       this.moodleClientManager.getRubric(cmid, (err, rubrics) => {
Kode lerroa:         if (err) {
Kode lerroa:           callback(new Error('Unable to get rubric from moodle. Check if you have the permission: ' + MoodleFunctions.getRubric.wsFunc))
Kode lerroa:         } else {
Kode lerroa:           this.moodleClientManager.getCmidInfo(cmid, (err, cmidInfo) => {
Kode lerroa:             if (err) {
Kode lerroa:               callback(new Error('Unable to retrieve assignment id from Moodle. Check if you have the permission: ' + MoodleFunctions.getCourseModuleInfo.wsFunc))
Kode lerroa:             } else {
Kode lerroa:               const assignmentId = cmidInfo.cm.instance
Kode lerroa:               this.constructRubricsModel({
Kode lerroa:                 moodleRubrics: rubrics,
Kode lerroa:                 courseId: courseId,
Kode lerroa:                 assignmentId: assignmentId,
Kode lerroa:                 callback: callback
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getStudents (courseId, callback) {
Kode lerroa:     this.moodleClientManager.getStudents(courseId, (err, students) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(new Error('Unable to get students from moodle. Check if you have the permission: ' + MoodleFunctions.getStudents.wsFunc))
Kode lerroa:       } else {
Kode lerroa:         callback(null, students)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   showToolIsConfiguring () {
Kode lerroa:     Alerts.loadingAlert({
Kode lerroa:       title: 'Configuring the tool, please be patient', // TODO i18n
Kode lerroa:       text: 'If the tool takes too much time, please reload the page and try again.'
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadAnnotationServer (callback) {
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()=1, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initLoginProcess (callback) {
Kode lerroa:     this.AnnotationServerClientManager.logIn((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         callback(null)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   constructRubricsModel ({ moodleRubrics, courseId, assignmentId, callback }) {
Kode lerroa:     this.rubric = new Codebook({
Kode lerroa:       name: _.get(moodleRubrics, 'areas[0].definitions[0].name'),
Kode lerroa:       moodleEndpoint: this.moodleEndpoint,
Kode lerroa:       assignmentName: this.assignmentName,
Kode lerroa:       courseId: courseId
Kode lerroa:     })
Kode lerroa:     // Ensure a rubric is retrieved
Kode lerroa:     if (moodleRubrics.areas[0].activemethod === 'rubric') {
Kode lerroa:       const rubricCriteria = _.get(moodleRubrics, 'areas[0].definitions[0].rubric.rubric_criteria')
Kode lerroa:       const rubricCmid = _.get(moodleRubrics, 'areas[0].cmid')
Kode lerroa:       if (!_.isUndefined(rubricCriteria) && !_.isUndefined(assignmentId) && !_.isUndefined(rubricCmid)) {
Kode lerroa:         // Set assignment id
Kode lerroa:         this.rubric.assignmentId = assignmentId
Kode lerroa:         this.rubric.cmid = moodleRubrics.areas[0].cmid
Kode lerroa:         // Generate rubric model
Kode lerroa:         for (let i = 0; i < rubricCriteria.length; i++) {
Kode lerroa:           const moodleCriteria = rubricCriteria[i]
Kode lerroa:           const criteria = new Theme({ name: LanguageUtils.normalizeString(moodleCriteria.description), id: moodleCriteria.id, description: LanguageUtils.normalizeString(moodleCriteria.description), annotationGuide: this.rubric })
Kode lerroa:           // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:           this.rubric.themes.push(criteria)
Kode lerroa:         }
Kode lerroa:         callback(null, this.rubric)
Kode lerroa:       } else {
Kode lerroa:         // Message user assignment has not a rubric associated
Kode lerroa:         Alerts.errorAlert({ text: 'This assignment has not a rubric.' }) // TODO i18n
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       // Message user assignment has not a rubric associated
Kode lerroa:       Alerts.errorAlert({ text: 'This assignment has not a rubric.' }) // TODO i18n
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleProvider
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class MoodleScraping {
Kode lerroa:   static scrapAssignmentData (callback) {
Kode lerroa:     // Get assignment id and moodle endpoint
Kode lerroa:     if (window.location.href.includes('grade/grading/')) {
Kode lerroa:       const assignmentElement = document.querySelector('a[href*="mod/assign"]')
Kode lerroa:       const assignmentURL = assignmentElement.href
Kode lerroa:       // Get assignment name
Kode lerroa:       this.assignmentName = assignmentElement.innerText
Kode lerroa:       // Get assignment id
Kode lerroa:       this.cmid = (new URL(assignmentURL)).searchParams.get('id')
Kode lerroa:       // Get moodle endpoint
Kode lerroa:       this.moodleEndpoint = _.split(window.location.href, 'grade/grading/')[0]
Kode lerroa:       // Get course id
Kode lerroa:       const courseElement = document.querySelector('a[href*="course/view"]')
Kode lerroa:       this.courseId = (new URL(courseElement.href)).searchParams.get('id')
Kode lerroa:     } else if (window.location.href.includes('mod/assign/view')) {
Kode lerroa:       // Get assignment id
Kode lerroa:       this.cmid = (new URL(window.location)).searchParams.get('id')
Kode lerroa:       // Get moodle endpoint
Kode lerroa:       this.moodleEndpoint = _.split(window.location.href, 'mod/assign/view')[0]
Kode lerroa:       let assignmentElement = null
Kode lerroa:       // Get assignment name
Kode lerroa:       // Try moodle 3.5 in assignment main page
Kode lerroa:       const assignmentElementContainer = document.querySelector('ol.breadcrumb')
Kode lerroa:       if (assignmentElementContainer) { // Is moodle 3.5
Kode lerroa:         // Get assignment name
Kode lerroa:         assignmentElement = assignmentElementContainer.querySelector('a[href*="mod/assign"]')
Kode lerroa:         this.assignmentName = assignmentElement.innerText
Kode lerroa:         // Get course id
Kode lerroa:         const courseElement = assignmentElementContainer.querySelector('a[href*="course/view"]')
Kode lerroa:         this.courseId = (new URL(courseElement.href)).searchParams.get('id')
Kode lerroa:       }
Kode lerroa:       if (!_.isElement(assignmentElement)) {
Kode lerroa:         // Try moodle 3.1 in assignment main page
Kode lerroa:         const assignmentElementContainer = document.querySelector('ul.breadcrumb')
Kode lerroa:         if (assignmentElementContainer) {
Kode lerroa:           // Get assignment name
Kode lerroa:           assignmentElement = assignmentElementContainer.querySelector('a[href*="mod/assign"]')
Kode lerroa:           this.assignmentName = assignmentElement.innerText
Kode lerroa:           // Get course id
Kode lerroa:           const courseElement = assignmentElementContainer.querySelector('a[href*="course/view"]')
Kode lerroa:           this.courseId = (new URL(courseElement.href)).searchParams.get('id')
Kode lerroa:         }
Kode lerroa:         if (!_.isElement(assignmentElement)) {
Kode lerroa:           // Try moodle 3.5 in student grader page (action=grader)
Kode lerroa:           const assignmentElementContainer = document.querySelector('[data-region="assignment-info"]')
Kode lerroa:           if (assignmentElementContainer) {
Kode lerroa:             // Get assignment name
Kode lerroa:             assignmentElement = assignmentElementContainer.querySelector('a[href*="mod/assign"]')
Kode lerroa:             this.assignmentName = assignmentElement.innerText.split(':')[1].substring(1)
Kode lerroa:             // Get course id
Kode lerroa:             const courseElement = assignmentElementContainer.querySelector('a[href*="course/view"]')
Kode lerroa:             this.courseId = (new URL(courseElement.href)).searchParams.get('id')
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (this.assignmentName && this.courseId && this.moodleEndpoint && this.cmid) {
Kode lerroa:       callback(null, {
Kode lerroa:         assignmentName: this.assignmentName,
Kode lerroa:         cmid: this.cmid,
Kode lerroa:         courseId: this.courseId,
Kode lerroa:         moodleEndpoint: this.moodleEndpoint
Kode lerroa:       })
Kode lerroa:     } else {
Kode lerroa:       callback(new Error(chrome.i18n.getMessage('MoodleWrongAssignmentPage')))
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleScraping
Kode lerroa: import NoCodebookScheme from './NoCodebookScheme'
Kode lerroa: import Codebook from '../../../model/Codebook'
Kode lerroa: import Alerts from '../../../../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class NoCodebook {
Kode lerroa:   static createDefaultAnnotations (callback) {
Kode lerroa:     Codebook.setAnnotationServer(null, (annotationServer) => {
Kode lerroa:       // Create annotation guide with only one element "highlight"
Kode lerroa:       const annotationGuide = Codebook.fromObjects(NoCodebookScheme)
Kode lerroa:       // Create review schema from default criteria
Kode lerroa:       annotationGuide.annotationServer = annotationServer
Kode lerroa:       // Create highlighter annotations
Kode lerroa:       const annotations = annotationGuide.toAnnotations()
Kode lerroa:       // TODO Codes annotations should be related to its corresponding theme: it requires to update Code annotations to relate them by ID instead of by tag
Kode lerroa:       // Send create highlighter
Kode lerroa:       window.abwa.annotationServerManager.client.createNewAnnotations(annotations, (err, createdAnnotations) => {
Kode lerroa:         if (err) {
Kode lerroa:           Alerts.errorAlert({ text: 'Unable to create new group.' })
Kode lerroa:         } else {
Kode lerroa:           window.abwa.sidebar.openSidebar()
Kode lerroa:           Alerts.closeAlert()
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null, createdAnnotations)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default NoCodebook
Kode lerroa: {
Kode lerroa:   "name": "Test",
Kode lerroa:   "definition": [
Kode lerroa:     {
Kode lerroa:       "name": "Highlight",
Kode lerroa:       "description": "Click here to highlight selected text content."
Kode lerroa:     }
Kode lerroa:   ]
Kode lerroa: }
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: // PVSCL:IFCOND(BuiltIn, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(NOT(Classifying), LINE)
Kode lerroa: 
Kode lerroa: import Codebook from '../../model/Codebook'
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: 
Kode lerroa: class CreateCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Initializes codebook creator funcionality
Kode lerroa:    */
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for createCodebook event
Kode lerroa:     this.initCreateCodebookEvent()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Initializes codebook create event listener
Kode lerroa:    */
Kode lerroa:   initCreateCodebookEvent () {
Kode lerroa:     this.events.createCodebook = { element: document, event: Events.createCodebook, handler: this.createCodebookEventHandler() }
Kode lerroa:     this.events.createCodebook.element.addEventListener(this.events.createCodebook.event, this.events.createCodebook.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createCodebookEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const promise = new Promise((resolve, reject) => {
Kode lerroa:         const howCreate = event.detail.howCreate
Kode lerroa:         // PVSCL:IFCOND(BuiltIn, LINE)
Kode lerroa: 
Kode lerroa:       })
Kode lerroa:       promise.catch((err) => {
Kode lerroa:         Alerts.errorAlert({ text: err })
Kode lerroa:       }).then((annotations) => {
Kode lerroa:         Codebook.fromAnnotations(annotations, (err, codebook) => {
Kode lerroa:           if (err) {
Kode lerroa:             Alerts.errorAlert({ text: 'Unable to create a codebook. Error: ' + err.message })
Kode lerroa:           } else {
Kode lerroa:             LanguageUtils.dispatchCustomEvent(Events.codebookCreated, { codebook: codebook })
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default CreateCodebook
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class DeleteCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for deleteCodebook event
Kode lerroa:     this.initDeleteCodebookEvent()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // EVENTS
Kode lerroa:   initDeleteCodebookEvent () {
Kode lerroa:     this.events.deleteCodebookEvent = { element: document, event: Events.deleteCodebook, handler: this.deleteCodebookEventHandler() }
Kode lerroa:     this.events.deleteCodebookEvent.element.addEventListener(this.events.deleteCodebookEvent.event, this.events.deleteCodebookEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deleteCodebookEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const codebook = event.detail.codebook
Kode lerroa:       const user = event.detail.user
Kode lerroa:       Alerts.confirmAlert({
Kode lerroa:         title: 'Deleting annotation group ' + codebook.name,
Kode lerroa:         text: 'Are you sure that you want to delete this group? Codebook and all the annotations done in all the documents will be erased.',
Kode lerroa:         alertType: Alerts.alertType.warning,
Kode lerroa:         callback: () => {
Kode lerroa:           window.abwa.annotationServerManager.client.removeAMemberFromAGroup({ id: codebook.id, user: user }, (err) => {
Kode lerroa:             if (err) {
Kode lerroa:               LanguageUtils.dispatchCustomEvent(Events.codebookDeleted, { err: err })
Kode lerroa:             } else {
Kode lerroa:               LanguageUtils.dispatchCustomEvent(Events.codebookDeleted, { group: codebook })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DeleteCodebook
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: import Events from '../../../Events'
Kode lerroa: 
Kode lerroa: class DeleteGroup {
Kode lerroa:   static deleteAnnotations () {
Kode lerroa:     // Ask user if they are sure to delete it
Kode lerroa:     Alerts.confirmAlert({
Kode lerroa:       alertType: Alerts.alertType.question,
Kode lerroa:       title: chrome.i18n.getMessage('DeleteAllAnnotationsConfirmationTitle'),
Kode lerroa:       text: chrome.i18n.getMessage('DeleteAllAnnotationsConfirmationMessage'),
Kode lerroa:       callback: (err, toDelete) => {
Kode lerroa:         // It is run only when the user confirms the dialog, so delete all the annotations
Kode lerroa:         if (err) {
Kode lerroa:           // Nothing to do
Kode lerroa:         } else {
Kode lerroa:           // Dispatch delete all annotations event
Kode lerroa:           LanguageUtils.dispatchCustomEvent(Events.deleteAllAnnotations)
Kode lerroa:           // TODO Check if it is better to maintain the sidebar opened or not
Kode lerroa:           window.abwa.sidebar.openSidebar()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DeleteGroup
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import ExportCodebookJSON from './ExportCodebookJSON'
Kode lerroa: 
Kode lerroa: class ExportCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for export codebook event
Kode lerroa:     this.initExportCodebookEventHandler()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // EVENTS
Kode lerroa:   initExportCodebookEventHandler () {
Kode lerroa:     this.events.exportCodebookEvent = { element: document, event: Events.exportCodebook, handler: this.exportCodebookEventHandler() }
Kode lerroa:     this.events.exportCodebookEvent.element.addEventListener(this.events.exportCodebookEvent.event, this.events.exportCodebookEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   exportCodebookEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       switch (event.detail.exportTo) {
Kode lerroa:         case 'JSON':
Kode lerroa:           ExportCodebookJSON.exportConfigurationSchemaToJSONFile(event.detail.codebookAnnotations, event.detail.codebook)
Kode lerroa:           break
Kode lerroa:         default :
Kode lerroa:           ExportCodebookJSON.exportConfigurationSchemaToJSONFile(event.detail.codebookAnnotations, event.detail.codebook)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ExportCodebook
Kode lerroa: import _ from 'lodash'
Kode lerroa: import FileSaver from 'file-saver'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import Codebook from '../../model/Codebook'
Kode lerroa: 
Kode lerroa: class ExportCodebookJSON {
Kode lerroa:   static exportConfigurationSchemeToJSObject (schemeAnnotations, name, callback) {
Kode lerroa:     Codebook.fromAnnotations(schemeAnnotations, (err, guide) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ text: 'The codebook scheme is not exported correctly. Error: ' + err.message })
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(guide.toObjects(name))
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static exportConfigurationSchemaToJSONFile (schemeAnnotations, group) {
Kode lerroa:     ExportCodebookJSON.exportConfigurationSchemeToJSObject(schemeAnnotations, group.name, (object) => {
Kode lerroa:       if (_.isObject(object)) {
Kode lerroa:         // Stringify JS object
Kode lerroa:         const stringifyObject = JSON.stringify(object, null, 2)
Kode lerroa:         // Download the file
Kode lerroa:         const blob = new window.Blob([stringifyObject], {
Kode lerroa:           type: 'text/plain;charset=utf-8'
Kode lerroa:         })
Kode lerroa:         FileSaver.saveAs(blob, group.name + '.json')
Kode lerroa:       } else {
Kode lerroa:         Alerts.errorAlert({ text: 'An unexpected error happened when trying to retrieve review model configuration. Reload webpage and try again.' })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ExportCodebookJSON
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import ImportCodebookJSON from './ImportCodebookJSON'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class ImportCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for export codebook event
Kode lerroa:     this.initImportCodebookEventHandler()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // EVENTS
Kode lerroa:   initImportCodebookEventHandler () {
Kode lerroa:     this.events.importCodebookEvent = { element: document, event: Events.importCodebook, handler: this.importCodebookEventHandler() }
Kode lerroa:     this.events.importCodebookEvent.element.addEventListener(this.events.importCodebookEvent.event, this.events.importCodebookEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   importCodebookEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       switch (event.detail.importTo) {
Kode lerroa:         case 'JSON':
Kode lerroa:           ImportCodebookJSON.import()
Kode lerroa:           break
Kode lerroa:         default :
Kode lerroa:           ImportCodebookJSON.import()
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ImportCodebook
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import FileUtils from '../../../utils/FileUtils'
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import Codebook from '../../model/Codebook'
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: 
Kode lerroa: class ImportCodebookJSON {
Kode lerroa:   static import () {
Kode lerroa:     ImportCodebookJSON.askUserForConfigurationSchema((err, jsonObject) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ text: 'Unable to parse json file. Error:<br/>' + err.message })
Kode lerroa:       } else {
Kode lerroa:         Alerts.inputTextAlert({
Kode lerroa:           alertType: Alerts.alertType.warning,
Kode lerroa:           title: 'Give a name to your imported review model',
Kode lerroa:           text: 'When the configuration is imported a new highlighter is created. You can return to your other review models using the sidebar.',
Kode lerroa:           inputPlaceholder: 'Type here the name of your review model...',
Kode lerroa:           preConfirm: (groupName) => {
Kode lerroa:             if (_.isString(groupName)) {
Kode lerroa:               if (groupName.length <= 0) {
Kode lerroa:                 const swal = require('sweetalert2')
Kode lerroa:                 swal.showValidationMessage('Name cannot be empty.')
Kode lerroa:               } else if (groupName.length > 25) {
Kode lerroa:                 const swal = require('sweetalert2')
Kode lerroa:                 swal.showValidationMessage('The review model name cannot be higher than 25 characters.')
Kode lerroa:               } else {
Kode lerroa:                 return groupName
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           },
Kode lerroa:           callback: (err, reviewName) => {
Kode lerroa:             if (err) {
Kode lerroa:               window.alert('Unable to load alert. Unexpected error, please contact developer.')
Kode lerroa:             } else {
Kode lerroa:               window.abwa.annotationServerManager.client.createNewGroup({ name: reviewName }, (err, newGroup) => {
Kode lerroa:                 if (err) {
Kode lerroa:                   Alerts.errorAlert({ text: 'Unable to create a new annotation group. Error: ' + err.message })
Kode lerroa:                 } else {
Kode lerroa:                   const guide = Codebook.fromObjects(jsonObject)
Kode lerroa:                   Codebook.setAnnotationServer(newGroup, (annotationServer) => {
Kode lerroa:                     guide.annotationServer = annotationServer
Kode lerroa:                     Alerts.loadingAlert({
Kode lerroa:                       title: 'Configuration in progress',
Kode lerroa:                       text: 'We are configuring everything to start reviewing.',
Kode lerroa:                       position: Alerts.position.center
Kode lerroa:                     })
Kode lerroa:                     ImportCodebookJSON.createConfigurationAnnotationsFromReview({
Kode lerroa:                       guide,
Kode lerroa:                       callback: (err) => {
Kode lerroa:                         if (err) {
Kode lerroa:                           Alerts.errorAlert({ text: 'There was an error when configuring Review&Go highlighter' })
Kode lerroa:                         } else {
Kode lerroa:                           Alerts.closeAlert()
Kode lerroa:                           LanguageUtils.dispatchCustomEvent(Events.codebookImported, { groupId: guide.annotationServer.group.id })
Kode lerroa:                         }
Kode lerroa:                       }
Kode lerroa:                     })
Kode lerroa:                   })
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createConfigurationAnnotationsFromReview ({ guide, callback }) {
Kode lerroa:     // Create highlighter annotations
Kode lerroa:     const annotations = guide.toAnnotations()
Kode lerroa:     // Send create highlighter
Kode lerroa:     window.abwa.annotationServerManager.client.createNewAnnotations(annotations, (err, annotations) => {
Kode lerroa:       callback(err, annotations)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static backupReviewGroup (callback) {
Kode lerroa:     // Get current group id
Kode lerroa:     const currentGroupId = window.abwa.groupSelector.currentGroup.id
Kode lerroa:     // Rename current group
Kode lerroa:     const date = new Date()
Kode lerroa:     const currentGroupNewName = 'ReviewAndGo-' + date.getFullYear() + '-' + date.getMonth() + '-' + date.getDay() + '-' + date.getHours()
Kode lerroa:     window.abwa.annotationServerManager.client.updateGroup(currentGroupId, { name: currentGroupNewName }, (err, result) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(new Error('Unable to backup current annotation group.'))
Kode lerroa:       } else {
Kode lerroa:         callback(null, result)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Ask user for a configuration file in JSON and it returns a javascript object with the configuration
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   static askUserForConfigurationSchema (callback) {
Kode lerroa:     // Ask user to upload the file
Kode lerroa:     Alerts.inputTextAlert({
Kode lerroa:       title: 'Upload your configuration file',
Kode lerroa:       html: 'Here you can upload your json file with the configuration for the Review&Go highlighter.',
Kode lerroa:       input: 'file',
Kode lerroa:       callback: (err, file) => {
Kode lerroa:         if (err) {
Kode lerroa:           window.alert('An unexpected error happened when trying to load the alert.')
Kode lerroa:         } else {
Kode lerroa:           // Read json file
Kode lerroa:           FileUtils.readJSONFile(file, (err, jsonObject) => {
Kode lerroa:             if (err) {
Kode lerroa:               callback(new Error('Unable to read json file: ' + err.message))
Kode lerroa:             } else {
Kode lerroa:               callback(null, jsonObject)
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ImportCodebookJSON
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import ColorUtils from '../../../utils/ColorUtils'
Kode lerroa: if (!$.contextMenu) {
Kode lerroa:   require('jquery-contextmenu/dist/jquery.contextMenu')
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:  * A class to collect functionality to create buttons and groups of buttons for the sidebar
Kode lerroa:  */
Kode lerroa: class Buttons {
Kode lerroa:   static createGroupedButtons ({ id, name, label, data, className, description, color = 'white', childGuideElements, groupHandler, buttonHandler, groupTemplate, groupRightClickHandler, buttonRightClickHandler, ondragstart, ondragover, ondrop }) {
Kode lerroa:     if (id) {
Kode lerroa:       let tagGroup
Kode lerroa:       // Create the container
Kode lerroa:       if (!groupTemplate) {
Kode lerroa:         groupTemplate = document.querySelector('#tagGroupTemplate')
Kode lerroa:         if (!_.isElement(groupTemplate)) {
Kode lerroa:           tagGroup = document.createElement('div')
Kode lerroa:           tagGroup.className = 'tagGroup'
Kode lerroa:           if (className) {
Kode lerroa:             tagGroup.className += ' ' + className
Kode lerroa:           }
Kode lerroa:           // Group name container
Kode lerroa:           const groupNameContainer = document.createElement('div')
Kode lerroa:           groupNameContainer.className = 'groupNameContainer'
Kode lerroa:           // Group name label
Kode lerroa:           const groupName = document.createElement('div')
Kode lerroa:           groupName.className = 'groupName'
Kode lerroa:           groupNameContainer.appendChild(groupName)
Kode lerroa:           // Create collapse button
Kode lerroa:           const collapseToogle = document.createElement('span')
Kode lerroa:           collapseToogle.className = 'collapseToggle'
Kode lerroa:           collapseToogle.addEventListener('click', () => {
Kode lerroa:             const tagGroup = document.querySelector('.tagGroup[data-code-id=' + id + ']')
Kode lerroa:             if (tagGroup.getAttribute('aria-expanded') === 'false') {
Kode lerroa:               tagGroup.setAttribute('aria-expanded', 'true')
Kode lerroa:             } else {
Kode lerroa:               tagGroup.setAttribute('aria-expanded', 'false')
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:           groupNameContainer.appendChild(collapseToogle)
Kode lerroa:           tagGroup.appendChild(groupNameContainer)
Kode lerroa:           const tagButtonContainer = document.createElement('div')
Kode lerroa:           tagButtonContainer.className = 'tagButtonContainer'
Kode lerroa:           tagGroup.appendChild(tagButtonContainer)
Kode lerroa:         } else {
Kode lerroa:           tagGroup = $(groupTemplate.content.firstElementChild).clone().get(0)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         tagGroup = $(groupTemplate.content.firstElementChild).clone().get(0)
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(data)) {
Kode lerroa:         const dataResult = data({ codeId: id })
Kode lerroa:         _.forEach(_.toPairs(dataResult), (pair) => { tagGroup.dataset[pair[0]] = pair[1] })
Kode lerroa:       }
Kode lerroa:       tagGroup.dataset.codeName = name
Kode lerroa:       tagGroup.dataset.codeId = id
Kode lerroa:       const tagButtonContainer = $(tagGroup).find('.tagButtonContainer')
Kode lerroa:       const groupNameSpan = tagGroup.querySelector('.groupName')
Kode lerroa:       const groupNameContainer = tagGroup.querySelector('.groupNameContainer')
Kode lerroa:       if (_.isFunction(label)) {
Kode lerroa:         groupNameSpan.innerText = label({ codeId: id, codeName: name })
Kode lerroa:       } else {
Kode lerroa:         groupNameSpan.innerText = name
Kode lerroa:       }
Kode lerroa:       if (description) {
Kode lerroa:         groupNameSpan.title = name + ': ' + description
Kode lerroa:       } else {
Kode lerroa:         groupNameSpan.title = name
Kode lerroa:       }
Kode lerroa:       groupNameContainer.style.backgroundColor = color
Kode lerroa:       groupNameSpan.dataset.baseColor = color
Kode lerroa:       // Create event handler for tag group
Kode lerroa:       groupNameSpan.addEventListener('click', groupHandler)
Kode lerroa:       // Tag button background color change
Kode lerroa:       // TODO It should be better to set it as a CSS property, but currently there is not an option for that
Kode lerroa:       groupNameContainer.addEventListener('mouseenter', () => {
Kode lerroa:         const currentColor = ColorUtils.colorFromString(groupNameContainer.style.backgroundColor)
Kode lerroa:         if (currentColor.valpha) {
Kode lerroa:           if (currentColor.alpha(currentColor.valpha + 0.2).isDark()) {
Kode lerroa:             groupNameSpan.style.color = 'white'
Kode lerroa:           }
Kode lerroa:           groupNameContainer.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(groupNameSpan.dataset.baseColor), currentColor.valpha + 0.2)
Kode lerroa:         } else {
Kode lerroa:           groupNameContainer.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(groupNameSpan.dataset.baseColor), 0.7)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       groupNameContainer.addEventListener('mouseleave', () => {
Kode lerroa:         if (groupNameSpan.dataset.chosen === 'true') {
Kode lerroa:           groupNameContainer.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(groupNameSpan.dataset.baseColor), 0.6)
Kode lerroa:         } else {
Kode lerroa:           groupNameSpan.style.color = ''
Kode lerroa:           groupNameContainer.style.backgroundColor = groupNameSpan.dataset.baseColor
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       // Set button right click handler
Kode lerroa:       if (_.isFunction(groupRightClickHandler)) {
Kode lerroa:         Buttons.createGroupRightClickHandler({ id, className, handler: groupRightClickHandler })
Kode lerroa:       }
Kode lerroa:       // Drag and drop functions
Kode lerroa:       if (_.isFunction(ondragstart)) {
Kode lerroa:         tagGroup.draggable = true
Kode lerroa:         // On drag start function
Kode lerroa:         tagGroup.addEventListener('dragstart', Buttons.createDragStartHandler(id, ondragstart))
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(ondragover)) {
Kode lerroa:         // On dragover function
Kode lerroa:         tagGroup.addEventListener('dragover', (event) => {
Kode lerroa:           event.stopPropagation()
Kode lerroa:           tagGroup.style.backgroundColor = 'rgba(150,150,150,0.5)'
Kode lerroa:         })
Kode lerroa:         tagGroup.addEventListener('dragleave', (event) => {
Kode lerroa:           event.stopPropagation()
Kode lerroa:           tagGroup.style.backgroundColor = ''
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(ondrop)) {
Kode lerroa:         tagGroup.addEventListener('dragover', (event) => {
Kode lerroa:           event.stopPropagation()
Kode lerroa:           event.preventDefault()
Kode lerroa:         })
Kode lerroa:         // On drop function
Kode lerroa:         groupNameSpan.addEventListener('drop', Buttons.createDropHandler({
Kode lerroa:           id,
Kode lerroa:           handler: ondrop,
Kode lerroa:           beforeDrop: () => {
Kode lerroa:             tagGroup.style.backgroundColor = ''
Kode lerroa:           }
Kode lerroa:         }))
Kode lerroa:       }
Kode lerroa:       // Create buttons and add to the container
Kode lerroa:       if (_.isArray(childGuideElements) && childGuideElements.length > 0) { // Only create group containers for groups which have elements
Kode lerroa:         for (let i = 0; i < childGuideElements.length; i++) {
Kode lerroa:           const element = childGuideElements[i]
Kode lerroa:           if (element.childElements && element.childElements.length > 0) {
Kode lerroa:             const groupButton = Buttons.createGroupedButtons({
Kode lerroa:               id: element.id,
Kode lerroa:               name: element.name,
Kode lerroa:               className: className,
Kode lerroa:               label: label,
Kode lerroa:               data: data,
Kode lerroa:               childGuideElements: element.childElements,
Kode lerroa:               color: element.color,
Kode lerroa:               groupHandler: groupHandler,
Kode lerroa:               buttonHandler: buttonHandler,
Kode lerroa:               groupRightClickHandler: groupRightClickHandler,
Kode lerroa:               buttonRightClickHandler: buttonRightClickHandler,
Kode lerroa:               ondragstart,
Kode lerroa:               ondragover,
Kode lerroa:               ondrop
Kode lerroa:             })
Kode lerroa:             tagButtonContainer.append(groupButton)
Kode lerroa:           } else {
Kode lerroa:             const button = Buttons.createButton({
Kode lerroa:               id: element.id,
Kode lerroa:               name: element.name,
Kode lerroa:               label: label,
Kode lerroa:               data: data,
Kode lerroa:               className: className,
Kode lerroa:               description: element.description,
Kode lerroa:               color: element.color,
Kode lerroa:               handler: buttonHandler,
Kode lerroa:               buttonRightClickHandler: buttonRightClickHandler,
Kode lerroa:               ondragstart,
Kode lerroa:               ondragover,
Kode lerroa:               ondrop
Kode lerroa:             })
Kode lerroa:             tagButtonContainer.append(button)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return tagGroup
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Group button must have an unique id')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createGroupRightClickHandler ({ id, className = 'tagGroup', handler }) {
Kode lerroa:     $.contextMenu({
Kode lerroa:       selector: '.' + className + '[data-code-id="' + id + '"] > .groupNameContainer > .groupName',
Kode lerroa:       build: () => {
Kode lerroa:         return handler(id)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createButtonRightClickHandler ({ id, className = 'tagButton', handler }) {
Kode lerroa:     $.contextMenu({
Kode lerroa:       selector: '.' + className + '[data-code-id="' + id + '"]',
Kode lerroa:       build: () => {
Kode lerroa:         return handler(id)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createDragStartHandler (id, handler) {
Kode lerroa:     return (event) => {
Kode lerroa:       event.stopPropagation()
Kode lerroa:       if (_.isFunction(handler)) {
Kode lerroa:         handler(event, id)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createDropHandler ({ id, handler, beforeDrop }) {
Kode lerroa:     return (event) => {
Kode lerroa:       if (_.isFunction(beforeDrop)) {
Kode lerroa:         beforeDrop()
Kode lerroa:       }
Kode lerroa:       event.preventDefault()
Kode lerroa:       event.stopPropagation()
Kode lerroa:       if (_.isFunction(handler)) {
Kode lerroa:         handler(event, id)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static createButton ({ id, name, label, data, className, color = 'rgba(200, 200, 200, 1)', description, handler, buttonTemplate, buttonRightClickHandler, ondragstart, ondragover, ondrop }) {
Kode lerroa:     if (id) {
Kode lerroa:       let tagButton
Kode lerroa:       // Create the container
Kode lerroa:       if (!buttonTemplate) {
Kode lerroa:         buttonTemplate = document.querySelector('#tagGroupTemplate')
Kode lerroa:         if (!_.isElement(buttonTemplate)) {
Kode lerroa:           tagButton = document.createElement('button')
Kode lerroa:           tagButton.className = 'tagButton'
Kode lerroa:           if (className) {
Kode lerroa:             tagButton.className += ' ' + className
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         $(buttonTemplate.content.firstElementChild).clone().get(0)
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(data)) {
Kode lerroa:         const dataResult = data({ codeId: id })
Kode lerroa:         _.forEach(_.toPairs(dataResult), (pair) => { tagButton.dataset[pair[0]] = pair[1] })
Kode lerroa:       }
Kode lerroa:       tagButton.dataset.codeName = name
Kode lerroa:       tagButton.dataset.codeId = id
Kode lerroa:       if (_.isFunction(label)) {
Kode lerroa:         tagButton.innerText = label({ codeId: id, codeName: name })
Kode lerroa:       } else {
Kode lerroa:         tagButton.innerText = name
Kode lerroa:       }
Kode lerroa:       if (description) {
Kode lerroa:         tagButton.title = name + ': ' + description
Kode lerroa:       } else {
Kode lerroa:         tagButton.title = name
Kode lerroa:       }
Kode lerroa:       tagButton.dataset.mark = name
Kode lerroa:       if (color) {
Kode lerroa:         $(tagButton).css('background-color', color)
Kode lerroa:         tagButton.dataset.baseColor = color
Kode lerroa:       }
Kode lerroa:       // Set handler for button
Kode lerroa:       tagButton.addEventListener('click', handler)
Kode lerroa:       // Set button right click handler
Kode lerroa:       if (_.isFunction(buttonRightClickHandler)) {
Kode lerroa:         Buttons.createButtonRightClickHandler({ id, className, handler: buttonRightClickHandler })
Kode lerroa:       }
Kode lerroa:       // Drag and drop functions
Kode lerroa:       if (_.isFunction(ondragstart)) {
Kode lerroa:         tagButton.draggable = true
Kode lerroa:         // On drag start function
Kode lerroa:         tagButton.addEventListener('dragstart', Buttons.createDragStartHandler(id, ondragstart))
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(ondragover)) {
Kode lerroa:         // On dragover function
Kode lerroa:         tagButton.addEventListener('dragenter', (event) => {
Kode lerroa:           event.stopPropagation()
Kode lerroa:           tagButton.style.backgroundColor = 'rgba(150,150,150,0.5)'
Kode lerroa:         })
Kode lerroa:         tagButton.addEventListener('dragleave', (event) => {
Kode lerroa:           event.stopPropagation()
Kode lerroa:           if (tagButton.dataset.chosen === 'true') {
Kode lerroa:             tagButton.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(tagButton.dataset.baseColor), 0.6)
Kode lerroa:           } else {
Kode lerroa:             tagButton.style.backgroundColor = tagButton.dataset.baseColor
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:       if (_.isFunction(ondrop)) {
Kode lerroa:         // Prevent dragover
Kode lerroa:         tagButton.addEventListener('dragover', (e) => {
Kode lerroa:           e.preventDefault()
Kode lerroa:           e.stopPropagation()
Kode lerroa:         })
Kode lerroa:         // On drop function
Kode lerroa:         tagButton.addEventListener('drop', Buttons.createDropHandler({
Kode lerroa:           id,
Kode lerroa:           handler: ondrop,
Kode lerroa:           beforeDrop: () => {
Kode lerroa:             if (tagButton.dataset.chosen === 'true') {
Kode lerroa:               tagButton.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(tagButton.dataset.baseColor), 0.6)
Kode lerroa:             } else {
Kode lerroa:               tagButton.style.backgroundColor = tagButton.dataset.baseColor
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }))
Kode lerroa:       }
Kode lerroa:       // Tag button background color change
Kode lerroa:       // TODO It should be better to set it as a CSS property, but currently there is not an option for that
Kode lerroa:       tagButton.addEventListener('mouseenter', () => {
Kode lerroa:         const currentColor = ColorUtils.colorFromString(tagButton.style.backgroundColor)
Kode lerroa:         if (currentColor.valpha) {
Kode lerroa:           if (currentColor.opaquer(0.2).isDark()) {
Kode lerroa:             tagButton.style.color = 'white'
Kode lerroa:           }
Kode lerroa:           tagButton.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(tagButton.dataset.baseColor), currentColor.valpha + 0.2)
Kode lerroa:         } else {
Kode lerroa:           tagButton.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(tagButton.dataset.baseColor), 0.7)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       tagButton.addEventListener('mouseleave', () => {
Kode lerroa:         tagButton.style.color = ''
Kode lerroa:         if (tagButton.dataset.chosen === 'true') {
Kode lerroa:           tagButton.style.backgroundColor = ColorUtils.setAlphaToColor(ColorUtils.colorFromString(tagButton.dataset.baseColor), 0.6)
Kode lerroa:         } else {
Kode lerroa:           tagButton.style.backgroundColor = tagButton.dataset.baseColor
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       return tagButton
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Button must have an unique id')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Buttons
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import Config from '../../../Config'
Kode lerroa: import Buttons from './Buttons'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Codebook from '../../model/Codebook'
Kode lerroa: import Theme from '../../model/Theme'
Kode lerroa: // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: import ColorUtils from '../../../utils/ColorUtils'
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class ReadCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.codebook = {}
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate,LINE)
Kode lerroa: 
Kode lerroa:     this.loadCodebook(() => {
Kode lerroa:       // Add event listener for codebook read event
Kode lerroa:       this.initCodebookCreatedEvent()
Kode lerroa:       this.initCodebookReadEvent(callback)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:     // Remove buttons container
Kode lerroa:     $('#tagsWrapper').remove()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // EVENTS
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   initCodebookReadEvent (callback) {
Kode lerroa:     this.events.codebookReadEvent = { element: document, event: Events.codebookRead, handler: this.codebookReadEventHandler() }
Kode lerroa:     this.events.codebookReadEvent.element.addEventListener(this.events.codebookReadEvent.event, this.events.codebookReadEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initCodebookCreatedEvent () {
Kode lerroa:     this.events.codebookCreatedEvent = { element: document, event: Events.codebookCreated, handler: this.codebookCreatedEventHandler() }
Kode lerroa:     this.events.codebookCreatedEvent.element.addEventListener(this.events.codebookCreatedEvent.event, this.events.codebookCreatedEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Loads the codebook inside the sidebar
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   loadCodebook (callback) {
Kode lerroa:     console.debug('Reading codebook')
Kode lerroa:     this.initCodebookStructure(() => {
Kode lerroa:       this.initCodebookContent(callback)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initFirstCodebookReadEventHandler (callback, callbackToExecuteAfterRead) {
Kode lerroa:     /* this.events.firstCodebookReadEvent = {element: document, event: Events.codebookRead, handler: this.codebookReadEventListener(callbackToExecuteAfterRead)}
Kode lerroa:     this.events.firstCodebookReadEvent.element.addEventListener(this.events.firstCodebookReadEvent.event, this.events.firstCodebookReadEvent.handler, false)
Kode lerroa:     */ if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   codebookReadEventListener (callback) {
Kode lerroa:     return (event) => {
Kode lerroa:       // Remove codebook read event listener after first read
Kode lerroa:       const eventHandlerToDisable = this.events.firstCodebookReadEvent
Kode lerroa:       eventHandlerToDisable.element.removeEventListener(eventHandlerToDisable.event, eventHandlerToDisable.handler)
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function add the html associated to the codebook in the sidebar
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   initCodebookStructure (callback) {
Kode lerroa:     const tagWrapperUrl = chrome.extension.getURL('pages/sidebar/tagWrapper.html')
Kode lerroa:     $.get(tagWrapperUrl, (html) => {
Kode lerroa:       $('#abwaSidebarContainer').append($.parseHTML(html))
Kode lerroa:       this.buttonContainer = document.querySelector('#buttonContainer')
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function loads the content of the codebook in the sidebar
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   initCodebookContent (callback) {
Kode lerroa:     // Retrieve from annotation server highlighter definition
Kode lerroa:     this.getCodebookDefinition(null, (err, codebookDefinitionAnnotations) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ text: 'Unable to retrieve annotations from annotation server to initialize highlighter buttons.' }) // TODO i18n
Kode lerroa:       } else {
Kode lerroa:         const initCodebookPromise = new Promise((resolve, reject) => {
Kode lerroa:           if (codebookDefinitionAnnotations.length === 0) {
Kode lerroa:             // PVSCL:IFCOND(BuiltIn AND NOT(ApplicationBased), LINE)
Kode lerroa: 
Kode lerroa:           } else {
Kode lerroa:             Codebook.fromAnnotations(codebookDefinitionAnnotations, (err, codebook) => {
Kode lerroa:               if (err) {
Kode lerroa:                 Alerts.errorAlert({ text: 'Error parsing codebook. Error: ' + err.message })
Kode lerroa:               } else {
Kode lerroa:                 this.codebook = codebook
Kode lerroa:                 this.renderCodebookInSidebar()
Kode lerroa:                 resolve()
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:         initCodebookPromise.then(() => {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function retrieves highlighter definition annotations from annotationServer (e.g.: Hypothes.is)
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   getCodebookDefinition (group, callback) {
Kode lerroa:     let groupUrl
Kode lerroa:     if (group) {
Kode lerroa:       groupUrl = group.links ? group.links.html : group.url
Kode lerroa:     } else {
Kode lerroa:       groupUrl = window.abwa.groupSelector.currentGroup.links.html
Kode lerroa:     }
Kode lerroa:     window.abwa.annotationServerManager.client.searchAnnotations({
Kode lerroa:       url: groupUrl,
Kode lerroa:       order: 'desc'
Kode lerroa:     }, (err, annotations) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ text: 'Unable to construct the highlighter. Please reload webpage and try it again.' })
Kode lerroa:       } else {
Kode lerroa:         // Retrieve tags which has the namespace
Kode lerroa:         annotations = _.filter(annotations, (annotation) => {
Kode lerroa:           return this.hasANamespace(annotation, Config.namespace.toString())
Kode lerroa:         })
Kode lerroa:         // Remove slr:spreadsheet annotation ONLY for SLR case
Kode lerroa:         annotations = _.filter(annotations, (annotation) => {
Kode lerroa:           return !this.hasATag(annotation, 'slr:spreadsheet')
Kode lerroa:         })
Kode lerroa:         // PVSCL:IFCOND(MoodleResource,LINE)
Kode lerroa: 
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, annotations)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   codebookReadEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Get the codebook
Kode lerroa:       this.codebook = event.detail.codebook
Kode lerroa:       this.renderCodebookInSidebar()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   renderCodebookInSidebar () {
Kode lerroa:     // Remove buttons from previous codebook if exists
Kode lerroa:     this.buttonContainer.innerText = ''
Kode lerroa:     // PVSCL:IFCOND(Codebook, LINE)
Kode lerroa: 
Kode lerroa:     // Populate sidebar buttons container
Kode lerroa:     this.createButtons()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function adds the buttons that must appear in the sidebar to be able to annotate
Kode lerroa:    */
Kode lerroa:   createButtons () {
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:     // Create current buttons
Kode lerroa:     const themes = this.codebook.themes
Kode lerroa:     // PVSCL:IFCOND(Alphabetical, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Number, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Date, LINE)
Kode lerroa: 
Kode lerroa:     for (let i = 0; i < themes.length; i++) {
Kode lerroa:       const theme = themes[i]
Kode lerroa:       let themeButtonContainer
Kode lerroa:       // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:       if (_.isElement(themeButtonContainer)) {
Kode lerroa:         this.buttonContainer.append(themeButtonContainer)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createGroupedThemeButtonContainer (theme, codes) {
Kode lerroa:     return Buttons.createGroupedButtons({
Kode lerroa:       id: theme.id,
Kode lerroa:       name: theme.name,
Kode lerroa:       className: 'codingElement',
Kode lerroa:       description: theme.description,
Kode lerroa:       color: theme.color,
Kode lerroa:       childGuideElements: codes,
Kode lerroa:       groupHandler: (event) => {
Kode lerroa:         const themeId = event.target.parentElement.parentElement.dataset.codeId
Kode lerroa:         if (themeId) {
Kode lerroa:           const theme = this.codebook.getCodeOrThemeFromId(themeId)
Kode lerroa:           if (LanguageUtils.isInstanceOf(theme, Theme)) {
Kode lerroa:             let id = ''
Kode lerroa:             let tags = ''
Kode lerroa:             // PVSCL:IFCOND(NOT(Multivalued),LINE)
Kode lerroa: 
Kode lerroa:             // PVSCL:IFCOND(MoodleResource,LINE)
Kode lerroa: 
Kode lerroa:             // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       },
Kode lerroa:       buttonHandler: (event) => {
Kode lerroa:         const codeId = event.target.dataset.codeId
Kode lerroa:         if (codeId) {
Kode lerroa:           const code = this.codebook.getCodeOrThemeFromId(codeId)
Kode lerroa:           if (LanguageUtils.isInstanceOf(code, Code)) {
Kode lerroa:             // PVSCL:IFCOND(NOT(Multivalued),LINE)
Kode lerroa: 
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }/* PVSCL:IFCOND(CodebookUpdate) */,
Kode lerroa: 
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createThemeButtonContainer (theme) {
Kode lerroa:     return Buttons.createButton({
Kode lerroa:       id: theme.id,
Kode lerroa:       name: theme.name,
Kode lerroa:       className: 'codingElement',
Kode lerroa:       description: theme.description,
Kode lerroa:       color: theme.color,
Kode lerroa:       handler: (event) => {
Kode lerroa:         const themeId = event.target.dataset.codeId
Kode lerroa:         if (themeId) {
Kode lerroa:           const theme = this.codebook.getCodeOrThemeFromId(themeId)
Kode lerroa:           if (LanguageUtils.isInstanceOf(theme, Theme)) {
Kode lerroa:             const tags = [Config.namespace + ':' + Config.tags.grouped.group + ':' + theme.name]
Kode lerroa:             // PVSCL:IFCOND(MoodleResource,LINE)
Kode lerroa: 
Kode lerroa:             // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }/* PVSCL:IFCOND(CodebookUpdate) */,
Kode lerroa: 
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Reloads the button if a new button has been added or deleted
Kode lerroa:    */
Kode lerroa:   reloadButtonContainer () {
Kode lerroa:     this.buttonContainer.innerHTML = ''
Kode lerroa:     this.createButtons()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Retrieve tags which has the given namespace
Kode lerroa:    * @param annotation, namespace
Kode lerroa:    */
Kode lerroa:   hasANamespace (annotation, namespace) {
Kode lerroa:     return _.findIndex(annotation.tags, (annotationTag) => {
Kode lerroa:       return _.startsWith(annotationTag.toLowerCase(), (namespace + ':').toLowerCase())
Kode lerroa:     }) !== -1
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Returns true if the annotation has the given tag
Kode lerroa:    * @param annotation, tag
Kode lerroa:    */
Kode lerroa:   hasATag (annotation, tag) {
Kode lerroa:     return _.findIndex(annotation.tags, (annotationTag) => {
Kode lerroa:       return _.startsWith(annotationTag.toLowerCase(), tag.toLowerCase())
Kode lerroa:     }) !== -1
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function gives a color to each codebook element
Kode lerroa:    */
Kode lerroa:   applyColorsToThemes () {
Kode lerroa:     if (this.codebook && this.codebook.themes) {
Kode lerroa:       const listOfColors = ColorUtils.getDifferentColors(this.codebook.themes.length)
Kode lerroa:       this.codebook.themes.forEach((theme) => {
Kode lerroa:         const color = listOfColors.pop()
Kode lerroa:         // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function creates the themes right click context menu.
Kode lerroa:    */
Kode lerroa:   themeRightClickHandler () {
Kode lerroa:     return (themeId) => {
Kode lerroa:       const items = {}
Kode lerroa:       // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:       return {
Kode lerroa:         callback: (key) => {
Kode lerroa:           // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:           // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:         },
Kode lerroa:         items: items
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Creates event handler for event CodebookCreated
Kode lerroa:    * @returns {function(...[*]=)}
Kode lerroa:    */
Kode lerroa:   codebookCreatedEventHandler () {
Kode lerroa:     return () => {
Kode lerroa:       this.initCodebookContent()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ReadCodebook
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: 
Kode lerroa: class RenameCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for renameCodebook event
Kode lerroa:     this.initRenameCodebookEvent()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // EVENTS
Kode lerroa:   initRenameCodebookEvent () {
Kode lerroa:     this.events.renameCodebookEvent = { element: document, event: Events.renameCodebook, handler: this.renameCodebookEventHandler() }
Kode lerroa:     this.events.renameCodebookEvent.element.addEventListener(this.events.renameCodebookEvent.event, this.events.renameCodebookEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Event handler for renameCodebook.
Kode lerroa:    */
Kode lerroa:   renameCodebookEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const codebook = event.detail.codebook
Kode lerroa:       Alerts.inputTextAlert({
Kode lerroa:         title: 'Rename review model ' + codebook.name,
Kode lerroa:         inputPlaceholder: 'Type here the name of your new review model...',
Kode lerroa:         inputValue: codebook.name,
Kode lerroa:         preConfirm: (codebookName) => {
Kode lerroa:           if (_.isString(codebookName)) {
Kode lerroa:             if (codebookName.length <= 0) {
Kode lerroa:               const swal = require('sweetalert2')
Kode lerroa:               swal.showValidationMessage('Name cannot be empty.')
Kode lerroa:             } else if (codebookName.length > 25) {
Kode lerroa:               const swal = require('sweetalert2')
Kode lerroa:               swal.showValidationMessage('The review model name cannot be higher than 25 characters.')
Kode lerroa:             } else {
Kode lerroa:               return codebookName
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         },
Kode lerroa:         callback: (err, codebookName) => {
Kode lerroa:           if (err) {
Kode lerroa:             window.alert('Unable to load swal. Please contact developer.')
Kode lerroa:             LanguageUtils.dispatchCustomEvent(Events.codebookRenamed, { err: err })
Kode lerroa:           } else {
Kode lerroa:             codebookName = LanguageUtils.normalizeString(codebookName)
Kode lerroa:             window.abwa.annotationServerManager.client.updateGroup(codebook.id, {
Kode lerroa:               name: codebookName,
Kode lerroa:               description: codebook.description || 'A Review&Go group to conduct a review'
Kode lerroa:             }, (err, codebook) => {
Kode lerroa:               if (err) {
Kode lerroa:                 LanguageUtils.dispatchCustomEvent(Events.codebookRenamed, { err: err })
Kode lerroa:               } else {
Kode lerroa:                 LanguageUtils.dispatchCustomEvent(Events.codebookRenamed, { group: codebook })
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default RenameCodebook
Kode lerroa: import Events from '../../../Events'
Kode lerroa: import Alerts from '../../../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Config from '../../../Config'
Kode lerroa: import Theme from '../../model/Theme'
Kode lerroa: import Classifying from '../../../annotationManagement/purposes/Classifying'
Kode lerroa: import Annotation from '../../../annotationManagement/Annotation'
Kode lerroa: // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa: import LanguageUtils from '../../../utils/LanguageUtils'
Kode lerroa: 
Kode lerroa: class UpdateCodebook {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Add event listener for updateCodebook event
Kode lerroa:     this.initCreateThemeEvent()
Kode lerroa:     this.initRemoveThemeEvent()
Kode lerroa:     this.initUpdateThemeEvent()
Kode lerroa:     // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initCreateThemeEvent () {
Kode lerroa:     this.events.createThemeEvent = { element: document, event: Events.createTheme, handler: this.createNewThemeEventHandler() }
Kode lerroa:     this.events.createThemeEvent.element.addEventListener(this.events.createThemeEvent.event, this.events.createThemeEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initUpdateThemeEvent () {
Kode lerroa:     this.events.updateThemeEvent = { element: document, event: Events.updateTheme, handler: this.createUpdateThemeEventHandler() }
Kode lerroa:     this.events.updateThemeEvent.element.addEventListener(this.events.updateThemeEvent.event, this.events.updateThemeEvent.handler, false)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initRemoveThemeEvent (callback) {
Kode lerroa:     this.events.removeThemeEvent = { element: document, event: Events.removeTheme, handler: this.removeThemeEventHandler() }
Kode lerroa:     this.events.removeThemeEvent.element.addEventListener(this.events.removeThemeEvent.event, this.events.removeThemeEvent.handler, false)
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function adds a button in the sidebar that allows to create new themes.
Kode lerroa:    */
Kode lerroa:   static createNewThemeButton () {
Kode lerroa:     const newThemeButton = document.createElement('button')
Kode lerroa:     newThemeButton.innerText = 'Create new theme'
Kode lerroa:     newThemeButton.id = 'newThemeButton'
Kode lerroa:     newThemeButton.className = 'tagButton codingElement'
Kode lerroa:     newThemeButton.addEventListener('click', () => {
Kode lerroa:       let newTheme
Kode lerroa:       Alerts.multipleInputAlert({
Kode lerroa:         title: 'You are creating a new theme: ',
Kode lerroa:         html: '<input autofocus class="formCodeName swal2-input" type="text" id="themeName" placeholder="New theme name" value=""/>' +
Kode lerroa:           '<textarea class="formCodeDescription swal2-textarea" data-minchars="1" data-multiple rows="6" id="themeDescription" placeholder="Please type a description that describes this theme..."></textarea>',
Kode lerroa:         preConfirm: () => {
Kode lerroa:           const themeNameElement = document.querySelector('#themeName')
Kode lerroa:           let themeName
Kode lerroa:           if (_.isElement(themeNameElement)) {
Kode lerroa:             themeName = themeNameElement.value
Kode lerroa:           }
Kode lerroa:           const themeDescriptionElement = document.querySelector('#themeDescription')
Kode lerroa:           let themeDescription
Kode lerroa:           if (_.isElement(themeDescriptionElement)) {
Kode lerroa:             themeDescription = themeDescriptionElement.value
Kode lerroa:           }
Kode lerroa:           newTheme = new Theme({ name: themeName, description: themeDescription, annotationGuide: window.abwa.codebookManager.codebookReader.codebook })
Kode lerroa:         },
Kode lerroa:         callback: () => {
Kode lerroa:           LanguageUtils.dispatchCustomEvent(Events.createTheme, { theme: newTheme })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:     window.abwa.codebookManager.codebookReader.buttonContainer.append(newThemeButton)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function creates a handler to create a new theme when it receives the createTheme event.
Kode lerroa:    * @return Event
Kode lerroa:    */
Kode lerroa:   createNewThemeEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const newThemeAnnotation = event.detail.theme.toAnnotation()
Kode lerroa:       window.abwa.annotationServerManager.client.createNewAnnotation(newThemeAnnotation, (err, annotation) => {
Kode lerroa:         if (err) {
Kode lerroa:           Alerts.errorAlert({ text: 'Unable to create the new code. Error: ' + err.toString() })
Kode lerroa:         } else {
Kode lerroa:           LanguageUtils.dispatchCustomEvent(Events.themeCreated, { newThemeAnnotation: annotation })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function creates a handler to update a new theme when it receives the updateTheme event.
Kode lerroa:    * @return Event
Kode lerroa:    */
Kode lerroa:   createUpdateThemeEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const theme = event.detail.theme
Kode lerroa:       let themeToUpdate
Kode lerroa:       // Show form to update theme
Kode lerroa:       Alerts.multipleInputAlert({
Kode lerroa:         title: 'You are updating the theme ' + theme.name,
Kode lerroa:         html: '<input autofocus class="formCodeName swal2-input" type="text" id="themeName" type="text" placeholder="New theme name" value="' + theme.name + '"/>' +
Kode lerroa:           '<textarea class="formCodeDescription swal2-textarea" data-minchars="1" data-multiple rows="6"  id="themeDescription" placeholder="Please type a description that describes this theme...">' + theme.description + '</textarea>',
Kode lerroa:         preConfirm: () => {
Kode lerroa:           const themeNameElement = document.querySelector('#themeName')
Kode lerroa:           let themeName
Kode lerroa:           if (_.isElement(themeNameElement)) {
Kode lerroa:             themeName = themeNameElement.value
Kode lerroa:           }
Kode lerroa:           const themeDescriptionElement = document.querySelector('#themeDescription')
Kode lerroa:           let themeDescription
Kode lerroa:           if (_.isElement(themeDescriptionElement)) {
Kode lerroa:             themeDescription = themeDescriptionElement.value
Kode lerroa:           }
Kode lerroa:           themeToUpdate = new Theme({ name: themeName, description: themeDescription, annotationGuide: window.abwa.codebookManager.codebookReader.codebook })
Kode lerroa:           // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:           themeToUpdate.id = theme.id
Kode lerroa:         },
Kode lerroa:         callback: () => {
Kode lerroa:           // Update codebook
Kode lerroa:           this.updateCodebookTheme(themeToUpdate)
Kode lerroa:           // Update all annotations done with this theme
Kode lerroa:           this.updateAnnotationsWithTheme(themeToUpdate)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function creates a handler to remove a theme when it receives the removeTheme event.
Kode lerroa:    * @return Event
Kode lerroa:    */
Kode lerroa:   removeThemeEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       const theme = event.detail.theme
Kode lerroa:       // Ask user is sure to remove
Kode lerroa:       Alerts.confirmAlert({
Kode lerroa:         title: 'Removing code ' + theme.name,
Kode lerroa:         text: 'Are you sure that you want to remove the theme ' + theme.name + '. All dependant codes will be deleted too. You cannot undo this operation.',
Kode lerroa:         alertType: Alerts.alertType.warning,
Kode lerroa:         callback: () => {
Kode lerroa:           let annotationsToDelete = [theme.id]
Kode lerroa:           // Get theme codes id to be removed too
Kode lerroa:           const codesId = _.map(theme.codes, (code) => { return code.id })
Kode lerroa:           if (_.every(codesId, _.isString)) {
Kode lerroa:             annotationsToDelete = annotationsToDelete.concat(codesId)
Kode lerroa:           }
Kode lerroa:           window.abwa.annotationServerManager.client.deleteAnnotations(annotationsToDelete, (err, result) => {
Kode lerroa:             if (err) {
Kode lerroa:               Alerts.errorAlert({ text: 'Unexpected error when deleting the code.' })
Kode lerroa:             } else {
Kode lerroa:               LanguageUtils.dispatchCustomEvent(Events.themeRemoved, { theme: theme })
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   updateCodebookTheme (themeToUpdate, callback) {
Kode lerroa:     const annotationsToUpdate = themeToUpdate.toAnnotations()
Kode lerroa:     const updatePromises = annotationsToUpdate.map((annotation) => {
Kode lerroa:       return new Promise((resolve, reject) => {
Kode lerroa:         window.abwa.annotationServerManager.client.updateAnnotation(annotation.id, annotation, (err, annotation) => {
Kode lerroa:           if (err) {
Kode lerroa:             reject(err)
Kode lerroa:           } else {
Kode lerroa:             resolve()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:     Promise
Kode lerroa:       .all(updatePromises)
Kode lerroa:       .catch((rejects) => {
Kode lerroa:         Alerts.errorAlert({ text: 'Unable to create the new code. Error: ' + rejects[0].toString() })
Kode lerroa:       }).then(() => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:         LanguageUtils.dispatchCustomEvent(Events.themeUpdated, { updatedTheme: themeToUpdate })
Kode lerroa:       })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateAnnotationsWithTheme (theme) {
Kode lerroa:     // Get all the annotations done in the group with this theme
Kode lerroa:     const searchByTagPromise = (tag) => {
Kode lerroa:       return new Promise((resolve, reject) => {
Kode lerroa:         window.abwa.annotationServerManager.client.searchAnnotations({
Kode lerroa:           group: window.abwa.groupSelector.currentGroup.id,
Kode lerroa:           tags: [tag]
Kode lerroa:         }, (err, annotations) => {
Kode lerroa:           if (err) {
Kode lerroa:             reject(err)
Kode lerroa:           } else {
Kode lerroa:             resolve(annotations)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:     const promises = [
Kode lerroa:       searchByTagPromise(Config.namespace + ':' + Config.tags.grouped.group + ':' + theme.name)
Kode lerroa:     ]
Kode lerroa:     // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:     Promise.all(promises).then((resolves) => {
Kode lerroa:       const annotationObjects = resolves[0] // Get annotations done
Kode lerroa:       let annotations = annotationObjects.map((annotation) => {
Kode lerroa:         try {
Kode lerroa:           return Annotation.deserialize(annotation)
Kode lerroa:         } catch (err) {
Kode lerroa:           return null
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       annotations = _.compact(annotations)
Kode lerroa:       // Update all the codes with the new name of the theme
Kode lerroa:       annotations = annotations.map(annotation => {
Kode lerroa:         const classifyingBody = annotation.getBodyForPurpose(Classifying.purpose)
Kode lerroa:         if (classifyingBody) {
Kode lerroa:           if (classifyingBody.value.id === theme.id) {
Kode lerroa:             classifyingBody.value = theme.toObject()
Kode lerroa:             return annotation
Kode lerroa:           } else {
Kode lerroa:             /* PVSCL:IFCOND(Hierarchy, LINE) */
Kode lerroa: 
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:       const promises = annotations.forEach((annotation) => {
Kode lerroa:         return new Promise((resolve, reject) => {
Kode lerroa:           window.abwa.annotationServerManager.client.updateAnnotation(annotation.id, annotation, (err, annotation) => {
Kode lerroa:             if (err) {
Kode lerroa:               reject(err)
Kode lerroa:             } else {
Kode lerroa:               resolve(annotation)
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:       Promise.all(promises || []).then(() => {})
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default UpdateCodebook
Kode lerroa: import _ from 'lodash'
Kode lerroa: import CreateCodebook from './operations/create/CreateCodebook'
Kode lerroa: import ReadCodebook from './operations/read/ReadCodebook'
Kode lerroa: // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(RenameCodebook, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(ImportCodebook, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class CodebookManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.codebookCreator = new CreateCodebook()
Kode lerroa:     this.codebookReader = new ReadCodebook()
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(RenameCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ImportCodebook, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     this.codebookCreator.init()
Kode lerroa:     this.codebookReader.init(() => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(RenameCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ImportCodebook, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Destroy components of codebook
Kode lerroa:     this.codebookCreator.destroy()
Kode lerroa:     this.codebookReader.destroy()
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(RenameCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ImportCodebook, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default CodebookManager
Kode lerroa: import Events from '../Events'
Kode lerroa: // PVSCL:IFCOND(NOT(Multivalued), LINE) // It is only used by SingleCode
Kode lerroa: 
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: import Theme from '../codebook/model/Theme'
Kode lerroa: // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Classifying from '../annotationManagement/purposes/Classifying'
Kode lerroa: import Annotation from '../annotationManagement/Annotation'
Kode lerroa: 
Kode lerroa: export class AnnotatedTheme {
Kode lerroa:   constructor ({
Kode lerroa:     theme = null,
Kode lerroa:     annotations = []
Kode lerroa:     /* PVSCL:IFCOND(Hierarchy) */, annotatedCodes = []/* PVSCL:ENDCOND */
Kode lerroa: 
Kode lerroa:   }) {
Kode lerroa:     // code
Kode lerroa:     this.theme = theme
Kode lerroa:     // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:     this.annotations = annotations
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   hasAnnotations () {
Kode lerroa:     return !(this.annotations.length === 0)
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: export class AnnotatedContentManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.annotatedThemes = {}
Kode lerroa:     this.events = {}
Kode lerroa:     // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing AnnotatedContentManager')
Kode lerroa:     // Retrieve all the annotations for this assignment
Kode lerroa:     this.updateAnnotationForAssignment(() => {
Kode lerroa:       this.reloadTagsChosen()
Kode lerroa:       console.debug('Initialized AnnotatedContentManager')
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // Init event handlers
Kode lerroa:     this.initEvents()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // Remove event listeners
Kode lerroa:     const events = _.values(this.events)
Kode lerroa:     for (let i = 0; i < events.length; i++) {
Kode lerroa:       events[i].element.removeEventListener(events[i].event, events[i].handler)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateAnnotationForAssignment (callback) {
Kode lerroa:     // Retrieve all the annotations for this assignment
Kode lerroa:     this.retrieveAnnotationsForAssignment((err, assignmentAnnotations) => {
Kode lerroa:       if (err) {
Kode lerroa:         // TODO Unable to retrieve annotations for this assignment
Kode lerroa:       } else {
Kode lerroa:         // Retrieve current annotatedThemes
Kode lerroa:         this.addingCodingsFromAnnotations(assignmentAnnotations)
Kode lerroa:         console.debug('Updated annotations for assignment')
Kode lerroa:         // Callback
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   retrieveAnnotationsForAssignment (callback) {
Kode lerroa:     let promise
Kode lerroa:     // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:     // Return retrieved annotations
Kode lerroa:     promise.catch((err) => {
Kode lerroa:       callback(err)
Kode lerroa:     }).then((annotations) => {
Kode lerroa:       callback(null, annotations)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   addingCodingsFromAnnotations (annotations) {
Kode lerroa:     let annotatedThemesWithoutAnnotations = this.defineStructure()
Kode lerroa:     for (let i = 0; i < annotations.length; i++) {
Kode lerroa:       const annotation = annotations[i]
Kode lerroa:       annotatedThemesWithoutAnnotations = this.addAnnotationToAnnotatedThemesOrCode(annotation, annotatedThemesWithoutAnnotations)
Kode lerroa:     }
Kode lerroa:     this.annotatedThemes = annotatedThemesWithoutAnnotations
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   defineStructure () {
Kode lerroa:     let annotatedThemesStructure
Kode lerroa:     // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:     return annotatedThemesStructure
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(NOT(Multivalued), LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   addAnnotationToAnnotatedThemesOrCode (annotation, annotatedThemesObject = this.annotatedThemes) {
Kode lerroa:     // Get classification code
Kode lerroa:     const classifyingBody = annotation.getBodyForPurpose(Classifying.purpose)
Kode lerroa:     if (classifyingBody) {
Kode lerroa:       const codeId = classifyingBody.value.id
Kode lerroa:       const annotatedThemeOrCode = this.getAnnotatedThemeOrCodeFromThemeOrCodeId(codeId, annotatedThemesObject)
Kode lerroa:       if (annotatedThemeOrCode) {
Kode lerroa:         annotatedThemeOrCode.annotations.push(annotation)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return annotatedThemesObject
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   removeAnnotationToAnnotatedThemesOrCode (annotation) {
Kode lerroa:     // Get classification code
Kode lerroa:     const classifyingBody = annotation.getBodyForPurpose(Classifying.purpose)
Kode lerroa:     if (classifyingBody) {
Kode lerroa:       const codeId = classifyingBody.value.id
Kode lerroa:       const annotatedThemeOrCode = this.getAnnotatedThemeOrCodeFromThemeOrCodeId(codeId)
Kode lerroa:       _.remove(annotatedThemeOrCode.annotations, (anno) => {
Kode lerroa:         return anno.id === annotation.id
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function returns the annotations done in current document for the given theme id or code id
Kode lerroa:    * @param themeOrCodeId
Kode lerroa:    * @returns array of annotations
Kode lerroa:    */
Kode lerroa:   getAnnotationsDoneWithThemeOrCodeId (themeOrCodeId) {
Kode lerroa:     // Get AnnotatedTheme or AnnotatedCode
Kode lerroa:     const themeOrCode = this.getAnnotatedThemeOrCodeFromThemeOrCodeId(themeOrCodeId)
Kode lerroa:     if (LanguageUtils.isInstanceOf(themeOrCode, AnnotatedTheme)) {
Kode lerroa:       // If it is the theme, we need to retrieve all the annotations with corresponding theme and annotations done with its children codes
Kode lerroa:       let annotations = _.filter(themeOrCode.annotations, (annotation) => {
Kode lerroa:         return _.intersection(window.abwa.targetManager.getDocumentLink(), _.values(annotation.target[0].source))
Kode lerroa:       })
Kode lerroa:       // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:       return annotations
Kode lerroa:     } /* PVSCL:IFCOND(Hierarchy) */else if (LanguageUtils.isInstanceOf(themeOrCode, AnnotatedCode)) {
Kode lerroa:  else {
Kode lerroa:       return []
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function returns the AnnotatedTheme or AnnotatedCode for the given theme id or code id
Kode lerroa:    * @param themeOrCodeId
Kode lerroa:    * @param annotatedThemesObject
Kode lerroa:    */
Kode lerroa:   getAnnotatedThemeOrCodeFromThemeOrCodeId (themeOrCodeId, annotatedThemesObject = this.annotatedThemes) {
Kode lerroa:     const themeOrCode = window.abwa.codebookManager.codebookReader.codebook.getCodeOrThemeFromId(themeOrCodeId)
Kode lerroa:     if (LanguageUtils.isInstanceOf(themeOrCode, Theme)) {
Kode lerroa:       // Return annotationTheme with the codeId we need
Kode lerroa:       return _.find(annotatedThemesObject, (annotatedTheme) => {
Kode lerroa:         return annotatedTheme.theme.id === themeOrCode.id
Kode lerroa:       })
Kode lerroa:     } /* PVSCL:IFCOND(Hierarchy) */else if (LanguageUtils.isInstanceOf(themeOrCode, Code)) {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initEvents () {
Kode lerroa:     // Create event listener for updated all annotations
Kode lerroa:     this.events.annotationCreated = { element: document, event: Events.annotationCreated, handler: this.createAnnotationCreatedEventHandler() }
Kode lerroa:     this.events.annotationCreated.element.addEventListener(this.events.annotationCreated.event, this.events.annotationCreated.handler, false)
Kode lerroa:     // Create event listener for updated all annotations
Kode lerroa:     this.events.annotationDeleted = { element: document, event: Events.annotationDeleted, handler: this.createDeletedAnnotationEventHandler() }
Kode lerroa:     this.events.annotationDeleted.element.addEventListener(this.events.annotationDeleted.event, this.events.annotationDeleted.handler, false)
Kode lerroa:     // Create event listener for updated all annotations
Kode lerroa:     this.events.deletedAllAnnotations = { element: document, event: Events.deletedAllAnnotations, handler: this.createDeletedAllAnnotationsEventHandler() }
Kode lerroa:     this.events.deletedAllAnnotations.element.addEventListener(this.events.deletedAllAnnotations.event, this.events.deletedAllAnnotations.handler, false)
Kode lerroa:     // PVSCL:IFCOND(NOT(Multivalued), LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(MoodleReport, LINE) // This one is only related to moodle as is the only feature that requires to take into account the annotated content manager when annotations are updated
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(CodebookUpdate, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   createCodeToAllEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Get level for this mark
Kode lerroa:       const code = window.abwa.codebookManager.codebookReader.codebook.getCodeOrThemeFromId(event.detail.codeId)
Kode lerroa:       if (code) {
Kode lerroa:         // Retrieve criteria from rubric
Kode lerroa:         this.codeToAll(code, event.detail.currentlyAnnotatedCode)
Kode lerroa:       } else {
Kode lerroa:         // Unable to retrieve criteria or level
Kode lerroa:         Alerts.errorAlert({
Kode lerroa:           title: 'Unable to code',
Kode lerroa:           text: 'There was an error in coding, please reload the page and try it again.' +
Kode lerroa:             chrome.i18n.getMessage('ErrorContactDeveloper', ['codeToAll', encodeURIComponent(new Error().stack)])
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createAnnotationCreatedEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       // Add event to the codings list
Kode lerroa:       if (event.detail.annotation) {
Kode lerroa:         const annotation = event.detail.annotation
Kode lerroa:         this.annotatedThemes = this.addAnnotationToAnnotatedThemesOrCode(annotation)
Kode lerroa:         if (event.detail.codeToAll) {
Kode lerroa:           // Get classification code
Kode lerroa:           const classifyingBody = annotation.getBodyForPurpose(Classifying.purpose)
Kode lerroa:           if (classifyingBody) {
Kode lerroa:             const codeId = classifyingBody.value.id
Kode lerroa:             LanguageUtils.dispatchCustomEvent(Events.codeToAll, {
Kode lerroa:               codeId: codeId,
Kode lerroa:               currentlyAnnotatedCode: event.detail.lastAnnotatedCode
Kode lerroa:             })
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           this.reloadTagsChosen()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createDeletedAnnotationEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       if (event.detail.annotation) {
Kode lerroa:         const annotation = event.detail.annotation
Kode lerroa:         this.removeAnnotationToAnnotatedThemesOrCode(annotation)
Kode lerroa:         // Dispatch updated content manager event
Kode lerroa:         LanguageUtils.dispatchCustomEvent(Events.annotatedContentManagerUpdated, { annotatedThemes: this.annotatedThemes })
Kode lerroa:       }
Kode lerroa:       this.reloadTagsChosen()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createDeletedAllAnnotationsEventHandler () {
Kode lerroa:     return (event) => {
Kode lerroa:       if (event.detail.annotations) {
Kode lerroa:         const annotations = event.detail.annotations
Kode lerroa:         for (let i = 0; i < annotations.length; i++) {
Kode lerroa:           const annotation = annotations[i]
Kode lerroa:           this.removeAnnotationToAnnotatedThemesOrCode(annotation)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       this.reloadTagsChosen()
Kode lerroa:       // Dispatch updated content manager event
Kode lerroa:       LanguageUtils.dispatchCustomEvent(Events.annotatedContentManagerUpdated, { annotatedThemes: this.annotatedThemes })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadTagsChosen () {
Kode lerroa:     // Retrieve annotated themes id
Kode lerroa:     for (let i = 0; i < this.annotatedThemes.length; i++) {
Kode lerroa:       // annotated
Kode lerroa:       const annotatedTheme = this.annotatedThemes[i]
Kode lerroa:       if (annotatedTheme.theme.codes && annotatedTheme.theme.codes.length > 0) {
Kode lerroa:         const annotatedGroupButton = document.querySelectorAll('.tagGroup[data-code-id="' + annotatedTheme.theme.id + '"]')
Kode lerroa:         const groupNameSpan = annotatedGroupButton[0].querySelector('.groupName')
Kode lerroa:         groupNameSpan.dataset.numberOfAnnotations = this.getAnnotationsDoneWithThemeOrCodeId(annotatedTheme.theme.id).length
Kode lerroa:         // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:       } else {
Kode lerroa:         const annotatedThemeButton = document.querySelectorAll('.tagButton[data-code-id="' + annotatedTheme.theme.id + '"]')
Kode lerroa:         annotatedThemeButton[0].dataset.numberOfAnnotations = this.getAnnotationsDoneWithThemeOrCodeId(annotatedTheme.theme.id).length
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: import _ from 'lodash'
Kode lerroa: import URLUtils from '../utils/URLUtils'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import Config from '../Config'
Kode lerroa: 
Kode lerroa: class AnnotationBasedInitializer {
Kode lerroa:   constructor () {
Kode lerroa:     this.initAnnotation = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     // Check if annotation is in hash params
Kode lerroa:     const annotationId = AnnotationBasedInitializer.getAnnotationHashParam()
Kode lerroa:     if (annotationId) {
Kode lerroa:       if (window.abwa.annotationServerManager.isLoggedIn() === false) {
Kode lerroa:         window.abwa.annotationServerManager.logIn((err, token) => {
Kode lerroa:           if (err) {
Kode lerroa:             Alerts.errorAlert({ title: 'Log in is required', text: 'It is necessary to log in your annotation server.' })
Kode lerroa:           } else {
Kode lerroa:             // Reload web page
Kode lerroa:             document.location.reload()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         window.abwa.annotationServerManager.client.fetchAnnotation(annotationId, (err, annotation) => {
Kode lerroa:           if (err) {
Kode lerroa:             // Alerts.errorAlert({title: 'Unable to retrieve ',text:})
Kode lerroa:           } else {
Kode lerroa:             this.initAnnotation = annotation
Kode lerroa:           }
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(annotation)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getAnnotationHashParam () {
Kode lerroa:     // Check if annotation is in hash params
Kode lerroa:     const decodedUri = decodeURIComponent(window.location.href)
Kode lerroa:     const params = URLUtils.extractHashParamsFromUrl(decodedUri)
Kode lerroa:     if (!_.isEmpty(params) && _.has(params, Config.urlParamName)) {
Kode lerroa:       return params[Config.urlParamName]
Kode lerroa:     } else {
Kode lerroa:       return false
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static isAutoOpenHashParam () {
Kode lerroa:     const decodedUri = decodeURIComponent(window.location.href)
Kode lerroa:     const params = URLUtils.extractHashParamsFromUrl(decodedUri)
Kode lerroa:     if (!_.isEmpty(params) && _.has(params, 'autoOpen')) {
Kode lerroa:       return params.autoOpen
Kode lerroa:     } else {
Kode lerroa:       return false
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationBasedInitializer
Kode lerroa: import _ from 'lodash'
Kode lerroa: import TargetManager from '../target/TargetManager'
Kode lerroa: import Sidebar from './Sidebar'
Kode lerroa: import CodebookManager from '../codebook/CodebookManager'
Kode lerroa: import Config from '../Config'
Kode lerroa: import Toolset from './Toolset'
Kode lerroa: import AnnotationManagement from '../annotationManagement/AnnotationManagement'
Kode lerroa: import GroupSelector from '../groupManipulation/GroupSelector'
Kode lerroa: import AnnotationBasedInitializer from './AnnotationBasedInitializer'
Kode lerroa: import { AnnotatedContentManager } from './AnnotatedContentManager'
Kode lerroa: // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BrowserStorage, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(PreviousAssignments, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(MoodleComment, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class ContentScriptManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.events = {}
Kode lerroa:     this.status = ContentScriptManager.status.notInitialized
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     console.debug('Initializing content script manager')
Kode lerroa:     this.status = ContentScriptManager.status.initializing
Kode lerroa:     this.loadTargetManager(() => {
Kode lerroa:       this.loadAnnotationServer(() => {
Kode lerroa:         window.abwa.sidebar = new Sidebar()
Kode lerroa:         window.abwa.sidebar.init(() => {
Kode lerroa:           window.abwa.annotationBasedInitializer = new AnnotationBasedInitializer()
Kode lerroa:           window.abwa.annotationBasedInitializer.init(() => {
Kode lerroa:             window.abwa.groupSelector = new GroupSelector()
Kode lerroa:             window.abwa.groupSelector.init(() => {
Kode lerroa:               // Reload for first time the content by group
Kode lerroa:               this.reloadContentByGroup()
Kode lerroa:               // PVSCL:IFCOND(Manual,LINE)
Kode lerroa: 
Kode lerroa:             })
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   reloadContentByGroup (callback) {
Kode lerroa:     // TODO Use async await or promises
Kode lerroa:     this.reloadCodebookManager()
Kode lerroa:       /* .then(() => {
Kode lerroa:         return this.reloadContentAnnotator()
Kode lerroa:       }) */
Kode lerroa:       .then(() => {
Kode lerroa:         return this.reloadToolset()
Kode lerroa:       })
Kode lerroa:       .then(() => {
Kode lerroa:         return this.reloadAnnotationManagement()
Kode lerroa:       })
Kode lerroa:       // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(MoodleComment, LINE)
Kode lerroa: 
Kode lerroa:       .then(() => {
Kode lerroa:         return this.reloadAnnotatedContentManager()
Kode lerroa:       })
Kode lerroa:       // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:       .then(() => {
Kode lerroa:         this.status = ContentScriptManager.status.initialized
Kode lerroa:         console.debug('Initialized content script manager')
Kode lerroa:       })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadAnnotatedContentManager () {
Kode lerroa:     return new Promise((resolve, reject) => {
Kode lerroa:       // Destroy annotated content manager
Kode lerroa:       this.destroyAnnotatedContentManager()
Kode lerroa:       // Create a new annotated content manager
Kode lerroa:       window.abwa.annotatedContentManager = new AnnotatedContentManager()
Kode lerroa:       window.abwa.annotatedContentManager.init((err) => {
Kode lerroa:         if (err) {
Kode lerroa:           reject(err)
Kode lerroa:         } else {
Kode lerroa:           resolve()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadAnnotationManagement () {
Kode lerroa:     return new Promise((resolve, reject) => {
Kode lerroa:       // Destroy current content annotator
Kode lerroa:       this.destroyAnnotationManagement()
Kode lerroa:       // Create a new content annotator for the current group
Kode lerroa:       window.abwa.annotationManagement = new AnnotationManagement()
Kode lerroa:       window.abwa.annotationManagement.init((err) => {
Kode lerroa:         if (err) {
Kode lerroa:           reject(err)
Kode lerroa:         } else {
Kode lerroa:           resolve()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadCodebookManager () {
Kode lerroa:     return new Promise((resolve, reject) => {
Kode lerroa:       // Destroy current tag manager
Kode lerroa:       this.destroyCodebookManager()
Kode lerroa:       // Create a new tag manager for the current group
Kode lerroa:       window.abwa.codebookManager = new CodebookManager(Config.namespace, Config.tags) // TODO Depending on the type of annotator
Kode lerroa:       window.abwa.codebookManager.init((err) => {
Kode lerroa:         if (err) {
Kode lerroa:           reject(err)
Kode lerroa:         } else {
Kode lerroa:           resolve()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleComment, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   reloadToolset () {
Kode lerroa:     return new Promise((resolve, reject) => {
Kode lerroa:       // Destroy toolset
Kode lerroa:       this.destroyToolset()
Kode lerroa:       // Create a new toolset
Kode lerroa:       window.abwa.toolset = new Toolset()
Kode lerroa:       window.abwa.toolset.init((err) => {
Kode lerroa:         if (err) {
Kode lerroa:           reject(err)
Kode lerroa:         } else {
Kode lerroa:           resolve()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleComment, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   destroyCodebookManager () {
Kode lerroa:     if (!_.isEmpty(window.abwa.codebookManager)) {
Kode lerroa:       window.abwa.codebookManager.destroy()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroyAnnotatedContentManager () {
Kode lerroa:     if (window.abwa.annotatedContentManager) {
Kode lerroa:       window.abwa.annotatedContentManager.destroy()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   destroyToolset () {
Kode lerroa:     if (window.abwa.toolset) {
Kode lerroa:       window.abwa.toolset.destroy()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     console.debug('Destroying content script manager')
Kode lerroa:     this.destroyTargetManager(() => {
Kode lerroa:       this.destroyCodebookManager()
Kode lerroa:       this.destroyAnnotationManagement()
Kode lerroa:       // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:       this.destroyToolset()
Kode lerroa:       // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:       // TODO Destroy groupSelector, roleManager,
Kode lerroa:       window.abwa.groupSelector.destroy(() => {
Kode lerroa:         window.abwa.sidebar.destroy(() => {
Kode lerroa:           this.destroyAnnotationServer(() => {
Kode lerroa:             this.status = ContentScriptManager.status.notInitialized
Kode lerroa:             console.debug('Correctly destroyed content script manager')
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback()
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:       // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadTargetManager (callback) {
Kode lerroa:     window.abwa.targetManager = new TargetManager()
Kode lerroa:     window.abwa.targetManager.init(() => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroyTargetManager (callback) {
Kode lerroa:     if (window.abwa.targetManager) {
Kode lerroa:       window.abwa.targetManager.destroy(() => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadAnnotationServer (callback) {
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()=1, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroyAnnotationServer (callback) {
Kode lerroa:     if (window.abwa.annotationServerManager) {
Kode lerroa:       window.abwa.annotationServerManager.destroy(callback)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroyAnnotationManagement (callback) {
Kode lerroa:     if (window.abwa.annotationManagement) {
Kode lerroa:       window.abwa.annotationManagement.destroy(callback)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: ContentScriptManager.status = {
Kode lerroa:   initializing: 'initializing',
Kode lerroa:   initialized: 'initialized',
Kode lerroa:   notInitialized: 'notInitialized'
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ContentScriptManager
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: import Events from '../Events'
Kode lerroa: 
Kode lerroa: import RolesManager from './RolesManager'
Kode lerroa: 
Kode lerroa: class ModeManager {
Kode lerroa:   constructor (mode) {
Kode lerroa:     if (mode) {
Kode lerroa:       this.mode = mode
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     if (window.abwa.rolesManager.role === RolesManager.roles.teacher) {
Kode lerroa:       if (window.abwa.annotationBasedInitializer.initAnnotation) {
Kode lerroa:         this.mode = ModeManager.modes.mark
Kode lerroa:         // Open sidebar
Kode lerroa:         window.abwa.sidebar.openSidebar()
Kode lerroa:       } else {
Kode lerroa:         this.mode = ModeManager.modes.evidencing
Kode lerroa:       }
Kode lerroa:       this.loadSidebarToggle(() => {
Kode lerroa:         this.initEventHandlers(() => {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     } else {
Kode lerroa:       this.mode = ModeManager.modes.view
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadSidebarToggle (callback) {
Kode lerroa:     const sidebarURL = chrome.extension.getURL('pages/sidebar/annotatorMode.html')
Kode lerroa:     $.get(sidebarURL, (html) => {
Kode lerroa:       // Append sidebar to content
Kode lerroa:       $('#abwaSidebarContainer').append($.parseHTML(html))
Kode lerroa:       // Set toggle status
Kode lerroa:       this.setToggleStatus()
Kode lerroa:       // Set tags text
Kode lerroa:       this.setPanelText()
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setToggleStatus () {
Kode lerroa:     if (this.mode === ModeManager.modes.evidencing) {
Kode lerroa:       this.setEvidencingMode()
Kode lerroa:     } else {
Kode lerroa:       this.setMarkingMode()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setPanelText () {
Kode lerroa:     // Mode element
Kode lerroa:     const modeHeaderLabel = document.querySelector('#modeHeader label')
Kode lerroa:     modeHeaderLabel.innerText = chrome.i18n.getMessage('Mode')
Kode lerroa:     const modeLabel = document.querySelector('#modeLabel')
Kode lerroa:     if (this.mode === ModeManager.modes.evidencing) {
Kode lerroa:       modeLabel.innerText = chrome.i18n.getMessage('Evidencing')
Kode lerroa:     } else {
Kode lerroa:       modeLabel.innerText = chrome.i18n.getMessage('Marking')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setEvidencingMode () {
Kode lerroa:     const annotatorToggle = document.querySelector('#annotatorToggle')
Kode lerroa:     const modeLabel = document.querySelector('#modeLabel')
Kode lerroa:     annotatorToggle.checked = false
Kode lerroa:     modeLabel.innerText = chrome.i18n.getMessage('Evidencing')
Kode lerroa:     this.mode = ModeManager.modes.evidencing
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setMarkingMode () {
Kode lerroa:     const annotatorToggle = document.querySelector('#annotatorToggle')
Kode lerroa:     const modeLabel = document.querySelector('#modeLabel')
Kode lerroa:     annotatorToggle.checked = true
Kode lerroa:     modeLabel.innerText = chrome.i18n.getMessage('Marking')
Kode lerroa:     this.mode = ModeManager.modes.mark
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   setViewingMode () {
Kode lerroa:     this.mode = ModeManager.modes.view
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initEventHandlers (callback) {
Kode lerroa:     const annotatorToggle = document.querySelector('#annotatorToggle')
Kode lerroa:     annotatorToggle.addEventListener('click', (event) => {
Kode lerroa:       if (annotatorToggle.checked) {
Kode lerroa:         this.setMarkingMode()
Kode lerroa:       } else {
Kode lerroa:         this.setEvidencingMode()
Kode lerroa:       }
Kode lerroa:       LanguageUtils.dispatchCustomEvent(Events.modeChanged, { mode: this.mode })
Kode lerroa:     })
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: ModeManager.modes = {
Kode lerroa:   review: 'review', // Activated for the reviewer role
Kode lerroa:   view: 'view' // Activated for the author
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ModeManager
Kode lerroa: import _ from 'lodash'
Kode lerroa: import jsYaml from 'js-yaml'
Kode lerroa: import Config from '../Config'
Kode lerroa: 
Kode lerroa: class RolesManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.role = RolesManager.roles.consumer
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing RolesManager')
Kode lerroa:     // Enable different functionality if current user is the teacher or student
Kode lerroa:     this.currentUserIsProducer((err, isProducer) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (isProducer) { // Open modes
Kode lerroa:           this.role = RolesManager.roles.producer
Kode lerroa:         } else {
Kode lerroa:           this.role = RolesManager.roles.consumer
Kode lerroa:         }
Kode lerroa:         console.debug('Initialized RolesManager')
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   currentUserIsProducer (callback) {
Kode lerroa:     window.abwa.annotationServerManager.client.searchAnnotations({
Kode lerroa:       url: window.abwa.groupSelector.currentGroup.links.html,
Kode lerroa:       order: 'desc',
Kode lerroa:       tags: Config.namespace + ':' + Config.tags.producer
Kode lerroa:     }, (err, annotations) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (annotations.length > 0) {
Kode lerroa:           const params = jsYaml.load(annotations[0].text)
Kode lerroa:           callback(null, params.producerId === window.abwa.groupSelector.user.userid) // Return if current user is producer
Kode lerroa:         } else {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     // TODO Destroy managers
Kode lerroa:     this.role = null
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: RolesManager.roles = {
Kode lerroa:   producer: 'teacher',
Kode lerroa:   consumer: 'student'
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default RolesManager
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class Sidebar {
Kode lerroa:   init (callback) {
Kode lerroa:     this.initSidebarStructure(() => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initSidebarStructure (callback) {
Kode lerroa:     const sidebarURL = chrome.extension.getURL('pages/sidebar/sidebar.html')
Kode lerroa:     $.get(sidebarURL, (html) => {
Kode lerroa:       this.waitUntilBodyLoads(() => {
Kode lerroa:         // Append sidebar to content
Kode lerroa:         $('body').append($.parseHTML(html))
Kode lerroa:         // Initialize sidebar labels
Kode lerroa:         this.initSidebarLabels()
Kode lerroa:         // Initialize sidebar toggle button
Kode lerroa:         this.initSidebarButton()
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   waitUntilBodyLoads (callback) {
Kode lerroa:     let counter = 0
Kode lerroa:     const checkBodyLoads = () => {
Kode lerroa:       if (_.isElement(document.body)) {
Kode lerroa:         callback()
Kode lerroa:       } else {
Kode lerroa:         if (counter === 1000) {
Kode lerroa:           console.error('The webpage is not loaded after 50 seconds, reload the webpage.')
Kode lerroa:         } else {
Kode lerroa:           counter++
Kode lerroa:           setTimeout(checkBodyLoads, 50)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     checkBodyLoads()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   initSidebarLabels () {}
Kode lerroa: 
Kode lerroa:   initSidebarButton () {
Kode lerroa:     const sidebarButton = document.querySelector('#abwaSidebarButton')
Kode lerroa:     sidebarButton.addEventListener('click', () => {
Kode lerroa:       this.toggleSidebar()
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   toggleSidebar () {
Kode lerroa:     const sidebarButton = document.querySelector('#abwaSidebarButton')
Kode lerroa:     sidebarButton.dataset.toggled = sidebarButton.dataset.toggled !== 'true'
Kode lerroa:     document.documentElement.dataset.sidebarShown = sidebarButton.dataset.toggled
Kode lerroa:     document.querySelector('#abwaSidebarContainer').dataset.shown = sidebarButton.dataset.toggled
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   openSidebar () {
Kode lerroa:     const sidebarButton = document.querySelector('#abwaSidebarButton')
Kode lerroa:     sidebarButton.dataset.toggled = 'true'
Kode lerroa:     document.documentElement.dataset.sidebarShown = sidebarButton.dataset.toggled
Kode lerroa:     document.querySelector('#abwaSidebarContainer').dataset.shown = sidebarButton.dataset.toggled
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   closeSidebar () {
Kode lerroa:     const sidebarButton = document.querySelector('#abwaSidebarButton')
Kode lerroa:     sidebarButton.dataset.toggled = 'false'
Kode lerroa:     document.documentElement.dataset.sidebarShown = sidebarButton.dataset.toggled
Kode lerroa:     document.querySelector('#abwaSidebarContainer').dataset.shown = sidebarButton.dataset.toggled
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   isOpened () {
Kode lerroa:     const sidebarButton = document.querySelector('#abwaSidebarButton')
Kode lerroa:     return sidebarButton.dataset.toggled
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     $('#abwaSidebarWrapper').remove()
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Sidebar
Kode lerroa: import axios from 'axios'
Kode lerroa: import _ from 'lodash'
Kode lerroa: // PVSCL:IFCOND(Canvas, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(AnnotatedPDF, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(GoogleSheetConsumer, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(LastAnnotation, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(TextSummary, LINE)
Kode lerroa: 
Kode lerroa: import Events from '../Events'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(AnnotationList, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(ImportAnnotations, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Export, LINE)
Kode lerroa: 
Kode lerroa: import $ from 'jquery'
Kode lerroa: 
Kode lerroa: class Toolset {
Kode lerroa:   constructor () {
Kode lerroa:     this.page = chrome.extension.getURL('pages/sidebar/toolset.html')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing toolset')
Kode lerroa:     axios.get(this.page).then((response) => {
Kode lerroa:       // Get sidebar container
Kode lerroa:       this.sidebarContainer = document.querySelector('#abwaSidebarContainer')
Kode lerroa:       // Insert toolset container
Kode lerroa:       // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:       this.toolsetContainer = this.sidebarContainer.querySelector('#toolset')
Kode lerroa:       this.toolsetHeader = this.toolsetContainer.querySelector('#toolsetHeader')
Kode lerroa:       this.toolsetBody = this.sidebarContainer.querySelector('#toolsetBody')
Kode lerroa:       const toolsetButtonTemplate = this.sidebarContainer.querySelector('#toolsetButtonTemplate')
Kode lerroa:       // PVSCL:IFCOND(AnnotatedPDF, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(Canvas, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(TextSummary, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(DeleteAll, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(LastAnnotation, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(GoogleSheetConsumer, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(MoodleReport, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(AnnotationList, LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(JSON OR ImportAnnotations, LINE)
Kode lerroa: 
Kode lerroa:       // Check if exist any element in the tools and show it
Kode lerroa:       if (!_.isEmpty(this.toolsetBody.innerHTML)) {
Kode lerroa:         this.show()
Kode lerroa:       }
Kode lerroa:       console.debug('Initialized toolset')
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(AnnotatedPDF, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Canvas, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(TextSummary, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(DeleteAll, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(LastAnnotation, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Show toolset in sidebar
Kode lerroa:    */
Kode lerroa:   show () {
Kode lerroa:     // Toolset aria-hidden is false
Kode lerroa:     this.toolsetContainer.setAttribute('aria-hidden', 'false')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Hide toolset in sidebar
Kode lerroa:    */
Kode lerroa:   hide () {
Kode lerroa:     // Toolset aria-hidden is true
Kode lerroa:     this.toolsetContainer.setAttribute('aria-hidden', 'true')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy () {
Kode lerroa:     if (_.isElement(this.toolsetContainer)) {
Kode lerroa:       this.toolsetContainer.remove()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ImportAnnotations or JSON, LINE)
Kode lerroa: 
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Toolset
Kode lerroa: /* eslint-disable */
Kode lerroa: import Config from '../Config'
Kode lerroa: // PVSCL:IFCOND(Assessing, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: export class Review {
Kode lerroa:   constructor(){
Kode lerroa:     this._annotations = []
Kode lerroa:   }
Kode lerroa:   insertAnnotation(annotation){
Kode lerroa:     this._annotations.push(annotation)
Kode lerroa:   }
Kode lerroa:   get annotations(){
Kode lerroa:     return this._annotations
Kode lerroa:   }
Kode lerroa:   groupByCriterionInsideLevel (level){
Kode lerroa:     let that = this
Kode lerroa:     let groups = []
Kode lerroa:     let levelAnnotations = this._annotations.filter((e) => {return e.level===level})
Kode lerroa:     for(let i in levelAnnotations){
Kode lerroa:       if(groups.find((e) => {return e.annotations[0].criterion===levelAnnotations[i].criterion})!=null) continue;
Kode lerroa:       groups.push(new AnnotationGroup(levelAnnotations.filter((e) => {return e.criterion===levelAnnotations[i].criterion}),that));
Kode lerroa:     }
Kode lerroa:     return groups;
Kode lerroa:   }
Kode lerroa:   get strengths(){
Kode lerroa:     return this.groupByCriterionInsideLevel("Strength")
Kode lerroa:   }
Kode lerroa:   get minorConcerns(){
Kode lerroa:     return this.groupByCriterionInsideLevel("Minor weakness")
Kode lerroa:   }
Kode lerroa:   get majorConcerns(){
Kode lerroa:     return this.groupByCriterionInsideLevel("Major weakness")
Kode lerroa:   }
Kode lerroa:   get typos(){
Kode lerroa:     return this.annotations.filter((e) => {return e.criterion==="Typos"})
Kode lerroa:   }
Kode lerroa:   get references(){
Kode lerroa:     //let references = [].concat.apply([],this.annotations.filter((e) => {return e.level!=null&&e.level!=''}).map((e) => {return e.suggestedLiterature!=null ? e.suggestedLiterature : []}))
Kode lerroa:     let references = [].concat.apply([],this.annotations.map((e) => {return e.suggestedLiterature!=null ? e.suggestedLiterature : []}))
Kode lerroa:     return references.filter((item,pos) => {return references.indexOf(item) === pos}).sort()
Kode lerroa:   }
Kode lerroa:   get unsortedAnnotations(){
Kode lerroa:     return this.annotations.filter((e) => {return e.criterion!=="Typos"&&(e.level==null||e.level=="")})
Kode lerroa:   }
Kode lerroa:   toString(){
Kode lerroa:     // Summary of the work
Kode lerroa:     let t = "<Summarize the work>\n\n";
Kode lerroa: 
Kode lerroa:     // Strengths
Kode lerroa:     if(this.strengths.length>0) t+= "STRENGTHS:\n\n";
Kode lerroa:     if(this.strengths.length==1){
Kode lerroa:       t += "The main strength of this work is that "+this.strengths[0].toString()+"\n\n";
Kode lerroa:     }
Kode lerroa:     else if(this.strengths.length>1){
Kode lerroa:       for(let s in this.strengths){
Kode lerroa:         t += "- "+this.strengths[s].toString()+"\n\n";
Kode lerroa:       }
Kode lerroa:       t += "\n\n";
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     // Major concerns
Kode lerroa:     if(this.majorConcerns.length>0){
Kode lerroa:       t += "MAJOR WEAKNESSES:\n\n"
Kode lerroa:       t += "In the following, I express ";
Kode lerroa:       if(this.majorConcerns.length>1) t += "some important concerns ";
Kode lerroa:       else t += "an important concern ";
Kode lerroa:       t += "I have about the manuscript"
Kode lerroa:       if(this.majorConcerns.length==1) t += ". "+this.majorConcerns[0].toString()+"\n\n";
Kode lerroa:       else{
Kode lerroa:         t += ":\n\n";
Kode lerroa:         for(let i=0;i<this.majorConcerns.length;i++){
Kode lerroa:           t += (i+1)+"- "+this.majorConcerns[i].toString()+"\n\n";
Kode lerroa:         }
Kode lerroa:         t += "\n\n";
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     // Minor concerns
Kode lerroa:     if(this.minorConcerns.length>0){
Kode lerroa:       t += "MINOR WEAKNESSES:\n\n"
Kode lerroa:       t += "There ";
Kode lerroa:       if(this.minorConcerns.length==1){
Kode lerroa:         t += "is ";
Kode lerroa:         if(this.majorConcerns.length>0) t+= "also ";
Kode lerroa:         t += "a minor point ";
Kode lerroa:       }
Kode lerroa:       else{
Kode lerroa:         t += "are ";
Kode lerroa:         if(this.majorConcerns.length>0) t+= "also ";
Kode lerroa:         t += "some minor points ";
Kode lerroa:       }
Kode lerroa:       t += "that should be clarified";
Kode lerroa:       if(this.minorConcerns.length==1) t += '. '+this.minorConcerns[0].toString()+"\n\n";
Kode lerroa:       else{
Kode lerroa:         t += ':\n\n'
Kode lerroa:         for(let i=0;i<this.minorConcerns.length;i++){
Kode lerroa:           t += (i+1)+"- "+this.minorConcerns[i].toString()+"\n\n";
Kode lerroa:         }
Kode lerroa:         t += "\n\n";
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     // Typos
Kode lerroa:     if(this.typos.length>0){
Kode lerroa:       t += "TYPOS:\n\n"
Kode lerroa:       for(let i=0;i<this.typos.length;i++){
Kode lerroa:         t += "\t- "
Kode lerroa:         if(this.typos[i].page!=null) t+= '(Page '+this.typos[i].page+'): '
Kode lerroa:         t += '"'+this.typos[i].highlightText+'"'
Kode lerroa:         if(this.typos[i].comment!=null) t+= '\n\t'+this.typos[i].comment
Kode lerroa:         t += '\n'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     // Other comments
Kode lerroa:     if(this.unsortedAnnotations.length>0){
Kode lerroa:       t += "COMMENTS:\n\n"
Kode lerroa:       let reviewReferences = this.references
Kode lerroa:       for(let i=0;i<this.unsortedAnnotations.length;i++){
Kode lerroa:         t += "\t- "
Kode lerroa:         if(this.unsortedAnnotations[i].page!=null) t+= '(Page '+this.unsortedAnnotations[i].page+') - '
Kode lerroa:         if (this.unsortedAnnotations[i].criterion !== null) {
Kode lerroa:           t += '[' + this.unsortedAnnotations[i].criterion + ']: '
Kode lerroa:         }
Kode lerroa:         t += '"'+this.unsortedAnnotations[i].highlightText+'"'
Kode lerroa:         if(this.unsortedAnnotations[i].comment!=null) t+= '\n\t'+this.unsortedAnnotations[i].comment
Kode lerroa:         let literature = this.unsortedAnnotations[i].suggestedLiterature!=null ? this.unsortedAnnotations[i].suggestedLiterature : []
Kode lerroa:         if(literature.length>0){
Kode lerroa:           t += '\n\tI would encourage the authors to look at the following papers: ';
Kode lerroa:           for(let j in literature){
Kode lerroa:             t += '['+(reviewReferences.indexOf(literature[j])+1)+']'
Kode lerroa:             if(j===literature.length-2&&literature.length>1) t += ' and '
Kode lerroa:             else if(literature.length>1&&j<literature.length-1) t += ', '
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         t += '\n\n'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     // References
Kode lerroa:     let references = this.references
Kode lerroa:     if(references.length>0){
Kode lerroa:       t += "REFERENCES:\n"
Kode lerroa:       for(let i=0;i<references.length;i++){
Kode lerroa:         t += "\n["+(i+1)+"] "+references[i]
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     t += "\n\n<Comments to editors>";
Kode lerroa: 
Kode lerroa:     return t;
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static parseAnnotations (annotations) {
Kode lerroa:     // TODO Substitute by (tagId -> name) of the annotation
Kode lerroa:     const criterionTag = Config.namespace + ':' + Config.tags.grouped.group + ':'
Kode lerroa:     const levelTag = Config.namespace + ':' + Config.tags.grouped.subgroup + ':'
Kode lerroa:     let r = new Review()
Kode lerroa: 
Kode lerroa:     for (let a in annotations) {
Kode lerroa:       if (annotations.hasOwnProperty(a)) {
Kode lerroa:         let criterion = null
Kode lerroa:         let annotation = annotations[a]
Kode lerroa:         annotation.tags.forEach((tag) => {
Kode lerroa:           if (tag.includes(levelTag)) {
Kode lerroa:             criterion = tag.replace(levelTag, '').trim()
Kode lerroa:           } else if (tag.includes(criterionTag)) {
Kode lerroa:             criterion = tag.replace(criterionTag, '').trim()
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:         // if (criterion == null || level == null) continue
Kode lerroa:         let textQuoteSelector = null
Kode lerroa:         let highlightText = ''
Kode lerroa:         let pageNumber = null
Kode lerroa: 
Kode lerroa:         for (let k in annotations[a].target) {
Kode lerroa:           if (annotations[a].target.hasOwnProperty(k)) {
Kode lerroa:             if (_.isArray(annotations[a].target[k].selector) && annotations[a].target[k].selector.find((e) => { return e.type === 'TextQuoteSelector' }) != null) {
Kode lerroa:               textQuoteSelector = annotations[a].target[k].selector.find((e) => { return e.type === 'TextQuoteSelector' })
Kode lerroa:               highlightText = textQuoteSelector.exact
Kode lerroa:             }
Kode lerroa:             if (_.isArray(annotations[a].target[k].selector) && annotations[a].target[k].selector.find((e) => { return e.type === 'FragmentSelector' }) != null) {
Kode lerroa:               pageNumber = annotations[a].target[k].selector.find((e) => { return e.type === 'FragmentSelector' }).page
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         let commentBody = annotations[a].getBodyForPurpose('commenting')
Kode lerroa:         let comment = commentBody? commentBody.value : ''
Kode lerroa:         // PVSCL:IFCOND(SuggestedLiterature, LINE)
Kode lerroa: 
Kode lerroa:         // PVSCL:IFCOND(Categorize, LINE)
Kode lerroa: 
Kode lerroa:         r.insertAnnotation(new Annotation({
Kode lerroa:           id: annotations[a].id,
Kode lerroa:           criterion/* PVSCL:IFCOND(Categorize) */,
Kode lerroa: ,
Kode lerroa:           highlightText,
Kode lerroa:           page: pageNumber,
Kode lerroa:           comment/* PVSCL:IFCOND(SuggestedLiterature) */,
Kode lerroa: 
Kode lerroa:         }))
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return r
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export class Annotation {
Kode lerroa:   constructor({id,criterion,level,highlightText,page,comment,suggestedLiterature}){
Kode lerroa:     this._criterion = criterion
Kode lerroa:     this._level = level
Kode lerroa:     this._highlightText = highlightText
Kode lerroa:     this._page = page
Kode lerroa:     this._comment = comment
Kode lerroa:     this._suggestedLiterature = suggestedLiterature
Kode lerroa:     this._id = id
Kode lerroa:   }
Kode lerroa:   get criterion(){
Kode lerroa:     return this._criterion
Kode lerroa:   }
Kode lerroa:   get level(){
Kode lerroa:     return this._level
Kode lerroa:   }
Kode lerroa:   get highlightText(){
Kode lerroa:     return this._highlightText
Kode lerroa:   }
Kode lerroa:   get page(){
Kode lerroa:     return this._page
Kode lerroa:   }
Kode lerroa:   get comment(){
Kode lerroa:     return this._comment
Kode lerroa:   }
Kode lerroa:   get suggestedLiterature(){
Kode lerroa:     return this._suggestedLiterature
Kode lerroa:   }
Kode lerroa:   get id(){
Kode lerroa:     return this._id
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export class AnnotationGroup {
Kode lerroa:   constructor(annotations,review){
Kode lerroa:     this._annotations = annotations
Kode lerroa:     this._review = review
Kode lerroa:   }
Kode lerroa:   get annotations(){
Kode lerroa:     return this._annotations
Kode lerroa:   }
Kode lerroa:   toString(){
Kode lerroa:     let t = ''
Kode lerroa:     /* let concernToString = (c) => {
Kode lerroa:       let str = ''
Kode lerroa:       switch(c){
Kode lerroa:         case "Relevance":
Kode lerroa:           str += "I was not convinced of the relevance of the problem.";
Kode lerroa:           break;
Kode lerroa:         case "Significance":
Kode lerroa:           str += "I think that the importance of the problem needs to be emphasized.";
Kode lerroa:           break;
Kode lerroa:         case "Depth of analysis":
Kode lerroa:           str += "The paper seems to overlook the why and focus too much on the what.";
Kode lerroa:           break;
Kode lerroa:         case "Adoption":
Kode lerroa:           str += "There is uncertainty about the adoption of the artefact by practitioners.";
Kode lerroa:           break;
Kode lerroa:         case "Generative potential":
Kode lerroa:           str += "The artefact lacks the potential to inspire further innovation in other new artefacts or new uses of existing artefacts.";
Kode lerroa:           break;
Kode lerroa:         case "Transferability":
Kode lerroa:           str += "There is no evidence about its generalisability to other domains.";
Kode lerroa:           break;
Kode lerroa:         case "Artefact":
Kode lerroa:           str += "The proposed solution is neither convincing nor even described in a suitable way."
Kode lerroa:           break;
Kode lerroa:         case "Novelty":
Kode lerroa:           str += "The authors need to show more clearly what is original in their solution."
Kode lerroa:           break;
Kode lerroa:         case "Evaluation":
Kode lerroa:           str += "I do have reservations about the evaluation process."
Kode lerroa:           break;
Kode lerroa:         case "Solution comparison":
Kode lerroa:           str += "The authors need to compare their artefact to other extant solutions."
Kode lerroa:           break;
Kode lerroa:         case "Behavior explanation":
Kode lerroa:           str += "There is no clear understanding of the behavior of the artefact."
Kode lerroa:           break;
Kode lerroa:         case "Research methods":
Kode lerroa:           str += "There are a number of issues with the methodology that need to be clarified/addressed."
Kode lerroa:           break;
Kode lerroa:         case "Justificatory knowledge":
Kode lerroa:           str += "I think the authors need to do a better job at grounding the design in existing research."
Kode lerroa:           break;
Kode lerroa:         case "Meta-requirements":
Kode lerroa:           str += "I would like to see more detail about the meta-requirements of the proposed solution."
Kode lerroa:           break;
Kode lerroa:         case "Meta-design":
Kode lerroa:           str += "A bit more detail about the meta-design would be helpful."
Kode lerroa:           break;
Kode lerroa:         case "Testable hypotheses":
Kode lerroa:           str += "The design theory lacks from testable hypotheses."
Kode lerroa:           break;
Kode lerroa:         case "Nascent Theory":
Kode lerroa:           // TODO
Kode lerroa:           break;
Kode lerroa:         case "Constructs":
Kode lerroa:           str += 'I would like to see more detail about constructs.'
Kode lerroa:           break;
Kode lerroa:         default:
Kode lerroa:           str += 'The authors need to do a better job as regards '+c.charAt(0).toLowerCase()+c.slice(1)+'.'
Kode lerroa:           break;
Kode lerroa:       }
Kode lerroa:       return str
Kode lerroa:     }
Kode lerroa:     switch(this._annotations[0].level){
Kode lerroa:       case "Strength":
Kode lerroa:         switch(this._annotations[0].criterion){
Kode lerroa:           case "Relevance":
Kode lerroa:             t += "the topic addressed is relevant and timely.";
Kode lerroa:             break;
Kode lerroa:           case "Significance":
Kode lerroa:             t += "it addresses an important topic.";
Kode lerroa:             break;
Kode lerroa:           case "Depth of analysis":
Kode lerroa:             t += "the paper is well-motivated and properly formulated.";
Kode lerroa:             break;
Kode lerroa:           case "Adoption":
Kode lerroa:             t += "the artefact has been adopted by real practitioners.";
Kode lerroa:             break;
Kode lerroa:           case "Generative potential":
Kode lerroa:             t += "it has the potential to inspire further innovation in other new artefacts or new uses of existing artefacts.";
Kode lerroa:             break;
Kode lerroa:           case "Transferability":
Kode lerroa:             t += "the solution can be generalised to other domains.";
Kode lerroa:             break;
Kode lerroa:           case "Artefact":
Kode lerroa:             t += "the proposed solution is clear and convincing."
Kode lerroa:             break;
Kode lerroa:           case "Novelty":
Kode lerroa:             t += "it finds a novel solution."
Kode lerroa:             break;
Kode lerroa:           case "Evaluation":
Kode lerroa:             t += "the evaluation was well conducted."
Kode lerroa:             break;
Kode lerroa:           case "Solution comparison":
Kode lerroa:             t += "the artefact has been compared with extant solutions."
Kode lerroa:             break;
Kode lerroa:           case "Behavior explanation":
Kode lerroa:             t += "there is clear understanding of the behavior of the artefact."
Kode lerroa:             break;
Kode lerroa:           case "Research methods":
Kode lerroa:             t += "research methods have been used rigurously."
Kode lerroa:             break;
Kode lerroa:           case "Justificatory knowledge":
Kode lerroa:             t += "the solution is rooted on existing research."
Kode lerroa:             break;
Kode lerroa:           case "Meta-requirements":
Kode lerroa:             t += "the meta-requirements have been specified."
Kode lerroa:             break;
Kode lerroa:           case "Meta-design":
Kode lerroa:             t += "the meta-design is present."
Kode lerroa:             break;
Kode lerroa:           case "Testable hypotheses":
Kode lerroa:             t += "testable hypotheses have been specified."
Kode lerroa:             break;
Kode lerroa:           case "Nascent Theory":
Kode lerroa:             // TODO
Kode lerroa:             break;
Kode lerroa:           case "Constructs":
Kode lerroa:             t += "constructs have been specified."
Kode lerroa:             break;
Kode lerroa:           default:
Kode lerroa:             t += this._annotations[0].criterion+' is/are ok.'
Kode lerroa:             break;
Kode lerroa:         }
Kode lerroa:         break
Kode lerroa:       case "Minor weakness":
Kode lerroa:         if(this._review.annotations.find((e) => {return e.criterion===this._annotations[0].criterion&&e.level==="Major concern"})!=null){
Kode lerroa:           t += "I have a more minor point "
Kode lerroa:           let connectors = ["with regard to","concerning","regarding","referring to"]
Kode lerroa:           t += connectors[Math.floor(Math.random()*connectors.length)]
Kode lerroa:           t += " the "
Kode lerroa:           switch(this._annotations[0].criterion){
Kode lerroa:             case "Relevance":
Kode lerroa:               t += "relevance of the problem.";
Kode lerroa:               break;
Kode lerroa:             case "Significance":
Kode lerroa:               t += "significance of the problem.";
Kode lerroa:               break;
Kode lerroa:             case "Depth of analysis":
Kode lerroa:               t += "depth of analysis of the problem.";
Kode lerroa:               break;
Kode lerroa:             case "Adoption":
Kode lerroa:               t += "adoption and use of the new artefact by practitioners.";
Kode lerroa:               break;
Kode lerroa:             case "Generative potential":
Kode lerroa:               t += "potential to inspire further innovation in other new artefacts or new uses of existing artefacts.";
Kode lerroa:               break;
Kode lerroa:             case "Transferability":
Kode lerroa:               t += "generalisability of the solution to other domains.";
Kode lerroa:               break;
Kode lerroa:             case "Artefact":
Kode lerroa:               t += "artefact."
Kode lerroa:               break;
Kode lerroa:             case "Novelty":
Kode lerroa:               t += "novelty of the artefact."
Kode lerroa:               break;
Kode lerroa:             case "Evaluation":
Kode lerroa:               t += "evaluation of the artefact."
Kode lerroa:               break;
Kode lerroa:             case "Solution comparison":
Kode lerroa:               t += "comparison of the artefact with other extant solutions."
Kode lerroa:               break;
Kode lerroa:             case "Behavior explanation":
Kode lerroa:               t += "behavior of the artefact."
Kode lerroa:               break;
Kode lerroa:             case "Research methods":
Kode lerroa:               t += "use of research methods."
Kode lerroa:               break;
Kode lerroa:             case "Justificatory knowledge":
Kode lerroa:               t += "grounding of the design in existing research."
Kode lerroa:               break;
Kode lerroa:             case "Meta-requirements":
Kode lerroa:               t += "meta-requirements."
Kode lerroa:               break;
Kode lerroa:             case "Meta-design":
Kode lerroa:               t += "meta-design."
Kode lerroa:               break;
Kode lerroa:             case "Testable hypotheses":
Kode lerroa:               t += "testeable hypotheses."
Kode lerroa:               break;
Kode lerroa:             case "Nascent Theory":
Kode lerroa:               // TODO
Kode lerroa:               break;
Kode lerroa:             case "Constructs":
Kode lerroa:               t += "constructs."
Kode lerroa:               break;
Kode lerroa:             default:
Kode lerroa:               t += this._annotations[0].criterion+'.'
Kode lerroa:               break;
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         else t += concernToString(this._annotations[0].criterion)
Kode lerroa:         break
Kode lerroa:       case "Major weakness":
Kode lerroa:         t += concernToString(this._annotations[0].criterion)
Kode lerroa:         break
Kode lerroa:       default:
Kode lerroa:         t += '[' + this._annotations[0].criterion + ']'
Kode lerroa:         break
Kode lerroa:     } */
Kode lerroa:     for(let i in this._annotations){
Kode lerroa:       if(this._annotations[i].highlightText===null) continue
Kode lerroa:       t += '\n\t* '
Kode lerroa:       if(this._annotations[i].page!==null) t += '(Page '+this._annotations[i].page+'): '
Kode lerroa:       t += '"'+this._annotations[i].highlightText+'". ';
Kode lerroa:       if(this._annotations[i].comment!=null) t += '\n\t'+this._annotations[i].comment;
Kode lerroa:     }
Kode lerroa:     let literature = [].concat.apply([],this._annotations.map((e) => {return e.suggestedLiterature}))
Kode lerroa:     let reviewReferences = this._review.references
Kode lerroa:     if(literature.length>0){
Kode lerroa:       t += '\n\tI would encourage the authors to look at the following papers: ';
Kode lerroa:       for(let j in literature){
Kode lerroa:         t += '['+(reviewReferences.indexOf(literature[j])+1)+']'
Kode lerroa:         if(j===literature.length-2&&literature.length>1) t += ' and '
Kode lerroa:         else if(literature.length>1&&j<literature.length-1) t += ', '
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return t
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: import axios from 'axios'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: let $
Kode lerroa: if (typeof window === 'undefined') {
Kode lerroa:   $ = require('jquery')(global.window)
Kode lerroa: } else {
Kode lerroa:   $ = require('jquery')
Kode lerroa: }
Kode lerroa: 
Kode lerroa: class GoogleSheetClient {
Kode lerroa:   constructor (token) {
Kode lerroa:     if (token) {
Kode lerroa:       this.token = token
Kode lerroa:     }
Kode lerroa:     this.baseURI = 'https://sheets.googleapis.com/v4/spreadsheets'
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(GoogleSheetConsumer, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   getSpreadsheet (spreadsheetId, callback) {
Kode lerroa:     $.ajax({
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       method: 'GET',
Kode lerroa:       url: this.baseURI + '/' + spreadsheetId,
Kode lerroa:       headers: {
Kode lerroa:         Authorization: 'Bearer ' + this.token,
Kode lerroa:         'Content-Type': 'application/json'
Kode lerroa:       },
Kode lerroa:       data: {
Kode lerroa:         includeGridData: true
Kode lerroa:       }
Kode lerroa:     }).done((result) => {
Kode lerroa:       callback(null, result)
Kode lerroa:     }).fail(() => {
Kode lerroa:       callback(new Error('Unable to retrieve gsheet'))
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getSheet (sheetData, callback) {
Kode lerroa:     this.getSpreadsheet(sheetData.spreadsheetId, (err, result) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         // Retrieve sheet by id if defined
Kode lerroa:         const sheet = _.find(result.sheets, (sheet) => { return sheet.properties.sheetId === parseInt(sheetData.sheetId) })
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, sheet)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getHyperlinkFromCell (cell) {
Kode lerroa:     // Try to get by hyperlink property
Kode lerroa:     if (cell.hyperlink) {
Kode lerroa:       return cell.hyperlink
Kode lerroa:     } else {
Kode lerroa:       if (!_.isEmpty(cell.userEnteredValue) && !_.isEmpty(cell.userEnteredValue.formulaValue)) {
Kode lerroa:         const value = cell.userEnteredValue.formulaValue
Kode lerroa:         const hyperlinkMatch = value.match(/=hyperlink\("([^"]+)"/i)
Kode lerroa:         if (!_.isEmpty(hyperlinkMatch) && hyperlinkMatch.length > 1) {
Kode lerroa:           return hyperlinkMatch[1].replace(/(^\w+:|^)\/\//, '')
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   batchUpdate (data, callback) {
Kode lerroa:     $.ajax({
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       method: 'POST',
Kode lerroa:       url: 'https://sheets.googleapis.com/v4/spreadsheets/' + data.spreadsheetId + ':batchUpdate',
Kode lerroa:       headers: {
Kode lerroa:         Authorization: 'Bearer ' + this.token,
Kode lerroa:         'Content-Type': 'application/json'
Kode lerroa:       },
Kode lerroa:       data: JSON.stringify({
Kode lerroa:         requests: data.requests
Kode lerroa:       })
Kode lerroa:     }).done(() => {
Kode lerroa:       // TODO Manage responses
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null)
Kode lerroa:       }
Kode lerroa:     }).fail((xhr, textStatus) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Error in batch update, error: ' + textStatus))
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateCell (data, callback) {
Kode lerroa:     const requests = []
Kode lerroa:     requests.push(this.createRequestUpdateCell(data))
Kode lerroa:     const batchUpdateData = {
Kode lerroa:       spreadsheetId: data.spreadsheetId,
Kode lerroa:       requests: requests
Kode lerroa:     }
Kode lerroa:     this.batchUpdate(batchUpdateData, (err) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    *
Kode lerroa:    * @param {{sheetId: number, row: number, column: number, backgroundColor: *, link: string, value: string, numberOfColumns: number, numberOfRows: number}} data
Kode lerroa:    * @returns {{repeatCell: {range: {sheetId: *|null, startRowIndex: number, endRowIndex: number, startColumnIndex, endColumnIndex: *}, cell: {userEnteredFormat: {backgroundColor}, userEnteredValue: {formulaValue: string}}, fields: string}}}
Kode lerroa:    */
Kode lerroa:   createRequestUpdateCell (data) {
Kode lerroa:     data.numberOfColumns = _.isNumber(data.numberOfColumns) ? data.numberOfColumns : 1
Kode lerroa:     data.numberOfRows = _.isNumber(data.numberOfRows) ? data.numberOfRows : 1
Kode lerroa:     let userEnteredValue = null
Kode lerroa:     if (_.isString(data.link)) {
Kode lerroa:       let formulaValue = '=HYPERLINK("' + data.link + '"; "' + data.value.replace(/"/g, '""') + '")'
Kode lerroa:       if (!_.isNaN(_.toNumber(data.value))) { // If is a number, change
Kode lerroa:         formulaValue = '=HYPERLINK("' + data.link + '"; ' + _.toNumber(data.value) + ')'
Kode lerroa:       }
Kode lerroa:       userEnteredValue = { formulaValue: formulaValue }
Kode lerroa:     } else {
Kode lerroa:       userEnteredValue = { stringValue: data.value }
Kode lerroa:     }
Kode lerroa:     return {
Kode lerroa:       repeatCell: {
Kode lerroa:         range: {
Kode lerroa:           sheetId: data.sheetId,
Kode lerroa:           startRowIndex: data.row,
Kode lerroa:           endRowIndex: data.row + data.numberOfRows,
Kode lerroa:           startColumnIndex: data.column,
Kode lerroa:           endColumnIndex: data.column + data.numberOfColumns
Kode lerroa:         },
Kode lerroa:         cell: {
Kode lerroa:           userEnteredFormat: {
Kode lerroa:             backgroundColor: data.backgroundColor
Kode lerroa:           },
Kode lerroa:           userEnteredValue: userEnteredValue
Kode lerroa:         },
Kode lerroa:         fields: 'userEnteredFormat(backgroundColor), userEnteredValue(formulaValue)'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createRequestUpdateCells (data) {
Kode lerroa:     return {
Kode lerroa:       updateCells: {
Kode lerroa:         rows: {
Kode lerroa:           values: data.cells
Kode lerroa:         },
Kode lerroa:         fields: '*',
Kode lerroa:         range: data.range
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Create a request for google sheet to copy a cell from source to destination.
Kode lerroa:    * @param {{sheetId: number, sourceRow: number, pasteType: string, sourceColumn: number, sourceNumberOfRows: number, sourceNumberOfColumns: number, destinationNumberOfRows: number, destinationNumberOfColumns: number, destinationRow: number, destinationColumn: number}} data
Kode lerroa:    * @returns {{copyPaste: {source: {sheetId: number|*|null, startRowIndex: *, endRowIndex: *, startColumnIndex: *, endColumnIndex: *}, destination: {sheetId: number|*|null, startRowIndex: *, endRowIndex: *, startColumnIndex: *, endColumnIndex: *}, pasteType: string, pasteOrientation: string}}}
Kode lerroa:    */
Kode lerroa:   createRequestCopyCell (data) {
Kode lerroa:     // TODO Check required params are defined
Kode lerroa:     data.sourceNumberOfColumns = _.isNumber(data.sourceNumberOfColumns) ? data.sourceNumberOfColumns : 1
Kode lerroa:     data.sourceNumberOfRows = _.isNumber(data.sourceNumberOfRows) ? data.sourceNumberOfRows : 1
Kode lerroa:     data.destinationNumberOfColumns = _.isNumber(data.destinationNumberOfColumns) ? data.destinationNumberOfColumns : 1
Kode lerroa:     data.destinationNumberOfRows = _.isNumber(data.destinationNumberOfRows) ? data.destinationNumberOfRows : 1
Kode lerroa:     data.pasteType = _.isString(data.pasteType) ? data.pasteType : 'PASTE_NORMAL'
Kode lerroa:     return {
Kode lerroa:       copyPaste: {
Kode lerroa:         source: {
Kode lerroa:           sheetId: data.sheetId,
Kode lerroa:           startRowIndex: data.sourceRow,
Kode lerroa:           endRowIndex: data.sourceRow + data.sourceNumberOfRows,
Kode lerroa:           startColumnIndex: data.sourceColumn,
Kode lerroa:           endColumnIndex: data.sourceColumn + data.sourceNumberOfColumns
Kode lerroa:         },
Kode lerroa:         destination: {
Kode lerroa:           sheetId: data.sheetId,
Kode lerroa:           startRowIndex: data.destinationRow,
Kode lerroa:           endRowIndex: data.destinationRow + data.destinationNumberOfRows,
Kode lerroa:           startColumnIndex: data.destinationColumn,
Kode lerroa:           endColumnIndex: data.destinationColumn + data.destinationNumberOfColumns
Kode lerroa:         },
Kode lerroa:         pasteType: data.pasteType,
Kode lerroa:         pasteOrientation: 'NORMAL'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    *
Kode lerroa:    * @param {{sheetId: *, length: number}} data
Kode lerroa:    * @returns {{appendDimension: {sheetId: *|null, dimension: string, length}}}
Kode lerroa:    */
Kode lerroa:   createRequestAppendEmptyColumn (data) {
Kode lerroa:     return {
Kode lerroa:       appendDimension: {
Kode lerroa:         sheetId: data.sheetId,
Kode lerroa:         dimension: 'COLUMNS',
Kode lerroa:         length: data.length
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   createRequestInsertEmptyColumn (data) {
Kode lerroa:     data.numberOfColumns = _.isNumber(data.numberOfColumns) ? data.numberOfColumns : 0
Kode lerroa:     return {
Kode lerroa:       insertDimension: {
Kode lerroa:         range: {
Kode lerroa:           sheetId: data.sheetId,
Kode lerroa:           dimension: 'COLUMNS',
Kode lerroa:           startIndex: data.startIndex,
Kode lerroa:           endIndex: data.startIndex + data.numberOfColumns
Kode lerroa:         },
Kode lerroa:         inheritFromBefore: false
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GoogleSheetClient
Kode lerroa: import _ from 'lodash'
Kode lerroa: import GoogleSheetClient from './GoogleSheetClient'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: 
Kode lerroa: const reloadIntervalInSeconds = 10 // Reload the google sheet client every 10 seconds
Kode lerroa: 
Kode lerroa: class GoogleSheetsClientManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.googleSheetClient = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     this.loadGSheetClient(() => {
Kode lerroa:       // Start reloading of client
Kode lerroa:       this.reloadInterval = setInterval(() => {
Kode lerroa:         this.reloadGSheetClient()
Kode lerroa:       }, reloadIntervalInSeconds * 1000)
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadGSheetClient (callback) {
Kode lerroa:     this.logInGoogleSheets((err, token) => {
Kode lerroa:       if (err) {
Kode lerroa:         this.googleSheetClient = null
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.googleSheetClient = new GoogleSheetClient(token)
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadGSheetClient () {
Kode lerroa:     this.logInSilentGoogleSheets((err, token) => {
Kode lerroa:       if (err) {
Kode lerroa:         this.googleSheetClient = null
Kode lerroa:       } else {
Kode lerroa:         this.googleSheetClient = new GoogleSheetClient(token)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   logInSilentGoogleSheets (callback) {
Kode lerroa:     // Promise if user has not given permissions in google sheets
Kode lerroa:     chrome.runtime.sendMessage({ scope: 'googleSheets', cmd: 'getTokenSilent' }, (result) => {
Kode lerroa:       if (result.token) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, result.token)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Login in google sheets and ask user if not logged in
Kode lerroa:    * @param callback - The callback for the response to log in google sheets
Kode lerroa:    */
Kode lerroa:   logInGoogleSheets (callback) {
Kode lerroa:     // Promise if user has not given permissions in google sheets
Kode lerroa:     chrome.runtime.sendMessage({ scope: 'googleSheets', cmd: 'getTokenSilent' }, (result) => {
Kode lerroa:       if (result.token) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, result.token)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.askUserToLogInGoogleSheets((err, token) => {
Kode lerroa:           if (err) {
Kode lerroa:             callback(err)
Kode lerroa:           } else {
Kode lerroa:             callback(null, token)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Ask user to log in google sheets
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   askUserToLogInGoogleSheets (callback) {
Kode lerroa:     Alerts.confirmAlert({
Kode lerroa:       title: 'Google sheets login required',
Kode lerroa:       text: chrome.i18n.getMessage('GoogleSheetLoginRequired'),
Kode lerroa:       callback: (err, result) => {
Kode lerroa:         if (err) {
Kode lerroa:           callback(new Error('Unable to create message to ask for login'))
Kode lerroa:         } else {
Kode lerroa:           if (result) {
Kode lerroa:             chrome.runtime.sendMessage({ scope: 'googleSheets', cmd: 'getToken' }, (result) => {
Kode lerroa:               if (result.error) {
Kode lerroa:                 if (_.isFunction(callback)) {
Kode lerroa:                   callback(result.error)
Kode lerroa:                 }
Kode lerroa:               } else {
Kode lerroa:                 if (_.isFunction(callback)) {
Kode lerroa:                   callback(null, result.token)
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:             })
Kode lerroa:           } else {
Kode lerroa:             callback(new Error('User don\'t want to log in google sheets'))
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GoogleSheetsClientManager
Kode lerroa: import _ from 'lodash'
Kode lerroa: import $ from 'jquery'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import ChromeStorage from '../utils/ChromeStorage'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(MoodleResourceBased,LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BuiltIn or ApplicationBased or NOT(Codebook), LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class GroupSelector {
Kode lerroa:   constructor () {
Kode lerroa:     this.selectedGroupNamespace = 'groupManipulation.currentGroup'
Kode lerroa:     this.groups = null
Kode lerroa:     this.currentGroup = null
Kode lerroa:     this.user = {}
Kode lerroa:     this.events = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     console.debug('Initializing group selector')
Kode lerroa:     // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(RenameCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ImportCodebook, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa:     this.checkIsLoggedIn((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         // Stop propagating the rest of the functions, because it is not logged in annotation server
Kode lerroa:         // Show that user need to log in remote annotation server to continue
Kode lerroa:         Alerts.errorAlert({
Kode lerroa:           title: 'Log in selected annotation server required',
Kode lerroa:           text: chrome.i18n.getMessage('annotationServerLoginRequired')
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         // Retrieve user profile (for further uses in other functionalities of the tool)
Kode lerroa:         this.retrieveUserProfile(() => {
Kode lerroa:           // Define current group
Kode lerroa:           this.defineCurrentGroup(() => {
Kode lerroa:             // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:             console.debug('Initialized group selector')
Kode lerroa:             if (_.isFunction(callback)) {
Kode lerroa:               callback(null)
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(RenameCodebook, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ImportCodebook, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ExportCodebook, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * This function defines the group of annotations that is selected by default when the application is opened
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   defineCurrentGroup (callback) {
Kode lerroa:     // PVSCL:IFCOND(ApplicationBased, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   defineGroupBasedOnInitAnnotation (callback) {
Kode lerroa:     const annotationGroupId = window.abwa.annotationBasedInitializer.initAnnotation.group
Kode lerroa:     // Load group of annotation
Kode lerroa:     this.retrieveUserProfile(() => {
Kode lerroa:       this.retrieveGroups((err, groups) => {
Kode lerroa:         if (err) {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(err)
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           // Set current group
Kode lerroa:           this.currentGroup = _.find(groups, (group) => { return group.id === annotationGroupId })
Kode lerroa:           // Save to chrome annotation server current group
Kode lerroa:           ChromeStorage.setData(this.selectedGroupNamespace, { data: JSON.stringify(this.currentGroup) }, ChromeStorage.local)
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback()
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   checkIsLoggedIn (callback) {
Kode lerroa:     const sidebarURL = chrome.extension.getURL('pages/sidebar/groupSelection.html')
Kode lerroa:     $.get(sidebarURL, (html) => {
Kode lerroa:       // Append sidebar to content
Kode lerroa:       $('#abwaSidebarContainer').append($.parseHTML(html))
Kode lerroa:       if (!window.abwa.annotationServerManager.isLoggedIn()) {
Kode lerroa:         // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(new Error('Is not logged in'))
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(BuiltIn OR NOT(Codebook),LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ExportCodebook,LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   retrieveGroups (callback) {
Kode lerroa:     window.abwa.annotationServerManager.client.getListOfGroups({}, (err, groups) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.groups = groups
Kode lerroa:         // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, groups)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   retrieveUserProfile (callback) {
Kode lerroa:     window.abwa.annotationServerManager.client.getUserProfile((err, profile) => {
Kode lerroa:       if (err) {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.user = profile
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null, profile.groups)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getCreatorData () {
Kode lerroa:     if (this.user) {
Kode lerroa:       // TODO Re-enable orcid mechanism to identify
Kode lerroa:       return window.abwa.annotationServerManager.annotationServerMetadata.userUrl + this.user.userid.replace('acct:', '').replace('@hypothes.is', '')
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default GroupSelector
Kode lerroa: import FileSaver from 'file-saver'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class AnnotationExporter {
Kode lerroa:   static exportCurrentDocumentAnnotations () {
Kode lerroa:     // Get annotations from tag manager and content annotator
Kode lerroa:     const codebook = window.abwa.codebookManager.codebookReader.codebook.toObjects(window.abwa.groupSelector.currentGroup.name)
Kode lerroa:     const annotations = window.abwa.annotationManagement.annotationReader.allAnnotations.map(a => a.serialize())
Kode lerroa:     // Remove not necessary information from annotations (group, permissions, user ?,...)
Kode lerroa:     const exportedDocumentAnnotations = _.map(annotations, (annotation) => {
Kode lerroa:       // Remove group id where annotation was created in
Kode lerroa:       annotation.group = ''
Kode lerroa:       // Remove permissions from the created annotation
Kode lerroa:       annotation.permissions = {}
Kode lerroa:       return annotation
Kode lerroa:     })
Kode lerroa:     // Create object to be exported
Kode lerroa:     const object = {
Kode lerroa:       codebook: codebook,
Kode lerroa:       documentAnnotations: exportedDocumentAnnotations
Kode lerroa:     }
Kode lerroa:     // Stringify JS object
Kode lerroa:     const stringifyObject = JSON.stringify(object, null, 2)
Kode lerroa:     // Download the file
Kode lerroa:     const blob = new window.Blob([stringifyObject], {
Kode lerroa:       type: 'text/plain;charset=utf-8'
Kode lerroa:     })
Kode lerroa:     FileSaver.saveAs(blob, 'AnnotationsForDocument-' + window.abwa.targetManager.documentTitle + '.json') // Add document title
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationExporter
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import FileUtils from '../utils/FileUtils'
Kode lerroa: import Codebook from '../codebook/model/Codebook'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class AnnotationImporter {
Kode lerroa:   static askUserToImportDocumentAnnotations (callback) {
Kode lerroa:     // Ask user to upload the file
Kode lerroa:     Alerts.inputTextAlert({
Kode lerroa:       title: 'Upload this document review annotations file',
Kode lerroa:       html: 'Here you can upload your json file with the annotations for this document.',
Kode lerroa:       input: 'file',
Kode lerroa:       callback: (err, file) => {
Kode lerroa:         if (err) {
Kode lerroa:           window.alert('An unexpected error happened when trying to load the alert.')
Kode lerroa:         } else {
Kode lerroa:           // Read json file
Kode lerroa:           FileUtils.readJSONFile(file, (err, jsonObject) => {
Kode lerroa:             if (err) {
Kode lerroa:               callback(new Error('Unable to read json file: ' + err.message))
Kode lerroa:             } else {
Kode lerroa:               callback(null, jsonObject)
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static importReviewAnnotations () {
Kode lerroa:     AnnotationImporter.askUserToImportDocumentAnnotations((err, jsonObject) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ text: 'Unable to parse json file. Error:<br/>' + err.message })
Kode lerroa:       } else {
Kode lerroa:         Alerts.inputTextAlert({
Kode lerroa:           alertType: Alerts.alertType.warning,
Kode lerroa:           title: 'Give a name to your imported annotations',
Kode lerroa:           text: 'When the configuration is imported a new highlighter is created. You can return to your other annotation codebooks using the sidebar.',
Kode lerroa:           inputPlaceholder: 'Type here the name of your review model...',
Kode lerroa:           inputValue: jsonObject.codebook.name,
Kode lerroa:           preConfirm: (groupName) => {
Kode lerroa:             if (_.isString(groupName)) {
Kode lerroa:               if (groupName.length <= 0) {
Kode lerroa:                 const swal = require('sweetalert2')
Kode lerroa:                 swal.showValidationMessage('Name cannot be empty.')
Kode lerroa:               } else if (groupName.length > 25) {
Kode lerroa:                 const swal = require('sweetalert2')
Kode lerroa:                 swal.showValidationMessage('The review model name cannot be higher than 25 characters.')
Kode lerroa:               } else {
Kode lerroa:                 return groupName
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           },
Kode lerroa:           callback: (err, reviewName) => {
Kode lerroa:             if (err) {
Kode lerroa:               window.alert('Unable to load alert. Unexpected error, please contact developer.')
Kode lerroa:             } else {
Kode lerroa:               window.abwa.annotationServerManager.client.createNewGroup({ name: reviewName }, (err, newGroup) => {
Kode lerroa:                 if (err) {
Kode lerroa:                   Alerts.errorAlert({ text: 'Unable to create a new annotation group. Error: ' + err.message })
Kode lerroa:                 } else {
Kode lerroa:                   // Create codebook
Kode lerroa:                   const tempCodebook = Codebook.fromObjects(jsonObject.codebook)
Kode lerroa:                   Codebook.setAnnotationServer(newGroup, (annotationServer) => {
Kode lerroa:                     tempCodebook.annotationServer = annotationServer
Kode lerroa:                     const annotations = tempCodebook.toAnnotations()
Kode lerroa:                     // Send create highlighter
Kode lerroa:                     window.abwa.annotationServerManager.client.createNewAnnotations(annotations, (err, codebookAnnotations) => {
Kode lerroa:                       if (err) {
Kode lerroa:                         Alerts.errorAlert({ text: 'Unable to create new group.' })
Kode lerroa:                       } else {
Kode lerroa:                         // Parse annotations and dispatch created codebook
Kode lerroa:                         Codebook.fromAnnotations(codebookAnnotations, (err, codebook) => {
Kode lerroa:                           if (err) {
Kode lerroa:                             Alerts.errorAlert({ text: 'Unable to create a codebook. Error: ' + err.message })
Kode lerroa:                           } else {
Kode lerroa:                             // Parse annotations codes to new code ids
Kode lerroa:                             jsonObject.documentAnnotations.forEach((annotation) => {
Kode lerroa:                               const classifyingBody = annotation.body.find(body => body.purpose === 'classifying')
Kode lerroa:                               if (classifyingBody) {
Kode lerroa:                                 const code = classifyingBody.value
Kode lerroa:                                 const codeName = code.name
Kode lerroa:                                 let theme
Kode lerroa:                                 // Get the theme which is annotation classified
Kode lerroa:                                 // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:                                 let codeOrTheme
Kode lerroa:                                 // PVSCL:IFCOND(Hierarchy, LINE)
Kode lerroa: 
Kode lerroa:                                 // Update annotation value
Kode lerroa:                                 if (codeOrTheme) {
Kode lerroa:                                   annotation.body[annotation.body.findIndex(body => body.purpose === 'classifying')].value = codeOrTheme.toObject()
Kode lerroa:                                 }
Kode lerroa:                               }
Kode lerroa:                               // Set group to annotations
Kode lerroa:                               annotation.group = newGroup.id
Kode lerroa:                               // Set permissions to annotations
Kode lerroa:                               annotation.permissions = { read: ['group:' + newGroup.id] }
Kode lerroa:                             })
Kode lerroa:                             // Create annotations for each element
Kode lerroa:                             window.abwa.annotationServerManager.client.createNewAnnotations(jsonObject.documentAnnotations, (err, annotations) => {
Kode lerroa:                               if (err) {
Kode lerroa:                                 Alerts.errorAlert({ text: 'Unable to import annotations. Error: ' + err.message })
Kode lerroa:                               } else {
Kode lerroa:                                 window.abwa.groupSelector.retrieveGroups(() => {
Kode lerroa:                                   window.abwa.groupSelector.setCurrentGroup(newGroup.id, () => {
Kode lerroa:                                     window.abwa.sidebar.openSidebar()
Kode lerroa:                                     // Dispatch annotations updated
Kode lerroa:                                     Alerts.closeAlert()
Kode lerroa:                                   })
Kode lerroa:                                 })
Kode lerroa:                               }
Kode lerroa:                             })
Kode lerroa:                           }
Kode lerroa:                         })
Kode lerroa:                       }
Kode lerroa:                     })
Kode lerroa:                   })
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationImporter
Kode lerroa: import axios from 'axios'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import jsonFormData from 'json-form-data'
Kode lerroa: 
Kode lerroa: class APISimulation {
Kode lerroa:   static getRubric (cmids, callback) {
Kode lerroa:     // TODO Verify that cmids is not an array
Kode lerroa:     // TODO Go to task main page
Kode lerroa:     const taskMainPageUrl = window.mag.moodleContentScript.moodleEndpoint + 'mod/assign/view.php?id=' + cmids
Kode lerroa:     axios.get(taskMainPageUrl)
Kode lerroa:       .then((response) => {
Kode lerroa:         const parser = new window.DOMParser()
Kode lerroa:         const docPreferences = parser.parseFromString(response.data, 'text/html')
Kode lerroa:         const rubricURLElement = docPreferences.querySelector('a[href*="grade/grading/manage.php?"]')
Kode lerroa:         if (rubricURLElement) {
Kode lerroa:           // TODO Go to rubric page
Kode lerroa:           const rubricURL = rubricURLElement.href
Kode lerroa:           axios.get(rubricURL)
Kode lerroa:             .then((response) => {
Kode lerroa:               const parser = new window.DOMParser()
Kode lerroa:               const docPreferences = parser.parseFromString(response.data, 'text/html')
Kode lerroa:               const rubricTable = docPreferences.querySelector('#rubric-criteria')
Kode lerroa:               // TODO Get each criterion
Kode lerroa:               const rubricCriteria = APISimulation.getRubricCriteriaFromRubricTable(rubricTable)
Kode lerroa:               const assignmentId = APISimulation.getAssignmentId(docPreferences)
Kode lerroa:               const assignmentName = APISimulation.getAssignmentName(docPreferences)
Kode lerroa:               // For each criterion
Kode lerroa:               const formattedRubric = APISimulation.constructGetRubricResponse({ rubricCriteria, cmid: cmids, assignmentId, assignmentName })
Kode lerroa:               callback(null, formattedRubric)
Kode lerroa:             })
Kode lerroa:         } else {
Kode lerroa:           // TODO Unable to retrieve rubric url
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     // TODO Get table of rubrics
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getAssignmentName () {
Kode lerroa:     // TODO Get assignment name
Kode lerroa:     return null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getRubricCriteriaFromRubricTable (rubricTable) {
Kode lerroa:     const criterionElements = rubricTable.querySelectorAll('.criterion')
Kode lerroa:     const criterias = []
Kode lerroa:     for (let i = 0; i < criterionElements.length; i++) {
Kode lerroa:       const criterionElement = criterionElements[i]
Kode lerroa:       const criteria = {}
Kode lerroa:       // Get id
Kode lerroa:       criteria.id = parseInt(_.last(criterionElement.id.split('-')))
Kode lerroa:       criteria.sortorder = i + 1
Kode lerroa:       criteria.description = criterionElement.querySelector('.description').innerText
Kode lerroa:       criteria.descriptionformat = 1 // The one by default is 1
Kode lerroa:       const levelElements = criterionElement.querySelectorAll('.level')
Kode lerroa:       const levels = []
Kode lerroa:       for (let j = 0; j < levelElements.length; j++) {
Kode lerroa:         const levelElement = levelElements[j]
Kode lerroa:         const level = {}
Kode lerroa:         // Get level id
Kode lerroa:         level.id = parseInt(_.last(levelElement.id.split('-')))
Kode lerroa:         // Get score
Kode lerroa:         level.score = parseFloat(levelElement.querySelector('.scorevalue').innerText)
Kode lerroa:         // Get descriptor
Kode lerroa:         level.definition = levelElement.querySelector('.definition').innerText
Kode lerroa:         // Get defintion format
Kode lerroa:         level.definitionformat = 1 // Default format of level definition
Kode lerroa:         // Add to levels
Kode lerroa:         levels.push(level)
Kode lerroa:       }
Kode lerroa:       criteria.levels = levels
Kode lerroa:       criterias.push(criteria)
Kode lerroa:     }
Kode lerroa:     return criterias
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getAssignmentId (document) {
Kode lerroa:     const deleteformElement = document.querySelector('a[href*="deleteform"]')
Kode lerroa:     if (deleteformElement) {
Kode lerroa:       const url = new URL(deleteformElement.href)
Kode lerroa:       return url.searchParams.get('deleteform')
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static addSubmissionComment (moodleEndpoint, data, callback) {
Kode lerroa:     // Retrieve session key
Kode lerroa:     APISimulation.getCurrentSessionKey(moodleEndpoint, (err, sessionKey) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         // Retrieve client_id for comment
Kode lerroa:         /* APISimulation.getClientIdForComment({
Kode lerroa:           moodleEndpoint, cmid: data.cmid, studentId: data.studentId, isTeacher: data.isTeacher
Kode lerroa:         }, (err, clientId) => {
Kode lerroa: 
Kode lerroa:         }) */
Kode lerroa:         const settings = {
Kode lerroa:           async: true,
Kode lerroa:           crossDomain: true,
Kode lerroa:           url: moodleEndpoint + '/comment/comment_ajax.php',
Kode lerroa:           method: 'POST',
Kode lerroa:           headers: {
Kode lerroa:             'Cache-Control': 'no-cache',
Kode lerroa:             'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
Kode lerroa:           },
Kode lerroa:           params: {
Kode lerroa:             wsfunction: 'mod_assign_save_grade',
Kode lerroa:             moodlewsrestformat: 'json'
Kode lerroa:           },
Kode lerroa:           data: {
Kode lerroa:             sesskey: sessionKey,
Kode lerroa:             action: 'add',
Kode lerroa:             client_id: '5c124b5dd5125', // TODO Check if it works in all moodle versions: It is a random client ID
Kode lerroa:             itemid: data.itemId,
Kode lerroa:             area: 'submission_comments',
Kode lerroa:             courseid: data.courseId,
Kode lerroa:             contextid: data.contextId,
Kode lerroa:             component: 'assignsubmission_comments',
Kode lerroa:             content: data.text
Kode lerroa:           },
Kode lerroa:           transformRequest: [(data) => {
Kode lerroa:             return jsonFormData(data)
Kode lerroa:           }]
Kode lerroa:         }
Kode lerroa:         axios(settings).then((response) => {
Kode lerroa:           callback(null, response.data)
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getCurrentSessionKey (moodleEndpoint, callback) {
Kode lerroa:     const settings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       url: moodleEndpoint + '/my/',
Kode lerroa:       method: 'GET',
Kode lerroa:       headers: {
Kode lerroa:         'Cache-Control': 'no-cache'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     axios(settings).then((response) => {
Kode lerroa:       const parser = new window.DOMParser()
Kode lerroa:       const docPreferences = parser.parseFromString(response.data, 'text/html')
Kode lerroa:       const sessionKeyInput = docPreferences.querySelector('input[name="sesskey"]')
Kode lerroa:       if (_.isElement(sessionKeyInput)) {
Kode lerroa:         callback(null, sessionKeyInput.value)
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('You are not logged in moodle, please login and try it again.'))
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getClientIdForComment ({ moodleEndpoint, isTeacher, cmid, studentId }, callback) {
Kode lerroa:     const settings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       method: 'GET',
Kode lerroa:       headers: {
Kode lerroa:         'Cache-Control': 'no-cache'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (isTeacher) {
Kode lerroa:       settings.url = moodleEndpoint + '/mod/assign/view.php?id=' + cmid + '&rownum=0&action=grader&userid=' + studentId
Kode lerroa:     } else {
Kode lerroa:       settings.url = moodleEndpoint + '/mod/assign/view.php?id=' + cmid
Kode lerroa:     }
Kode lerroa:     axios(settings).then((response) => {
Kode lerroa:       const parser = new window.DOMParser()
Kode lerroa:       const docPreferences = parser.parseFromString(response.data, 'text/html')
Kode lerroa:       const clientIdContainer = docPreferences.evaluate("//script[contains(., 'client_id')]", document, null, window.XPathResult.ANY_TYPE, null).iterateNext()
Kode lerroa:       if (clientIdContainer) {
Kode lerroa:         try {
Kode lerroa:           const clientId = clientIdContainer.innerText.split('client_id":"')[1].split('","commentarea')[0]
Kode lerroa:           callback(null, clientId)
Kode lerroa:         } catch (err) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static removeSubmissionComment () {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getSubmissionComments () {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static constructGetRubricResponse ({ cmid, rubricCriteria, assignmentId, assignmentName = '' }) {
Kode lerroa:     return {
Kode lerroa:       areas: [
Kode lerroa:         {
Kode lerroa:           cmid: cmid,
Kode lerroa:           activemethod: 'rubric',
Kode lerroa:           definitions: [
Kode lerroa:             {
Kode lerroa:               id: assignmentId,
Kode lerroa:               method: 'rubric',
Kode lerroa:               name: assignmentName,
Kode lerroa:               rubric: {
Kode lerroa:                 rubric_criteria: rubricCriteria
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           ]
Kode lerroa:         }
Kode lerroa:       ],
Kode lerroa:       warnings: []
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default APISimulation
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class BackToWorkspace {
Kode lerroa:   static createWorkspaceLink (callback) {
Kode lerroa:     this.linkToWorkspace = document.createElement('a')
Kode lerroa:     if (window.abwa.codebookManager.codebookReader.codebook) {
Kode lerroa:       const rubric = window.abwa.codebookManager.codebookReader.codebook
Kode lerroa:       const studentId = window.abwa.targetManager.fileMetadata.studentId
Kode lerroa:       this.linkToWorkspace.href = rubric.moodleEndpoint + 'mod/assign/view.php?id=' + rubric.cmid + '&rownum=0&action=grader&userid=' + studentId
Kode lerroa:       this.linkToWorkspace.target = '_blank'
Kode lerroa:     }
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback(this.linkToWorkspace)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default BackToWorkspace
Kode lerroa: import _ from 'lodash'
Kode lerroa: import axios from 'axios'
Kode lerroa: import jsonFormData from 'json-form-data'
Kode lerroa: 
Kode lerroa: class MoodleClient {
Kode lerroa:   constructor (endpoint, token) {
Kode lerroa:     this.endpoint = endpoint
Kode lerroa:     this.token = token
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateToken (token) {
Kode lerroa:     this.token = token
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateEndpoint (endpoint) {
Kode lerroa:     this.endpoint = endpoint
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getRubric (cmids, callback) {
Kode lerroa:     const settings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       url: this.endpoint + '/webservice/rest/server.php?',
Kode lerroa:       params: {
Kode lerroa:         wstoken: this.token,
Kode lerroa:         wsfunction: 'core_grading_get_definitions',
Kode lerroa:         areaname: 'submissions',
Kode lerroa:         'cmids[0]': cmids,
Kode lerroa:         moodlewsrestformat: 'json',
Kode lerroa:         activeonly: 0
Kode lerroa:       },
Kode lerroa:       method: 'GET',
Kode lerroa:       headers: {
Kode lerroa:         'Cache-Control': 'no-cache'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     axios(settings).then((response) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null, response.data)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getCmidInfo (cmid, callback) {
Kode lerroa:     const data = { cmid: cmid }
Kode lerroa:     const settings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       url: this.endpoint + 'webservice/rest/server.php?',
Kode lerroa:       method: 'POST',
Kode lerroa:       params: {
Kode lerroa:         wstoken: this.token,
Kode lerroa:         wsfunction: 'core_course_get_course_module',
Kode lerroa:         moodlewsrestformat: 'json'
Kode lerroa:       },
Kode lerroa:       headers: {
Kode lerroa:         'cache-control': 'no-cache',
Kode lerroa:         'Content-Type': 'multipart/form-data'
Kode lerroa:       },
Kode lerroa:       processData: false,
Kode lerroa:       contentType: false,
Kode lerroa:       mimeType: 'multipart/form-data',
Kode lerroa:       data: data,
Kode lerroa:       transformRequest: [(data) => {
Kode lerroa:         return jsonFormData(data)
Kode lerroa:       }]
Kode lerroa:     }
Kode lerroa:     axios(settings).then((response) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null, response.data)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateStudentGradeWithRubric (data, callback) {
Kode lerroa:     const settings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       url: this.endpoint + '/webservice/rest/server.php?',
Kode lerroa:       method: 'POST',
Kode lerroa:       headers: {
Kode lerroa:         'Cache-Control': 'no-cache',
Kode lerroa:         'Content-Type': 'multipart/form-data'
Kode lerroa:       },
Kode lerroa:       params: {
Kode lerroa:         wstoken: this.token,
Kode lerroa:         wsfunction: 'mod_assign_save_grade',
Kode lerroa:         moodlewsrestformat: 'json'
Kode lerroa:       },
Kode lerroa:       data: data,
Kode lerroa:       transformRequest: [(data) => {
Kode lerroa:         return jsonFormData(data)
Kode lerroa:       }]
Kode lerroa:     }
Kode lerroa:     axios(settings).then((response) => {
Kode lerroa:       axios(settings).then((response) => {
Kode lerroa:         callback(null, response.data)
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getStudents (courseId, callback) {
Kode lerroa:     const settings = {
Kode lerroa:       async: true,
Kode lerroa:       crossDomain: true,
Kode lerroa:       url: this.endpoint + '/webservice/rest/server.php?',
Kode lerroa:       params: {
Kode lerroa:         wstoken: this.token,
Kode lerroa:         wsfunction: 'core_enrol_get_enrolled_users',
Kode lerroa:         courseid: courseId,
Kode lerroa:         moodlewsrestformat: 'json'
Kode lerroa:       },
Kode lerroa:       method: 'GET',
Kode lerroa:       headers: {
Kode lerroa:         'Cache-Control': 'no-cache'
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     axios(settings).then((response) => {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(null, response.data)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleClient
Kode lerroa: import MoodleClient from './MoodleClient'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleFunctions from './MoodleFunctions'
Kode lerroa: import APISimulation from './APISimulation'
Kode lerroa: import Config from '../Config'
Kode lerroa: // const RolesManager = require('../contentScript/RolesManager')
Kode lerroa: 
Kode lerroa: class MoodleClientManager {
Kode lerroa:   constructor (moodleEndPoint) {
Kode lerroa:     if (_.isNull(moodleEndPoint)) {
Kode lerroa:       console.error('Moodle client manager requires a moodle endpoint')
Kode lerroa:     } else {
Kode lerroa:       this.moodleEndpoint = moodleEndPoint
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     // Retrieve token from moodle
Kode lerroa:     chrome.runtime.sendMessage({ scope: 'moodle', cmd: 'getTokenForEndpoint', data: { endpoint: this.moodleEndpoint } }, (result) => {
Kode lerroa:       if (result.err) {
Kode lerroa:         callback(new Error('Unable to retrieve valid token'))
Kode lerroa:       } else {
Kode lerroa:         this.tokens = result.tokens
Kode lerroa:         this.moodleClient = new MoodleClient(this.moodleEndpoint)
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getRubric (cmids, callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       // Check if API simulation is enabled
Kode lerroa:       chrome.runtime.sendMessage({ scope: 'moodle', cmd: 'isApiSimulationActivated' }, (isActivated) => {
Kode lerroa:         if (isActivated.activated) {
Kode lerroa:           APISimulation.getRubric(cmids, callback)
Kode lerroa:         } else {
Kode lerroa:           const token = this.getTokenFor(MoodleFunctions.getRubric.wsFunc)
Kode lerroa:           if (_.isString(token)) {
Kode lerroa:             this.moodleClient.updateToken(token)
Kode lerroa:             this.moodleClient.getRubric(cmids, callback)
Kode lerroa:           } else {
Kode lerroa:             callback(new Error('NoPermissions'))
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getCmidInfo (cmid, callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       const token = this.getTokenFor(MoodleFunctions.getCourseModuleInfo.wsFunc)
Kode lerroa:       if (_.isString(token)) {
Kode lerroa:         this.moodleClient.updateToken(token)
Kode lerroa:         this.moodleClient.getCmidInfo(cmid, callback)
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('NoPermissions'))
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   updateStudentGradeWithRubric (data, callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       const token = this.getTokenFor(MoodleFunctions.updateStudentsGradeWithRubric.wsFunc)
Kode lerroa:       if (_.isString(token)) {
Kode lerroa:         this.moodleClient.updateToken(token)
Kode lerroa:         this.moodleClient.updateStudentGradeWithRubric(data, (err, data) => {
Kode lerroa:           if (err) {
Kode lerroa:             callback(err)
Kode lerroa:           } else {
Kode lerroa:             if (data === null) {
Kode lerroa:               callback(null)
Kode lerroa:             } else if (data.exception === 'dml_missing_record_exception') {
Kode lerroa:               callback(new Error(chrome.i18n.getMessage('ErrorSavingMarksInMoodle')))
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('NoPermissions'))
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getStudents (courseId, callback) {
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       const token = this.getTokenFor(MoodleFunctions.getStudents.wsFunc)
Kode lerroa:       if (_.isString(token)) {
Kode lerroa:         this.moodleClient.updateToken(token)
Kode lerroa:         this.moodleClient.getStudents(courseId, callback)
Kode lerroa:       } else {
Kode lerroa:         callback(new Error('NoPermissions'))
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getTokenFor (wsFunction) {
Kode lerroa:     const tokenWrapper = _.find(this.tokens, (token) => {
Kode lerroa:       return _.find(token.tests, (test) => {
Kode lerroa:         return test.service === wsFunction && test.enabled
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:     if (tokenWrapper) {
Kode lerroa:       return tokenWrapper.token
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   addSubmissionComment ({ courseId, studentId, text, callback }) {
Kode lerroa:     APISimulation.addSubmissionComment(this.moodleEndpoint, {
Kode lerroa:       courseId,
Kode lerroa:       studentId,
Kode lerroa:       text,
Kode lerroa:       isTeacher: window.abwa.rolesManager.role === Config.tags.producer,
Kode lerroa:       callback,
Kode lerroa:       contextId: window.abwa.targetManager.fileMetadata.contextId,
Kode lerroa:       itemId: window.abwa.targetManager.fileMetadata.itemId
Kode lerroa:     }, callback)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   removeSubmissionComment ({ commentId, annotationId, callback }) {
Kode lerroa:     if (commentId) {
Kode lerroa: 
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getSubmissionComments () {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getStudentPreviousSubmissions ({ studentId, course = null }) {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleClientManager
Kode lerroa: import MoodleClient from './MoodleClient'
Kode lerroa: 
Kode lerroa: const moodleClient = new MoodleClient('', '')
Kode lerroa: 
Kode lerroa: const MoodleFunctions = {
Kode lerroa:   updateStudentsGradeWithRubric: {
Kode lerroa:     wsFunc: 'mod_assign_save_grade',
Kode lerroa:     testParams: {},
Kode lerroa:     clientFunc: moodleClient.updateStudentGradeWithRubric
Kode lerroa:   },
Kode lerroa:   getRubric: {
Kode lerroa:     wsFunc: 'core_grading_get_definitions',
Kode lerroa:     testParams: '0',
Kode lerroa:     clientFunc: moodleClient.getRubric
Kode lerroa:   },
Kode lerroa:   getStudents: {
Kode lerroa:     wsFunc: 'core_enrol_get_enrolled_users',
Kode lerroa:     testParams: '0',
Kode lerroa:     clientFunc: moodleClient.getStudents
Kode lerroa:   },
Kode lerroa:   getCourseModuleInfo: {
Kode lerroa:     wsFunc: 'core_course_get_course_module',
Kode lerroa:     testParams: {},
Kode lerroa:     clientFunc: moodleClient.getCmidInfo
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleFunctions
Kode lerroa: class MoodleUtils {
Kode lerroa:   static createURLForAnnotation ({ annotation, studentId, courseId, cmid }) {
Kode lerroa:     return annotation.target[0].source.url + '#studentId:' + studentId + '&mag:' + annotation.id + '&courseId:' + courseId + '&cmid:' + cmid
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default MoodleUtils
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import _ from 'lodash'
Kode lerroa: // PVSCL:IFCOND(BrowserStorage,LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(MoodleProvider or MoodleConsumer, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: class Options {
Kode lerroa:   init () {
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(BrowserStorage,LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Neo4J, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(MoodleConsumer or MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(BrowserStorage,LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Neo4J, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   showSelectedAnnotationServerConfiguration (selectedAnnotationServer) {
Kode lerroa:     // Hide all annotation server configurations
Kode lerroa:     const annotationServerConfigurationCards = document.querySelectorAll('.annotationServerConfiguration')
Kode lerroa:     annotationServerConfigurationCards.forEach((annotationServerConfigurationCard) => {
Kode lerroa:       annotationServerConfigurationCard.setAttribute('aria-hidden', 'true')
Kode lerroa:     })
Kode lerroa:     // Show corresponding selected annotationServer configuration card
Kode lerroa:     const selectedAnnotationServerConfigurationCard = document.querySelector('#' + selectedAnnotationServer + 'ConfigurationCard')
Kode lerroa:     if (_.isElement(selectedAnnotationServerConfigurationCard)) {
Kode lerroa:       selectedAnnotationServerConfigurationCard.setAttribute('aria-hidden', 'false')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(MoodleProvider or MoodleConsumer, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Options
Kode lerroa: class Popup {
Kode lerroa:   constructor () {
Kode lerroa:     this.activated = false
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   deactivate () {
Kode lerroa:     this.activated = false
Kode lerroa:     chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
Kode lerroa:       chrome.tabs.sendMessage(tabs[0].id, { action: 'destroyContentScript' }, () => {
Kode lerroa:         // eslint-disable-next-line quotes
Kode lerroa:         chrome.pageAction.setIcon({ tabId: tabs[0].id, path: "images/PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))/icon-38-bw.png" })
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   activate () {
Kode lerroa:     this.activated = true
Kode lerroa:     chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
Kode lerroa:       chrome.tabs.sendMessage(tabs[0].id, { action: 'initContentScript' }, () => {
Kode lerroa:         // eslint-disable-next-line quotes
Kode lerroa:         chrome.pageAction.setIcon({ tabId: tabs[0].id, path: "images/PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))/icon-38.png" })
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Popup
Kode lerroa: export default {
Kode lerroa:   name: 'html',
Kode lerroa:   selectors: ['FragmentSelector', 'RangeSelector', 'TextPositionSelector', 'TextQuoteSelector']
Kode lerroa: }
Kode lerroa: export default {
Kode lerroa:   name: 'pdf',
Kode lerroa:   selectors: ['FragmentSelector', 'TextPositionSelector', 'TextQuoteSelector']
Kode lerroa: }
Kode lerroa: export default {
Kode lerroa:   name: 'txt',
Kode lerroa:   selectors: ['TextPositionSelector', 'TextQuoteSelector']
Kode lerroa: }
Kode lerroa: import _ from 'lodash'
Kode lerroa: import Events from '../Events'
Kode lerroa: // PVSCL:IFCOND(PDF, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(TXT, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(HTML, LINE)
Kode lerroa: 
Kode lerroa: import URLUtils from '../utils/URLUtils'
Kode lerroa: import LanguageUtils from '../utils/LanguageUtils'
Kode lerroa: import Alerts from '../utils/Alerts'
Kode lerroa: import RandomUtils from '../utils/RandomUtils'
Kode lerroa: // PVSCL:IFCOND(URN, LINE)
Kode lerroa: 
Kode lerroa: import axios from 'axios'
Kode lerroa: const URL_CHANGE_INTERVAL_IN_SECONDS = 1
Kode lerroa: 
Kode lerroa: class TargetManager {
Kode lerroa:   constructor () {
Kode lerroa:     this.url = null
Kode lerroa:     this.urlChangeInterval = null
Kode lerroa:     this.urlParam = null
Kode lerroa:     this.documentId = null
Kode lerroa:     this.documentTitle = ''
Kode lerroa:     // PVSCL:IFCOND(HTML, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(URN, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init (callback) {
Kode lerroa:     if (document.querySelector('embed[type="application/pdf"]')) {
Kode lerroa:       window.location = chrome.extension.getURL('content/pdfjs/web/viewer.html') + '?file=' + encodeURIComponent(window.location.href)
Kode lerroa:     } else if (this.isPlainTextFile()) {
Kode lerroa:       window.location = chrome.extension.getURL('content/plainTextFileViewer/index.html') + '?file=' + encodeURIComponent(window.location.href)
Kode lerroa:     } else {
Kode lerroa:       this.reloadTargetInformation(() => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   reloadTargetInformation (callback) {
Kode lerroa:     // PVSCL:IFCOND(DOI, LINE)
Kode lerroa: 
Kode lerroa:     this.tryToLoadPublicationPDF()
Kode lerroa:     // PVSCL:IFCOND(Dropbox, LINE)
Kode lerroa: 
Kode lerroa:     this.loadDocumentFormat().catch((err) => {
Kode lerroa:       Alerts.errorAlert({ title: 'Not supported document format', text: err.message })
Kode lerroa:     }).then(() => {
Kode lerroa:       this.tryToLoadTitle()
Kode lerroa:       this.tryToLoadURL()
Kode lerroa:       this.tryToLoadURN()
Kode lerroa:       this.tryToLoadTargetId()
Kode lerroa:       if (this.url.startsWith('file:///')) {
Kode lerroa:         this.localFile = true
Kode lerroa:       } else if (this.documentFormat !== PDF) { // If document is not pdf, it can change its URL
Kode lerroa:         // Support in ajax websites web url change, web url can change dynamically, but local files never do
Kode lerroa:         this.initSupportWebURLChange()
Kode lerroa:       }
Kode lerroa:       let promise
Kode lerroa:       // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:       promise.then(() => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback()
Kode lerroa:         }
Kode lerroa:       }).catch((err) => {
Kode lerroa:         // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa:       })
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tryToLoadURN () {
Kode lerroa:     // If document is PDF
Kode lerroa:     if (this.documentFormat === PDF) {
Kode lerroa:       this.fingerprint = window.PDFViewerApplication.pdfDocument.pdfInfo.fingerprint
Kode lerroa:       this.urn = 'urn:x-pdf:' + this.fingerprint
Kode lerroa:     } else {
Kode lerroa:       // If document is plain text
Kode lerroa:       this.fingerprint = this.tryToLoadPlainTextFingerprint()
Kode lerroa:       if (this.fingerprint) {
Kode lerroa:         this.urn = 'urn:x-txt:' + this.fingerprint
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tryToLoadTargetId () {
Kode lerroa:     // Wait until updated all annotations is loaded
Kode lerroa:     this.targetIdEventListener = document.addEventListener(Events.updatedAllAnnotations, () => {
Kode lerroa:       if (window.abwa.annotationManagement.annotationReader.allAnnotations.length > 0) {
Kode lerroa:         this.documentId = window.abwa.annotationManagement.annotationReader.allAnnotations[0].target[0].source.id
Kode lerroa:       } else {
Kode lerroa:         this.documentId = RandomUtils.randomString()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tryToLoadURL () {
Kode lerroa:     if (this.urlParam) {
Kode lerroa:       this.url = this.urlParam
Kode lerroa:     } else {
Kode lerroa:       this.url = this.getDocumentURL()
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getDocumentURL () {
Kode lerroa:     if (this.documentFormat === PDF) {
Kode lerroa:       return window.PDFViewerApplication.url
Kode lerroa:     } else {
Kode lerroa:       return URLUtils.retrieveMainUrl(window.location.href) // TODO Check this, i think this url is not valid
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Resolves which format
Kode lerroa:    * @returns {Promise<unknown>}
Kode lerroa:    */
Kode lerroa:   loadDocumentFormat () {
Kode lerroa:     return new Promise((resolve, reject) => {
Kode lerroa:       if (window.location.pathname === '/content/pdfjs/web/viewer.html') {
Kode lerroa:         this.documentFormat = PDF
Kode lerroa:         this.waitUntilPDFViewerLoad(() => {
Kode lerroa:           resolve()
Kode lerroa:         })
Kode lerroa:         return true
Kode lerroa:       } /* PVSCL:IFCOND(TXT) */else if (document.body && document.body.children.length === 1 && document.body.children[0].nodeName === 'PRE') { // TODO Check if document is loaded in content/plainTextFileViewer
Kode lerroa: else {
Kode lerroa:         // PVSCL:IFCOND(HTML, LINE)
Kode lerroa: 
Kode lerroa:         if (_.isEmpty(this.documentFormat)) {
Kode lerroa:           reject(new Error('Unable to identify document format. Probably, this document format is not supported by the tool.'))
Kode lerroa:         } else {
Kode lerroa:           resolve()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   destroy (callback) {
Kode lerroa:     // PVSCL:IFCOND(PDF, LINE)
Kode lerroa: 
Kode lerroa:     if (_.isFunction(callback)) {
Kode lerroa:       callback()
Kode lerroa:     }
Kode lerroa:     clearInterval(this.urlChangeInterval)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   waitUntilPDFViewerLoad (callback) {
Kode lerroa:     const interval = setInterval(() => {
Kode lerroa:       if (_.isObject(window.PDFViewerApplication.pdfDocument)) {
Kode lerroa:         clearInterval(interval)
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(window.PDFViewerApplication)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }, 500)
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(DOI, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   tryToLoadURLParam () {
Kode lerroa:     const decodedUri = decodeURIComponent(window.location.href)
Kode lerroa:     console.log(decodedUri)
Kode lerroa:     const params = URLUtils.extractHashParamsFromUrl(decodedUri, '::')
Kode lerroa:     console.log(params)
Kode lerroa:     if (!_.isEmpty(params) && !_.isEmpty(params.url)) {
Kode lerroa:       console.debug(params.url)
Kode lerroa:       this.urlParam = params.url
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tryToLoadPublicationPDF () {
Kode lerroa:     try {
Kode lerroa:       this.citationPdf = document.querySelector('meta[name="citation_pdf_url"]').content
Kode lerroa:     } catch (e) {
Kode lerroa:       console.debug('citation pdf url not found')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getDocumentRootElement () {
Kode lerroa:     /* PVSCL:IFCOND(PDF) */if (this.documentFormat === PDF) {
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getDocumentURIToSearchInAnnotationServer () {
Kode lerroa:     if (this.documentFormat === PDF) {
Kode lerroa:       return this.urn
Kode lerroa:     } else {
Kode lerroa:       return this.url
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getDocumentURIToSaveInAnnotationServer () {
Kode lerroa:     if (this.doi) {
Kode lerroa:       return 'https://doi.org/' + this.doi
Kode lerroa:     } else if (this.url) {
Kode lerroa:       return this.url
Kode lerroa:     } else if (this.urn) {
Kode lerroa:       return this.urn
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Unable to retrieve any IRI for this document.')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Adds an observer which checks if the URL changes
Kode lerroa:    */
Kode lerroa:   initSupportWebURLChange () {
Kode lerroa:     if (_.isEmpty(this.urlChangeInterval)) {
Kode lerroa:       this.urlChangeInterval = setInterval(() => {
Kode lerroa:         const newUrl = this.getDocumentURL()
Kode lerroa:         if (newUrl !== this.url) {
Kode lerroa:           console.debug('Document URL updated from %s to %s', this.url, newUrl)
Kode lerroa:           this.url = newUrl
Kode lerroa:           // Reload target information
Kode lerroa:           this.reloadTargetInformation(() => {
Kode lerroa:             // Dispatch event
Kode lerroa:             LanguageUtils.dispatchCustomEvent(Events.updatedDocumentURL, { url: this.url })
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }, URL_CHANGE_INTERVAL_IN_SECONDS * 1000)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa:   // PVSCL:IFCOND(URN, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa:   getDocumentURIs () {
Kode lerroa:     const uris = {}
Kode lerroa:     if (this.doi) {
Kode lerroa:       uris.doi = 'https://doi.org/' + this.doi
Kode lerroa:     }
Kode lerroa:     if (this.url) {
Kode lerroa:       uris.url = this.url
Kode lerroa:     }
Kode lerroa:     if (this.urn) {
Kode lerroa:       uris.urn = this.urn
Kode lerroa:     }
Kode lerroa:     if (this.citationPdf) {
Kode lerroa:       uris.citationPdf = this.citationPdf
Kode lerroa:     }
Kode lerroa:     return uris
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getDocumentLink () {
Kode lerroa:     const uris = this.getDocumentURIs()
Kode lerroa:     return _.values(uris, (uri) => {
Kode lerroa:       return { href: uri }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getDocumentFingerprint () {
Kode lerroa:     if (this.fingerprint) {
Kode lerroa:       return this.fingerprint
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   isPlainTextFile () {
Kode lerroa:     const extension = window.location.href.split('.').pop().split(/#|\?/g)[0]
Kode lerroa:     return 'xml,xsl,xslt,xquery,xsql,'.split(',').includes(extension)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   tryToLoadTitle () {
Kode lerroa:     // Try to load by doi
Kode lerroa:     const promise = new Promise((resolve, reject) => {
Kode lerroa:       if (this.doi) {
Kode lerroa:         const settings = {
Kode lerroa:           async: true,
Kode lerroa:           crossDomain: true,
Kode lerroa:           url: 'https://doi.org/' + this.doi,
Kode lerroa:           method: 'GET',
Kode lerroa:           headers: {
Kode lerroa:             Accept: 'application/json',
Kode lerroa:             'Content-Type': 'application/json',
Kode lerroa:             'Cache-Control': 'no-cache'
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:         // Call using axios
Kode lerroa:         axios(settings).then((response) => {
Kode lerroa:           if (response.data && response.data.title) {
Kode lerroa:             this.documentTitle = response.data.title
Kode lerroa:           }
Kode lerroa:           resolve()
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         resolve()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     promise.then(() => {
Kode lerroa:       // Try to load title from page metadata
Kode lerroa:       if (_.isEmpty(this.documentTitle)) {
Kode lerroa:         try {
Kode lerroa:           const documentTitleElement = document.querySelector('meta[name="citation_title"]')
Kode lerroa:           if (!_.isNull(documentTitleElement)) {
Kode lerroa:             this.documentTitle = documentTitleElement.content
Kode lerroa:           }
Kode lerroa:           if (!this.documentTitle) {
Kode lerroa:             const documentTitleElement = document.querySelector('meta[property="og:title"]')
Kode lerroa:             if (!_.isNull(documentTitleElement)) {
Kode lerroa:               this.documentTitle = documentTitleElement.content
Kode lerroa:             }
Kode lerroa:             if (!this.documentTitle) {
Kode lerroa:               const promise = new Promise((resolve, reject) => {
Kode lerroa:                 // Try to load title from pdf metadata
Kode lerroa:                 if (this.documentFormat === PDF) {
Kode lerroa:                   this.waitUntilPDFViewerLoad(() => {
Kode lerroa:                     if (window.PDFViewerApplication.documentInfo.Title) {
Kode lerroa:                       this.documentTitle = window.PDFViewerApplication.documentInfo.Title
Kode lerroa:                     }
Kode lerroa:                     resolve()
Kode lerroa:                   })
Kode lerroa:                 } else {
Kode lerroa:                   resolve()
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:               promise.then(() => {
Kode lerroa:                 // Try to load title from document title
Kode lerroa:                 if (!this.documentTitle) {
Kode lerroa:                   this.documentTitle = document.title || 'Unknown document'
Kode lerroa:                 }
Kode lerroa:               })
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         } catch (e) {
Kode lerroa:           console.debug('Title not found for this document')
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Returns id for target source
Kode lerroa:    * @returns String
Kode lerroa:    */
Kode lerroa:   getDocumentId () {
Kode lerroa:     return this.documentId || RandomUtils.randomString()
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default TargetManager
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: let swal = null
Kode lerroa: if (document && document.head) {
Kode lerroa:   swal = require('sweetalert2').default
Kode lerroa: }
Kode lerroa: 
Kode lerroa: class Alerts {
Kode lerroa:   static confirmAlert ({ alertType = Alerts.alertType.info, title = '', text = '', confirmButtonText = 'OK', cancelButtonText = 'Cancel', reverseButtons, allowOutsideClick = true, allowEscapeKey = true, callback, cancelCallback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         title: title,
Kode lerroa:         html: text,
Kode lerroa:         type: alertType,
Kode lerroa:         confirmButtonText,
Kode lerroa:         cancelButtonText,
Kode lerroa:         reverseButtons,
Kode lerroa:         allowOutsideClick,
Kode lerroa:         allowEscapeKey,
Kode lerroa:         showCancelButton: true
Kode lerroa:       }).then((result) => {
Kode lerroa:         if (result.value) {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null, result.value)
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           if (_.isFunction(cancelCallback)) {
Kode lerroa:             cancelCallback(null)
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static infoAlert ({ text = chrome.i18n.getMessage('expectedInfoMessageNotFound'), title = 'Info', callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         type: Alerts.alertType.info,
Kode lerroa:         title: title,
Kode lerroa:         html: text
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static updateableAlert ({ text = chrome.i18n.getMessage('expectedInfoMessageNotFound'), type = Alerts.alertType.info, title = 'Info', timerIntervalHandler = null, timerIntervalPeriodInSeconds = 0.1, allowOutsideClick = true, allowEscapeKey = true, callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       const fire = () => {
Kode lerroa:         let timerInterval
Kode lerroa:         swal.fire({
Kode lerroa:           type: Alerts.alertType.info,
Kode lerroa:           title: title,
Kode lerroa:           html: text,
Kode lerroa:           allowOutsideClick,
Kode lerroa:           allowEscapeKey,
Kode lerroa:           showConfirmButton: true,
Kode lerroa:           onOpen: () => {
Kode lerroa:             if (_.isFunction(timerIntervalHandler)) {
Kode lerroa:               timerInterval = setInterval(() => {
Kode lerroa:                 timerIntervalHandler(swal, timerInterval)
Kode lerroa:               }, timerIntervalPeriodInSeconds * 1000)
Kode lerroa:             }
Kode lerroa:           },
Kode lerroa:           onClose: () => {
Kode lerroa:             clearInterval(timerInterval)
Kode lerroa:           }
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:       if (Alerts.isVisible()) {
Kode lerroa:         Alerts.closeAlert()
Kode lerroa:         setTimeout(fire, 1000)
Kode lerroa:       } else {
Kode lerroa:         fire()
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static errorAlert ({ text = chrome.i18n.getMessage('unexpectedError'), title = 'Oops...', callback, onClose }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         type: Alerts.alertType.error,
Kode lerroa:         title: title,
Kode lerroa:         html: text
Kode lerroa:       }).then(() => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static successAlert ({ text = 'Your process is correctly done', title = 'Great!', callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         type: Alerts.alertType.success,
Kode lerroa:         title: title,
Kode lerroa:         html: text
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static temporalAlert ({ text = 'It is done', title = 'Finished', type = Alerts.alertType.info, timer = 1500, position = 'top-end', callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         position: position,
Kode lerroa:         type: type,
Kode lerroa:         title: title, // TODO i18n
Kode lerroa:         html: text,
Kode lerroa:         showConfirmButton: false,
Kode lerroa:         timer: timer
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static loadingAlert ({ text = 'If it takes too much time, please reload the page and try again.', position = 'top-end', title = 'Working on something, please be patient', confirmButton = false, timerIntervalHandler, callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       let timerInterval
Kode lerroa:       swal({
Kode lerroa:         position: position,
Kode lerroa:         title: title,
Kode lerroa:         html: text,
Kode lerroa:         showConfirmButton: confirmButton,
Kode lerroa:         onBeforeOpen: () => {
Kode lerroa:           swal.showLoading()
Kode lerroa:           if (_.isFunction(timerIntervalHandler)) {
Kode lerroa:             timerInterval = setInterval(() => {
Kode lerroa:               if (swal.isVisible()) {
Kode lerroa:                 timerIntervalHandler(swal)
Kode lerroa:               } else {
Kode lerroa:                 clearInterval(timerInterval)
Kode lerroa:               }
Kode lerroa:             }, 100)
Kode lerroa:           }
Kode lerroa:         },
Kode lerroa:         onAfterClose: () => {
Kode lerroa:           clearInterval(timerInterval)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static inputTextAlert ({ title, input = 'text', type, inputPlaceholder = '', inputValue = '', preConfirm, cancelCallback, showCancelButton = true, html = '', allowOutsideClick = true, allowEscapeKey = true, callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         title: title,
Kode lerroa:         input: input,
Kode lerroa:         inputPlaceholder: inputPlaceholder,
Kode lerroa:         inputValue: inputValue,
Kode lerroa:         html: html,
Kode lerroa:         type: type,
Kode lerroa:         preConfirm: preConfirm,
Kode lerroa:         allowOutsideClick,
Kode lerroa:         allowEscapeKey,
Kode lerroa:         showCancelButton: showCancelButton
Kode lerroa:       }).then((result) => {
Kode lerroa:         if (result.value) {
Kode lerroa:           if (_.isFunction(callback)) {
Kode lerroa:             callback(null, result.value)
Kode lerroa:           }
Kode lerroa:         } else {
Kode lerroa:           if (_.isFunction(cancelCallback)) {
Kode lerroa:             cancelCallback()
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static multipleInputAlert ({ title = 'Input', html = '', preConfirm, position = Alerts.position.center, onBeforeOpen, showCancelButton = true, allowOutsideClick = true, allowEscapeKey = true, callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         title: title,
Kode lerroa:         html: html,
Kode lerroa:         focusConfirm: false,
Kode lerroa:         preConfirm: preConfirm,
Kode lerroa:         position: position,
Kode lerroa:         onBeforeOpen: onBeforeOpen,
Kode lerroa:         allowOutsideClick,
Kode lerroa:         allowEscapeKey,
Kode lerroa:         showCancelButton: showCancelButton
Kode lerroa:       }).then(() => {
Kode lerroa:         if (_.isFunction(callback)) {
Kode lerroa:           callback(null)
Kode lerroa:         }
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static tryToLoadSwal () {
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       try {
Kode lerroa:         swal = require('sweetalert2')
Kode lerroa:       } catch (e) {
Kode lerroa:         swal = null
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static warningAlert ({ text = 'Something that you need to worry about happened. ' + chrome.i18n.getMessage('ContactAdministrator'), title = 'Warning', callback }) {
Kode lerroa:     Alerts.tryToLoadSwal()
Kode lerroa:     if (_.isNull(swal)) {
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(new Error('Unable to load swal'))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       swal({
Kode lerroa:         type: Alerts.alertType.warning,
Kode lerroa:         title: title,
Kode lerroa:         html: text
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static closeAlert () {
Kode lerroa:     swal.close()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static isVisible () {
Kode lerroa:     return swal.isVisible()
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: Alerts.alertType = {
Kode lerroa:   warning: 'warning',
Kode lerroa:   error: 'error',
Kode lerroa:   success: 'success',
Kode lerroa:   info: 'info',
Kode lerroa:   question: 'question'
Kode lerroa: }
Kode lerroa: 
Kode lerroa: Alerts.position = {
Kode lerroa:   top: 'top',
Kode lerroa:   topStart: 'top-start',
Kode lerroa:   topEnd: 'top-end',
Kode lerroa:   center: 'center',
Kode lerroa:   centerStart: 'center-start',
Kode lerroa:   centerEnd: 'center-end',
Kode lerroa:   bottom: 'bottom',
Kode lerroa:   bottomStart: 'bottom-start',
Kode lerroa:   bottomEnd: 'bottom-end'
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Alerts
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class AnnotationUtils {
Kode lerroa:   static getTagFromAnnotation (annotation, prefix) {
Kode lerroa:     return _.find(annotation.tags, (tag) => {
Kode lerroa:       return tag.startsWith(prefix)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getTagSubstringFromAnnotation (annotation, prefix) {
Kode lerroa:     const tag = AnnotationUtils.getTagFromAnnotation(annotation, prefix)
Kode lerroa:     if (tag) {
Kode lerroa:       return tag.replace(prefix, '')
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static modifyTag (annotation, oldTag, newTag) {
Kode lerroa:     const index = _.findIndex(annotation.tags, (tag) => { return oldTag === tag })
Kode lerroa:     if (index > -1) {
Kode lerroa:       annotation.tags[index] = newTag
Kode lerroa:       return annotation
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static isReplyOf (formerAnnotation, replyAnnotation) {
Kode lerroa:     if (_.has(replyAnnotation, 'references')) {
Kode lerroa:       return !!_.find(replyAnnotation.references, (ref) => { return ref === formerAnnotation.id })
Kode lerroa:     } else {
Kode lerroa:       return false
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static areFromSameDocument (a, b) {
Kode lerroa:     // Check by target.source
Kode lerroa:     if (_.has(a, 'target[0].source') && _.has(b, 'target[0].source')) {
Kode lerroa:       // If source is object (w3c standard)
Kode lerroa:       if (_.isObject(a.target[0].source) && _.isObject(b.target[0].source)) {
Kode lerroa:         if (_.intersection(_.values(a.target[0].source), _.values(b.target[0].source)).length > 0) {
Kode lerroa:           return true
Kode lerroa:         }
Kode lerroa:       } else if (_.isString(a.target[0].source) && _.isString(b.target[0].source)) { // If source is string (hypothes.is use case)
Kode lerroa:         if (a.target[0].source === b.target[0].source) {
Kode lerroa:           return true
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // Check by uri
Kode lerroa:     return a.uri === b.uri
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Get from an annotation the most reliable URI to locate the annotated resource or target
Kode lerroa:    * @param annotation
Kode lerroa:    */
Kode lerroa:   static getReliableURItoLocateTarget (annotation) {
Kode lerroa:     if (_.has(annotation, 'target[0].source')) {
Kode lerroa:       const source = annotation.target[0].source
Kode lerroa:       // The most reliable source is DOI
Kode lerroa:       if (source.doi) {
Kode lerroa:         return source.doi
Kode lerroa:       }
Kode lerroa:       // The next more reliable URI is the URL, but only if it is not a local URL (protocol = file:) or is URN (protocol = urn:)
Kode lerroa:       if (source.url) {
Kode lerroa:         const protocol = new URL(source.url).protocol
Kode lerroa:         if (protocol !== 'file:' && protocol !== 'urn:') {
Kode lerroa:           return source.url
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     // For Hypothes.is it is not stored in source, is stored in documentMetadata
Kode lerroa:     if (_.has(annotation, 'documentMetadata')) {
Kode lerroa:       const documentMetadata = annotation.documentMetadata
Kode lerroa:       // The most reliable source is DOI
Kode lerroa:       if (_.has(documentMetadata, 'dc.identifier[0]')) {
Kode lerroa:         return documentMetadata.dc.identifier[0]
Kode lerroa:       }
Kode lerroa:       // The next more reliable URI is the URL, but only if it is not a local URL (protocol = file:)
Kode lerroa:       const reliableURL = annotation.documentMetadata.link.find(link => {
Kode lerroa:         const protocol = new URL(link.href).protocol
Kode lerroa:         return protocol !== 'urn:' && protocol !== 'file:'
Kode lerroa:       })
Kode lerroa:       if (reliableURL) {
Kode lerroa:         return reliableURL.href
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     if (new URL(annotation.uri).protocol !== 'file:') {
Kode lerroa:       return annotation.uri
Kode lerroa:     }
Kode lerroa:     return null
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default AnnotationUtils
Kode lerroa: 'use strict'
Kode lerroa: 
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class ChromeStorage {
Kode lerroa:   /**
Kode lerroa:    * Stores data on chrome storage (local or sync) given a namespace or ID
Kode lerroa:    * @param namespace A String which identify the space to store the data
Kode lerroa:    * @param data The data to save
Kode lerroa:    * @param storageArea The area to save the data (local or sync)
Kode lerroa:    * @param callback The function to execute after saving the data
Kode lerroa:    * @throws Error if it was unable to storage data
Kode lerroa:    */
Kode lerroa:   static setData (namespace, data, storageArea, callback) {
Kode lerroa:     // Create to be saved object
Kode lerroa:     const obj = {}
Kode lerroa:     obj[namespace] = data
Kode lerroa:     storageArea.set(obj, () => {
Kode lerroa:       // Execute callback and return error if happened
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(chrome.runtime.lastError)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Retrieve data from chrome storage given a namespace or ID
Kode lerroa:    * @param namespace A String which identify the space to store the data
Kode lerroa:    * @param storageArea The area to save the data (local or sync)
Kode lerroa:    * @param callback The function to execute after saving the data
Kode lerroa:    */
Kode lerroa:   static getData (namespace, storageArea, callback) {
Kode lerroa:     storageArea.get(namespace, function (items) {
Kode lerroa:       // Execute callback and return error if happened and the data required
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(chrome.runtime.lastError, items[namespace])
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: ChromeStorage.local = chrome.storage.local
Kode lerroa: ChromeStorage.sync = chrome.storage.sync
Kode lerroa: 
Kode lerroa: export default ChromeStorage
Kode lerroa: import ColorHash from 'color-hash'
Kode lerroa: import Color from 'color'
Kode lerroa: import UniqueColors from 'unique-colors'
Kode lerroa: 
Kode lerroa: class ColorUtils {
Kode lerroa:   static getDefaultColor () {
Kode lerroa:     return 'rgba(150,150,150,0.5)'
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getRandomColor () {
Kode lerroa:     const red = (Math.floor(Math.random() * 256))
Kode lerroa:     const green = (Math.floor(Math.random() * 256))
Kode lerroa:     const blue = (Math.floor(Math.random() * 256))
Kode lerroa:     let alpha = Math.random()
Kode lerroa:     if (alpha < 0.5) {
Kode lerroa:       alpha = 0.5
Kode lerroa:     }
Kode lerroa:     return 'rgba(' + red + ',' + green + ',' + blue + ', ' + alpha + ')'
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static colorFromString (str) {
Kode lerroa:     return new Color(str)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getHashColor (text, alpha) {
Kode lerroa:     const colorHash = new ColorHash({ hash: ColorUtils.customHash })
Kode lerroa:     const resultArray = colorHash.rgb(text)
Kode lerroa:     const alphaValue = alpha || 0.5
Kode lerroa:     return 'rgba(' + resultArray[0] + ',' + resultArray[1] + ',' + resultArray[2] + ', ' + alphaValue + ')'
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static setAlphaToColor (color, alpha) {
Kode lerroa:     return Color(color).alpha(alpha).rgb().string()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static customHash (str) {
Kode lerroa:     let hash = 0
Kode lerroa:     for (let i = 0; i < str.length; i++) {
Kode lerroa:       const char = str.charCodeAt(i)
Kode lerroa:       hash += char
Kode lerroa:     }
Kode lerroa:     return hash
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static hasAlpha (str) {
Kode lerroa:     const color = new Color(str)
Kode lerroa:     return color.valpha !== 1
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getDifferentColors (number) {
Kode lerroa:     return UniqueColors.unique_colors(number)
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default ColorUtils
Kode lerroa: import sha256 from 'js-sha256'
Kode lerroa: 
Kode lerroa: class CryptoUtils {
Kode lerroa:   static hash (string = '') {
Kode lerroa:     return sha256(string)
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default CryptoUtils
Kode lerroa: import $ from 'jquery'
Kode lerroa: 
Kode lerroa: class DOM {
Kode lerroa:   static searchElementByTarget (target) {
Kode lerroa:     // Check if current page corresponds to target source
Kode lerroa:     const currentLocation = location.href.replace(location.hash, '')
Kode lerroa:     if (target.source.includes(currentLocation)) {
Kode lerroa:       const selectors = target.selector
Kode lerroa:       // Use the best selector
Kode lerroa:       let element = null
Kode lerroa:       for (let i = 0; i < selectors.length && element === null; i++) {
Kode lerroa:         const selector = selectors[i]
Kode lerroa:         if (selector.type === 'FragmentSelector') {
Kode lerroa:           element = document.querySelector('#' + selector.value)
Kode lerroa:         }
Kode lerroa:         /* else if(selector.type==='RangeSelector'){
Kode lerroa:          console.log(selector.value);
Kode lerroa:          element = document.evaluate('//body'+selector.value, document, null, XPathResult.ANY_TYPE, null);
Kode lerroa:          } */
Kode lerroa:       }
Kode lerroa:       return element
Kode lerroa:     } else {
Kode lerroa:       throw new Error('Current website is not same as target source')
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    *
Kode lerroa:    * @param callSettings
Kode lerroa:    * @param querySelector
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   static scrapElement (callSettings, querySelector, callback) {
Kode lerroa:     $.ajax(callSettings).done((resultString) => {
Kode lerroa:       const tempWrapper = document.createElement('div')
Kode lerroa:       tempWrapper.innerHTML = resultString
Kode lerroa:       callback(null, tempWrapper.querySelectorAll(querySelector))
Kode lerroa:     }).fail((error) => {
Kode lerroa:       callback(error)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getNextNode (node, skipChildren, endNode) {
Kode lerroa:     // if there are child nodes and we didn't come from a child node
Kode lerroa:     if (endNode === node) {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:     if (node.firstChild && !skipChildren) {
Kode lerroa:       return node.firstChild
Kode lerroa:     }
Kode lerroa:     if (!node.parentNode) {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:     return node.nextSibling || DOM.getNextNode(node.parentNode, true, endNode)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getLeafNodesInRange (range) {
Kode lerroa:     let startNode = range.startContainer.childNodes[range.startOffset] || range.startContainer // it's a text node
Kode lerroa:     const endNode = range.endContainer.childNodes[range.endOffset] || range.endContainer
Kode lerroa: 
Kode lerroa:     if (startNode === endNode && startNode.childNodes.length === 0) {
Kode lerroa:       return [startNode]
Kode lerroa:     }
Kode lerroa:     const leafNodes = []
Kode lerroa:     do {
Kode lerroa:       // If it is a leaf node, push it
Kode lerroa:       if (startNode.childNodes.length === 0) {
Kode lerroa:         leafNodes.push(startNode)
Kode lerroa:       }
Kode lerroa:       startNode = DOM.getNextNode(startNode, false, endNode)
Kode lerroa:     } while (startNode)
Kode lerroa:     return leafNodes
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getNextSiblings (currentNode) {
Kode lerroa:     let iterator = currentNode
Kode lerroa:     const siblings = []
Kode lerroa:     while (iterator.nextSibling !== null) {
Kode lerroa:       siblings.push(iterator.nextSibling)
Kode lerroa:       iterator = iterator.nextSibling
Kode lerroa:     }
Kode lerroa:     return siblings
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getPreviousSiblings (currentNode) {
Kode lerroa:     let iterator = currentNode
Kode lerroa:     const siblings = []
Kode lerroa:     while (iterator.previousSibling !== null) {
Kode lerroa:       siblings.push(iterator.previousSibling)
Kode lerroa:       iterator = iterator.previousSibling
Kode lerroa:     }
Kode lerroa:     return siblings
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getParentNodeWithId (elem) {
Kode lerroa:     try {
Kode lerroa:       return $(elem).parents('[id]').get(0).id
Kode lerroa:     } catch (e) {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DOM
Kode lerroa: import DOM from './DOM'
Kode lerroa: import LanguageUtils from './LanguageUtils'
Kode lerroa: import $ from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: const domAnchorTextQuote = require('dom-anchor-text-quote')
Kode lerroa: const domAnchorTextPosition = require('dom-anchor-text-position')
Kode lerroa: const xpathRange = require('xpath-range')
Kode lerroa: 
Kode lerroa: class DOMTextUtils {
Kode lerroa:   static getFragmentSelector (range) {
Kode lerroa:     if (range.commonAncestorContainer) {
Kode lerroa:       const parentId = DOM.getParentNodeWithId(range.commonAncestorContainer)
Kode lerroa:       if (parentId) {
Kode lerroa:         return {
Kode lerroa:           conformsTo: 'https://tools.ietf.org/html/rfc3236',
Kode lerroa:           type: 'FragmentSelector',
Kode lerroa:           value: parentId
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getRangeSelector (range) {
Kode lerroa:     const rangeSelector = xpathRange.fromRange(range)
Kode lerroa:     LanguageUtils.renameObjectKey(rangeSelector, 'start', 'startContainer')
Kode lerroa:     LanguageUtils.renameObjectKey(rangeSelector, 'end', 'endContainer')
Kode lerroa:     rangeSelector.type = 'RangeSelector'
Kode lerroa:     return rangeSelector
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getTextPositionSelector (range) {
Kode lerroa:     const textPositionSelector = domAnchorTextPosition.fromRange(document.body, range)
Kode lerroa:     textPositionSelector.type = 'TextPositionSelector'
Kode lerroa:     return textPositionSelector
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getTextQuoteSelector (range) {
Kode lerroa:     const textQuoteSelector = domAnchorTextQuote.fromRange(document.body, range)
Kode lerroa:     textQuoteSelector.type = 'TextQuoteSelector'
Kode lerroa:     return textQuoteSelector
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Highlights the content which are pointed by the selectors in the DOM with corresponding class name, id and data
Kode lerroa:    * @param selectors
Kode lerroa:    * @param className
Kode lerroa:    * @param id
Kode lerroa:    * @param data
Kode lerroa:    * @param exhaustive Runs all the algorithms until annotation match is found. For intensive CPU webpages maybe you are interested in disable this option. When disable, the last and more CPU use algorithm tryRetrieveRangeTextSelector is not executed
Kode lerroa:    * @param format
Kode lerroa:    * @returns {NodeList}
Kode lerroa:    * @throws TypeError
Kode lerroa:    */
Kode lerroa:   static highlightContent ({ selectors, className, id, data, exhaustive = true, format }) {
Kode lerroa:     const range = this.retrieveRange({ selectors, exhaustive, format })
Kode lerroa:     if (range) {
Kode lerroa:       const nodes = DOM.getLeafNodesInRange(range)
Kode lerroa:       if (nodes.length > 0) {
Kode lerroa:         const startNode = nodes.shift()
Kode lerroa:         if (nodes.length > 0) { // start and end nodes are not the same
Kode lerroa:           const endNode = nodes.pop()
Kode lerroa:           const nodesBetween = nodes
Kode lerroa:           // Start node
Kode lerroa:           const startWrapper = document.createElement('mark')
Kode lerroa:           $(startWrapper).addClass(className)
Kode lerroa:           startWrapper.dataset.annotationId = id
Kode lerroa:           startWrapper.dataset.startNode = ''
Kode lerroa:           startWrapper.dataset.highlightClassName = className
Kode lerroa:           DOMTextUtils.wrapNodeContent(startNode, startWrapper, range.startOffset, startNode.nodeValue.length)
Kode lerroa:           // End node
Kode lerroa:           const endWrapper = document.createElement('mark')
Kode lerroa:           $(endWrapper).addClass(className)
Kode lerroa:           endWrapper.dataset.annotationId = id
Kode lerroa:           endWrapper.dataset.endNode = ''
Kode lerroa:           endWrapper.dataset.highlightClassName = className
Kode lerroa:           DOMTextUtils.wrapNodeContent(endNode, endWrapper, 0, range.endOffset)
Kode lerroa:           // Nodes between
Kode lerroa:           nodesBetween.forEach(nodeBetween => {
Kode lerroa:             const leafNodes = this.retrieveLeafNodes(nodeBetween)
Kode lerroa:             for (let i = 0; i < leafNodes.length; i++) {
Kode lerroa:               if (leafNodes[i].textContent.length > 0 && (leafNodes[i].parentNode !== endNode && leafNodes[i].parentNode !== startNode)) {
Kode lerroa:                 const wrapper = document.createElement('mark')
Kode lerroa:                 $(wrapper).addClass(className)
Kode lerroa:                 wrapper.dataset.annotationId = id
Kode lerroa:                 wrapper.dataset.endNode = ''
Kode lerroa:                 wrapper.dataset.highlightClassName = className
Kode lerroa:                 $(leafNodes[i]).wrap(wrapper)
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else {
Kode lerroa:           const wrapper = document.createElement('mark')
Kode lerroa:           $(wrapper).addClass(className)
Kode lerroa:           wrapper.dataset.highlightClassName = className
Kode lerroa:           wrapper.dataset.annotationId = id
Kode lerroa:           DOMTextUtils.wrapNodeContent(startNode, wrapper, range.startOffset, range.endOffset)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return document.querySelectorAll('[data-annotation-id=\'' + id + '\']')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Wraps node content from start to end position in the wrapper
Kode lerroa:    * @param node
Kode lerroa:    * @param wrapper
Kode lerroa:    * @param startPosition
Kode lerroa:    * @param endPosition
Kode lerroa:    */
Kode lerroa:   static wrapNodeContent (node, wrapper, startPosition, endPosition) {
Kode lerroa:     if (node.nodeType === 3) {
Kode lerroa:       wrapper.textContent = node.nodeValue.slice(startPosition, endPosition)
Kode lerroa:       const nodeArray = [
Kode lerroa:         document.createTextNode(node.nodeValue.slice(0, startPosition)), // Previous to wrapper text
Kode lerroa:         wrapper.outerHTML, // Highlighted text
Kode lerroa:         document.createTextNode(node.nodeValue.slice(endPosition, node.nodeValue.length)) // After to wrapper text
Kode lerroa:       ]
Kode lerroa:       node.parentNode.insertBefore(nodeArray[0], node)
Kode lerroa:       node.parentNode.insertBefore($(nodeArray[1])[0], node)
Kode lerroa:       node.parentNode.insertBefore(nodeArray[2], node)
Kode lerroa:       node.parentNode.removeChild(node) // Remove original node
Kode lerroa:     } else {
Kode lerroa:       wrapper.innerHTML = node.nodeValue.slice(startPosition, endPosition)
Kode lerroa:       const newStringifiedContent = node.nodeValue.slice(0, startPosition) + wrapper.outerHTML + node.nodeValue.slice(endPosition, node.nodeValue.length)
Kode lerroa:       DOMTextUtils.replaceContent(node, newStringifiedContent)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Given a list of selectors and the format of the document, returns the range of selected text fragment in the document
Kode lerroa:    * @param selectors
Kode lerroa:    * @param exhaustive
Kode lerroa:    * @param format
Kode lerroa:    * @returns {null}
Kode lerroa:    */
Kode lerroa:   static retrieveRange ({ selectors, exhaustive = true, format }) {
Kode lerroa:     const fragmentSelector = _.find(selectors, (selector) => { return selector.type === 'FragmentSelector' })
Kode lerroa:     const rangeSelector = _.find(selectors, (selector) => { return selector.type === 'RangeSelector' })
Kode lerroa:     const textQuoteSelector = _.find(selectors, (selector) => { return selector.type === 'TextQuoteSelector' })
Kode lerroa:     const textPositionSelector = _.find(selectors, (selector) => { return selector.type === 'TextPositionSelector' })
Kode lerroa:     // Check whether the document is PDF, HTML or TXT
Kode lerroa:     if (format.name === 'pdf') {
Kode lerroa:       return DOMTextUtils.retrieveRangeForPDFDocument({ fragmentSelector, textPositionSelector, textQuoteSelector, exhaustive })
Kode lerroa:     } else if (format.name === 'txt') {
Kode lerroa:       return DOMTextUtils.retrieveRangeForTXTDocument({ textPositionSelector, textQuoteSelector })
Kode lerroa:     } else if (format.name === 'html') {
Kode lerroa:       return DOMTextUtils.retrieveRangeForHTMLDocument({ fragmentSelector, textPositionSelector, textQuoteSelector, rangeSelector, exhaustive })
Kode lerroa:     } else {
Kode lerroa:       console.error('Document format is not valid')
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveRangeForPDFDocument ({ fragmentSelector, textPositionSelector, textQuoteSelector, exhaustive }) {
Kode lerroa:     let fragmentElement
Kode lerroa:     let range
Kode lerroa:     if (fragmentSelector.page) {
Kode lerroa:       // Check only in corresponding page
Kode lerroa:       const pageElement = document.querySelector('.page[data-page-number="' + fragmentSelector.page + '"][data-loaded="true"]')
Kode lerroa:       if (_.isElement(pageElement)) {
Kode lerroa:         fragmentElement = pageElement
Kode lerroa:       } else {
Kode lerroa:         console.debug('Document page is not loaded, annotation missing.')
Kode lerroa:         return null
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     range = DOMTextUtils.tryRetrieveRangeTextPositionSelector(textPositionSelector, textQuoteSelector.exact)
Kode lerroa:     if (!range) {
Kode lerroa:       if (exhaustive) { // Try by hard exhaustive
Kode lerroa:         range = DOMTextUtils.tryRetrieveRangeTextSelector(fragmentElement, textQuoteSelector)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return range
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveRangeForTXTDocument ({ textPositionSelector, textQuoteSelector }) {
Kode lerroa:     let range = null
Kode lerroa:     if (_.isObject(textPositionSelector) && _.isObject(textQuoteSelector)) {
Kode lerroa:       range = DOMTextUtils.tryRetrieveRangeTextPositionSelector(textPositionSelector, textQuoteSelector.exact)
Kode lerroa:       if (!range) {
Kode lerroa:         range = DOMTextUtils.tryRetrieveRangeTextSelector(document.body, textQuoteSelector)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return range
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveRangeForHTMLDocument ({ fragmentSelector, textPositionSelector, textQuoteSelector, rangeSelector, exhaustive }) {
Kode lerroa:     let range = null
Kode lerroa:     if (_.isObject(fragmentSelector) || _.isObject(rangeSelector)) { // It is an element of DOM
Kode lerroa:       let fragmentElement = null
Kode lerroa:       if (_.has(fragmentSelector, 'value')) {
Kode lerroa:         fragmentElement = document.querySelector('#' + fragmentSelector.value)
Kode lerroa:       }
Kode lerroa:       if (_.isElement(fragmentElement)) {
Kode lerroa:         range = DOMTextUtils.tryRetrieveRangeTextSelector(fragmentElement, textQuoteSelector)
Kode lerroa:       } else {
Kode lerroa:         let startRangeElement = null
Kode lerroa:         if (_.has(rangeSelector, 'startContainer')) {
Kode lerroa:           startRangeElement = document.evaluate('.' + rangeSelector.startContainer, document, null, window.XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue
Kode lerroa:         }
Kode lerroa:         let endRangeElement = null
Kode lerroa:         if (_.has(rangeSelector, 'endContainer')) {
Kode lerroa:           endRangeElement = document.evaluate('.' + rangeSelector.endContainer, document, null, window.XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue
Kode lerroa:         }
Kode lerroa:         if (_.isElement(startRangeElement) && _.isElement(endRangeElement)) {
Kode lerroa:           range = DOMTextUtils.tryRetrieveRangeTextSelector(fragmentElement, textQuoteSelector)
Kode lerroa:         } else {
Kode lerroa:           range = DOMTextUtils.tryRetrieveRangeTextPositionSelector(textPositionSelector, textQuoteSelector.exact)
Kode lerroa:           if (!range) {
Kode lerroa:             if (exhaustive) { // Try by hard exhaustive
Kode lerroa:               range = DOMTextUtils.tryRetrieveRangeTextSelector(document.body, textQuoteSelector)
Kode lerroa:               if (!range) {
Kode lerroa:                 range = DOMTextUtils.retrieveRangeTextSelectorUsingNativeFind(textQuoteSelector.exact, textPositionSelector)
Kode lerroa:               }
Kode lerroa:             } else {
Kode lerroa:               range = DOMTextUtils.retrieveRangeTextSelectorUsingNativeFind(textQuoteSelector.exact, textPositionSelector)
Kode lerroa:             }
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else if (textQuoteSelector && textPositionSelector) { // It is a text of PDF
Kode lerroa:       range = DOMTextUtils.tryRetrieveRangeTextPositionSelector(textPositionSelector, textQuoteSelector.exact)
Kode lerroa:       if (!range) {
Kode lerroa:         if (exhaustive) { // Try by hard exhaustive
Kode lerroa:           range = DOMTextUtils.tryRetrieveRangeTextSelector(document.body, textQuoteSelector)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return range
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    *
Kode lerroa:    * @param textPositionSelector
Kode lerroa:    * @param exactText
Kode lerroa:    * @returns {null|*}
Kode lerroa:    */
Kode lerroa:   static tryRetrieveRangeTextPositionSelector (textPositionSelector, exactText) {
Kode lerroa:     const possibleRange = domAnchorTextPosition.toRange(document.body, { start: textPositionSelector.start, end: textPositionSelector.end })
Kode lerroa:     if (possibleRange && possibleRange.toString() === exactText) {
Kode lerroa:       return possibleRange
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static tryRetrieveRangeTextSelector (fragmentElement, textQuoteSelector) {
Kode lerroa:     if (_.isNull(fragmentElement) || document.children[0] === fragmentElement) {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:     let range = null
Kode lerroa:     try {
Kode lerroa:       range = domAnchorTextQuote.toRange(fragmentElement.parentNode, textQuoteSelector)
Kode lerroa:     } catch (e) {
Kode lerroa:       range = DOMTextUtils.tryRetrieveRangeTextSelector(fragmentElement.parentNode, textQuoteSelector)
Kode lerroa:     }
Kode lerroa:     if (_.isNull(range)) {
Kode lerroa:       range = DOMTextUtils.tryRetrieveRangeTextSelector(fragmentElement.parentNode, textQuoteSelector)
Kode lerroa:     }
Kode lerroa:     return range
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    *
Kode lerroa:    * @param str
Kode lerroa:    * @returns {*}
Kode lerroa:    */
Kode lerroa:   static findAllMatches (str) {
Kode lerroa:     // Get current selection range for set again after the algorithm
Kode lerroa:     const userSelection = window.getSelection().getRangeAt(0)
Kode lerroa:     // Find matches using window.find
Kode lerroa:     const matches = []
Kode lerroa:     let findResult = document.execCommand('FindString', true, str)
Kode lerroa:     let currentMatch = window.getSelection().getRangeAt(0).cloneRange()
Kode lerroa:     // Search forward of the current position
Kode lerroa:     while (findResult && _.isUndefined(_.find(matches, (match) => { return match.startOffset === currentMatch.startOffset || match.endOffset === currentMatch.endOffset }))) {
Kode lerroa:       matches.push(window.getSelection().getRangeAt(0).cloneRange())
Kode lerroa:       findResult = document.execCommand('FindString', true, str)
Kode lerroa:       currentMatch = window.getSelection().getRangeAt(0).cloneRange()
Kode lerroa:     }
Kode lerroa:     // Set current selection as the former one set by the user
Kode lerroa:     window.getSelection().removeAllRanges()
Kode lerroa:     window.getSelection().addRange(userSelection)
Kode lerroa:     return _.uniq(matches)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveRangeTextSelectorUsingNativeFind (exact, textPositionSelector) {
Kode lerroa:     const matches = DOMTextUtils.findAllMatches(exact)
Kode lerroa:     if (matches.length === 0) {
Kode lerroa:       return null
Kode lerroa:     } else if (matches.length === 1) {
Kode lerroa:       return matches[0]
Kode lerroa:     } else if (matches.length > 1) {
Kode lerroa:       // Try to find by position selector
Kode lerroa:       const matchedTextPositionSelectors = _.map(matches, (match) => {
Kode lerroa:         return DOMTextUtils.getTextPositionSelector(match)
Kode lerroa:       })
Kode lerroa:       let matchedRange = _.find(matchedTextPositionSelectors, (matchedSelector) => {
Kode lerroa:         return matchedSelector.start === textPositionSelector.start && matchedSelector.end === textPositionSelector.end
Kode lerroa:       })
Kode lerroa:       if (matchedRange) {
Kode lerroa:         return matchedRange
Kode lerroa:       } else {
Kode lerroa:         const range = domAnchorTextPosition.toRange(document.body, textPositionSelector.start, textPositionSelector.end)
Kode lerroa:         matchedRange = _.find(matches, (matchRange) => {
Kode lerroa:           return range.startOffset === matchRange.startOffset && range.endOffset === matchRange.endOffset
Kode lerroa:         })
Kode lerroa:         if (matchedRange) {
Kode lerroa:           return matchedRange
Kode lerroa:         } else {
Kode lerroa:           return matches[0] // Return the first match
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static replaceContent (oldNode, newNode) {
Kode lerroa:     // Find a better solution which not creates new elements
Kode lerroa:     const span = document.createElement('span')
Kode lerroa:     span.innerHTML = newNode
Kode lerroa:     oldNode.replaceWith(span)
Kode lerroa:     $(span.childNodes).unwrap()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveFirstTextNode (element) {
Kode lerroa:     if (element.nodeType === window.Node.TEXT_NODE) {
Kode lerroa:       return element
Kode lerroa:     } else {
Kode lerroa:       if (element.firstChild) {
Kode lerroa:         return DOMTextUtils.retrieveFirstTextNode(element.firstChild)
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveLeafNodes (element) {
Kode lerroa:     let childNodes = []
Kode lerroa:     if (element.childNodes.length > 0) {
Kode lerroa:       for (let i = 0; i < element.childNodes.length; i++) {
Kode lerroa:         const childNode = element.childNodes[i]
Kode lerroa:         childNodes = childNodes.concat(this.retrieveLeafNodes(childNode))
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       childNodes = [element]
Kode lerroa:     }
Kode lerroa:     return childNodes
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static unHighlightAllContent (className) {
Kode lerroa:     // Remove highlighted elements
Kode lerroa:     const highlightElements = document.querySelectorAll('.' + className)
Kode lerroa:     DOMTextUtils.unHighlightElements(highlightElements)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static unHighlightElements (highlightElements) {
Kode lerroa:     if (_.isArray(highlightElements)) {
Kode lerroa:       highlightElements.forEach((highlightElement) => {
Kode lerroa:         // If element content is not empty, unwrap maintaining its content
Kode lerroa:         $(highlightElement.firstChild).unwrap()
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static unHighlightById (id) {
Kode lerroa:     const highlightElements = document.querySelectorAll('[data-annotation-id=\'' + id + '\']')
Kode lerroa:     DOMTextUtils.unHighlightElements(highlightElements)
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DOMTextUtils
Kode lerroa: 'use strict'
Kode lerroa: 
Kode lerroa: import LanguageUtils from './LanguageUtils'
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:  *
Kode lerroa:  */
Kode lerroa: class DataUtils {
Kode lerroa:   static shuffle (originalArray) {
Kode lerroa:     const array = originalArray.slice()
Kode lerroa:     let currentIndex = array.length
Kode lerroa:     let temporaryValue
Kode lerroa:     let randomIndex
Kode lerroa: 
Kode lerroa:     // While there remain elements to shuffle...
Kode lerroa:     while (currentIndex !== 0) {
Kode lerroa:       // Pick a remaining element...
Kode lerroa:       randomIndex = Math.floor(Math.random() * currentIndex)
Kode lerroa:       currentIndex -= 1
Kode lerroa: 
Kode lerroa:       // And swap it with the current element.
Kode lerroa:       temporaryValue = array[currentIndex]
Kode lerroa:       array[currentIndex] = array[randomIndex]
Kode lerroa:       array[randomIndex] = temporaryValue
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     return array
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getRandomElement (array) {
Kode lerroa:     return array[Math.floor(Math.random() * array.length)]
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static removeByExample (array, props) {
Kode lerroa:     const removableObjects = DataUtils.filterArray(array, props, { index: true })
Kode lerroa:     for (let i = 0; i < removableObjects.length; i++) {
Kode lerroa:       array.splice(removableObjects[i].index, 1)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static queryByExample (array, props) {
Kode lerroa:     return DataUtils.filterArray(array, props)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static queryIndexByExample (array, props) {
Kode lerroa:     return DataUtils.filterArray(array, props, { index: true })[0].index
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static queryByContains (array, props, customComparison) {
Kode lerroa:     if (customComparison) {
Kode lerroa:       return DataUtils.filterArray(array, props, { contains: true, properties: { comparison: customComparison } })
Kode lerroa:     } else {
Kode lerroa:       return DataUtils.filterArray(array, props, { contains: true })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static filterArray (array, props, opts) {
Kode lerroa:     const filteredArray = []
Kode lerroa:     for (let i = 0; i < array.length; i++) {
Kode lerroa:       const elem = array[i]
Kode lerroa:       let matchedElem = null
Kode lerroa:       // Filter type (contains at least one prop, or all the props)
Kode lerroa:       if (opts && opts.contains) {
Kode lerroa:         if (DataUtils.isPropertyIncluded(elem, props, opts)) {
Kode lerroa:           matchedElem = elem
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         if (DataUtils.arePropertiesIncluded(elem, props)) {
Kode lerroa:           matchedElem = elem
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       // If a result is matched, add it
Kode lerroa:       if (matchedElem) {
Kode lerroa:         if (opts && opts.index) {
Kode lerroa:           filteredArray.push({ index: i, obj: elem })
Kode lerroa:         } else {
Kode lerroa:           filteredArray.push(elem)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return filteredArray
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static arePropertiesIncluded (objectSource, properties) {
Kode lerroa:     const keys = Object.keys(properties)
Kode lerroa:     for (let i = 0; i < keys.length; i++) {
Kode lerroa:       const key = keys[i]
Kode lerroa:       if (objectSource[key] !== properties[key]) {
Kode lerroa:         return false
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return true
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static isPropertyIncluded (objectSource, properties, opts) {
Kode lerroa:     const keys = Object.keys(properties)
Kode lerroa:     for (let i = 0; i < keys.length; i++) {
Kode lerroa:       const key = keys[i]
Kode lerroa:       // TODO FIXIT!!! Incluye texto, no texto igual
Kode lerroa:       if (opts.properties && opts.properties.comparison && LanguageUtils.isFunction(opts.properties.comparison)) {
Kode lerroa:         if (opts.properties.comparison(objectSource[key], properties[key])) {
Kode lerroa:           return true
Kode lerroa:         } else {
Kode lerroa:           if (objectSource[key] === properties[key]) {
Kode lerroa:             return true
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return false
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static stringInclude (str1, str2) {
Kode lerroa:     if (str1 && str2) {
Kode lerroa:       return str1.toLowerCase().includes(str2.toLowerCase())
Kode lerroa:     }
Kode lerroa:     return false
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static intersectionNonEqual (a, b, equalComparison) {
Kode lerroa:     return a.filter((n) => {
Kode lerroa:       for (let i = 0; i < b.length; i++) {
Kode lerroa:         if (equalComparison(n, b[i])) {
Kode lerroa:           return true
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       return false
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DataUtils
Kode lerroa: class DateUtils {
Kode lerroa:   static getYearMonthDay (date) {
Kode lerroa:     if (!date) {
Kode lerroa:       date = new Date()
Kode lerroa:     }
Kode lerroa:     let dd = date.getDate()
Kode lerroa:     let mm = date.getMonth() + 1 // January is 0!
Kode lerroa: 
Kode lerroa:     const yyyy = date.getFullYear()
Kode lerroa:     if (dd < 10) {
Kode lerroa:       dd = '0' + dd
Kode lerroa:     }
Kode lerroa:     if (mm < 10) {
Kode lerroa:       mm = '0' + mm
Kode lerroa:     }
Kode lerroa:     return dd + '/' + mm + '/' + yyyy
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default DateUtils
Kode lerroa: class FileUtils {
Kode lerroa:   static readTextFile (file, callback) {
Kode lerroa:     try {
Kode lerroa:       const reader = new window.FileReader()
Kode lerroa:       // Closure to capture the file information.
Kode lerroa:       reader.onload = (e) => {
Kode lerroa:         if (e && e.target && e.target.result) {
Kode lerroa:           callback(null, e.target.result)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       reader.readAsText(file)
Kode lerroa:     } catch (e) {
Kode lerroa:       callback(e)
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static readJSONFile (file, callback) {
Kode lerroa:     FileUtils.readTextFile(file, (err, text) => {
Kode lerroa:       if (err) {
Kode lerroa:         callback(err)
Kode lerroa:       } else {
Kode lerroa:         try {
Kode lerroa:           const json = JSON.parse(text)
Kode lerroa:           callback(null, json)
Kode lerroa:         } catch (err) {
Kode lerroa:           callback(err)
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default FileUtils
Kode lerroa: 'use strict'
Kode lerroa: 
Kode lerroa: import jQuery from 'jquery'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class LanguageUtils {
Kode lerroa:   /**
Kode lerroa:    * Check if a given object is a function
Kode lerroa:    * @param func An object
Kode lerroa:    * @returns {*|boolean}
Kode lerroa:    */
Kode lerroa:   static isFunction (func) {
Kode lerroa:     return func && typeof func === 'function'
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Returns true if the object is empty, null, etc.
Kode lerroa:    * @param obj
Kode lerroa:    * @returns {*|boolean}
Kode lerroa:    */
Kode lerroa:   static isEmptyObject (obj) {
Kode lerroa:     return jQuery.isEmptyObject(obj)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Returns true if the object is instance of a Class
Kode lerroa:    * @param obj
Kode lerroa:    * @param classReference
Kode lerroa:    * @returns {boolean}
Kode lerroa:    */
Kode lerroa:   static isInstanceOf (obj, classReference) {
Kode lerroa:     return obj instanceof classReference
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Fill the object with the properties
Kode lerroa:    * @param object
Kode lerroa:    * @param properties
Kode lerroa:    * @returns {*}
Kode lerroa:    */
Kode lerroa:   static fillObject (object, properties) {
Kode lerroa:     return Object.assign(object, properties)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Create a custom event with the corresponding name, message and metadata
Kode lerroa:    * @param name
Kode lerroa:    * @param message
Kode lerroa:    * @param data
Kode lerroa:    * @returns {CustomEvent}
Kode lerroa:    */
Kode lerroa:   static createCustomEvent (name, message, data) {
Kode lerroa:     return (new window.CustomEvent(name, {
Kode lerroa:       detail: {
Kode lerroa:         message: message,
Kode lerroa:         data: data,
Kode lerroa:         time: new Date()
Kode lerroa:       },
Kode lerroa:       bubbles: true,
Kode lerroa:       cancelable: true
Kode lerroa:     }))
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Renames an object's key
Kode lerroa:    * @param o
Kode lerroa:    * @param oldKey
Kode lerroa:    * @param newKey
Kode lerroa:    */
Kode lerroa:   static renameObjectKey (o, oldKey, newKey) {
Kode lerroa:     if (oldKey !== newKey) {
Kode lerroa:       Object.defineProperty(o, newKey,
Kode lerroa:         Object.getOwnPropertyDescriptor(o, oldKey))
Kode lerroa:       delete o[oldKey]
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Dispatches a custom event with the given name
Kode lerroa:    * @param eventName
Kode lerroa:    * @param metadata
Kode lerroa:    */
Kode lerroa:   static dispatchCustomEvent (eventName, metadata) {
Kode lerroa:     const event = new window.CustomEvent(
Kode lerroa:       eventName, {
Kode lerroa:         detail: metadata,
Kode lerroa:         bubbles: true,
Kode lerroa:         cancelable: true
Kode lerroa:       }
Kode lerroa:     )
Kode lerroa:     document.body.dispatchEvent(event)
Kode lerroa:     return event
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Run promises in serial. Taken from https://decembersoft.com/posts/promises-in-serial-with-array-reduce/
Kode lerroa:    * @param promises
Kode lerroa:    * @param callback
Kode lerroa:    */
Kode lerroa:   static runPromisesInSerial (promises, callback) {
Kode lerroa:     promises.reduce((promiseChain, currentTask) => {
Kode lerroa:       return promiseChain.then(chainResults =>
Kode lerroa:         currentTask.then(currentResult => {
Kode lerroa:           return [...chainResults, currentResult]
Kode lerroa:         })
Kode lerroa:       )
Kode lerroa:     }, Promise.resolve([])).then(arrayOfResults => {
Kode lerroa:       // Do something with all results
Kode lerroa:       if (_.isFunction(callback)) {
Kode lerroa:         callback(arrayOfResults)
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Normalize strings removing tildes, etc.
Kode lerroa:    * @param string
Kode lerroa:    * @returns {*}
Kode lerroa:    */
Kode lerroa:   static normalizeString (string) {
Kode lerroa:     return string.normalize('NFD').replace(/[\u0300-\u036f]/g, '')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Normalizes string to a valid string for ID. Based on: https://stackoverflow.com/questions/10619126/make-sure-string-is-a-valid-css-id-name
Kode lerroa:    * @param string
Kode lerroa:    */
Kode lerroa:   static normalizeStringToValidID (string) {
Kode lerroa:     return string.replace(/(^-\d-|^\d|^-\d|^--)/, 'a$1').replace(/[\W]/g, '-')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static getStringBetween (string, previous, after) {
Kode lerroa:     const firstSplit = string.split(previous)
Kode lerroa:     if (firstSplit.length > 1) {
Kode lerroa:       const secondSplit = firstSplit.pop().split(after)
Kode lerroa:       if (secondSplit.length > 1) {
Kode lerroa:         return secondSplit[0]
Kode lerroa:       } else {
Kode lerroa:         return null
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default LanguageUtils
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class PDFTextUtils {
Kode lerroa:   static getFragmentSelector (range) {
Kode lerroa:     const pageContainer = range.startContainer.parentElement.closest('.page')
Kode lerroa:     if (_.isElement(pageContainer)) {
Kode lerroa:       try {
Kode lerroa:         const pageNumber = parseInt(pageContainer.dataset.pageNumber)
Kode lerroa:         return {
Kode lerroa:           conformsTo: 'http://tools.ietf.org/rfc/rfc3778',
Kode lerroa:           type: 'FragmentSelector',
Kode lerroa:           page: pageNumber
Kode lerroa:         }
Kode lerroa:       } catch (e) {
Kode lerroa:         return null
Kode lerroa:       }
Kode lerroa:     } else {
Kode lerroa:       return null
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default PDFTextUtils
Kode lerroa: import _ from 'lodash'
Kode lerroa: class RandomUtils {
Kode lerroa:   static randomString (length = 20, charSet) {
Kode lerroa:     charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-'
Kode lerroa:     let randomString = ''
Kode lerroa:     for (let i = 0; i < length; i++) {
Kode lerroa:       const randomPoz = Math.floor(Math.random() * charSet.length)
Kode lerroa:       randomString += charSet.substring(randomPoz, randomPoz + 1)
Kode lerroa:     }
Kode lerroa:     return randomString
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static randomUnique (arrayOfIds = [], length, charset) {
Kode lerroa:     let unique = false
Kode lerroa:     let randomString = ''
Kode lerroa:     while (!unique) {
Kode lerroa:       randomString = RandomUtils.randomString(length, charset)
Kode lerroa:       if (!_.find(arrayOfIds, randomString)) {
Kode lerroa:         unique = true
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:     return randomString
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default RandomUtils
Kode lerroa: class SheetUtils {
Kode lerroa:   static columnToLetter (columnNumber) {
Kode lerroa:     let temp = ''
Kode lerroa:     let letter = ''
Kode lerroa:     while (columnNumber > 0) {
Kode lerroa:       temp = (columnNumber - 1) % 26
Kode lerroa:       letter = String.fromCharCode(temp + 65) + letter
Kode lerroa:       columnNumber = (columnNumber - temp - 1) / 26
Kode lerroa:     }
Kode lerroa:     return letter
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default SheetUtils
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class URLUtils {
Kode lerroa:   /**
Kode lerroa:    * Given a url with format https://domain.org#elem:abc&elem:bcd it returns you the object {elem: 'abc', elem: 'bcd'}
Kode lerroa:    * @param url
Kode lerroa:    * @param separator
Kode lerroa:    * @returns {{}}
Kode lerroa:    */
Kode lerroa:   static extractHashParamsFromUrl (url, separator) {
Kode lerroa:     separator = separator || ':'
Kode lerroa:     const splittedUrl = url.split('#')
Kode lerroa:     let result = null
Kode lerroa:     if (splittedUrl.length > 1) {
Kode lerroa:       const hash = splittedUrl[1]
Kode lerroa:       result = hash.split('&').reduce((result, item) => {
Kode lerroa:         const parts = item.split(separator)
Kode lerroa:         result[parts[0]] = decodeURIComponent(parts[1])
Kode lerroa:         return result
Kode lerroa:       }, {})
Kode lerroa:     }
Kode lerroa:     return result
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Check if both urls are the same without hash params, protocol, and so on
Kode lerroa:    * @param url1
Kode lerroa:    * @param url2
Kode lerroa:    */
Kode lerroa:   static areSameURI (url1, url2) {
Kode lerroa:     let cleanUrl1 = decodeURI(url1)
Kode lerroa:     let cleanUrl2 = decodeURI(url2)
Kode lerroa:     cleanUrl1 = cleanUrl1.replace(/(^\w+:|^)\/\//, '').split('#')[0] // Remove protocol and hash params
Kode lerroa:     cleanUrl1 = _.replace(_.replace(cleanUrl1, /\+/g, ''), /\s/g, '') // Remove + symbols and whitespaces
Kode lerroa:     cleanUrl2 = cleanUrl2.replace(/(^\w+:|^)\/\//, '').split('#')[0]
Kode lerroa:     cleanUrl2 = _.replace(_.replace(cleanUrl2, /\+/g, ''), /\s/g, '')
Kode lerroa:     return cleanUrl1 === cleanUrl2
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * From a url, it removes hash params or other extra content which is not an unique source reference URL
Kode lerroa:    */
Kode lerroa:   static retrieveMainUrl (url) {
Kode lerroa:     return url.split('#')[0] // Remove the hash
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static retrieveDomainFromURL (url) {
Kode lerroa:     let hostname
Kode lerroa:     // Remove the protocol
Kode lerroa:     if (url.indexOf('://') > -1) {
Kode lerroa:       hostname = url.split('/')[2]
Kode lerroa:     } else {
Kode lerroa:       hostname = url.split('/')[0]
Kode lerroa:     }
Kode lerroa:     // Find & remove port number
Kode lerroa:     hostname = hostname.split(':')[0]
Kode lerroa:     // Find & remove "?"
Kode lerroa:     hostname = hostname.split('?')[0]
Kode lerroa:     return hostname
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static isUrl (string) {
Kode lerroa:     try {
Kode lerroa:       const url = new URL(string)
Kode lerroa:       return url.href === string
Kode lerroa:     } catch (typeError) {
Kode lerroa:       return false
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static objectToParams (obj) {
Kode lerroa:     return Object.keys(obj).map(key => key + ':' + encodeURIComponent(obj[key])).join('&')
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default URLUtils
Kode lerroa: import BrowserStorageManager from './annotationServer/browserStorage/BrowserStorageManager'
Kode lerroa: import URLUtils from './utils/URLUtils'
Kode lerroa: import Alerts from './utils/Alerts'
Kode lerroa: import Config from './Config'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class BrowserStorageSearch {
Kode lerroa:   static init () {
Kode lerroa:     // Retrieve from params the search
Kode lerroa:     const query = BrowserStorageSearch.parseParamsToSearch()
Kode lerroa: 
Kode lerroa:     // Set search text input value
Kode lerroa:     document.querySelector('#searchAnnotationsInput').value = window.location.href.split('#')[1]
Kode lerroa: 
Kode lerroa:     // Retrieve annotations based on params
Kode lerroa:     window.browserStorageManager = new BrowserStorageManager()
Kode lerroa:     window.browserStorageManager.init((err) => {
Kode lerroa:       if (err) {
Kode lerroa:         Alerts.errorAlert({ text: 'Unable to retrieve annotations list. Error: ' + err.message })
Kode lerroa:       } else {
Kode lerroa:         if (_.has(query, 'id')) {
Kode lerroa:           window.browserStorageManager.client.fetchAnnotation(query.id, (err, annotation) => {
Kode lerroa:             if (err) {
Kode lerroa:               Alerts.errorAlert({ text: 'Unable to retrieve annotations. Error: ' + err.message })
Kode lerroa:             } else {
Kode lerroa:               BrowserStorageSearch.showAnnotationsOnInterface([annotation])
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         } else {
Kode lerroa:           // Search annotations
Kode lerroa:           window.browserStorageManager.client.searchAnnotations(query, (err, annotations) => {
Kode lerroa:             if (err) {
Kode lerroa:               Alerts.errorAlert({ text: 'Unable to retrieve annotations. Error: ' + err.message })
Kode lerroa:             } else {
Kode lerroa:               BrowserStorageSearch.showAnnotationsOnInterface(annotations)
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:     // Init on enter key to reload the page with new search
Kode lerroa:     BrowserStorageSearch.setSearchOnEnterClickEventHandler()
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static parseParamsToSearch () {
Kode lerroa:     return URLUtils.extractHashParamsFromUrl(window.location.href)
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static showAnnotationsOnInterface (annotations = []) {
Kode lerroa:     annotations.forEach((annotation) => {
Kode lerroa:       // Clone template
Kode lerroa:       const annotationCard = document.querySelector('#annotationCardTemplate').content.cloneNode(true)
Kode lerroa:       annotationCard.id = 'annotationCard_' + annotation.id
Kode lerroa:       annotationCard.querySelector('.annotationCardUsername').innerText = annotation.creator || annotation.user
Kode lerroa:       annotationCard.querySelector('.annotationCardUsername').addEventListener('click', () => {
Kode lerroa:         document.location.href = window.browserStorageManager.constructSearchUrl({ user: annotation.creator || annotation.user })
Kode lerroa:         document.location.reload()
Kode lerroa:       })
Kode lerroa:       annotationCard.querySelector('.annotationCardGroup').innerText = annotation.group
Kode lerroa:       annotationCard.querySelector('.annotationCardGroup').addEventListener('click', () => {
Kode lerroa:         document.location.href = window.browserStorageManager.constructSearchUrl({ group: annotation.group })
Kode lerroa:         document.location.reload()
Kode lerroa:       })
Kode lerroa:       annotationCard.querySelector('.annotationCardDate').innerText = annotation.updated
Kode lerroa:       if (annotation.target && annotation.target[0] && annotation.target[0].selector) {
Kode lerroa:         annotationCard.querySelector('.annotationCardExact').innerText = annotation.target[0].selector.find((selector) => { return selector.type === 'TextQuoteSelector' }).exact
Kode lerroa:       }
Kode lerroa:       if (_.isArray(annotation.body)) {
Kode lerroa:         const commentBody = annotation.body.find(body => body.purpose === 'commenting')
Kode lerroa:         if (commentBody) {
Kode lerroa:           annotationCard.querySelector('.annotationCardComment').innerText = commentBody.value
Kode lerroa:         } else {
Kode lerroa:           annotationCard.querySelector('.annotationCardComment').innerText = ''
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       annotationCard.querySelector('.annotationCardTags').innerText = JSON.stringify(annotation.tags)
Kode lerroa:       if (_.isArray(annotation.target) && annotation.target[0]) {
Kode lerroa:         const source = annotation.target[0].source
Kode lerroa:         if (_.isObject(source) && source.url) {
Kode lerroa:           annotationCard.querySelector('.annotationCardLink').querySelector('a').href = source.url + '#' + Config.urlParamName + ':' + annotation.id
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:       document.querySelector('#searchResult').appendChild(annotationCard)
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   static setSearchOnEnterClickEventHandler () {
Kode lerroa:     document.querySelector('#searchAnnotationsInput').addEventListener('keyup', (event) => {
Kode lerroa:       if (event.keyCode === 13) {
Kode lerroa:         // Cancel the default action, if needed
Kode lerroa:         event.preventDefault()
Kode lerroa:         // Get element input text
Kode lerroa:         const queryString = event.target.value
Kode lerroa:         // TODO Check valid query
Kode lerroa:         const query = URLUtils.extractHashParamsFromUrl('http://something.com#' + queryString)
Kode lerroa:         if (_.isObject(query)) {
Kode lerroa:           // Reload webpage with new query
Kode lerroa:           document.location.href = window.browserStorageManager.constructSearchUrl(query)
Kode lerroa:           document.location.reload()
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: BrowserStorageSearch.init()
Kode lerroa: // Configuration for default annotation server
Kode lerroa: let defaultAnnotationServer
Kode lerroa: // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Collect(p | IF p->pv:Name() = AnnotationServer->pv:Attribute('defaultAnnotationServer') THEN 1 ELSE 0 ENDIF)->pv:Contains(1), LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: // Tags configuration
Kode lerroa: const grouped = {
Kode lerroa:   group: 'theme'
Kode lerroa: }
Kode lerroa: // PVSCL:IFCOND(Hierarchy,LINE)
Kode lerroa: 
Kode lerroa: const tags = {
Kode lerroa:   grouped: grouped,
Kode lerroa:   motivation: 'motivation'
Kode lerroa: }
Kode lerroa: // PVSCL:IFCOND(MoodleResource, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(GoogleSheetProvider, LINE)
Kode lerroa: 
Kode lerroa: const Config = {
Kode lerroa:   // PVSCL:IFCOND(BuiltIn or ApplicationBased OR NOT(Codebook), LINE)
Kode lerroa: 
Kode lerroa:   defaultAnnotationServer: defaultAnnotationServer,
Kode lerroa:   namespace: 'oa',
Kode lerroa:   // eslint-disable-next-line quotes
Kode lerroa:   urlParamName: "PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))", // Name to activate the extension if the url contains this hash param
Kode lerroa:   tags: tags,
Kode lerroa:   colors: {
Kode lerroa:     minAlpha: 0.2,
Kode lerroa:     maxAlpha: 0.8
Kode lerroa:   },
Kode lerroa:   assessmentCategories: [{
Kode lerroa:     name: 'Minor weakness'
Kode lerroa:   }, {
Kode lerroa:     name: 'Major weakness'
Kode lerroa:   }, {
Kode lerroa:     name: 'Strength'
Kode lerroa:   }]
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Config
Kode lerroa: const Events = {
Kode lerroa:   // Annotation management events
Kode lerroa:   annotationCreated: 'annotationCreated',
Kode lerroa:   annotationUpdated: 'annotationUpdated',
Kode lerroa:   annotationDeleted: 'annotationDeleted',
Kode lerroa:   // PVSCL:IFCOND(Validate, LINE)
Kode lerroa: 
Kode lerroa:   createAnnotation: 'createAnnotation',
Kode lerroa:   updateAnnotation: 'updateAnnotation',
Kode lerroa:   deleteAnnotation: 'deleteAnnotation',
Kode lerroa:   updatedAllAnnotations: 'updatedAllAnnotations',
Kode lerroa:   // PVSCL:IFCOND(UserFilter, LINE)
Kode lerroa: 
Kode lerroa:   updatedDocumentURL: 'updatedDocumentURL',
Kode lerroa:   // PVSCL:IFCOND(Comment, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Reply, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(DeleteAll, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Filter, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Codebook, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(CodebookDelete, LINE)
Kode lerroa: 
Kode lerroa:   targetChanged: 'targetChanged', // TODO Review if it is used somewhere
Kode lerroa:   // PVSCL:IFCOND(NOT (Multivalued), LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(Manual, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(ImportAnnotations, LINE)
Kode lerroa: 
Kode lerroa:   // PVSCL:IFCOND(SidebarNavigation, LINE)
Kode lerroa: 
Kode lerroa:   annotatedContentManagerUpdated: 'annotatedContentManagerUpdated',
Kode lerroa:   navigateToAnnotation: 'navigateToAnnotation',
Kode lerroa:   codebookRead: 'codebookRead' // Not in codebook variation point because absense of Codebook/Classifying also requires this event currently
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default Events
Kode lerroa: import URLUtils from './utils/URLUtils'
Kode lerroa: import Config from './Config'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import DOI from 'doi-regex'
Kode lerroa: 
Kode lerroa: class ACMContentScript {
Kode lerroa:   constructor () {
Kode lerroa:     this.doi = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Get url params
Kode lerroa:     const params = URLUtils.extractHashParamsFromUrl(window.location.href)
Kode lerroa:     // Get document doi
Kode lerroa:     if (!_.isEmpty(params) && !_.isEmpty(params.doi)) {
Kode lerroa:       this.doi = params.doi
Kode lerroa:     } else {
Kode lerroa:       // Scrap the doi from web
Kode lerroa:       this.doi = this.findDoi()
Kode lerroa:     }
Kode lerroa:     // Get pdf link element
Kode lerroa:     const pdfLinkElement = this.getPdfLinkElement()
Kode lerroa:     if (pdfLinkElement) {
Kode lerroa:       // Get if this tab has an annotation to open
Kode lerroa:       if (!_.isEmpty(params) && !_.isEmpty(params[Config.urlParamName])) {
Kode lerroa:         // Activate the extension
Kode lerroa:         chrome.runtime.sendMessage({ scope: 'extension', cmd: 'activatePopup' }, (result) => {
Kode lerroa:           console.log('Activated popup')
Kode lerroa:           // Retrieve pdf url
Kode lerroa:           let pdfUrl = pdfLinkElement.href
Kode lerroa:           // Create hash with required params to open extension
Kode lerroa:           let hash = '#' + Config.urlParamName + ':' + params[Config.urlParamName]
Kode lerroa:           if (this.doi) {
Kode lerroa:             hash += '&doi:' + this.doi
Kode lerroa:           }
Kode lerroa:           // Append hash to pdf url
Kode lerroa:           pdfUrl += hash
Kode lerroa:           // Redirect browser to pdf
Kode lerroa:           window.location.replace(pdfUrl)
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         // Append doi to PDF url
Kode lerroa:         if (pdfLinkElement) {
Kode lerroa:           pdfLinkElement.href += '#doi:' + this.doi
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Depending on the article, the ACM-DL shows the DOI in different parts of the document. This function tries to find in the DOM the DOI for the current paper
Kode lerroa:    * @returns {*}
Kode lerroa:    */
Kode lerroa:   findDoi () {
Kode lerroa:     let doiElement = document.querySelector('#divmain > table:nth-child(4) > tbody > tr > td > table > tbody > tr:nth-child(4) > td > span:nth-child(10) > a')
Kode lerroa:     if (this.checkIfDoiElement(doiElement)) {
Kode lerroa:       return doiElement.innerText
Kode lerroa:     }
Kode lerroa:     doiElement = document.querySelector('#divmain > table > tbody > tr > td:nth-child(1) > table:nth-child(3) > tbody > tr > td > table > tbody > tr:nth-child(5) > td > span:nth-child(10) > a')
Kode lerroa:     if (this.checkIfDoiElement(doiElement)) {
Kode lerroa:       return doiElement.innerText
Kode lerroa:     }
Kode lerroa:     doiElement = document.querySelector('#divmain > table > tbody > tr > td:nth-child(1) > table:nth-child(3) > tbody > tr > td > table > tbody > tr:nth-child(4) > td > span:nth-child(10) > a')
Kode lerroa:     if (this.checkIfDoiElement(doiElement)) {
Kode lerroa:       return doiElement.innerText
Kode lerroa:     }
Kode lerroa:     return null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   checkIfDoiElement (doiElement) {
Kode lerroa:     return _.isElement(doiElement) &&
Kode lerroa:       _.isString(doiElement.innerText) &&
Kode lerroa:       _.isArray(DOI.groups(doiElement.innerText)) &&
Kode lerroa:       _.isString(DOI.groups(doiElement.innerText)[1])
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getPdfLinkElement () {
Kode lerroa:     return document.querySelector('#divmain > table:nth-child(2) > tbody > tr > td:nth-child(1) > table:nth-child(1) > tbody > tr > td:nth-child(2) > a')
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: window.acm = {}
Kode lerroa: window.acm.acmContentScript = new ACMContentScript()
Kode lerroa: window.acm.acmContentScript.init()
Kode lerroa: import Popup from './popup/Popup'
Kode lerroa: // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(Neo4J, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(GoogleSheetProvider or GoogleSheetConsumer, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(DOI or NavigationScript, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1, LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa: 
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: // Enable chromereload by uncommenting this line:
Kode lerroa: // import 'chromereload/devonly'
Kode lerroa: 
Kode lerroa: chrome.runtime.onInstalled.addListener((details) => {
Kode lerroa:   console.log('previousVersion', details.previousVersion)
Kode lerroa: })
Kode lerroa: 
Kode lerroa: chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
Kode lerroa:   chrome.pageAction.show(tabId)
Kode lerroa: })
Kode lerroa: 
Kode lerroa: chrome.tabs.onCreated.addListener((tab) => {
Kode lerroa: 
Kode lerroa: })
Kode lerroa: 
Kode lerroa: class Background {
Kode lerroa:   constructor () {
Kode lerroa:     // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa:     this.tabs = {}
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // PVSCL:IFCOND(Hypothesis, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(Neo4J, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(GoogleSheetProvider or GoogleSheetConsumer, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(DOI or NavigationScript, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()>1, LINE)
Kode lerroa: 
Kode lerroa:     // PVSCL:IFCOND(MoodleProvider, LINE)
Kode lerroa: 
Kode lerroa:     // Initialize page_action event handler
Kode lerroa:     chrome.pageAction.onClicked.addListener((tab) => {
Kode lerroa:       // PVSCL:IFCOND(URN, LINE)
Kode lerroa: 
Kode lerroa:     })
Kode lerroa: 
Kode lerroa:     // On tab is reloaded
Kode lerroa:     chrome.tabs.onUpdated.addListener((tabId) => {
Kode lerroa:       if (this.tabs[tabId]) {
Kode lerroa:         if (this.tabs[tabId].activated) {
Kode lerroa:           this.tabs[tabId].activate()
Kode lerroa:         }
Kode lerroa:       } else {
Kode lerroa:         this.tabs[tabId] = new Popup()
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa: 
Kode lerroa:     // Initialize message manager
Kode lerroa:     chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
Kode lerroa:       if (request.scope === 'extension') {
Kode lerroa:         if (request.cmd === 'whoiam') {
Kode lerroa:           sendResponse(sender)
Kode lerroa:         } else if (request.cmd === 'deactivatePopup') {
Kode lerroa:           if (!_.isEmpty(this.tabs) && !_.isEmpty(this.tabs[sender.tab.id])) {
Kode lerroa:             this.tabs[sender.tab.id].deactivate()
Kode lerroa:           }
Kode lerroa:           sendResponse(true)
Kode lerroa:         } else if (request.cmd === 'activatePopup') {
Kode lerroa:           if (!_.isEmpty(this.tabs) && !_.isEmpty(this.tabs[sender.tab.id])) {
Kode lerroa:             this.tabs[sender.tab.id].activate()
Kode lerroa:           }
Kode lerroa:           sendResponse(true)
Kode lerroa:         } else if (request.cmd === 'amIActivated') {
Kode lerroa:           if (this.tabs[sender.tab.id].activated) {
Kode lerroa:             sendResponse({ activated: true })
Kode lerroa:           } else {
Kode lerroa:             sendResponse({ activated: false })
Kode lerroa:           }
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     })
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: window.background = new Background()
Kode lerroa: window.background.init()
Kode lerroa: import AnnotationBasedInitializer from './contentScript/AnnotationBasedInitializer'
Kode lerroa: import ContentScriptManager from './contentScript/ContentScriptManager'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: console.debug('Loaded abwa content script')
Kode lerroa: if (_.isEmpty(window.abwa)) {
Kode lerroa:   window.abwa = {} // Global namespace for variables
Kode lerroa: import GSheetProvider from './codebook/operations/create/googleSheetsProvider/GSheetProvider'
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: window.addEventListener('load', () => {
Kode lerroa:   console.debug('Loaded sheet content script')
Kode lerroa:   // When page is loaded, popup button should be always deactivated
Kode lerroa:   chrome.runtime.sendMessage({ scope: 'extension', cmd: 'deactivatePopup' }, (result) => {
Kode lerroa:     console.log('Deactivated popup')
Kode lerroa:   })
Kode lerroa:   // When popup button is clicked
Kode lerroa:   chrome.extension.onMessage.addListener((msg, sender, sendResponse) => {
Kode lerroa:     if (_.isEmpty(window.googleSheetProvider)) {
Kode lerroa:       if (msg.action === 'initContentScript') {
Kode lerroa:         window.googleSheetProvider = {}
Kode lerroa:         window.googleSheetProvider.contentScriptManager = new GSheetProvider()
Kode lerroa:         window.googleSheetProvider.contentScriptManager.init(() => {
Kode lerroa:           // Disable the button of popup
Kode lerroa:           chrome.runtime.sendMessage({ scope: 'extension', cmd: 'deactivatePopup' }, (result) => {
Kode lerroa:             console.log('Deactivated popup')
Kode lerroa:           })
Kode lerroa:           window.googleSheetProvider = null
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   })
Kode lerroa: })
Kode lerroa: import ChromeStorage from './utils/ChromeStorage'
Kode lerroa: import HypothesisClientManager from './annotationServer/hypothesis/HypothesisClientManager'
Kode lerroa: import _ from 'lodash'
Kode lerroa: const selectedGroupNamespace = 'hypothesis.currentGroup'
Kode lerroa: 
Kode lerroa: console.log('Loaded hypothesis group content script')
Kode lerroa: 
Kode lerroa: window.addEventListener('load', () => {
Kode lerroa:   // Retrieve last saved group
Kode lerroa:   ChromeStorage.getData(selectedGroupNamespace, ChromeStorage.local, (err, savedCurrentGroup) => {
Kode lerroa:     if (err) {
Kode lerroa:       console.error('Error while retrieving default group')
Kode lerroa:     } else {
Kode lerroa:       // Parse chrome storage result
Kode lerroa:       if (!_.isEmpty(savedCurrentGroup) && savedCurrentGroup.data) {
Kode lerroa:         // Nothing to change
Kode lerroa:       } else {
Kode lerroa:         // Set hypothes.is web page group as current group
Kode lerroa:         window.abwa = {}
Kode lerroa:         window.abwa.annotationServerManager = new HypothesisClientManager()
Kode lerroa:         window.abwa.annotationServerManager.init(() => {
Kode lerroa:           window.abwa.annotationServerManager.client.getUserProfile((err, userProfile) => {
Kode lerroa:             if (err) {
Kode lerroa:               console.error('Error while retrieving user profile in hypothesis')
Kode lerroa:             } else {
Kode lerroa:               const urlSplit = window.location.href.split('/')
Kode lerroa:               const indexOfGroups = _.indexOf(urlSplit, 'groups')
Kode lerroa:               if (urlSplit[indexOfGroups + 1]) {
Kode lerroa:                 const groupId = urlSplit[indexOfGroups + 1]
Kode lerroa:                 // Set current group
Kode lerroa:                 const group = _.find(userProfile.groups, (group) => { return group.id === groupId })
Kode lerroa:                 if (group) {
Kode lerroa:                   // Save to chrome storage current group
Kode lerroa:                   ChromeStorage.setData(selectedGroupNamespace, { data: JSON.stringify(group) }, ChromeStorage.local, () => {
Kode lerroa:                     console.log('Set as group: ' + group.name)
Kode lerroa:                   })
Kode lerroa:                 }
Kode lerroa:               }
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   })
Kode lerroa: })
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: window.addEventListener('load', () => {
Kode lerroa:   console.debug('Loaded moodle assignment add content script')
Kode lerroa:   // Look for send students notifications
Kode lerroa:   const studentsNotificationsSelectElement = document.querySelector('#id_sendstudentnotifications')
Kode lerroa:   if (_.isElement(studentsNotificationsSelectElement)) {
Kode lerroa:     studentsNotificationsSelectElement.value = 0
Kode lerroa:     console.debug('Disabled automatic notification to students')
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   // Enable feedback comments
Kode lerroa:   const feedbackCommentsCheckElement = document.querySelector('#id_assignfeedback_comments_enabled')
Kode lerroa:   if (_.isElement(feedbackCommentsCheckElement)) {
Kode lerroa:     feedbackCommentsCheckElement.checked = true
Kode lerroa:     console.debug('Activated feedback comments to students')
Kode lerroa:   }
Kode lerroa: })
Kode lerroa: import _ from 'lodash'
Kode lerroa: import MoodleProvider from './codebook/operations/create/moodleProvider/MoodleProvider'
Kode lerroa: import MoodleAugmentation from './codebook/operations/create/moodleProvider/augmentation/MoodleAugmentation'
Kode lerroa: 
Kode lerroa: window.addEventListener('load', () => {
Kode lerroa:   console.debug('Loaded moodle content script')
Kode lerroa:   // When page is loaded, popup button should be always deactivated
Kode lerroa:   chrome.runtime.sendMessage({ scope: 'extension', cmd: 'deactivatePopup' }, (result) => {
Kode lerroa:     console.log('Deactivated popup')
Kode lerroa:   })
Kode lerroa:   // When popup button is clicked
Kode lerroa:   chrome.extension.onMessage.addListener((msg, sender, sendResponse) => {
Kode lerroa:     if (_.isEmpty(window.mag)) {
Kode lerroa:       if (msg.action === 'initContentScript') {
Kode lerroa:         window.mag = {}
Kode lerroa:         window.mag.moodleContentScript = new MoodleProvider()
Kode lerroa:         window.mag.moodleContentScript.init(() => {
Kode lerroa:           // Disable the button of popup
Kode lerroa:           chrome.runtime.sendMessage({ scope: 'extension', cmd: 'deactivatePopup' }, (result) => {
Kode lerroa:             console.log('Deactivated popup')
Kode lerroa:           })
Kode lerroa:           window.mag = null
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   })
Kode lerroa:   // Augmentate moodle to add user id for each file link
Kode lerroa:   window.moodleAugmentation = new MoodleAugmentation()
Kode lerroa:   window.moodleAugmentation.init()
Kode lerroa: })
Kode lerroa: // Enable chromereload by uncommenting this line:
Kode lerroa: // import 'chromereload/devonly'
Kode lerroa: 
Kode lerroa: import Options from './options/Options'
Kode lerroa: 
Kode lerroa: window.addEventListener('load', () => {
Kode lerroa:   window.options = new Options()
Kode lerroa:   window.options.init()
Kode lerroa: })
Kode lerroa: // Enable chromereload by uncommenting this line:
Kode lerroa: import 'chromereload/devonly'
Kode lerroa: import 'bootstrap/dist/js/bootstrap'
Kode lerroa: 
Kode lerroa: import Popup from './popup/Popup'
Kode lerroa: 
Kode lerroa: window.addEventListener('load', () => {
Kode lerroa:   window.popup = new Popup()
Kode lerroa:   window.popup.init()
Kode lerroa: })
Kode lerroa: import TextUtils from './utils/URLUtils'
Kode lerroa: import Config from './Config'
Kode lerroa: // PVSCL:IFCOND(Hypothesis,LINE)
Kode lerroa: 
Kode lerroa: // PVSCL:IFCOND(BrowserStorage,LINE)
Kode lerroa: 
Kode lerroa: import _ from 'lodash'
Kode lerroa: 
Kode lerroa: class ScienceDirectContentScript {
Kode lerroa:   init () {
Kode lerroa:     // Get if this tab has an annotation to open and a doi
Kode lerroa:     const params = TextUtils.extractHashParamsFromUrl(window.location.href)
Kode lerroa:     if (!_.isEmpty(params) && !_.isEmpty(params[Config.namespace])) {
Kode lerroa:       // Activate the extension
Kode lerroa:       chrome.runtime.sendMessage({ scope: 'extension', cmd: 'activatePopup' }, (result) => {
Kode lerroa:         // Retrieve if annotation is done in current url or in pdf version
Kode lerroa:         this.loadAnnotationServer(() => {
Kode lerroa:           window.scienceDirect.annotationServerManager.client.fetchAnnotation(params[Config.namespace], (err, annotation) => {
Kode lerroa:             if (err) {
Kode lerroa:               console.error(err)
Kode lerroa:             } else {
Kode lerroa:               // TODO Check if annotation is from this page
Kode lerroa:             }
Kode lerroa:           })
Kode lerroa:         })
Kode lerroa:       })
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   loadAnnotationServer (callback) {
Kode lerroa:     // PVSCL:IFCOND(AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()=1, LINE)
Kode lerroa: 
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: window.scienceDirect = {}
Kode lerroa: window.scienceDirect.scienceDirectContentScript = new ScienceDirectContentScript()
Kode lerroa: window.scienceDirect.scienceDirectContentScript.init()
Kode lerroa: import URLUtils from './utils/URLUtils'
Kode lerroa: import _ from 'lodash'
Kode lerroa: import DOI from 'doi-regex'
Kode lerroa: import Config from './Config'
Kode lerroa: 
Kode lerroa: class SpringerContentScript {
Kode lerroa:   constructor () {
Kode lerroa:     this.doi = null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   init () {
Kode lerroa:     // Get document doi from metadata or dom
Kode lerroa:     // Get url params
Kode lerroa:     const params = URLUtils.extractHashParamsFromUrl(window.location.href)
Kode lerroa:     // Get document doi
Kode lerroa:     if (!_.isEmpty(params) && !_.isEmpty(params.doi)) {
Kode lerroa:       this.doi = params.doi
Kode lerroa:     } else {
Kode lerroa:       // Scrap the doi from web
Kode lerroa:       this.doi = this.findDoi()
Kode lerroa:     }
Kode lerroa:     // Get pdf link element
Kode lerroa:     const pdfLinkElements = this.getPdfLinkElement()
Kode lerroa:     if (pdfLinkElements.length > 0) {
Kode lerroa:       // Get if this tab has an annotation to open
Kode lerroa:       if (!_.isEmpty(params) && !_.isEmpty(params[Config.urlParamName])) {
Kode lerroa:         // Activate the extension
Kode lerroa:         chrome.runtime.sendMessage({ scope: 'extension', cmd: 'activatePopup' }, (result) => {
Kode lerroa:           console.log('Activated popup')
Kode lerroa:           // Retrieve pdf url
Kode lerroa:           let pdfUrl = pdfLinkElements[0].href
Kode lerroa:           // Create hash with required params to open extension
Kode lerroa:           let hash = '#' + Config.urlParamName + ':' + params[Config.urlParamName]
Kode lerroa:           if (this.doi) {
Kode lerroa:             hash += '&doi:' + this.doi
Kode lerroa:           }
Kode lerroa:           // Append hash to pdf url
Kode lerroa:           pdfUrl += hash
Kode lerroa:           // Redirect browser to pdf
Kode lerroa:           window.location.replace(pdfUrl)
Kode lerroa:         })
Kode lerroa:       } else {
Kode lerroa:         // Append doi to PDF url
Kode lerroa:         const doi = this.doi
Kode lerroa:         pdfLinkElements.forEach(function (pdfLinkElement) {
Kode lerroa:           pdfLinkElement.href += '#doi:' + doi
Kode lerroa:         })
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   /**
Kode lerroa:    * Depending on the article, the ACM-DL shows the DOI in different parts of the document. This function tries to find in the DOM the DOI for the current paper
Kode lerroa:    * @returns {*}
Kode lerroa:    */
Kode lerroa:   findDoi () {
Kode lerroa:     const doiElem = document.querySelector('head > meta[name="citation_doi"]')
Kode lerroa:     if (_.isElement(doiElem)) {
Kode lerroa:       if (!this.checkIfDoiElement(doiElem.content)) {
Kode lerroa:         return doiElem.content
Kode lerroa:       }
Kode lerroa:     }
Kode lerroa: 
Kode lerroa:     const doiText = document.querySelector('#doi-url')
Kode lerroa:     if (this.checkIfDoiElement(doiText)) {
Kode lerroa:       return doiText.innerText
Kode lerroa:     }
Kode lerroa:     return null
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   checkIfDoiElement (doiElement) {
Kode lerroa:     return _.isElement(doiElement) &&
Kode lerroa:       _.isString(doiElement.innerText) &&
Kode lerroa:       _.isArray(DOI.groups(doiElement.innerText)) &&
Kode lerroa:       _.isString(DOI.groups(doiElement.innerText)[1])
Kode lerroa:   }
Kode lerroa: 
Kode lerroa:   getPdfLinkElement () {
Kode lerroa:     // Paper download link
Kode lerroa:     const selectorsStrings = ['#main-content > div > div > div.cta-button-container.cta-button-container--top.cta-button-container--stacked.u-mb-16.u-hide-two-col > div > a',
Kode lerroa:       '#article-actions > div > div.download-article.test-pdf-link > div > a',
Kode lerroa:       '#cobranding-and-download-availability-text > div > a',
Kode lerroa:       '#main-content > article.main-wrapper.main-wrapper--no-gradient.main-wrapper--dual-main > div > div > div.cta-button-container.cta-button-container--inline.cta-button-container--stacked.u-pt-36.test-download-book-separate-buttons > div:nth-child(1) > a',
Kode lerroa:       '#main-content > article.main-wrapper.main-wrapper--no-gradient.main-wrapper--dual-main > div > div > div.cta-button-container.cta-button-container--stacked.u-pt-36 > div > div > a']
Kode lerroa:     const pdfLinks = selectorsStrings.reduce(function (result, selector) {
Kode lerroa:       const pdfLink = document.querySelector(selector)
Kode lerroa:       if (_.isElement(pdfLink)) {
Kode lerroa:         result.push(pdfLink)
Kode lerroa:       }
Kode lerroa:       return result
Kode lerroa:     }, [])
Kode lerroa:     return pdfLinks
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: window.springer = {}
Kode lerroa: window.springer.springerContentScript = new SpringerContentScript()
Kode lerroa: window.springer.springerContentScript.init()
Kode lerroa: #searchAnnotationsContainer {
Kode lerroa:   height: 10%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #searchAnnotationsInput {
Kode lerroa:   font-size: large;
Kode lerroa:   margin-top: 20px;
Kode lerroa:   left: 50px;
Kode lerroa:   padding: 10px;
Kode lerroa:   width: 300px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #searchResult {
Kode lerroa:   overflow-y: scroll;
Kode lerroa:   max-height: 90%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationCard {
Kode lerroa:   font-size: 13px;
Kode lerroa:   line-height: 15px;
Kode lerroa:   font-weight: 400;
Kode lerroa:   border: 1px solid #ececec;
Kode lerroa:   list-style: none;
Kode lerroa:   padding: 15px;
Kode lerroa:   margin-bottom: 10px;
Kode lerroa:   box-shadow: 0 1px 1px 0 rgba(0,0,0,.1);
Kode lerroa:   background: #fff;
Kode lerroa:   overflow-wrap: break-word;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationCardUsername {
Kode lerroa:   color: #202020;
Kode lerroa:   font-weight: bold;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationCardGroup {
Kode lerroa:   color: #3f3f3f;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationCardExact {
Kode lerroa:   padding: 0 10px;
Kode lerroa:   overflow-wrap: break-word;
Kode lerroa:   color: #a6a6a6;
Kode lerroa:   font-family: sans-serif;
Kode lerroa:   font-size: 12px;
Kode lerroa:   font-style: italic;
Kode lerroa:   letter-spacing: .1px;
Kode lerroa:   border-left: 3px solid #dbdbdb;
Kode lerroa:   margin-bottom: 10px;
Kode lerroa:   margin-left: 0;
Kode lerroa:   margin-right: 0;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .annotationCardDate {
Kode lerroa:   font-size: 11px;
Kode lerroa:   line-height: 12px;
Kode lerroa:   font-weight: 400;
Kode lerroa:   letter-spacing: .2px;
Kode lerroa:   color: #a6a6a6;
Kode lerroa: }
Kode lerroa: @import '../../node_modules/jquery-contextmenu/src/sass/jquery.contextMenu';
Kode lerroa: @import '../../node_modules/components-jqueryui/themes/base/jquery-ui';
Kode lerroa: /* PVSCL:IFCOND(Autocomplete, LINE) */
Kode lerroa: 
Kode lerroa: 
Kode lerroa: /* PVSCL:IFCOND(Manual, LINE) */
Kode lerroa: 
Kode lerroa: /* PVSCL:IFCOND(PreviousAssignments, LINE) */
Kode lerroa: 
Kode lerroa: @import './tagWrapper';
Kode lerroa: @import './locationManager';
Kode lerroa: @import './sidebar';
Kode lerroa: @import './slrDataExtraction';
Kode lerroa: @import 'toolset';
Kode lerroa: @import 'userFilter';
Kode lerroa: @import './textAnnotator';
Kode lerroa: @import './reviewAssistant';
Kode lerroa: @import './reviewCanvas';
Kode lerroa: @import "./variables";
Kode lerroa: @import "./variables";
Kode lerroa: @import "./variables";
Kode lerroa: @import '../../node_modules/bootstrap/scss/bootstrap';
Kode lerroa: 
Kode lerroa: .annotationServerConfiguration[aria-hidden="true"] {
Kode lerroa:   display: none;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .requiredFormInput:after {
Kode lerroa:   color: red;
Kode lerroa:   content: " *";
Kode lerroa: }
Kode lerroa: 
Kode lerroa: input:invalid {
Kode lerroa:   border-color: red;
Kode lerroa:   border-width: 2px;
Kode lerroa: }
Kode lerroa: mark.highlightedAnnotation {
Kode lerroa:   color: transparent;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer {
Kode lerroa:   opacity: 1;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer ::selection {
Kode lerroa:   background: rgba(130, 190, 240, 0.6);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .textLayer .highlight.selected {
Kode lerroa:   background-color: rgba(150, 150, 150, 0.5);
Kode lerroa: }
Kode lerroa: 
Kode lerroa: /* Fix for background black on pdf using swal2 */
Kode lerroa: .swal2-shown {
Kode lerroa:   height: 100% !important;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: #outerContainer {
Kode lerroa:   position: absolute;
Kode lerroa: }
Kode lerroa: @import "./variables";
Kode lerroa: ul.ui-autocomplete{
Kode lerroa:   z-index: 2147483647 !important;
Kode lerroa: }
Kode lerroa: .ui-menu-item{
Kode lerroa:   font-size: xx-small
Kode lerroa: }
Kode lerroa: #literatureList{
Kode lerroa:   list-style:none;
Kode lerroa: }
Kode lerroa: #literatureList li span{
Kode lerroa:   margin-left: 20px;
Kode lerroa:   cursor:default;
Kode lerroa: }
Kode lerroa: #literatureList li{
Kode lerroa:   margin-top:2px;
Kode lerroa:   font-size: xx-small;
Kode lerroa:   text-align: left;
Kode lerroa:   /*margin-left: -38px;*/
Kode lerroa:   max-height: 15px;
Kode lerroa:   border: 1px solid #ccc;
Kode lerroa:   padding: 3px;
Kode lerroa:   border-radius: 3px 3px 3px 3px;
Kode lerroa:   text-overflow:ellipsis;
Kode lerroa:   word-break: break-all;
Kode lerroa:   overflow:hidden;
Kode lerroa:   white-space: nowrap;
Kode lerroa: }
Kode lerroa: .removeReference{
Kode lerroa:   position:absolute;
Kode lerroa:   display:block;
Kode lerroa:   box-sizing:border-box;
Kode lerroa:   width:13px;
Kode lerroa:   height:13px;
Kode lerroa:   border-width:3px;
Kode lerroa:   border-style: solid;
Kode lerroa:   border-color:#ccc;
Kode lerroa:   border-radius:100%;
Kode lerroa:   background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%, white 56%,transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%, white 56%,transparent 56%, transparent 100%);
Kode lerroa:   background-color:#ccc;
Kode lerroa:   transition: all 0.3s ease;
Kode lerroa:   margin-top: -1px;
Kode lerroa: }
Kode lerroa: .removeReference:hover{
Kode lerroa:   border-color:#666;
Kode lerroa:   background-color:#666;
Kode lerroa:   cursor:pointer;
Kode lerroa: }
Kode lerroa: @import "./variables";
Kode lerroa: @import "./variables";
Kode lerroa: @import "./variables";
Kode lerroa: @import "./variables";
Kode lerroa: /* For plain text files, must be shown moved to avoid sidebar hides annotable content */
Kode lerroa: body > pre {
Kode lerroa:   margin-left: 161px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .reply_user {
Kode lerroa:   font-size: 70%;
Kode lerroa:   font-style: oblique;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .reply_text {
Kode lerroa:   font-size: 70%;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .reply_date {
Kode lerroa:   font-size: 70%;
Kode lerroa:   margin: 15px;
Kode lerroa: }
Kode lerroa: 
Kode lerroa: .highlightedAnnotation .highlightedAnnotation{ // TODO
Kode lerroa:   background-color: transparent !important;
Kode lerroa: }
Kode lerroa: /* PVSCL:IFCOND(Autocomplete, LINE) */
Kode lerroa: 
Kode lerroa: 
Kode lerroa: // POLE SELECTION IN COMMENT BOX
Kode lerroa: .criterionName{
Kode lerroa:   margin-bottom:5%;
Kode lerroa: }
Kode lerroa: .poleRadio{
Kode lerroa:   display:none;
Kode lerroa: }
Kode lerroa: .poleRadio:checked + .poleImage{
Kode lerroa:   opacity:1;
Kode lerroa:   border-radius:15px 15px 15px 15px;
Kode lerroa:   border: solid 2px #a4caf4;
Kode lerroa: }
Kode lerroa: .poleRadio + .poleImage{
Kode lerroa:   opacity:0.4;
Kode lerroa:   vertical-align:middle;
Kode lerroa: }
Kode lerroa: .poleRadio + .poleImage:hover{
Kode lerroa:   opacity:1;
Kode lerroa: }
Kode lerroa: /* PVSCL:IFCOND(Autocomplete, LINE) */
Kode lerroa: 
Kode lerroa: @import "./variables";
Kode lerroa: #userFilterContainer {
Kode lerroa:   padding: 5px;
Kode lerroa: }
Kode lerroa: $sidebarZIndex: 2147483647;
Kode lerroa: $sideBarWidth: 150px;
Kode lerroa: $themeColor: #7952b3;
Kode lerroa: $themeLightColor: #9972d3;
Kode lerroa: $sidebarBackgroundColor: whitesmoke;
Kode lerroa: $containerHeaderBackgroundColor: rgba(50,50,50,0.7);
Kode lerroa: $subContainerHeaderBackgroundColor: rgba(100,100,100,0.7);
Kode lerroa: $containerHeaderFontColor: white;
Kode lerroa: $switchSize: 48px;
Kode lerroa: 
Kode lerroa: $chromeExtensionMainURL: 'chrome-extension://__MSG_@@extension_id__/'
Kode lerroa: {
Kode lerroa:   "name": "__MSG_appName__",
Kode lerroa:   "short_name": "__MSG_appShortName__",
Kode lerroa:   "description": "__MSG_appDescription__",
Kode lerroa:   "version": "0.0.1",
Kode lerroa:   "manifest_version": 2,
Kode lerroa:   "default_locale": "en",
Kode lerroa:   "icons": {
Kode lerroa:     "256": "images/PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))/icon-512.png"
Kode lerroa:   },
Kode lerroa:   "background": {
Kode lerroa:     "scripts": [
Kode lerroa:       "scripts/background.js"
Kode lerroa:     ]
Kode lerroa:   },
Kode lerroa:   "content_scripts": [
Kode lerroa:     {
Kode lerroa:       "matches": ["*://*/*"PVSCL:IFCOND(URN), "file:///*/*"PVSCL:ENDCOND],
Kode lerroa: ],
Kode lerroa:       // PVSCL:IFCOND(GoogleSheetProvider,LINE)
Kode lerroa: 
Kode lerroa:       // PVSCL:IFCOND(MoodleProvider,LINE)
Kode lerroa: 
Kode lerroa:       "js": ["scripts/contentScript.js"],
Kode lerroa:       "css": ["styles/contentScript.css"],
Kode lerroa:       "run_at": "document_start",
Kode lerroa:       "all_frames": false
Kode lerroa:     }PVSCL:IFCOND(GoogleSheetProvider),
Kode lerroa: PVSCL:IFCOND(ACM),
Kode lerroa: PVSCL:IFCOND(ScienceDirect),
Kode lerroa: PVSCL:IFCOND(Springer),
Kode lerroa: PVSCL:IFCOND(Manual and Hypothesis and AnnotationServer->pv:SelectedChildren('ps:annotationServer')->pv:Size()=1),
Kode lerroa: PVSCL:IFCOND(MoodleProvider),
Kode lerroa: 
Kode lerroa:   ],
Kode lerroa:   "content_security_policy": "script-src 'self' 'unsafe-eval'; object-src 'self'",
Kode lerroa:   "page_action": {
Kode lerroa:     "default_icon": "images/PVSCL:EVAL(WebAnnotator.WebAnnotationClient->pv:Attribute('appShortName'))/icon-38-bw.png",
Kode lerroa:     "default_title": "__MSG_browserActionTitle__"
Kode lerroa:   },
Kode lerroa:   "options_page": "pages/options.html",
Kode lerroa:   "options_ui": {
Kode lerroa:     "page": "pages/options.html",
Kode lerroa:     "chrome_style": false,
Kode lerroa:     "open_in_tab": true
Kode lerroa:   },
Kode lerroa:   "permissions": [
Kode lerroa:     "https://hypothes.is/",
Kode lerroa:     "storage",PVSCL:IFCOND(GoogleSheetProvider OR GoogleSheetConsumer)
Kode lerroa: 
Kode lerroa:     "tabs"PVSCL:IFCOND(URN),
Kode lerroa: PVSCL:IFCOND(URL),
Kode lerroa: PVSCL:IFCOND(DOI),
Kode lerroa: PVSCL:IFCOND(ScienceDirect),
Kode lerroa: PVSCL:IFCOND(Dropbox),
Kode lerroa: 
Kode lerroa:   ],
Kode lerroa:   PVSCL:IFCOND(GoogleSheetProvider or GoogleSheetConsumer, LINE)
Kode lerroa: 
Kode lerroa:   "web_accessible_resources": ["pages/*.html", "content/*", "images/*"]PVSCL:IFCOND(WebAnnotator.WebAnnotationClient->pv:Attribute('key')<>''),
Kode lerroa: 
Kode lerroa: }
Kode lerroa: /**
Kode lerroa:  * Converts and removes keys with a
Kode lerroa:  * browser prefix to the key without prefix
Kode lerroa:  *
Kode lerroa:  * Example:
Kode lerroa:  *
Kode lerroa:  *    __chrome__keyName
Kode lerroa:  *    __firefox__keyName
Kode lerroa:  *    __opera__keyName
Kode lerroa:  *    __edge__keyName
Kode lerroa:  *
Kode lerroa:  * to `keyName`.
Kode lerroa:  * This way we can write one manifest that's valid
Kode lerroa:  * for all browsers
Kode lerroa:  *
Kode lerroa:  * @param  {Object} manifest
Kode lerroa:  * @return {Object}
Kode lerroa:  */
Kode lerroa: export default function applyBrowserPrefixesFor (_vendor) {
Kode lerroa:   vendor = _vendor
Kode lerroa:   return iterator
Kode lerroa: };
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:  * Vendor key
Kode lerroa:  * @type {String}
Kode lerroa:  */
Kode lerroa: let vendor = ''
Kode lerroa: 
Kode lerroa: /**
Kode lerroa:  * Recursive iterator over all object keys
Kode lerroa:  * @param  {Object} obj    Object to iterate over
Kode lerroa:  * @return {Object}        Processed object
Kode lerroa:  */
Kode lerroa: function iterator (obj) {
Kode lerroa:   Object.keys(obj).forEach((key) => {
Kode lerroa:     let match = key.match(/^__(chrome|firefox|opera|edge)__(.*)/)
Kode lerroa:     if (match) {
Kode lerroa:       // Swap key with non prefixed name
Kode lerroa:       if (match[1] === vendor) {
Kode lerroa:         obj[match[2]] = obj[key]
Kode lerroa:       }
Kode lerroa: 
Kode lerroa:       // Remove the prefixed key
Kode lerroa:       // so it won't cause warings
Kode lerroa:       delete obj[key]
Kode lerroa:     } else { // no match? try deeper
Kode lerroa:       // Recurse over object's inner keys
Kode lerroa:       if (typeof (obj[key]) === 'object') iterator(obj[key])
Kode lerroa:     }
Kode lerroa:   })
Kode lerroa:   return obj
Kode lerroa: }
Kode lerroa: import yargs from 'yargs'
Kode lerroa: 
Kode lerroa: const args = yargs
Kode lerroa: 
Kode lerroa:   .option('production', {
Kode lerroa:     boolean: true,
Kode lerroa:     default: false,
Kode lerroa:     describe: 'Minify all scripts and assets'
Kode lerroa:   })
Kode lerroa: 
Kode lerroa:   .option('watch', {
Kode lerroa:     boolean: true,
Kode lerroa:     default: false,
Kode lerroa:     describe: 'Watch all files and start a livereload server'
Kode lerroa:   })
Kode lerroa: 
Kode lerroa:   .option('verbose', {
Kode lerroa:     boolean: true,
Kode lerroa:     default: false,
Kode lerroa:     describe: 'Log additional data'
Kode lerroa:   })
Kode lerroa: 
Kode lerroa:   .option('vendor', {
Kode lerroa:     string: true,
Kode lerroa:     default: 'chrome',
Kode lerroa:     describe: 'Compile the extension for different vendors',
Kode lerroa:     choices: ['chrome', 'firefox', 'opera', 'edge']
Kode lerroa:   })
Kode lerroa: 
Kode lerroa:   .option('sourcemaps', {
Kode lerroa:     describe: 'Force the creation of sourcemaps'
Kode lerroa:   })
Kode lerroa: 
Kode lerroa:   .argv
Kode lerroa: 
Kode lerroa: // Use production flag for sourcemaps
Kode lerroa: // as a fallback
Kode lerroa: if (typeof args.sourcemaps === 'undefined') {
Kode lerroa:   args.sourcemaps = !args.production
Kode lerroa: }
Kode lerroa: 
Kode lerroa: export default args
Kode lerroa: import gulp from 'gulp'
Kode lerroa: require('./scripts')
Kode lerroa: require('./manifest')
Kode lerroa: require('./styles')
Kode lerroa: require('./pages')
Kode lerroa: require('./locales')
Kode lerroa: require('./images')
Kode lerroa: require('./fonts')
Kode lerroa: require('./chromereload')
Kode lerroa: require('./content')
Kode lerroa: require('./clean')
Kode lerroa: 
Kode lerroa: gulp.task('build', gulp.series('clean', gulp.parallel(
Kode lerroa:   'manifest',
Kode lerroa:   'scripts',
Kode lerroa:   'styles',
Kode lerroa:   'pages',
Kode lerroa:   'locales',
Kode lerroa:   'images',
Kode lerroa:   'fonts',
Kode lerroa:   'chromereload',
Kode lerroa:   'content'
Kode lerroa: )))
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gutil from 'gulp-util'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: // In order to make chromereload work you'll need to include
Kode lerroa: // the following line in your `scipts/background.js` file.
Kode lerroa: //
Kode lerroa: //    import 'chromereload/devonly';
Kode lerroa: //
Kode lerroa: // This will reload your extension everytime a file changes.
Kode lerroa: // If you just want to reload a specific context of your extension
Kode lerroa: // (e.g. `pages/options.html`) include the script in that context
Kode lerroa: // (e.g. `scripts/options.js`).
Kode lerroa: //
Kode lerroa: // Please note that you'll have to restart the gulp task if you
Kode lerroa: // create new file. We'll fix that when gulp 4 comes out.
Kode lerroa: 
Kode lerroa: gulp.task('chromereload', (cb) => {
Kode lerroa:   // This task runs only if the
Kode lerroa:   // watch argument is present!
Kode lerroa:   if (!args.watch) return cb()
Kode lerroa: 
Kode lerroa:   // Start livereload server
Kode lerroa:   livereload.listen({
Kode lerroa:     reloadPage: 'Extension',
Kode lerroa:     quiet: !args.verbose
Kode lerroa:   })
Kode lerroa: 
Kode lerroa:   gutil.log('Starting', gutil.colors.cyan('\'livereload-server\''))
Kode lerroa: 
Kode lerroa:   // The watching for javascript files is done by webpack
Kode lerroa:   // Check out ./tasks/scripts.js for further info.
Kode lerroa:   gulp.watch('app/manifest.json', gulp.series('manifest'))
Kode lerroa:   gulp.watch('app/styles/**/*.css', gulp.series('styles:css'))
Kode lerroa:   gulp.watch('app/styles/**/*.less', gulp.series('styles:less'))
Kode lerroa:   gulp.watch('app/styles/**/*.scss', gulp.series('styles:sass'))
Kode lerroa:   gulp.watch('app/pages/**/*.html', gulp.series('pages'))
Kode lerroa:   gulp.watch('app/_locales/**/*', gulp.series('locales'))
Kode lerroa:   gulp.watch('app/images/**/*', gulp.series('images'))
Kode lerroa:   gulp.watch('app/fonts/**/*.{woff,ttf,eot,svg}', gulp.series('fonts'))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import del from 'del'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('clean', () => {
Kode lerroa:   return del(`dist/${args.vendor}/**/*`)
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('content', () => {
Kode lerroa:   return gulp.src('app/content/**/*.*')
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/content`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: 
Kode lerroa: gulp.task('default', gulp.series('build'))
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('fonts', () => {
Kode lerroa:   return gulp.src('app/fonts/**/*.{woff,woff2,ttf,eot,svg}')
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/fonts`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import imagemin from 'gulp-imagemin'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('images', () => {
Kode lerroa:   return gulp.src('app/images/**/*')
Kode lerroa:     .pipe(gulpif(args.production, imagemin()))
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/images`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('locales', () => {
Kode lerroa:   return gulp.src('app/_locales/**/*.json')
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/_locales`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import { colors, log } from 'gulp-util'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import jsonTransform from 'gulp-json-transform'
Kode lerroa: import plumber from 'gulp-plumber'
Kode lerroa: import applyBrowserPrefixesFor from './lib/applyBrowserPrefixesFor'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: let manifest = () => {
Kode lerroa:   return gulp.src('app/manifest.json')
Kode lerroa:     .pipe(plumber({
Kode lerroa:       errorHandler: error => {
Kode lerroa:         if (error) {
Kode lerroa:           log('manifest:', colors.red('Invalid manifest.json'))
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }))
Kode lerroa:     .pipe(
Kode lerroa:       jsonTransform(
Kode lerroa:         applyBrowserPrefixesFor(args.vendor),
Kode lerroa:         2 /* whitespace */
Kode lerroa:       )
Kode lerroa:     )
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: }
Kode lerroa: 
Kode lerroa: gulp.task('manifest', () => {
Kode lerroa:   return gulp.src('app/manifest.json')
Kode lerroa:     .pipe(plumber({
Kode lerroa:       errorHandler: error => {
Kode lerroa:         if (error) {
Kode lerroa:           log('manifest:', colors.red('Invalid manifest.json'))
Kode lerroa:         }
Kode lerroa:       }
Kode lerroa:     }))
Kode lerroa:     .pipe(
Kode lerroa:       jsonTransform(
Kode lerroa:         applyBrowserPrefixesFor(args.vendor),
Kode lerroa:         2 /* whitespace */
Kode lerroa:       )
Kode lerroa:     )
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: 
Kode lerroa: exports.manifest = manifest
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import { colors, log } from 'gulp-util'
Kode lerroa: import zip from 'gulp-zip'
Kode lerroa: import packageDetails from '../package.json'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: function getPackFileType () {
Kode lerroa:   switch (args.vendor) {
Kode lerroa:     case 'firefox':
Kode lerroa:       return '.xpi'
Kode lerroa:     default:
Kode lerroa:       return '.zip'
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: gulp.task('pack', gulp.series('build', () => {
Kode lerroa:   let name = packageDetails.name
Kode lerroa:   let version = packageDetails.version
Kode lerroa:   let filetype = getPackFileType()
Kode lerroa:   let filename = `${name}-${version}-${args.vendor}${filetype}`
Kode lerroa:   return gulp.src(`dist/${args.vendor}/**/*`)
Kode lerroa:     .pipe(zip(filename))
Kode lerroa:     .pipe(gulp.dest('./packages'))
Kode lerroa:     .on('end', () => {
Kode lerroa:       let distStyled = colors.magenta(`dist/${args.vendor}`)
Kode lerroa:       let filenameStyled = colors.magenta(`./packages/${filename}`)
Kode lerroa:       log(`Packed ${distStyled} to ${filenameStyled}`)
Kode lerroa:     })
Kode lerroa: }))
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('pages', () => {
Kode lerroa:   return gulp.src('app/pages/**/*.html')
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/pages`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import { log, colors } from 'gulp-util'
Kode lerroa: import named from 'vinyl-named'
Kode lerroa: import webpack from 'webpack'
Kode lerroa: import gulpWebpack from 'webpack-stream'
Kode lerroa: import plumber from 'gulp-plumber'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: import 'regenerator-runtime/runtime'
Kode lerroa: import 'core-js/stable'
Kode lerroa: 
Kode lerroa: const ENV = args.production ? 'production' : 'development'
Kode lerroa: 
Kode lerroa: gulp.task('scripts', () => {
Kode lerroa:   return gulp.src(['app/scripts/*.js'])
Kode lerroa:     .pipe(plumber({
Kode lerroa:       // Webpack will log the errors
Kode lerroa:       errorHandler () {}
Kode lerroa:     }))
Kode lerroa:     .pipe(named())
Kode lerroa:     .pipe(gulpWebpack({
Kode lerroa:       devtool: args.sourcemaps ? 'inline-source-map' : false,
Kode lerroa:       watch: args.watch,
Kode lerroa:       mode: ENV, // TODO Set to ENV. Currently uglify is not encoding contentScript.js in UTF-8
Kode lerroa:       plugins: [
Kode lerroa:         new webpack.ProvidePlugin({
Kode lerroa:           $: 'jquery',
Kode lerroa:           jQuery: 'jquery',
Kode lerroa:           'window.jQuery': 'jquery',
Kode lerroa:           Popper: ['popper.js', 'default']
Kode lerroa:         }),
Kode lerroa:         new webpack.DefinePlugin({
Kode lerroa:           'process.env.NODE_ENV': JSON.stringify(ENV),
Kode lerroa:           'process.env.VENDOR': JSON.stringify(args.vendor)
Kode lerroa:         })
Kode lerroa:       ],
Kode lerroa:       module: {
Kode lerroa:         rules: [{
Kode lerroa:           test: /\.js$/,
Kode lerroa:           loader: 'eslint-loader',
Kode lerroa:           exclude: /node_modules/,
Kode lerroa:           enforce: 'pre'
Kode lerroa:         }, {
Kode lerroa:           test: /\.js$/,
Kode lerroa:           loader: 'babel-loader',
Kode lerroa:           query: { compact: false }
Kode lerroa:         }]
Kode lerroa:       },
Kode lerroa:       optimization: {
Kode lerroa:         removeAvailableModules: false,
Kode lerroa:         removeEmptyChunks: false,
Kode lerroa:         splitChunks: false
Kode lerroa:       }
Kode lerroa:     },
Kode lerroa:     webpack,
Kode lerroa:     (err, stats) => {
Kode lerroa:       if (err) return
Kode lerroa:       log(`Finished '${colors.cyan('scripts')}'`, stats.toString({
Kode lerroa:         chunks: false,
Kode lerroa:         colors: true,
Kode lerroa:         cached: false,
Kode lerroa:         children: false
Kode lerroa:       }))
Kode lerroa:     }))
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/scripts`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import gulpif from 'gulp-if'
Kode lerroa: import gutil from 'gulp-util'
Kode lerroa: import sourcemaps from 'gulp-sourcemaps'
Kode lerroa: import less from 'gulp-less'
Kode lerroa: import sass from 'gulp-sass'
Kode lerroa: import cleanCSS from 'gulp-clean-css'
Kode lerroa: import livereload from 'gulp-livereload'
Kode lerroa: import args from './lib/args'
Kode lerroa: 
Kode lerroa: gulp.task('styles:css', function () {
Kode lerroa:   return gulp.src('app/styles/*.css')
Kode lerroa:     .pipe(gulpif(args.sourcemaps, sourcemaps.init()))
Kode lerroa:     .pipe(gulpif(args.production, cleanCSS()))
Kode lerroa:     .pipe(gulpif(args.sourcemaps, sourcemaps.write()))
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/styles`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: 
Kode lerroa: gulp.task('styles:less', function () {
Kode lerroa:   return gulp.src('app/styles/*.less')
Kode lerroa:     .pipe(gulpif(args.sourcemaps, sourcemaps.init()))
Kode lerroa:     .pipe(less({ paths: ['./app'] }).on('error', function (error) {
Kode lerroa:       gutil.log(gutil.colors.red('Error (' + error.plugin + '): ' + error.message))
Kode lerroa:       this.emit('end')
Kode lerroa:     }))
Kode lerroa:     .pipe(gulpif(args.production, cleanCSS()))
Kode lerroa:     .pipe(gulpif(args.sourcemaps, sourcemaps.write()))
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/styles`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: 
Kode lerroa: gulp.task('styles:sass', function () {
Kode lerroa:   return gulp.src('app/styles/*.scss')
Kode lerroa:     .pipe(gulpif(args.sourcemaps, sourcemaps.init()))
Kode lerroa:     .pipe(sass({ includePaths: ['./app'] }).on('error', function (error) {
Kode lerroa:       gutil.log(gutil.colors.red('Error (' + error.plugin + '): ' + error.message))
Kode lerroa:       this.emit('end')
Kode lerroa:     }))
Kode lerroa:     .pipe(gulpif(args.production, cleanCSS()))
Kode lerroa:     .pipe(gulpif(args.sourcemaps, sourcemaps.write()))
Kode lerroa:     .pipe(gulp.dest(`dist/${args.vendor}/styles`))
Kode lerroa:     .pipe(gulpif(args.watch, livereload()))
Kode lerroa: })
Kode lerroa: 
Kode lerroa: gulp.task('styles', gulp.series(
Kode lerroa:   'styles:css',
Kode lerroa:   'styles:less',
Kode lerroa:   'styles:sass'
Kode lerroa: ))
Kode lerroa: const gulp = require('gulp')
Kode lerroa: const mocha = require('gulp-mocha')
Kode lerroa: 
Kode lerroa: // Load Environment variables required to initialize the bot
Kode lerroa: require('dotenv').config()
Kode lerroa: 
Kode lerroa: /* gulp.task('test', function () {
Kode lerroa:   return gulp.src('wdio.conf.js').pipe(webdriver())
Kode lerroa: }) */
Kode lerroa: 
Kode lerroa: gulp.task('test', function () {
Kode lerroa:   return gulp.src('test/**/*.js', {read: false})
Kode lerroa:   // `gulp-mocha` needs filepaths so you can't have any plugins before it
Kode lerroa:     .pipe(mocha({reporter: 'base'}))
Kode lerroa: })
Kode lerroa: /**
Kode lerroa:  * Bumping version number and tagging the repository with it.
Kode lerroa:  * Please read http://semver.org/
Kode lerroa:  *
Kode lerroa:  * You can use the commands
Kode lerroa:  *
Kode lerroa:  *     gulp patch     # makes v0.1.0  v0.1.1
Kode lerroa:  *     gulp feature   # makes v0.1.1  v0.2.0
Kode lerroa:  *     gulp release   # makes v0.2.1  v1.0.0
Kode lerroa:  *
Kode lerroa:  * To bump the version numbers accordingly after you did a patch,
Kode lerroa:  * introduced a feature or made a backwards-incompatible release.
Kode lerroa:  */
Kode lerroa: 
Kode lerroa: import gulp from 'gulp'
Kode lerroa: import git from 'gulp-git'
Kode lerroa: import bump from 'gulp-bump'
Kode lerroa: import filter from 'gulp-filter'
Kode lerroa: import tagVersion from 'gulp-tag-version'
Kode lerroa: 
Kode lerroa: function inc (importance) {
Kode lerroa:   // get all the files to bump version in
Kode lerroa:   return gulp.src([
Kode lerroa:     'package.json',
Kode lerroa:     'app/manifest.json'
Kode lerroa:   ], {
Kode lerroa:     base: './'
Kode lerroa:   })
Kode lerroa:     // bump the version number in those files
Kode lerroa:     .pipe(bump({
Kode lerroa:       type: importance
Kode lerroa:     }))
Kode lerroa:     // save it back to filesystem
Kode lerroa:     .pipe(gulp.dest('./'))
Kode lerroa:     // commit the changed version number
Kode lerroa:     .pipe(git.commit('bump package version'))
Kode lerroa:     // read only one file to get the version number
Kode lerroa:     .pipe(filter('package.json'))
Kode lerroa:     // **tag it in the repository**
Kode lerroa:     .pipe(tagVersion())
Kode lerroa: }
Kode lerroa: 
Kode lerroa: gulp.task('patch', () => {
Kode lerroa:   return inc('patch')
Kode lerroa: })
Kode lerroa: 
Kode lerroa: gulp.task('feature', () => {
Kode lerroa:   return inc('minor')
Kode lerroa: })
Kode lerroa: 
Kode lerroa: gulp.task('release', () => {
Kode lerroa:   return inc('major')
Kode lerroa: })
Kode lerroa: {
Kode lerroa:   "presets": [[
Kode lerroa:     "@babel/preset-env", {
Kode lerroa:       "targets": {
Kode lerroa:         "browsers": "last 2 versions"
Kode lerroa:       },
Kode lerroa:       "useBuiltIns": "usage",
Kode lerroa:       "corejs": {
Kode lerroa:         "version": 3
Kode lerroa:       },
Kode lerroa:       "debug": false
Kode lerroa:     }]],
Kode lerroa:     "plugins": [
Kode lerroa:      ["@babel/plugin-proposal-class-properties", { "loose": true }],
Kode lerroa:     "@babel/plugin-proposal-export-default-from",
Kode lerroa:     "@babel/plugin-syntax-async-generators"
Kode lerroa:   ],
Kode lerroa:   "ignore": ["node_modules"],
Kode lerroa:   "retainLines": true,
Kode lerroa:   "sourceType": "unambiguous"
Kode lerroa: }
Kode lerroa: # http://editorconfig.org
Kode lerroa: root = true
Kode lerroa: 
Kode lerroa: [*]
Kode lerroa: indent_style = space
Kode lerroa: indent_size = 2
Kode lerroa: charset = utf-8
Kode lerroa: trim_trailing_whitespace = true
Kode lerroa: insert_final_newline = true
Kode lerroa: 
Kode lerroa: [*.md]
Kode lerroa: trim_trailing_whitespace = false
Kode lerroa: {
Kode lerroa:   "env": {
Kode lerroa:     "browser": true
Kode lerroa:   },
Kode lerroa:   "extends": "standard",
Kode lerroa:   "globals": {
Kode lerroa:     "chrome": true,
Kode lerroa:     "crypto": true
Kode lerroa:   },
Kode lerroa:   "parser": "babel-eslint",
Kode lerroa:   "plugins": [],
Kode lerroa:   "rules": {
Kode lerroa:     "no-unused-vars": "off",
Kode lerroa:     "no-multiple-empty-lines": "off",
Kode lerroa:     "padded-blocks": "off",
Kode lerroa:     "prefer-const": "off"
Kode lerroa:   }
Kode lerroa: }
Kode lerroa: 
Kode lerroa: errorShots
Kode lerroa: 
Kode lerroa: .DS_Store
Kode lerroa: 
Kode lerroa: node_modules
Kode lerroa: npm-debug.log
Kode lerroa: 
Kode lerroa: dist/
Kode lerroa: packages/
Kode lerroa: ### JetBrains template
Kode lerroa: # Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm
Kode lerroa: # Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839
Kode lerroa: 
Kode lerroa: # User-specific stuff:
Kode lerroa: .idea/**/workspace.xml
Kode lerroa: .idea/**/tasks.xml
Kode lerroa: .idea/dictionaries
Kode lerroa: 
Kode lerroa: # Sensitive or high-churn files:
Kode lerroa: .idea/**/dataSources/
Kode lerroa: .idea/**/dataSources.ids
Kode lerroa: .idea/**/dataSources.xml
Kode lerroa: .idea/**/dataSources.local.xml
Kode lerroa: .idea/**/sqlDataSources.xml
Kode lerroa: .idea/**/dynamic.xml
Kode lerroa: .idea/**/uiDesigner.xml
Kode lerroa: 
Kode lerroa: # Gradle:
Kode lerroa: .idea/**/gradle.xml
Kode lerroa: .idea/**/libraries
Kode lerroa: 
Kode lerroa: # CMake
Kode lerroa: cmake-build-debug/
Kode lerroa: 
Kode lerroa: # Mongo Explorer plugin:
Kode lerroa: .idea/**/mongoSettings.xml
Kode lerroa: 
Kode lerroa: ## File-based project format:
Kode lerroa: *.iws
Kode lerroa: 
Kode lerroa: ## Plugin-specific files:
Kode lerroa: 
Kode lerroa: # IntelliJ
Kode lerroa: out/
Kode lerroa: 
Kode lerroa: # mpeltonen/sbt-idea plugin
Kode lerroa: .idea_modules/
Kode lerroa: 
Kode lerroa: # JIRA plugin
Kode lerroa: atlassian-ide-plugin.xml
Kode lerroa: 
Kode lerroa: # Cursive Clojure plugin
Kode lerroa: .idea/replstate.xml
Kode lerroa: 
Kode lerroa: # Crashlytics plugin (for Android Studio and IntelliJ)
Kode lerroa: com_crashlytics_export_strings.xml
Kode lerroa: crashlytics.properties
Kode lerroa: crashlytics-build.properties
Kode lerroa: fabric.properties
Kode lerroa: 
Kode lerroa: ### Node template
Kode lerroa: # Logs
Kode lerroa: logs
Kode lerroa: *.log
Kode lerroa: npm-debug.log*
Kode lerroa: yarn-debug.log*
Kode lerroa: yarn-error.log*
Kode lerroa: 
Kode lerroa: # Runtime data
Kode lerroa: pids
Kode lerroa: *.pid
Kode lerroa: *.seed
Kode lerroa: *.pid.lock
Kode lerroa: 
Kode lerroa: # Directory for instrumented libs generated by jscoverage/JSCover
Kode lerroa: lib-cov
Kode lerroa: 
Kode lerroa: # Coverage directory used by tools like istanbul
Kode lerroa: coverage
Kode lerroa: 
Kode lerroa: # nyc test coverage
Kode lerroa: .nyc_output
Kode lerroa: 
Kode lerroa: # Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
Kode lerroa: .grunt
Kode lerroa: 
Kode lerroa: # Bower dependency directory (https://bower.io/)
Kode lerroa: bower_components
Kode lerroa: 
Kode lerroa: # node-waf configuration
Kode lerroa: .lock-wscript
Kode lerroa: 
Kode lerroa: # Compiled binary addons (https://nodejs.org/api/addons.html)
Kode lerroa: build/Release
Kode lerroa: 
Kode lerroa: # Dependency directories
Kode lerroa: jspm_packages/
Kode lerroa: 
Kode lerroa: # Typescript v1 declaration files
Kode lerroa: typings/
Kode lerroa: 
Kode lerroa: # Optional npm cache directory
Kode lerroa: .npm
Kode lerroa: 
Kode lerroa: # Optional eslint cache
Kode lerroa: .eslintcache
Kode lerroa: 
Kode lerroa: # Optional REPL history
Kode lerroa: .node_repl_history
Kode lerroa: 
Kode lerroa: # Output of 'npm pack'
Kode lerroa: *.tgz
Kode lerroa: 
Kode lerroa: # Yarn Integrity file
Kode lerroa: .yarn-integrity
Kode lerroa: 
Kode lerroa: # dotenv environment variables file
Kode lerroa: .env
Kode lerroa: 
Kode lerroa: ### macOS template
Kode lerroa: # General
Kode lerroa: .AppleDouble
Kode lerroa: .LSOverride
Kode lerroa: 
Kode lerroa: # Icon must end with two \r
Kode lerroa: Icon
Kode lerroa: 
Kode lerroa: # Thumbnails
Kode lerroa: ._*
Kode lerroa: 
Kode lerroa: # Files that might appear in the root of a volume
Kode lerroa: .DocumentRevisions-V100
Kode lerroa: .fseventsd
Kode lerroa: .Spotlight-V100
Kode lerroa: .TemporaryItems
Kode lerroa: .Trashes
Kode lerroa: .VolumeIcon.icns
Kode lerroa: .com.apple.timemachine.donotpresent
Kode lerroa: 
Kode lerroa: # Directories potentially created on remote AFP share
Kode lerroa: .AppleDB
Kode lerroa: .AppleDesktop
Kode lerroa: Network Trash Folder
Kode lerroa: Temporary Items
Kode lerroa: .apdisk
Kode lerroa: 
Kode lerroa: /build/
Kode lerroa: if (Test-Path ./node_modules) {
Kode lerroa: 	echo "Nothing to do"
Kode lerroa: } else {
Kode lerroa: 	if (Test-Path ../../node_modules) {
Kode lerroa: 		echo "No need to create a symbolic link"
Kode lerroa: 	} else {
Kode lerroa: 		echo "npm install and creating a symbolic link"
Kode lerroa: 		npm install
Kode lerroa: 		mv ./node_modules ../../node_modules
Kode lerroa: 	}
Kode lerroa: }
Kode lerroa: if (Get-Command gulp -errorAction SilentlyContinue) {
Kode lerroa: 	gulp default
Kode lerroa: } else {
Kode lerroa: 	echo "Install gulp globally"
Kode lerroa: 	npm install gulp -g
Kode lerroa: 	gulp default
Kode lerroa: }
Kode lerroa: #!/bin/bash
Kode lerroa: 
Kode lerroa: PROJECT_DIR="./node_modules"
Kode lerroa: NODE_MODULES_DIR="../../../node_modules"
Kode lerroa: if [ -d "$PROJECT_DIR" ]; then
Kode lerroa:     echo "Nothing to do"
Kode lerroa: else
Kode lerroa:     if [ -d "$NODE_MODULES_DIR" ]; then
Kode lerroa:         echo "Creating a symbolic link"
Kode lerroa:         ln -s $NODE_MODULES_DIR $PROJECT_DIR
Kode lerroa:     else
Kode lerroa:         echo "npm install and creating a symbolic link"
Kode lerroa:         npm install
Kode lerroa:         mv $PROJECT_DIR $NODE_MODULES_DIR
Kode lerroa:         ln -s $NODE_MODULES_DIR $PROJECT_DIR
Kode lerroa:     fi
Kode lerroa: fi
Kode lerroa: 
Kode lerroa: echo "Running gulp default"
Kode lerroa: 
Kode lerroa: gulp default
Kode lerroa: 
Kode lerroa: # Remove node_modules link in project (bug with pure::variants in mac when right click on elements in xfm, vdm, ccfm files)
Kode lerroa: rm $PROJECT_DIR
Kode lerroa: import requireDir from 'require-dir'
Kode lerroa: 
Kode lerroa: // Check out the tasks directory
Kode lerroa: // if you want to modify tasks!
Kode lerroa: requireDir('./tasks')
Kode lerroa: {
Kode lerroa:   "name": "WebAnnotator",
Kode lerroa:   "private": true,
Kode lerroa:   "version": "0.0.1",
Kode lerroa:   "description": "This is a product to conduct web annotation",
Kode lerroa:   "scripts": {
Kode lerroa:     "start": "npm run dev:chrome",
Kode lerroa:     "build": "npm run build:chrome",
Kode lerroa:     "build:chrome": "gulp pack --production --vendor=chrome",
Kode lerroa:     "build:firefox": "gulp pack --production --vendor=firefox",
Kode lerroa:     "build:opera": "gulp pack --production --vendor=opera",
Kode lerroa:     "build:edge": "gulp pack --production --vendor=edge",
Kode lerroa:     "dev": "npm run dev:chrome",
Kode lerroa:     "dev:chrome": "gulp --watch --vendor=chrome",
Kode lerroa:     "dev:firefox": "gulp --watch --vendor=firefox",
Kode lerroa:     "dev:opera": "gulp --watch --vendor=opera",
Kode lerroa:     "dev:edge": "gulp --watch --vendor=edge",
Kode lerroa:     "lint": "standard"
Kode lerroa:   },
Kode lerroa:   "standard": {
Kode lerroa:     "globals": [
Kode lerroa:       "chrome"
Kode lerroa:     ]
Kode lerroa:   },
Kode lerroa:   "dependencies": {
Kode lerroa:     "awesomplete": "^1.1.5",
Kode lerroa:     "axios": "^0.19.2",
Kode lerroa:     "bootstrap": "^4.4.1",
Kode lerroa:     "circular-json-es6": "^2.0.2",
Kode lerroa:     "color": "^3.1.2",
Kode lerroa:     "color-hash": "^1.0.3",
Kode lerroa:     "components-jqueryui": "^1.12.1",
Kode lerroa:     "doi-regex": "^0.1.10",
Kode lerroa:     "dom-anchor-text-position": "^4.0.0",
Kode lerroa:     "dom-anchor-text-quote": "^4.0.2",
Kode lerroa:     "dom-node-iterator": "^3.5.3",
Kode lerroa:     "dom-seek": "^4.0.3",
Kode lerroa:     "file-saver": "^2.0.2",
Kode lerroa:     "html2canvas": "^1.0.0-rc.5",
Kode lerroa:     "hypothesis-api-client": "^0.1.7",
Kode lerroa:     "moment": "^2.24.0",
Kode lerroa:     "jquery": "^3.4.1",
Kode lerroa:     "jquery-contextmenu": "^2.9.0",
Kode lerroa:     "js-sha256": "^0.9.0",
Kode lerroa:     "json-form-data": "^1.7.2",
Kode lerroa:     "jsonld": "^3.0.1",
Kode lerroa:     "jspdf": "^1.5.3",
Kode lerroa:     "linkify-urls": "^3.1.0",
Kode lerroa:     "lodash": "^4.17.15",
Kode lerroa:     "qs": "^6.9.2",
Kode lerroa:     "qtip2": "^3.0.3",
Kode lerroa:     "showdown": "^1.9.1",
Kode lerroa:     "sweetalert2": "^7.33.1",
Kode lerroa:     "unique-colors": "^1.0.1",
Kode lerroa:     "wildcard": "^2.0.0",
Kode lerroa:     "xpath-range": "^1.1.1"
Kode lerroa:   },
Kode lerroa:   "devDependencies": {
Kode lerroa:     "@babel/register": "^7.9.0",
Kode lerroa:     "@babel/cli": "^7.8.4",
Kode lerroa:     "@babel/core": "7.9.0",
Kode lerroa:     "@babel/plugin-proposal-class-properties": "^7.8.3",
Kode lerroa:     "@babel/plugin-proposal-export-default-from": "^7.8.3",
Kode lerroa:     "@babel/plugin-syntax-async-generators": "^7.8.4",
Kode lerroa:     "@babel/preset-env": "^7.9.0",
Kode lerroa:     "babel-core": "^7.0.0-bridge.0",
Kode lerroa:     "babel-eslint": "^10.1.0",
Kode lerroa:     "babel-loader": "^8.1.0",
Kode lerroa:     "chai": "^4.2.0",
Kode lerroa:     "chromereload": "0.x.x",
Kode lerroa:     "core-js": "^3.6.4",
Kode lerroa:     "debounce": "^1.2.0",
Kode lerroa:     "del": "^5.1.0",
Kode lerroa:     "dotenv": "^8.2.0",
Kode lerroa:     "eslint": "^6.8.0",
Kode lerroa:     "eslint-config-standard": "^14.1.1",
Kode lerroa:     "eslint-loader": "^3.0.3",
Kode lerroa:     "eslint-plugin-import": "^2.20.1",
Kode lerroa:     "eslint-plugin-node": "^11.0.0",
Kode lerroa:     "eslint-plugin-promise": "^4.2.1",
Kode lerroa:     "eslint-plugin-standard": "^4.0.1",
Kode lerroa:     "gulp": "^4.0.2",
Kode lerroa:     "gulp-bump": "^3.1.3",
Kode lerroa:     "gulp-cache": "^1.1.3",
Kode lerroa:     "gulp-clean-css": "^4.3.0",
Kode lerroa:     "gulp-filter": "^6.0.0",
Kode lerroa:     "gulp-git": "^2.10.0",
Kode lerroa:     "gulp-if": "3.0.0",
Kode lerroa:     "gulp-imagemin": "^7.1.0",
Kode lerroa:     "gulp-json-transform": "^0.4.7",
Kode lerroa:     "gulp-less": "^4.0.1",
Kode lerroa:     "gulp-livereload": "^4.0.2",
Kode lerroa:     "gulp-mocha": "^7.0.2",
Kode lerroa:     "gulp-plumber": "^1.2.1",
Kode lerroa:     "gulp-sass": "^4.0.2",
Kode lerroa:     "gulp-sequence": "^1.0.0",
Kode lerroa:     "gulp-sourcemaps": "^2.6.5",
Kode lerroa:     "gulp-tag-version": "^1.3.1",
Kode lerroa:     "gulp-util": "3.0.8",
Kode lerroa:     "gulp-zip": "^5.0.1",
Kode lerroa:     "js-yaml": "^3.13.1",
Kode lerroa:     "mocha": "^7.1.1",
Kode lerroa:     "natives": "^1.1.6",
Kode lerroa:     "node-sass": "^4.13.1",
Kode lerroa:     "popper.js": "^1.16.1",
Kode lerroa:     "regenerator-runtime": "^0.13.5",
Kode lerroa:     "require-dir": "^1.2.0",
Kode lerroa:     "standard": "^14.3.3",
Kode lerroa:     "vinyl-named": "1.x.x",
Kode lerroa:     "webpack": "^4.42.1",
Kode lerroa:     "webpack-cli": "^3.3.11",
Kode lerroa:     "webpack-dev-server": "^3.10.3",
Kode lerroa:     "webpack-stream": "^5.2.1",
Kode lerroa:     "yargs": "^15.3.1"
Kode lerroa:   }
Kode lerroa: }
